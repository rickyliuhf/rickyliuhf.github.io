<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/18/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">SQLite锁机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-17 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-17T20:56:00+08:00">2017-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite锁机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="SQLite锁的粒度到哪里？"><a href="#SQLite锁的粒度到哪里？" class="headerlink" title="SQLite锁的粒度到哪里？"></a>SQLite锁的粒度到哪里？</h1><p>SQLite锁的是整个数据库文件，不支持页锁、表锁和行锁，粒度较粗。</p>
<p>当一个连接要写数据库文件时，所有其他的连接都会阻塞，直到写数据的连接事务结束。</p>
<p>SQLite 3.7.0 新增 Write-Ahead Log 机制改变了事务行为，读写可以并发。</p>
<h1 id="为什么SQLite不支持表锁和行锁呢？"><a href="#为什么SQLite不支持表锁和行锁呢？" class="headerlink" title="为什么SQLite不支持表锁和行锁呢？"></a>为什么SQLite不支持表锁和行锁呢？</h1><p>支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。</p>
<p>同时复杂性增大会增加运行设备电量的损害，对于手机这类这种电量敏感的设备比较重要。</p>
<h1 id="SQLite锁机制是怎样的？"><a href="#SQLite锁机制是怎样的？" class="headerlink" title="SQLite锁机制是怎样的？"></a>SQLite锁机制是怎样的？</h1><p>有多个数据库连接同时访问同一个数据库，就产生了资源竞争，需要锁机制保证资源竞争的正确性</p>
<p>数据库操作无非就是读和写，按道理普通的读写锁就可以实现，但高并发下读写锁仍然有优化的空间，为了提高整体的吞吐量，SQLite使用了锁逐步提升的机制</p>
<p>SQLite共有5种锁状态：</p>
<ol>
<li> 无锁（unlocked）</li>
<li> 共享（shared）</li>
<li> 预留（reserved）</li>
<li> 未决（pending）</li>
<li> 排它（exclusive）</li>
</ol>
<p>每个数据库连接同一时刻只能处于其中一个状态</p>
<p>无锁：</p>
<ol>
<li> 即使事务已经开始，在没有读写数据库前，都是无锁状态</li>
</ol>
<p>共享：</p>
<ol>
<li> 读数据库必须获得共享锁</li>
<li> 多个数据库连接可以同时获得共享锁，即允许多个连接同时读数据库</li>
<li> 写数据库前必须要释放所有的共享锁</li>
</ol>
<p>预留：</p>
<ol>
<li> 写数据需要先获取到预留锁</li>
<li> 持有预留锁后就可以立即把数据写入缓存中，而不用竞争数据库文件，把可以不占用的数据库文件可以完成的事情提前完成，这样最大程度的减少独占数据库文件的时间</li>
<li> 预留锁可以与共享锁共存</li>
<li> 预留锁不影响其他已经持有共享锁的连接继续读数据库</li>
<li> 预留锁不阻止其他连接获得新的共享锁，因为并不确定是否要立即写入数据库文件，可能之后还要修改数据库内容，提交事务的时候才知道后面不会再修改数据库了</li>
<li> 一个数据库同时只能有一个预留锁存在</li>
</ol>
<p>未决：</p>
<ol>
<li> 当连接提交事务时，就要把缓存里的数据往数据库文件中写入，以保证事务的持久性</li>
<li> 对数据库文件写数据前，需要保证没有连接再持有共享锁</li>
<li> 但此时可能还有其他连接持有共享锁，需要等待这些连接释放共享锁后，才能写数据</li>
<li> 同时要阻止新的连接获取共享锁，否则写数据一直得不到执行</li>
<li> 所以从预留锁要转变为未决锁，来阻止新的连接获取共享锁</li>
</ol>
<p>排它：</p>
<ol>
<li> 所有共享锁释放后，未决锁提升为排他锁</li>
<li> 排它锁和未决锁一样，会阻止新的连接获取共享锁，阻止读数据</li>
<li> 获得排它锁后，就可以把缓存中的数据写入数据库文件</li>
</ol>
<p>参考资料：</p>
<p>《SQLite权威指南（第2版）》116页  第4章 SQLite中的高级SQL - 数据库锁</p>
<h1 id="SQLite锁为什么搞这么多状态？"><a href="#SQLite锁为什么搞这么多状态？" class="headerlink" title="SQLite锁为什么搞这么多状态？"></a>SQLite锁为什么搞这么多状态？</h1><ul>
<li>由于写数据时是排他的，其他连接无法读数据库，所以要尽可能的减少写数据时的耗时，才能提高系统整体的吞吐量。</li>
<li>所以写数据时先获取预留锁，把可以在不占用数据库文件的事情提前做好。</li>
<li>那些需要占用数据库文件才能做的事情留到获取到排他锁时再做。<ul>
<li>获取排它锁前需要保证没有连接再获取共享锁。</li>
<li>所以先从预留锁提升到未决锁，用来阻止新的共享锁的获取。</li>
<li>等待已经获取的共享锁的连接执行完后释放了所有的共享锁，最后获取到排它锁写数据库文件。</li>
</ul>
</li>
</ul>
<h1 id="锁的状态转移过程是怎样的？"><a href="#锁的状态转移过程是怎样的？" class="headerlink" title="锁的状态转移过程是怎样的？"></a>锁的状态转移过程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091837.png"></p>
<h1 id="为什么事务的开始都要先获取未决锁，再获取共享锁？"><a href="#为什么事务的开始都要先获取未决锁，再获取共享锁？" class="headerlink" title="为什么事务的开始都要先获取未决锁，再获取共享锁？"></a>为什么事务的开始都要先获取未决锁，再获取共享锁？</h1><p>因为如果已经获得了未决锁，说明要占用数据库文件进行写操作，就不允许读了，而读数据库需要获得共享锁，这里就阻止别的连接获取共享锁。</p>
<h1 id="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"><a href="#有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？" class="headerlink" title="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"></a>有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？</h1><p>获得预留锁时，读写可以并发执行，但是真正写数据库需要阻止共享锁获取。</p>
<p>这样做可以提升系统整体的吞吐量。</p>
<h1 id="SQLite锁机制需要注意什么？"><a href="#SQLite锁机制需要注意什么？" class="headerlink" title="SQLite锁机制需要注意什么？"></a>SQLite锁机制需要注意什么？</h1><p>注意死锁的发生</p>
<h1 id="SQLite什么情况下会发生死锁？"><a href="#SQLite什么情况下会发生死锁？" class="headerlink" title="SQLite什么情况下会发生死锁？"></a>SQLite什么情况下会发生死锁？</h1><p>SQLite发生死锁时会抛出database is locked的异常信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091949.png"></p>
<p>参考《SQL权威指南（第2版）》117页 SQLite中的高级SQL - 死锁</p>
<h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>用正确的事务类型来开启事务</p>
<p>存在并发写数据，就开启immediate或exclusive事务，提供了同步机制</p>
<p>SQLite有三种不同的事务类型：</p>
<ol>
<li> DEFERRED（推迟）</li>
<li> MMEDIATE（立即）</li>
<li> EXCLUSIVE（排它）</li>
</ol>
<p>事务类型在BEGIN命令中指定。</p>
<p>一个deferred事务不获取任何锁，直到它需要锁的时候。而且BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态；默认情况下是这样的。如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取SHARED LOCK；同样，当进行第一次写操作时，它会获取RESERVED LOCK。</p>
<p>由BEGIN开始的Immediate事务会试着获取RESERVED LOCK。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作，但是RESERVED LOCK会阻止其它的连接BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，SQLite会返回SQLITE_BUSY错误。这时你就可以对数据库进行修改操作，但是你不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。</p>
<p>Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 上面那个例子的问题在于两个连接最终都想写数据库，但是他们都没有放弃各自原来的锁，最终，shared 锁导致了问题的出现。如果两个连接都以BEGIN IMMEDIATE开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入BEGIN IMMEDIATE，其它的连接就得等待。BEGIN IMMEDIATE和BEGIN EXCLUSIVE通常被写事务使用。就像同步机制一样，它防止了死锁的产生。 基本的准则是：如果你在使用的数据库没有其它的连接，用BEGIN就足够了。但是，如果你使用的数据库在其它的连接也要对数据库进行写操作，就得使用BEGIN IMMEDIATE或BEGIN EXCLUSIVE开始你的事务。</p>
<h1 id="Android中对SQLite开启的哪一种事务类型？"><a href="#Android中对SQLite开启的哪一种事务类型？" class="headerlink" title="Android中对SQLite开启的哪一种事务类型？"></a>Android中对SQLite开启的哪一种事务类型？</h1><p>SQLiteDatabase开启事务有两个方法：</p>
<ol>
<li> beginTransaction()开启exclusive事务类型</li>
<li> beginTransactionNonExclusive()开启immediate事务类型</li>
</ol>
<h1 id="锁的状态存储在哪里？"><a href="#锁的状态存储在哪里？" class="headerlink" title="锁的状态存储在哪里？"></a>锁的状态存储在哪里？</h1><p>数据库文件是独立于进程的，多个进程可以访问同一个文件，所以数据库锁是存在数据库文件中的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092032.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092040.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">SQLite并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-16 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-16T20:31:00+08:00">2017-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite并发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQLite支持多线程吗？"><a href="#SQLite支持多线程吗？" class="headerlink" title="SQLite支持多线程吗？"></a>SQLite支持多线程吗？</h1><p>SQLite支持多线程，但是是有条件的支持，也就是：</p>
<ul>
<li>同一个连接不能在多线程中使用，不同连接才可以在多线程中使用，这个是最宏观的SQLite多线程准则。</li>
<li>SQLite的文件锁是粗颗粒的，也就是以数据库文件为维度加锁，涉及到5种锁状态。</li>
</ul>
<p>为了确保数据库安全，SQLite 内部抽象了两种类型的互斥锁（锁的具体实现和宿主平台有关）来应对线程并发问题：</p>
<ul>
<li>fullMutex<br>可以理解为 connection mutex，和连接句柄（上问描述的 sqlite3 结构体）绑定。<br>保证任何时候，最多只有一个线程在执行基于连接的事务。</li>
<li>coreMutex<br>当前进程中，与文件绑定的锁。<br>用于保护数据库相关临界资源，确保在任何时候，最多只有一个线程在访问。</li>
</ul>
<h2 id="SQLite三种线程模型"><a href="#SQLite三种线程模型" class="headerlink" title="SQLite三种线程模型"></a>SQLite三种线程模型</h2><ul>
<li>single-thread<ul>
<li>  coreMutex 和 fullMutex 都被禁用。</li>
<li>  用户层需要确保在任何时候只有一个线程访问 API，否则抛出异常。</li>
</ul>
</li>
<li>multi-thread<ul>
<li>  coreMutex 保留，fullMutex 禁用。</li>
<li>  可以多个线程基于不同的连接并发访问数据库，但单个连接在任何时候只能被一个线程访问。</li>
<li>单个 connection，如果并发访问，会抛出异常。<ul>
<li>  报错信息：illegal multi-threaded access to database connection。</li>
</ul>
</li>
</ul>
</li>
<li>serialized<ul>
<li>  coreMutex 和 fullMutex 都保留。</li>
</ul>
</li>
</ul>
<h1 id="同一个数据库连接多线程访问会有什么问题？"><a href="#同一个数据库连接多线程访问会有什么问题？" class="headerlink" title="同一个数据库连接多线程访问会有什么问题？"></a>同一个数据库连接多线程访问会有什么问题？</h1><p>一个数据库连接对应一个事务操作，多线程访问一个连接会造成事务不原子化，事务执行结果会混乱。</p>
<h1 id="不同的连接同时写数据库会发生什么？"><a href="#不同的连接同时写数据库会发生什么？" class="headerlink" title="不同的连接同时写数据库会发生什么？"></a>不同的连接同时写数据库会发生什么？</h1><p>就走入了SQLite本身的锁机制。</p>
<p>写数据会去获取保留锁、独占锁。</p>
<p>如果还有连接要写入，就会返回SQLITE_BUSY。</p>
<h1 id="Android中的SQLite的Thread-Mode是什么？"><a href="#Android中的SQLite的Thread-Mode是什么？" class="headerlink" title="Android中的SQLite的Thread Mode是什么？"></a>Android中的SQLite的Thread Mode是什么？</h1><p><a target="_blank" rel="noopener" href="http://www.sqlite.org/threadsafe.html">SQLite官网</a>说默认线程模式是serialized</p>
<p>Android的SQLiteDatabase类的<a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">setLockingEnabled(boolean lockingEnabled)文档</a>说，默认线程模式是Multi-thread。</p>
<p>API 16 setLockingEnabled() 方法又废弃了。</p>
<p>不管怎么说肯定不是single-thread，不是multi-thread就是serialized。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11167834/what-is-the-default-threading-mode-of-sqlite-in-android">What is the Default Threading mode of SQLite in Android?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">数据库索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-15 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-15T20:31:00+08:00">2017-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/数据库索引/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="索引的作用？"><a href="#索引的作用？" class="headerlink" title="索引的作用？"></a>索引的作用？</h1><p>按某列的条件做查询后（where子句中访问的列），需要线性扫描全表太慢了。</p>
<p>用B+树实现索引可以在对数时间内完成查询。</p>
<h1 id="索引为什么不用平衡二叉查找树，要用B树或B-树做索引？"><a href="#索引为什么不用平衡二叉查找树，要用B树或B-树做索引？" class="headerlink" title="索引为什么不用平衡二叉查找树，要用B树或B+树做索引？"></a>索引为什么不用平衡二叉查找树，要用B树或B+树做索引？</h1><p>B树又称多路平衡二叉查找树，一个结点存储多个值，可以降低树的高度，即降低了访问结点的次数，一次访问可以认为是一次IO，降低了IO次数就会提高整体的访问速度。</p>
<h1 id="为什么不用哈希表做索引？查询时间复杂度不是O-1"><a href="#为什么不用哈希表做索引？查询时间复杂度不是O-1" class="headerlink" title="为什么不用哈希表做索引？查询时间复杂度不是O(1)?"></a>为什么不用哈希表做索引？查询时间复杂度不是O(1)?</h1><ol>
<li> 哈希索引对于范围查询和排序却无法很好地支持，最终导致全表扫描</li>
<li> 哈希索引不支持多列联合索引的最左匹配规则</li>
<li> 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li>
</ol>
<h1 id="为什么用B-树做索引而不用B树？"><a href="#为什么用B-树做索引而不用B树？" class="headerlink" title="为什么用B+树做索引而不用B树？"></a>为什么用B+树做索引而不用B树？</h1><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</p>
<p> B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。</p>
<p>而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间。</p>
<h1 id="使用B树做索引的好处？"><a href="#使用B树做索引的好处？" class="headerlink" title="使用B树做索引的好处？"></a>使用B树做索引的好处？</h1><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h1 id="索引有什么缺点？"><a href="#索引有什么缺点？" class="headerlink" title="索引有什么缺点？"></a>索引有什么缺点？</h1><ol>
<li> 占用空间，因为会把列的信息都复制一遍</li>
<li> 插入、修改、删除时需要额外花时间更新索引</li>
</ol>
<h1 id="索引适用场景？"><a href="#索引适用场景？" class="headerlink" title="索引适用场景？"></a>索引适用场景？</h1><p>适用查询非常频繁而更新不频繁的列。</p>
<h2 id="where子句中对列的访问"><a href="#where子句中对列的访问" class="headerlink" title="where子句中对列的访问"></a>where子句中对列的访问</h2><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p>
<h1 id="为什么外键要加索引？"><a href="#为什么外键要加索引？" class="headerlink" title="为什么外键要加索引？"></a>为什么外键要加索引？</h1><p>避免子表上的全表扫描。（外键在子表上，外键对应主表的主键）</p>
<p>假设删除departments主表id=10的记录，如果employees子表的department_id外键没有索引，那么就会全表扫描employees子表，以确认是否存在department id=10的记录。</p>
<h1 id="联合索引是什么？"><a href="#联合索引是什么？" class="headerlink" title="联合索引是什么？"></a>联合索引是什么？</h1><p>对多个字段联合创建的索引。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232210.png"></p>
<p>只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p>
<p>通俗理解：</p>
<p>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</p>
<p>所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p>
<p>查英语字典、汉语字典也是这样。</p>
<h1 id="联合索引的底层实现是怎样的？"><a href="#联合索引的底层实现是怎样的？" class="headerlink" title="联合索引的底层实现是怎样的？"></a>联合索引的底层实现是怎样的？</h1><p>索引的底层是一颗B+树，联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。</p>
<p>构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。</p>
<p>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232238.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p>联合索引会对最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序，以此类推。</p>
<p>所以如果要利用到联合索引中靠后列的索引，前面列就必须相等，如果前面列不相等（比如用范围查询），那么后面的列没办法保证顺序，后面列的顺序都是在前面列相等的情况下才保持顺序的。</p>
<h1 id="为什么表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么表必须有主键，并且推荐使用整型的自增主键？"></a>为什么表必须有主键，并且推荐使用整型的自增主键？</h1><p>不建主键不代表没有主键，没有建主键innodb会帮你选一个字段，一个可以标识唯一的字段，选为默认字段，如果这个字段唯一的话，不重复，可一键唯一索引的话，就会作为类似于唯一索引，用这个字段来作为唯一索引来维护整个表的数据。如果没有，mysql会生成一个唯一的列，类似于rowid，只不过你看不到，他会用生成的这个唯一列，维护B+Tree的结构，查数据的时候还是用B+Tree的结构去查找。</p>
<h2 id="为什么推荐整型呢？"><a href="#为什么推荐整型呢？" class="headerlink" title="为什么推荐整型呢？"></a>为什么推荐整型呢？</h2><p>我们想象一下查找过程，是把节点load到内存然后在内存里去比较大小，也就是在查找的过程中要不断的去进行数据的比对。假设UUID，既不自增也不是整形。问一下，是整形的1&lt;2比较的效率高还是字符串的“abc”和“abe”比较的效率高呢？显然是前者，因为字符串的比较是转换成ASICI一位一位的比，如果最后一位不一样，比到最后才比较出大小，就比整形比较慢多了，存储空间来说，整形更小。索引越节约资源越好。</p>
<p>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232458.png"></p>
<p>所以建议使用int的auto_increment作为主键。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232514.png"><br>主键的值是顺序的，所以每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p>
<h2 id="为什么是自增的呢？"><a href="#为什么是自增的呢？" class="headerlink" title="为什么是自增的呢？"></a>为什么是自增的呢？</h2><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h1 id="聚簇索引是什么？"><a href="#聚簇索引是什么？" class="headerlink" title="聚簇索引是什么？"></a>聚簇索引是什么？</h1><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>数据库表数据是用B+树来存储组织的，那么这个B+树可以认为是一种索引，这就是聚簇索引。</p>
<p>索引是针对某一列而言的，一般的聚簇索引就是主键列。</p>
<p>聚簇索引确定了表数据的物理存储顺序，聚簇索引B+树的叶子结点存储的是整个行数据</p>
<p>由于聚簇索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚簇索引。</p>
<p>聚簇索引类似于电话簿，按姓氏排列数据。汉语字典也是聚簇索引的典型应用，在汉语字典里，索引项是字母+声调，字典正文也是按照先字母再声调的顺序排列。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<p>如果是普通的索引，B+树的叶子结点存储的行的主键，然后需要再去聚簇索引下去查询一遍，找到完整的行数据，有一个回表查询的过程，所以在聚簇索引上查询会少了回表查询的过程，查询速度快。</p>
<p>MySQL官方对聚簇索引的解释：</p>
<p><strong>The InnoDB term for a primary key index</strong>. InnoDB table storage is organized based on the values of the primary key columns, to speed up queries and sorts involving the primary key columns. For best performance, choose the primary key columns carefully based on the most performance-critical queries. Because modifying the columns of the clustered index is an expensive operation, choose primary columns that are rarely or never updated.</p>
<p>注意标黑的那段话，聚簇索引就是主键的一种术语。</p>
<h1 id="聚簇索引有什么用？"><a href="#聚簇索引有什么用？" class="headerlink" title="聚簇索引有什么用？"></a>聚簇索引有什么用？</h1><p>聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">聚集索引</a>可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚簇（物理排序），避免每次查询该列时都进行排序，从而节省成本。</p>
<p>在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查(between、&lt;、&lt;=、&gt;、&gt;=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大大提高查询速度。</p>
<h1 id="为什么非聚簇索引结构叶子节点存储的是主键值？"><a href="#为什么非聚簇索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非聚簇索引结构叶子节点存储的是主键值？"></a>为什么非聚簇索引结构叶子节点存储的是主键值？</h1><p>为了一致性和节省存储空间。已经维护了一套主键索引+数据的B+Tree结构，如果再有其他的非主键索引的话，索引的叶子节点存储的是主键，这是为了节省空间，因为继续存数据的话，那就会导致一份数据存了多份，空间占用就会翻倍。另一方面也是一致性的考虑，都通过主键索引来找到最终的数据，避免维护多份数据导致不一致的情况。</p>
<h1 id="哪些列适合作为聚簇索引？"><a href="#哪些列适合作为聚簇索引？" class="headerlink" title="哪些列适合作为聚簇索引？"></a>哪些列适合作为聚簇索引？</h1><p>1、主键列,该列在where子句中使用并且插入是随机的。</p>
<p>2、按范围存取的列，如pri_order &gt; 100 and pri_order &lt; 200。</p>
<p>3、在group by或order by中使用的列。</p>
<p>4、不经常修改的列。</p>
<p>5、在连接操作中使用的列。</p>
<h1 id="聚簇索引的优点和缺点？"><a href="#聚簇索引的优点和缺点？" class="headerlink" title="聚簇索引的优点和缺点？"></a>聚簇索引的优点和缺点？</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li> 适合范围查询</li>
<li> 适配排序</li>
<li> 当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引只能定位到对应主键，然后要再回表查询聚簇索引，才能找到完整的行数据。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p>
<p>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
<p>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
<p>4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
<h1 id="二级索引是什么？"><a href="#二级索引是什么？" class="headerlink" title="二级索引是什么？"></a>二级索引是什么？</h1><p>表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p>
<p>除了聚簇索引以外的所有索引都称为二级索引，二级索引的叶子节点内容是主键的值。</p>
<p>二级索引没有存储全部的数据，假如二级索引满足查询需求，则直接返回，即为覆盖索引，反之则需要回表去主键索引(聚簇索引)查询。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233004.png"></p>
<h1 id="何时使用聚簇索引与非聚簇索引？"><a href="#何时使用聚簇索引与非聚簇索引？" class="headerlink" title="何时使用聚簇索引与非聚簇索引？"></a>何时使用聚簇索引与非聚簇索引？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233032.png"></p>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><p>（1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列，即较频繁作为查询条件的字段才去创建索引</p>
<p>（2）取值离散小、查询中很少涉及、重复值比较多的列，索引效果较差，没有必要在此列建立索引</p>
<p>（3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p>
<p>（4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<p>（5）更新频繁字段不适合创建索引。</p>
<h1 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h1><ol>
<li> 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li> 存储引擎不能使用索引范围条件右边的列</li>
<li> 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</li>
<li> mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li> is null,is not null也无法使用索引</li>
<li> like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/" class="post-title-link" itemprop="url">关系型数据库-范式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-12 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-12T20:31:00+08:00">2017-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/关系型数据库-范式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="范式解决的是什么问题？"><a href="#范式解决的是什么问题？" class="headerlink" title="范式解决的是什么问题？"></a>范式解决的是什么问题？</h1><p>消除数据冗余，提高增删改查的性能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Java/Java%20%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java%20%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/" class="post-title-link" itemprop="url">Java 泛型、上下界通配符、泛型擦除</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-26 19:22:00" itemprop="dateCreated datePublished" datetime="2016-10-26T19:22:00+08:00">2016-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java/Java%20%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java/Java 泛型、上下界通配符、泛型擦除/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="泛型解决的是什么问题？"><a href="#泛型解决的是什么问题？" class="headerlink" title="泛型解决的是什么问题？"></a>泛型解决的是什么问题？</h1><p>在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p>
<p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。</p>
<h1 id="通配符表示什么？"><a href="#通配符表示什么？" class="headerlink" title="通配符表示什么？"></a>通配符表示什么？</h1><p>通配符?表示未知类型</p>
<h1 id="泛型存在什么问题？"><a href="#泛型存在什么问题？" class="headerlink" title="泛型存在什么问题？"></a>泛型存在什么问题？</h1><p>泛型的类型存在继承关系，不代表使用泛型的类也存在继承关系。</p>
<p>例如Integer是Number的子类，List<Integer>不是List<Number>的子类，不能把List<Integer>的变量赋值给List<Number>的变量。</p>
<h1 id="为什么不能把List的变量赋值给List的变量？"><a href="#为什么不能把List的变量赋值给List的变量？" class="headerlink" title="为什么不能把List的变量赋值给List的变量？"></a>为什么不能把List<Integer>的变量赋值给List<Number>的变量？</h1><p>因为List<Number>可能还存储Float、Double等类型的元素，List<Integer>如果可以赋值给List<Number>，List<Integer>里就可以存储Float、Double等非Integer元素了，这与泛型的定义冲突</p>
<h1 id="上界通配符是什么？"><a href="#上界通配符是什么？" class="headerlink" title="上界通配符是什么？"></a>上界通配符是什么？</h1><p><code>&lt;? extends T&gt;</code>：是指 “上界通配符（Upper Bounds Wildcards）”。</p>
<p>上界通配符只能读取，因为读取到的类型进行类型转换是安全的，所有的子类都可以安全的转换为父类。</p>
<p>但是不能插入，因为不知道具体类型。</p>
<h1 id="下界通配符是什么？"><a href="#下界通配符是什么？" class="headerlink" title="下界通配符是什么？"></a>下界通配符是什么？</h1><p><code>&lt;? super T&gt;</code>：是指 “下界通配符（Lower Bounds Wildcards）”</p>
<p>当你知道集合里所持有的元素类型都是A及其父类的时候，此时往list集合里面插入A及其子类（B或C）是安全的。</p>
<h1 id="泛型通配符具体的使用场景？"><a href="#泛型通配符具体的使用场景？" class="headerlink" title="泛型通配符具体的使用场景？"></a>泛型通配符具体的使用场景？</h1><p>有一组类继承关系如下：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210829000917.png"></p>
<p>一个常见的获取容器元素的需求就是，写一个基于容器元素基类的方法，从容器中去取出元素进行打印，而不用针对每一个具体子类定义打印方法。</p>
<p>但实际<code>List&lt;Apple&gt;</code>不能赋值给<code>List&lt;Fruit&gt;</code>，编译会报错，如下：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210829000935.png"></p>
<p>因为<code>List&lt;Fruit&gt;</code>可能还持有Banana或Pear，与<code>List&lt;Apple&gt;</code>不能等价。</p>
<p>把<code>List&lt;Fruit&gt;</code>改为<code>List&lt;? extends Fruit&gt;</code>就可以了，这个上界通配符的意思是，List里持有的都是Fruit的子类，具体是哪些子类不知道，<code>List&lt;Apple&gt;</code>可以看做是<code>List&lt;? extends Fruit&gt;</code>子类，从<code>List&lt;? extends Fruit&gt;</code>也只能取出Fruit，不能取出Fruit的子类。但是不能给<code>List&lt;? extends Fruit&gt;</code>里add任何的Apple、Banana、Pear，因为 <code>? extends Fruit</code> 并不知道具体的子类是什么。</p>
<p>需要读取就用上界匹配符。</p>
<p>当需要往容器添加元素，<code>List&lt;Object&gt;</code>不能直接赋值给<code>List&lt;Fruit&gt;</code>变量。</p>
<p>因为<code>List&lt;Object&gt;</code>可能存在非Fruit的元素，如果允许赋值，跟类型定义就矛盾了。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210829001034.png"></p>
<p>解决方法就是把<code>List&lt;Fruit&gt;</code>改为<code>List&lt;? super Fruit&gt;</code></p>
<p><code>addVariousFruits(List&lt;? super Fruit&gt; fruitList)</code></p>
<p>下界通配符表示容器中都是Fruit的父类元素，<code>List&lt;? super Fruit&gt;</code>是<code>List&lt;Object&gt;</code>的父类，所以<code>List&lt;Object&gt;</code>可以赋值给<code>List&lt;? super Fruit&gt;</code>变量。</p>
<h1 id="什么时候用上界通配符？什么时候用下界通配符？"><a href="#什么时候用上界通配符？什么时候用下界通配符？" class="headerlink" title="什么时候用上界通配符？什么时候用下界通配符？"></a>什么时候用上界通配符？什么时候用下界通配符？</h1><p>PECS原则：Producer extends Consumer super</p>
<ul>
<li>  如果你只需要从集合中获得类型T , 使用&lt;? extends T&gt;通配符</li>
<li>  如果你只需要将类型T放到集合中, 使用&lt;? super T&gt;通配符</li>
<li>  如果你既要获取又要放置元素，则不使用任何通配符。</li>
</ul>
<h1 id="泛型擦除是什么意思"><a href="#泛型擦除是什么意思" class="headerlink" title="泛型擦除是什么意思?"></a>泛型擦除是什么意思?</h1><p>仅于编译时类型检查，在运行时擦除类型信息。</p>
<p>生成的字节码中不包含泛型的类型信息。</p>
<h1 id="泛型擦除会带来什么问题？"><a href="#泛型擦除会带来什么问题？" class="headerlink" title="泛型擦除会带来什么问题？"></a>泛型擦除会带来什么问题？</h1><p>在编译时不一定能靠编译器坚持出类型错误，擦除使得使用泛型的代码可以和没有使用泛型的代码随意互用，这样运行时有可能发生类型转换异常。</p>
<p>比如通过反射调用代码，可以绕过编译器的类型错误检查，因为反射是在运行时发生的，编译后泛型的类型就被擦除了，所以不会报错。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828230831.png"><br>深入理解Java虚拟机（第2版）10.3.1 泛型与类型擦除</p>
<p>如下的代码输出结果为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = new ArrayList&lt;String&gt;(); </span><br><span class="line">List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">System.out.println(l1.getClass() == l2.getClass());</span><br></pre></td></tr></table></figure>

<h1 id="既然泛型擦除有问题，为什么当初不设计成跟C-模板那种一样呢？"><a href="#既然泛型擦除有问题，为什么当初不设计成跟C-模板那种一样呢？" class="headerlink" title="既然泛型擦除有问题，为什么当初不设计成跟C++模板那种一样呢？"></a>既然泛型擦除有问题，为什么当初不设计成跟C++模板那种一样呢？</h1><p>C++的模板实例化类时会为每种类型都创建新的类，就会造成代码膨胀。</p>
<p>同时为了保持JDK5之前的代码能够兼容运行。</p>
<h1 id="泛型擦除的优点"><a href="#泛型擦除的优点" class="headerlink" title="泛型擦除的优点"></a>泛型擦除的优点</h1><ol>
<li> 兼容JDK5之前的代码</li>
<li> 不会像C++模板造成代码膨胀</li>
</ol>
<h1 id="泛型擦除的缺点"><a href="#泛型擦除的缺点" class="headerlink" title="泛型擦除的缺点"></a>泛型擦除的缺点</h1><ol>
<li> 编译时不一定能靠编译器坚持出类型错误，这样运行时有可能发生类型转换异常，例如反射可以绕过编译器的类型错误检查。</li>
<li> 不能创建具体类型的泛型数组。</li>
<li> 方法重载时不同的泛型具体类会被认为擦除后是一个类型从而禁止重载。</li>
</ol>
<h1 id="为什么不能创建具体类型的泛型数组？"><a href="#为什么不能创建具体类型的泛型数组？" class="headerlink" title="为什么不能创建具体类型的泛型数组？"></a>为什么不能创建具体类型的泛型数组？</h1><p><code>List&lt;Integer&gt;[] list = new ArrayList&lt;Integer&gt;[];</code></p>
<p>这段代码编译会不通过</p>
<p><code>List&lt;Integer&gt;</code>和  <code>List&lt;Boolean&gt;</code>在 jvm 中等同于<code>List&lt;Object&gt;</code>，所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是  <code>List&lt;Integer&gt;</code>类型还是  <code>List&lt;Boolean&gt;</code>类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Java/Java%20Integer%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java%20Integer%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Java Integer缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-25 20:25:00" itemprop="dateCreated datePublished" datetime="2016-10-25T20:25:00+08:00">2016-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java/Java%20Integer%E7%BC%93%E5%AD%98/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java/Java Integer缓存/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Integer的缓存机制是怎么回事？"><a href="#Integer的缓存机制是怎么回事？" class="headerlink" title="Integer的缓存机制是怎么回事？"></a>Integer的缓存机制是怎么回事？</h1><p>学会看字节码就知道自动装箱拆箱实际调用的是什么。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Java/Java%20Integer%E7%BC%93%E5%AD%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Java/Java%20%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81Integer%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java%20%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81Integer%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Java 自动装箱、自动拆箱</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-23 22:03:00" itemprop="dateCreated datePublished" datetime="2016-10-23T22:03:00+08:00">2016-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java/Java%20%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81Integer%E7%BC%93%E5%AD%98/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java/Java 自动装箱、Integer缓存/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么要有装箱和拆箱？"><a href="#为什么要有装箱和拆箱？" class="headerlink" title="为什么要有装箱和拆箱？"></a>为什么要有装箱和拆箱？</h1><p>有些情况下基本类型无法实现对应功能。</p>
<h1 id="有哪些场景不得不使用包装类？"><a href="#有哪些场景不得不使用包装类？" class="headerlink" title="有哪些场景不得不使用包装类？"></a>有哪些场景不得不使用包装类？</h1><ol>
<li> 集合类只能使用包装类型，不允许使用基本类型，所以需要有包装类</li>
<li> 由于基本类型没有null的状态，所以需要有包装类对象能够表示null</li>
<li> 泛型只针对类，不能使用基本类型</li>
<li> 反射也只能反射类，不能反射基本类型</li>
<li> 包装类一旦创建，是值不可变的对象，不容易赋值出错
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Java/Java%20%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81Integer%E7%BC%93%E5%AD%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Java/RxJava%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/RxJava%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">RxJava浅析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-12 21:23:00" itemprop="dateCreated datePublished" datetime="2016-09-12T21:23:00+08:00">2016-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java/RxJava%E6%B5%85%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java/RxJava浅析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RxJava背景"><a href="#RxJava背景" class="headerlink" title="RxJava背景"></a>RxJava背景</h1><p>RxJava是NetFlix出品的Java框架， 官方描述为 a library for composing asynchronous and event-based programs using observable sequences for the Java VM，翻译过来就是“使用可观察序列组成的一个异步地、基于事件的响应式编程框架”。</p>
<h1 id="RxJava可以解决什么问题？"><a href="#RxJava可以解决什么问题？" class="headerlink" title="RxJava可以解决什么问题？"></a>RxJava可以解决什么问题？</h1><p>主要是对数据流的组合变换非常强大和方便。</p>
<ul>
<li>各种偏函数式风格的操作符</li>
<li>冷热流</li>
<li>异步转同步</li>
<li>解决回调地狱</li>
</ul>
<p>主要缺点是学习和理解成本过高。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Java/RxJava%E6%B5%85%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">序列化：Serializable与Parceable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-05 21:03:00" itemprop="dateCreated datePublished" datetime="2016-08-05T21:03:00+08:00">2016-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java/Java Serializable序列化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="序列化的意义和价值是什么？"><a href="#序列化的意义和价值是什么？" class="headerlink" title="序列化的意义和价值是什么？"></a>序列化的意义和价值是什么？</h1><p>序列化就是把对象转换为字节序列。</p>
<p>反序列化就是把字节序列还原为对象。</p>
<p>对象是程序运行时的信息载体，序列化机制使得对象信息可以脱离程序的运行而独立存在，这样便于进行网络传输或持久性存储到磁盘。</p>
<h1 id="序列化考量的重点是什么？"><a href="#序列化考量的重点是什么？" class="headerlink" title="序列化考量的重点是什么？"></a>序列化考量的重点是什么？</h1><ol>
<li> 协议是否跨平台</li>
<li> 序列化速度</li>
<li> 字节序列大小</li>
</ol>
<h1 id="Serializable底层运作机制是怎样的？"><a href="#Serializable底层运作机制是怎样的？" class="headerlink" title="Serializable底层运作机制是怎样的？"></a>Serializable底层运作机制是怎样的？</h1><p>查看ObjectInputStream的readObject方法  和 ObjectOutputStream的writeObject的代码。</p>
<p>主要运用了反射。</p>
<h1 id="Serializable如何自定义决定哪些字段写入和读取？"><a href="#Serializable如何自定义决定哪些字段写入和读取？" class="headerlink" title="Serializable如何自定义决定哪些字段写入和读取？"></a>Serializable如何自定义决定哪些字段写入和读取？</h1><ol>
<li> 通过transient关键字修饰属性，排除在序列化之外</li>
<li> 在类中增加writeObejct和readObject方法，JDK中的ArrayList、HashMap等都复写了writeObject</li>
<li> 在类中增加writeReplace和readResolve方法，提供了writeReplace就不会执行writeObject，提供了readResolve就不会执行readObject</li>
<li> 实现Externalizable接口，显式实现readExternal和writeExternal</li>
</ol>
<p>Java为用户定义了默认的序列化、反序列化方法，其实就是ObjectOutputStream的defaultWriteObject方法和ObjectInputStream的defaultReadObject方法。</p>
<p>为什么HashMap要自定义序列化逻辑呢？<br>可能的原因是，存储数据的数组table，一般都是不满的（因为HashMap的负载因子默认0.75，超过就会扩容），里面肯定会有很多null，如果是默认的序列化，这些null也会被被序列化，显然这些null是没有必要的做序列化的。</p>
<p>ArrayList自定义序列化方法，也是因为elementData数组可能没存满。</p>
<h1 id="serialVersionUID是干什么的？"><a href="#serialVersionUID是干什么的？" class="headerlink" title="serialVersionUID是干什么的？"></a>serialVersionUID是干什么的？</h1><p>反序列化需要指定一个类，但是类的结构会变更，如何保证已经序列化的字节序列与当前的类结构是对应上的，可以在字节序列和类中分别存储一个版本号，只有版本号相同，就当做是可转行的，版本号不同反序列化就报错。</p>
<p>类中指定版本号是使用private static final long serialVersionUID属性，值为任意。如果不声明这个属性，虚拟机会根据类信息自动生成一个版本号。</p>
<p>这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</p>
<h1 id="什么情况下需要修改serialVersionUID呢？"><a href="#什么情况下需要修改serialVersionUID呢？" class="headerlink" title="什么情况下需要修改serialVersionUID呢？"></a>什么情况下需要修改serialVersionUID呢？</h1><p>分三种情况：</p>
<ol>
<li> 如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li>
<li> 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li>
<li> 如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li>
</ol>
<h1 id="Serializable序列化会有什么问题？"><a href="#Serializable序列化会有什么问题？" class="headerlink" title="Serializable序列化会有什么问题？"></a>Serializable序列化会有什么问题？</h1><p>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</p>
<p>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</p>
<h1 id="Serializable反序列化会有什么问题？"><a href="#Serializable反序列化会有什么问题？" class="headerlink" title="Serializable反序列化会有什么问题？"></a>Serializable反序列化会有什么问题？</h1><p>反序列化不会调用类的构造函数，会调用第一个非序列化父类的无参构造函数</p>
<p>这点可以通过 ObjectInputSteam -&gt; readObject -&gt; readObject0 -&gt; readOrdinaryObject -&gt; desc.newInstance() 得知，desc是ObjectStreamClass的实例，ObjectStreamClass.newInstance()的注释是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new instance of the represented class.  If the class is</span><br><span class="line"> * externalizable, invokes its public no-arg constructor; otherwise, if the</span><br><span class="line"> * class is serializable, invokes the no-arg constructor of the first</span><br><span class="line"> * non-serializable superclass.  Throws UnsupportedOperationException if</span><br><span class="line"> * this class descriptor is not associated with a class, if the associated</span><br><span class="line"> * class is non-serializable or if the appropriate no-arg constructor is</span><br><span class="line"> * inaccessible/unavailable.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>这样设计的目的是什么？</p>
<p>推测是因为如果调用了类的构造函数，如果构造函数中有改变类属性状态的代码，反序列化后就得不到序列化时的状态了，所以不能调用。</p>
<h1 id="Serializable的具体序列化执行过程中哪些地方用到了大量的反射？"><a href="#Serializable的具体序列化执行过程中哪些地方用到了大量的反射？" class="headerlink" title="Serializable的具体序列化执行过程中哪些地方用到了大量的反射？"></a>Serializable的具体序列化执行过程中哪些地方用到了大量的反射？</h1><p>因为没有在代码层面手动写入特定字段，序列化都是全自动化的，在ObjectOutputStream底层都是通过反射获取类的字段信息，defaultWriteFields()读取类的属性字段是通过Field，Field从ObjectStreamClass的getFields()得来，getFields()内部还是反射。</p>
<p>ObjectInputStream也通过反射创建类。</p>
<h1 id="Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？"><a href="#Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？" class="headerlink" title="Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？"></a>Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？</h1><p>创建大量的临时对象会引发频繁的垃圾回收，垃圾回收会stop the world，进而引起进程的卡顿。</p>
<p>Serializable的序列化过程比较复杂，有很多对象参与工作，例如ObjectStreamClass。</p>
<h1 id="Parceable底层运作机制是怎样的？"><a href="#Parceable底层运作机制是怎样的？" class="headerlink" title="Parceable底层运作机制是怎样的？"></a>Parceable底层运作机制是怎样的？</h1><p>Interface for classes whose instances can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field called CREATOR of a type that implements the Parcelable.Creator interface.<br>A typical implementation of Parcelable is:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mData;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(mData);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;MyParcelable&gt; CREATOR</span><br><span class="line">            = <span class="keyword">new</span> Parcelable.Creator&lt;MyParcelable&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyParcelable <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable(in);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> MyParcelable[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        mData = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parcelable通过Parcel的一系列read和write方法实现序列化，Parcel的read和write方法都是在native层实现。</p>
<p>Parcel把对象数据直接序列化输出在内存，并且数据结构很紧凑，几乎只存储数据值，不存储额外的信息，而Serializable会存储很多额外的信息，所以Parcel序列化的输出的信息量就比Serializable少，同时没有用反射，而是直接操作内存指针，因此速度更快。<br>缺点：<br>    1. 由于数据紧凑，没有存储必要的判断信息，不能用于持久化存储，因为反序列化时，缺乏足够的信息来保证数据恢复的正确性。<br>    2. 需要手动指定哪些字段写入，并且写入顺序和读入顺序要一致</p>
<h1 id="Parceable与Serializable有什么区别？"><a href="#Parceable与Serializable有什么区别？" class="headerlink" title="Parceable与Serializable有什么区别？"></a>Parceable与Serializable有什么区别？</h1><p>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作。</p>
<p>Parcelable  自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828174331.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Android ViewDragHelper源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-05-21 17:58:17" itemprop="dateCreated datePublished" datetime="2015-05-21T17:58:17+08:00">2015-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:16:10" itemprop="dateModified" datetime="2021-08-31T12:16:10+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android ViewDragHelper源码解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">181</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">236</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
