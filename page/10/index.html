<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/10/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-CopyOnWriteArrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-CopyOnWriteArrayList/" class="post-title-link" itemprop="url">Java集合类-CopyOnWriteArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-13 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-13T20:00:00+08:00">2018-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-CopyOnWriteArrayList/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-CopyOnWriteArrayList/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ArrayList存在什么问题？"><a href="#ArrayList存在什么问题？" class="headerlink" title="ArrayList存在什么问题？"></a>ArrayList存在什么问题？</h1><p>ArrayList是线程不安全的。</p>
<p>可以用Collections.synchronizedList()加全局独占锁保证线程安全，但在读多写少的情况下，多线程读之间互斥降低了系统吞吐量。</p>
<p>如果读与读之间不互斥，写与写、写与读才互斥，这样可以保证最大的吞吐量，这就是CopyOnWriteArrayList。</p>
<h1 id="CopyOnWriteArrayList保证线程安全的原理？"><a href="#CopyOnWriteArrayList保证线程安全的原理？" class="headerlink" title="CopyOnWriteArrayList保证线程安全的原理？"></a>CopyOnWriteArrayList保证线程安全的原理？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用读写锁保证并发，可以保证读读之间没有阻塞等待，但有线程写数据时，读线程必须阻塞等待，这保证了每次都都可以读到最新修改的值。</p>
<p>CopyOnWriteArrayList牺牲了读的实时性，读操作不上锁，只在写数据时使用ReentrantLock上锁，写数据时会把原数组拷贝到新的数组中，写数据的同时再有线程读数据，读到的是之前数组的值，不保证数据实时性，只保证最终结果一致性，牺牲了数据实时性，换取了读操作没有阻塞等待。</p>
<p>对数据实时性要求很高的需求，不要使用CopyOnWriteArrayList。</p>
<p>线程1在add数据时，线程2随后get数据，不一定能获取到线程1刚add的的元素，因为线程1可能还没执行完。</p>
<h1 id="CopyOnWriteArrayList存在什么问题？"><a href="#CopyOnWriteArrayList存在什么问题？" class="headerlink" title="CopyOnWriteArrayList存在什么问题？"></a>CopyOnWriteArrayList存在什么问题？</h1><ol>
<li> 读数据不是实时的，读的时候可能正在写数据，读不到最新的值，也不会阻塞等待，适合读多写少的场景</li>
<li> 每次写数据都要复制整个数组，如果写操作频繁，会频繁触发垃圾回收，垃圾回收又会导致线程停顿，造成APP卡顿变多</li>
</ol>
<h1 id="CopyOnWriteArrayList适用场景？"><a href="#CopyOnWriteArrayList适用场景？" class="headerlink" title="CopyOnWriteArrayList适用场景？"></a>CopyOnWriteArrayList适用场景？</h1><ol>
<li> 高并发</li>
<li> 读多写少</li>
<li> 对读数据实时性要求不高</li>
</ol>
<h1 id="为什么没有扩容"><a href="#为什么没有扩容" class="headerlink" title="为什么没有扩容?"></a>为什么没有扩容?</h1><p>因为每次add元素都要拷贝数组，这个时间消耗是必须的，所以也没必要扩容了，拷贝数据到一个恰好比原数组多一个位置的新数组。</p>
<h1 id="Vector有什么问题"><a href="#Vector有什么问题" class="headerlink" title="Vector有什么问题?"></a>Vector有什么问题?</h1><ol>
<li> Vector是线程安全的列表，底层实现也是数组，但是几乎每一个方法都加上了synchonized，多线程读操作之间会互斥，读多写少的情况下，吞吐量不高</li>
<li> Vector扩容，容量是翻倍，指数增长，ArrayList只增长为原来的1.5倍，更节约空间。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/" class="post-title-link" itemprop="url">Java集合类-ArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-12 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-12T20:00:00+08:00">2018-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-ArrayList/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ArrayList如何扩容的？"><a href="#ArrayList如何扩容的？" class="headerlink" title="ArrayList如何扩容的？"></a>ArrayList如何扩容的？</h1><p>无参构造函数中初始化一个空数组</p>
<p>调用add，往数组末尾添加元素前，会调用ensureCapacityInternal(size+1)，第一次会创建DEFAULT_CAPACITY（值为10）长度的数组，再会调用grow()，新的数组长度为之前长度的1.5倍，接着调用Arrays.copyOf()将旧的数组元素复制到新数组中，底层实现是System.arraycopy()。</p>
<p>以上是自动扩容，也可以调用ensureCapacity(minCapacity)来手动扩容，需要手动扩容因为，如果提前知道数据量很大，就可以直接扩容到指定容量，自动扩容每次都会扩容原来的1.5倍，避免频繁拷贝数组的开销。</p>
<p>remove和clear后没有缩容，只会把数组中不需要的元素对应的位置设置为null，以便垃圾回收。</p>
<h1 id="ArrayList查询元素的时间复杂度是多少？"><a href="#ArrayList查询元素的时间复杂度是多少？" class="headerlink" title="ArrayList查询元素的时间复杂度是多少？"></a>ArrayList查询元素的时间复杂度是多少？</h1><p>数组访问任意位置元素的时间复杂度为O(1)</p>
<h1 id="ArrayList插入元素的时间复杂度是多少？"><a href="#ArrayList插入元素的时间复杂度是多少？" class="headerlink" title="ArrayList插入元素的时间复杂度是多少？"></a>ArrayList插入元素的时间复杂度是多少？</h1><p>插入末尾时间复杂度为O(1)，因为有指针记录末尾的位置，有新元素直接填充末尾的空位，当末尾没有空位时，需要扩容，扩容为原来长度的1.5倍，扩容需要拷贝旧数组的数据到新数组，时间复杂度是O(n），所以插入元素到末尾的均摊时间复杂度是O(1)。</p>
<p>插入元素到中间位置的时间复杂度较高，因为要把插入位置后面所有元素后移一位，设数组长度为n，插入第1、2、3、… 、n-1、n个位置，分别需要移动元素的个数是n、n-1、n-2、… 、2、1，由等差数列求和公式得结果为n(n+1)/2，除以n得平均移动(n+1)/2个，所以插入到中间位置的平均时间复杂度是O(n)。</p>
<h1 id="ArrayList删除元素的时间复杂度是多少？"><a href="#ArrayList删除元素的时间复杂度是多少？" class="headerlink" title="ArrayList删除元素的时间复杂度是多少？"></a>ArrayList删除元素的时间复杂度是多少？</h1><p>与插入元素的情况一样，删除末尾元素时间复杂度为O(1)，删除中间位置的元素要把该位置后面的元素都前移一位，平均时间复杂度为O(n)</p>
<h1 id="ArrayList与LinkedList有何区别？"><a href="#ArrayList与LinkedList有何区别？" class="headerlink" title="ArrayList与LinkedList有何区别？"></a>ArrayList与LinkedList有何区别？</h1><ol>
<li> ArrayList基于数组实现，容量不够时会动态扩容；LinkedList基于链表实现，实际是是一个双向链表，同时可以作为队列、栈使用</li>
<li> ArrayList适合随机访问数据，时间复杂度O(1)；LinkedList不适合随机访问数据，因为这会遍历链表，最坏情况下访问最后一个元素，要遍历整个链表，时间复杂度O(n)</li>
<li> LinkedList适合插入和删除首尾元素，时间复杂度O(1)；ArrayList插入和删除尾元素，其实是在数组的末尾填充元素，时间复杂度O(1)，插入尾元素可能会触发扩容，扩容时会拷贝数组，时间复杂度会达到O(n)，ArrayList插入和删除非末尾元素，需要移动操作，时间复杂度O(n)</li>
<li> LinkedList需要占用更多的内存，因为每个结点除了存储元素数据外，还有额外的链表指针，ArrayList底层是数组，存储的直接是元素数据</li>
<li> ArrayList对于CPU缓存命中率友好，因为存储空间连续，符合数据访问的空间局部性特点</li>
</ol>
<h1 id="如何求两个ArrayList的交集、并集、差集？"><a href="#如何求两个ArrayList的交集、并集、差集？" class="headerlink" title="如何求两个ArrayList的交集、并集、差集？"></a>如何求两个ArrayList的交集、并集、差集？</h1><p>并集：addAll</p>
<p>交集：retainAll</p>
<p>差集：removeAll</p>
<h1 id="ArrayList序列化有什么注意事项？"><a href="#ArrayList序列化有什么注意事项？" class="headerlink" title="ArrayList序列化有什么注意事项？"></a>ArrayList序列化有什么注意事项？</h1><p>底层的elementData数组，可能没有填充满，所以不能直接序列化，会浪费空间，序列化时要先写入数组元素真实个数，再写入数组中实际存储的元素</p>
<h1 id="Arrays-asList-T…-a-有什么坑"><a href="#Arrays-asList-T…-a-有什么坑" class="headerlink" title="Arrays.asList(T… a)有什么坑"></a>Arrays.asList(T… a)有什么坑</h1><ol>
<li> 传递一个原始数据类型的数组，例如int[]，会只被当做一个元素，只能使用对象类型的数组</li>
<li> 得到的list无法add、remove、clear，会抛出异常</li>
</ol>
<h1 id="ArrayList有什么坑？"><a href="#ArrayList有什么坑？" class="headerlink" title="ArrayList有什么坑？"></a>ArrayList有什么坑？</h1><p>List.remove()有两个。</p>
<p>一个public E remove(int index)</p>
<p>一个是public boolean remove(Object o)</p>
<p>容易调用不是预期的重载方法。</p>
<h1 id="ArrayList单线程遍历然后删除元素会有什么问题？"><a href="#ArrayList单线程遍历然后删除元素会有什么问题？" class="headerlink" title="ArrayList单线程遍历然后删除元素会有什么问题？"></a>ArrayList单线程遍历然后删除元素会有什么问题？</h1><p>索引错位。</p>
<p>用Iterartor的next迭代列表的时候，通过ArrayList的remove方法移除元素会抛出ConcurrentModificationException，因为迭代器迭代的时候，内部也是用一个int类型指针记录位置的，要是外面删除了元素，位置就错位了，迭代就不准了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c66c47851882562e5443491">ArrayList的扩容机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/2a42d992a5d74435b625415ce511bb69">ArrayList和LinkedList有什么区别？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-LinkedHashMap/" class="post-title-link" itemprop="url">Java集合类-LinkedHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-11 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-11T20:00:00+08:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-LinkedHashMap/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-LinkedHashMap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LinkedHashMap特点"><a href="#LinkedHashMap特点" class="headerlink" title="LinkedHashMap特点"></a>LinkedHashMap特点</h1><p>作用：记录HashMap插入元素的顺序或访问元素的顺序</p>
<p>原理：双向链表和哈希表的结合</p>
<p>使用场景：适用于实现缓存，用空间换时间，如LRU</p>
<p>继承HashMap，大部分操作和HashMap实现一致</p>
<h1 id="元素的顺序在访问时是怎样体现的？"><a href="#元素的顺序在访问时是怎样体现的？" class="headerlink" title="元素的顺序在访问时是怎样体现的？"></a>元素的顺序在访问时是怎样体现的？</h1><p>构造函数可以指定accessOrder：</p>
<ul>
<li>true表示记录元素访问顺序。</li>
<li>false表示记录元素插入的顺序，默认为false。</li>
</ul>
<p>创建一个记录元素访问顺序的LinkedHashMap：<br><code>new LinkedHashMap(16, 0.75f, true)</code></p>
<ul>
<li>记录元素插入顺序时，通过迭代器遍历时，先插入的元素会先访问到。</li>
<li>记录元素访问顺序时，刚访问过的元素会调整到链表末尾，通过迭代器遍历时，先遍历到的是最久没有被访问过的元素。</li>
</ul>
<h1 id="为什么最新插入和最后访问的要放在末尾？"><a href="#为什么最新插入和最后访问的要放在末尾？" class="headerlink" title="为什么最新插入和最后访问的要放在末尾？"></a>为什么最新插入和最后访问的要放在末尾？</h1><p>插入新元素默认就是在链表尾部插入，是符合常规逻辑的，最新访问的放在末尾也就是统一这个规则了。</p>
<h1 id="LinkedHashMap实现原理？"><a href="#LinkedHashMap实现原理？" class="headerlink" title="LinkedHashMap实现原理？"></a>LinkedHashMap实现原理？</h1><p>双向链表的结点类继承HashMap桶中链表的结点类，增加了前后指针，实际效果如下：</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825215429.png"></p>
<h1 id="LinkedHashMap有什么应用？"><a href="#LinkedHashMap有什么应用？" class="headerlink" title="LinkedHashMap有什么应用？"></a>LinkedHashMap有什么应用？</h1><p>LRU缓存。</p>
<p>用LinkedHashMap手撕 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">LeetCode.146. LRU 缓存机制（难度：中等）</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> map = LinkedHashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map[key] ?: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size == capacity &amp;&amp; !map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">val</span> oldest = map.iterator().next()</span><br><span class="line">            map.remove(oldest.key)</span><br><span class="line">        &#125;</span><br><span class="line">        map[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-ArrayMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-ArrayMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Android集合类-ArrayMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-10 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-10T20:00:00+08:00">2018-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-ArrayMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Android集合类-ArrayMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ArrayMap、SparseArray、HashMap的区别？"><a href="#ArrayMap、SparseArray、HashMap的区别？" class="headerlink" title="ArrayMap、SparseArray、HashMap的区别？"></a>ArrayMap、SparseArray、HashMap的区别？</h1><ul>
<li><p>数据结构</p>
<ul>
<li>  ArrayMap和SparseArray采用的都是两个数组，Android专门针对内存优化而设计的</li>
<li>  HashMap采用的是数据+链表+红黑树</li>
</ul>
</li>
<li><p>内存优化</p>
<ul>
<li>  ArrayMap比HashMap更节省内存，综合性能方面在数据量不大的情况下，推荐使用ArrayMap；</li>
<li>  Hash需要创建一个额外对象来保存每一个放入map的entry，且容量的利用率比ArrayMap低，整体更消耗内存</li>
<li>  SparseArray比ArrayMap节省1/3的内存，但SparseArray只能用于key为int类型的Map，所以int类型的Map数据推荐使用SparseArray；</li>
</ul>
</li>
<li><p>性能方面：</p>
<ul>
<li>  ArrayMap查找时间复杂度O(logN)；ArrayMap增加、删除操作需要移动成员，速度相比较慢，对于个数小于1000的情况下，性能基本没有明显差异</li>
<li>  HashMap查找、修改的时间复杂度为O(1)；</li>
<li>  SparseArray适合频繁删除和插入来回执行的场景，性能比较好</li>
</ul>
</li>
<li><p>缓存机制</p>
<ul>
<li>  ArrayMap针对容量为4和8的对象进行缓存，可避免频繁创建对象而分配内存与GC操作，这两个缓存池大小的上限为10个，防止缓存池无限增大；</li>
<li>  HashMap没有缓存机制</li>
<li>  SparseArray有延迟回收机制，提供删除效率，同时减少数组成员来回拷贝的次数</li>
</ul>
</li>
<li><p>扩容机制</p>
<ul>
<li>  ArrayMap是在容量满的时机触发容量扩大至原来的1.5倍，在容量不足1/3时触发内存收缩至原来的0.5倍，更节省的内存扩容机制</li>
<li>  HashMap是在容量的0.75倍时触发容量扩大至原来的2倍，且没有内存收缩机制。HashMap扩容过程有hash重建，相对耗时。所以能大致知道数据量，可指定创建指定容量的对象，能减少性能浪费。</li>
</ul>
</li>
<li><p>并发问题</p>
<ul>
<li>  ArrayMap是非线程安全的类，大量方法中通过对mSize判断是否发生并发，来决定抛出异常。但没有覆盖到所有并发场景，比如大小没有改变而成员内容改变的情况就没有覆盖</li>
<li>  HashMap是在每次增加、删除、清空操作的过程将modCount加1，在关键方法内进入时记录当前mCount，执行完核心逻辑后，再检测mCount是否被其他线程修改，来决定抛出异常。这一点的处理比ArrayMap更有全面。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>HashMap的查找和插入时间复杂度为O(1)的代价是牺牲大量的内存来实现的。</li>
<li>而SparseArray和ArrayMap性能略逊于HashMap，但更节省内存。</li>
<li>SparseArray的key是int类型，ArrayMap的key是任意类型。</li>
<li>SparseArray删除元素是延迟删除，减少数组拷贝的频次。</li>
<li>ArrayMap有对容量4和8的缓存机制，避免频繁的内存分配和垃圾回收。</li>
</ul>
<p>Android中的小数据量的哈希表，Google推荐数据量小于1000使用ArrayMap，大于1000使用HashMap。</p>
<h1 id="为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？"><a href="#为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？" class="headerlink" title="为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？"></a>为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？</h1><p>ArrayMap中的 mHashs 数组以升序的方式保存了所有的 hash code，在查找数据时则通过二分查找 hash code 所对应的 index。这也是它的 get() 比 HashMap 慢的根据原因所在。</p>
<p>插入、删除需要移动数组的元素，数据多了的话，速度也相对较慢，数据少了影响较小。</p>
<h1 id="ArrayMap底层存储结构是怎样的？"><a href="#ArrayMap底层存储结构是怎样的？" class="headerlink" title="ArrayMap底层存储结构是怎样的？"></a>ArrayMap底层存储结构是怎样的？</h1><ul>
<li>  mHashes是一个记录所有key的hashcode值组成的数组，是从小到大的排序方式；</li>
<li>  mArray是一个记录着key-value键值对所组成的数组，是mHashes大小的2倍；</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214641.png"></p>
<p>为什么mArray的大小是mHahses的2倍？</p>
<p>因为mArray存储了key和value，所以需要2倍于mHashes的容量。</p>
<p>mHashes 在 index 处存储了 key 的 hash code，而 mArray 则在 hash code 的 index&lt;&lt;1 处存储 key，在 index&lt;&lt;1 + 1 处存储 value。简单点说就是偶数处存储 key，相邻奇数处存储 value。</p>
<h1 id="多个key的hashCode发生冲突时是怎么存储数据的？"><a href="#多个key的hashCode发生冲突时是怎么存储数据的？" class="headerlink" title="多个key的hashCode发生冲突时是怎么存储数据的？"></a>多个key的hashCode发生冲突时是怎么存储数据的？</h1><p>HashMap用的是拉链法把同一个hashCode元素放在一个桶中</p>
<p>ArrayMap用的是开放定址法之线性探测法</p>
<p>相同的hashCode存储在mHashes数组中相邻的位置，把原来数组中该位置之后的元素全部后移一位</p>
<p>例子：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214729.png"></p>
<p>index == 0 时 和 index == 1时的 hash code 是一样的，说明 key1 与 key2 的 hash code 是一样的，也就是存在 hash 冲突了。那么，如上，这里的解决办法就是 hash code 存储了 2 份，而 key-value 分别存储一份。</p>
<h1 id="ArrayMap-indexOf-key-hash-原理"><a href="#ArrayMap-indexOf-key-hash-原理" class="headerlink" title="ArrayMap.indexOf(key, hash)原理?"></a>ArrayMap.indexOf(key, hash)原理?</h1><p>源码的注释已经说的很明白</p>
<ol>
<li> 在mHashes中二分查找hash的索引</li>
<li> 如果mHashes中没找到hash，说明不存在这个元素，返回二分查找得出的应该插入的位置，以保障mHashes存储的hash保持升序</li>
<li> 如果mHashes中找到了hash，有两种情况：找到元素了  或  存在哈希冲突，这一点通过mArray存储的key和方法传入的key是否相等来判断，如果相等说明找到元素了，不相等则没有找到，没有找到要返回待插入的位置</li>
<li> 由于相同的hash在mHashes中存储在相邻的位置，如果mHashes中找到了hash，但是mArray中存储的key不相等，则往右往左分别寻找相同hash对应的mArray中的key是否相等</li>
</ol>
<h1 id="ArrayMap-put-key-value-原理"><a href="#ArrayMap-put-key-value-原理" class="headerlink" title="ArrayMap.put(key, value)原理?"></a>ArrayMap.put(key, value)原理?</h1><ol>
<li> 求key的hashCode</li>
<li> 通过indexOf(key, hash)计算新的hash应该插入mHashes数组中什么位置</li>
<li> 如果index &gt; 0 说明之前这个key已经存了值，替换为新的value就结束put流程</li>
<li> index &lt; 0 说明mHashes里不存在这个hash，index为待插入的位置</li>
<li> 如果容量不够了，就申请新的数组，容量为之前的1.5倍，把旧数组的值全部拷贝到新的数组</li>
<li> index后面的元素全部后移一位，给index的位置腾出空间</li>
<li> 存储hash到mHashes[index]，存储key、value到mArray的index * 2和index * 2 + 1的位置</li>
</ol>
<h1 id="为什么通过key求得index后要左移1位？"><a href="#为什么通过key求得index后要左移1位？" class="headerlink" title="为什么通过key求得index后要左移1位？"></a>为什么通过key求得index后要左移1位？</h1><p>因为这个index是mHashes的索引，mHashes数组长度是mArray数组长度的一半，索引乘以2，就是作为mArray的索引</p>
<h1 id="ArrayMap-remove-原理？"><a href="#ArrayMap-remove-原理？" class="headerlink" title="ArrayMap.remove()原理？"></a>ArrayMap.remove()原理？</h1><p>一般情况下删除一个数据，只需要将 index 后面的数据都往 index 方向移一位，然后删除末位数即可。</p>
<p>如果再满足缩容的条件就进行缩容，条件是mHashs长度大于 2 * BASE_SIZE 且  实际元素个数小于mHashs长度的1/3，就把容量压缩为实际元素大小的1.5倍</p>
<p>为什么是1.5倍，这样保证不会频繁的创建数组，也不会浪费太多的空间，平衡了性能</p>
<h1 id="mHashes里存的hashcode为什么要升序？"><a href="#mHashes里存的hashcode为什么要升序？" class="headerlink" title="mHashes里存的hashcode为什么要升序？"></a>mHashes里存的hashcode为什么要升序？</h1><p>因为要二分查找获取插入位置。</p>
<h1 id="为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？"><a href="#为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？" class="headerlink" title="为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？"></a>为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？</h1><h2 id="HashMap是怎么计算索引位置的？"><a href="#HashMap是怎么计算索引位置的？" class="headerlink" title="HashMap是怎么计算索引位置的？"></a>HashMap是怎么计算索引位置的？</h2><p>HashMap是直接用数组大小与key的hashCode做与操作得到数组索引。</p>
<h2 id="为什么ArrayMap不按照HashMap计算索引的方式来做呢？"><a href="#为什么ArrayMap不按照HashMap计算索引的方式来做呢？" class="headerlink" title="为什么ArrayMap不按照HashMap计算索引的方式来做呢？"></a>为什么ArrayMap不按照HashMap计算索引的方式来做呢？</h2><p>因为扩容后会重新hash，让元素分布的更均匀以较少哈希冲突，重新hash过程比较耗时，实现起来也比较复杂。</p>
<p>数据量小的情况下，用二分查找足够应付。</p>
<h1 id="ArrayMap为什么要设计一个缓存机制？"><a href="#ArrayMap为什么要设计一个缓存机制？" class="headerlink" title="ArrayMap为什么要设计一个缓存机制？"></a>ArrayMap为什么要设计一个缓存机制？</h1><p>很多场景可能起初都是数据很少，为了减少频繁地创建和回收数组，特意设计了两个缓存池，分别缓存大小为4和8的ArrayMap对象，这两个长度的Map根据统计信息应该用的很多。</p>
<h1 id="ArrayMap缓存机制实现原理？"><a href="#ArrayMap缓存机制实现原理？" class="headerlink" title="ArrayMap缓存机制实现原理？"></a>ArrayMap缓存机制实现原理？</h1><p>freeArrays(hashes, array, size) 会把hashes数组和array数组用链表的形式存储下来，头结点用mBaseCache、mTwiceBaseCache存储，分别表示数组长度为4和8的缓存<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214932.png"></p>
<p>freeArrays()触发时机:</p>
<ul>
<li>  当执行removeAt()移除最后一个元素的情况</li>
<li>  当执行clear()清理的情况</li>
<li>  当执行ensureCapacity()在当前容量小于预期容量的情况下, 先执行allocArrays,再执行freeArrays</li>
<li>  当执行put()在容量满的情况下, 先执行allocArrays, 再执行freeArrays</li>
</ul>
<p>当allocArrays分配内存时，如果所需要分配的大小等于4或者8，且相对应的缓冲池不为空，则会从相应缓存池中取出缓存的mArray和mHashes。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214947.png"></p>
<p>这里需要注意的是只有大小为4或者8的内存分配才有可能从缓存池取数据，因为freeArrays过程放入缓存池的大小只有4或8，对于其他大小的内存分配则需要创建新的数组。</p>
<p>优化小技巧，对于分配数据不超过8的对象的情况下，一定要创建4或者8大小，否则浪费了缓存机制。比如ArrayMap[7]就是不友好的写法，建议写成ArrayMap[8]。</p>
<p>两个缓存池大小上限为10个。</p>
<h1 id="扩容的条件？"><a href="#扩容的条件？" class="headerlink" title="扩容的条件？"></a>扩容的条件？</h1><p>mSize是实际存储的元素的个数</p>
<p>当mSize大于或等于mHashes数组长度时需要扩容，新容量的规则如下：</p>
<ul>
<li>  当map个数满足条件 osize&lt;4时，则扩容后的大小为4；</li>
<li>  当map个数满足条件 4&lt;= osize &lt; 8时，则扩容后的大小为8；</li>
<li>  当map个数满足条件 osize&gt;=8时，则扩容后的大小为原来的1.5倍；</li>
</ul>
<h1 id="缩容的条件？"><a href="#缩容的条件？" class="headerlink" title="缩容的条件？"></a>缩容的条件？</h1><p>当数组内存的大小大于8，且已存储数据的个数mSize小于数组空间大小的1/3的情况下，需要收紧数据的内容容量，分配新的数组，老的内存靠虚拟机自动回收。</p>
<ul>
<li>  如果mSize&lt;=8，则设置新大小为8；</li>
<li>  如果mSize&gt; 8，则设置新大小为mSize的1.5倍。</li>
</ul>
<p>也就是说在数据较大的情况下，当内存使用量不足1/3的情况下，内存数组会收紧50%</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903762470060045">ArrayMap详解及源码分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-SparseArray%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-SparseArray%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Android集合类-SparseArray原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-09 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-09T20:00:00+08:00">2018-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-SparseArray%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Android集合类-SparseArray原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="稀疏表是什么？"><a href="#稀疏表是什么？" class="headerlink" title="稀疏表是什么？"></a>稀疏表是什么？</h1><p>key为整数的哈希表</p>
<h1 id="稀疏表特点"><a href="#稀疏表特点" class="headerlink" title="稀疏表特点"></a>稀疏表特点</h1><ul>
<li>Key为int类型的哈希表，避免了Integer自动装箱。</li>
<li>底层用数组存储元素，一个数组存储key，一个数组存储value，key是有序的，通过二分查找来定位元素。</li>
<li>插入元素会移动数组，remove的时候只设置了一个removed标记位，避免频繁移动数组元素。</li>
<li>数据量大的时候，复制数组时间就长了，查找时间也长了。</li>
<li>好处是不需要额外的结构体，比较节约空间，数据量较小情况下访问想效率比较高。</li>
</ul>
<h1 id="SparseArray相比HashMap解决了什么？"><a href="#SparseArray相比HashMap解决了什么？" class="headerlink" title="SparseArray相比HashMap解决了什么？"></a>SparseArray相比HashMap解决了什么？</h1><p>优点：</p>
<ol>
<li> 避免了基本数据类型的装箱操作</li>
<li> 不需要额外的结构体，单个元素的存储成本更低</li>
<li> 数据量小的情况下，随机访问的效率更高，因为不需要额外复杂操作、删除元素也是延迟的</li>
</ol>
<p>缺点：</p>
<ol>
<li> 插入操作需要复制数组，增删效率降低</li>
<li> 数据量巨大时，复制数组成本巨大，gc()成本也巨大</li>
<li> 数据量巨大时，查询效率也会明显下降，因为需要二分查找，而不是直接哈希命中</li>
</ol>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903442901630983">SparseArray 的使用及实现原理</a></li>
</ul>
<h1 id="SparseArray适用场景？"><a href="#SparseArray适用场景？" class="headerlink" title="SparseArray适用场景？"></a>SparseArray适用场景？</h1><p>原则：</p>
<ol>
<li> 数据量不大（千这个数量级以内）。</li>
<li> 空间比时间重要，例如移动端对内存使用量敏感。</li>
<li> 需要使用Map，且key为int类型。</li>
</ol>
<p>例如：<br>如果有一个ViewPager的每个页面都有一个图表，并且图表的点有上千个，而ViewPager会缓存左右两页，至少要开3个图表，用HashMap明显占用内存更多，容易引发内存溢出，而且自动装箱的消耗更多，用SparseArray肯定更快，内存占用更小。</p>
<h1 id="SparseArray-put-int-key-E-value-原理？"><a href="#SparseArray-put-int-key-E-value-原理？" class="headerlink" title="SparseArray.put(int key, E value)原理？"></a>SparseArray.put(int key, E value)原理？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a mapping from the specified key to the specified value,</span></span><br><span class="line"><span class="comment"> * replacing the previous mapping from the specified key if there</span></span><br><span class="line"><span class="comment"> * was one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是一次插入数据的操作，单看的话有些难懂，因为插入跟删除之间有一定的关系，所以要看懂这段代码，还必须搞懂删除的逻辑。在看删除之前，还是先大体梳理一下插入的几个特点：</p>
<ul>
<li>  <strong>存放<code>key</code>的数组是有序的（二分查找的前提条件）</strong></li>
<li>  <strong>如果冲突，新值直接覆盖原值，并且不会返回原值（<code>HashMap</code>会返回原值）</strong></li>
<li>  <strong>如果当前要插入的 key 的索引上的值为DELETE，直接覆盖</strong></li>
<li>  <strong>前几步都失败了，检查是否需要<code>gc()</code>并且在该索引上插入数据</strong></li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903442901630983">SparseArray 的使用及实现原理</a></li>
</ul>
<h1 id="GrowingArrayUtils-insert-的原理？"><a href="#GrowingArrayUtils-insert-的原理？" class="headerlink" title="GrowingArrayUtils.insert()的原理？"></a>GrowingArrayUtils.insert()的原理？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts an element into the array at the specified index, growing the array if there is no</span></span><br><span class="line"><span class="comment"> * more room.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array The array to which to append the element. Must NOT be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentSize The number of elements in the array. Must be less than or equal to</span></span><br><span class="line"><span class="comment"> *                    array.length.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element The element to insert.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array to which the element was appended. This may be different than the given</span></span><br><span class="line"><span class="comment"> *         array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] insert(T[] array, <span class="keyword">int</span> currentSize, <span class="keyword">int</span> index, T element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentSize + <span class="number">1</span> &lt;= array.length) &#123;</span><br><span class="line">        System.arraycopy(array, index, array, index + <span class="number">1</span>, currentSize - index);</span><br><span class="line">        array[index] = element;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(),</span><br><span class="line">            growSize(currentSize));</span><br><span class="line">    System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, index);</span><br><span class="line">    newArray[index] = element;</span><br><span class="line">    System.arraycopy(array, index, newArray, index + <span class="number">1</span>, array.length - index);</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前数据个数并不超过数组长度，直接把待插入位置后面的元素全部后移一位，腾出空间给新元素。</p>
<p>如果数据总个数超过了数组容纳的长度，需要扩容，扩容大小为growSize(currentSize)求得，为原大小的两倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given the current size of an array, returns an ideal size to which the array should grow.</span></span><br><span class="line"><span class="comment"> * This is typically double the given size, but should not be relied upon to do so in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">growSize</span><span class="params">(<span class="keyword">int</span> currentSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize &lt;= <span class="number">4</span> ? <span class="number">8</span> : currentSize * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据新大小创建新的数组，然后：</p>
<ol>
<li> 把原数组中待插入位置前面的元素都复制到新数组的前面</li>
<li> 新数组中指定位置插入新元素</li>
<li> 把原数组中待插入位置后面的元素都复制到新数组中插入元素的后面</li>
</ol>
<h1 id="SparseArray-remove-int-key-原理"><a href="#SparseArray-remove-int-key-原理" class="headerlink" title="SparseArray.remove(int key)原理?"></a>SparseArray.remove(int key)原理?</h1><p>通过key二分查找到index，然后讲DELETED赋值给mValues[index]，标记这个位置会删除</p>
<p>为什么删除标记位DELETED？而不是直接删除元素？</p>
<p>直接删除元素会复制数组，如果删除比较频繁，就会降低性能，这里是为了避免频繁进行数组拷贝调整</p>
<h1 id="什么时候会清理掉DELETED的元素？"><a href="#什么时候会清理掉DELETED的元素？" class="headerlink" title="什么时候会清理掉DELETED的元素？"></a>什么时候会清理掉DELETED的元素？</h1><p>SparseArray.gc()里会清理</p>
<h1 id="SparseArray-gc-的原理？"><a href="#SparseArray-gc-的原理？" class="headerlink" title="SparseArray.gc()的原理？"></a>SparseArray.gc()的原理？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mValues里如果没有DELETED，那么i和o应该是相等的，但是如果有DELETED，o就会小于i，然后就可以把元素全部前移到数组头部，把空位留在数组尾部，相当于碎片整理了一下，留下了尾部整块的空闲空间。</p>
<h1 id="什么时候触发GC-？"><a href="#什么时候触发GC-？" class="headerlink" title="什么时候触发GC()？"></a>什么时候触发GC()？</h1><p>以下方法会调用gc()：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214148.png"></p>
<p>put的时候如果发现数组大小不够，就清理。</p>
<p>size()求大小需要求得正确的大小。</p>
<h1 id="SparseArray使用过程有什么坑？"><a href="#SparseArray使用过程有什么坑？" class="headerlink" title="SparseArray使用过程有什么坑？"></a>SparseArray使用过程有什么坑？</h1><p>indexOfValue比较的是value的指针，而并没有调用equals方法。</p>
<p>如果value是String就有问题。</p>
<p>如果是Integer，在Integer的缓存范围内也有问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an index for which &#123;<span class="doctag">@link</span> #valueAt&#125; would return the</span></span><br><span class="line"><span class="comment"> * specified value, or a negative number if no keys map to the</span></span><br><span class="line"><span class="comment"> * specified value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Beware that this is a linear search, unlike lookups by key,</span></span><br><span class="line"><span class="comment"> * and that multiple keys can map to the same value and this will</span></span><br><span class="line"><span class="comment"> * find only one of them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note also that unlike most collections&#x27; &#123;<span class="doctag">@code</span> indexOf&#125; methods,</span></span><br><span class="line"><span class="comment"> * this method compares values using &#123;<span class="doctag">@code</span> ==&#125; rather than &#123;<span class="doctag">@code</span> equals&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfValue</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hapoy9/article/details/75554539">安卓SparseArray的indexOfValue方法遇到的坑</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/brehrehr/article/details/100118779">记录SparseArray的使用方法和使用过程遇到的问题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/" class="post-title-link" itemprop="url">Java集合类-TreeMap、ConcurrentSkipListMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-08 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-08T20:00:00+08:00">2018-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-TreeMap、ConcurrentSkipListMap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TreeMap作用"><a href="#TreeMap作用" class="headerlink" title="TreeMap作用"></a>TreeMap作用</h1><ul>
<li> 元素可以按key保持顺序。</li>
<li> 因为有序，提供了很多范围查询的方法，非常方便。</li>
</ul>
<h1 id="TreeMap的实现"><a href="#TreeMap的实现" class="headerlink" title="TreeMap的实现"></a>TreeMap的实现</h1><p>TreeMap实现了NavigableMap接口，该接口又继承SortedMap接口，两个提供了很多范围查询的方法，非常方便。</p>
<p>用红黑树实现，插入、删除、查询的平均时间复杂度都是log(n)。</p>
<h1 id="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap"><a href="#TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap" class="headerlink" title="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?"></a>TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?</h1><ol>
<li> 因为红黑树的结构调整可能涉及整个树的结点，这样并发下就要锁住很多结点，使用跳表会更局部一点，只锁住局部的几个结点，并发性能更高。</li>
<li> 红黑树加锁实现起来比较复杂，跳表是链表加锁比较容易实现</li>
</ol>
<p>可以用过Collections.synchronizedSortedMap()保证线程安全，也可以改用ConcurrentSkipListMap并发性能更好。</p>
<h1 id="TreeMap为什么用红黑树不用AVL树？"><a href="#TreeMap为什么用红黑树不用AVL树？" class="headerlink" title="TreeMap为什么用红黑树不用AVL树？"></a>TreeMap为什么用红黑树不用AVL树？</h1><p>跟HashMap中的问题一样。</p>
<p>红黑树的3结点可以吸收变化，在多次使用中可以减少调整数据结构的次数，从而提升性能。</p>
<h1 id="ConcurrentSkipListMap是什么？"><a href="#ConcurrentSkipListMap是什么？" class="headerlink" title="ConcurrentSkipListMap是什么？"></a>ConcurrentSkipListMap是什么？</h1><p>跳表：链表+多级索引（多层链表）。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825212310.png"></p>
<ul>
<li>给有序链表再增加若干层额外的指针索引，用空间换时间。</li>
<li>每一层都是一个有序链表。</li>
<li>实际效果类似于平衡二叉搜索树。</li>
<li>插入、删除、查询的平均时间复杂度都是log(n)。</li>
<li>支持按key排序所有元素，也支持快速查找。</li>
</ul>
<h1 id="跳表的数据结构存在什么问题？"><a href="#跳表的数据结构存在什么问题？" class="headerlink" title="跳表的数据结构存在什么问题？"></a>跳表的数据结构存在什么问题？</h1><p>按照理想的生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。</p>
<h1 id="跳表与红黑树区别？"><a href="#跳表与红黑树区别？" class="headerlink" title="跳表与红黑树区别？"></a>跳表与红黑树区别？</h1><ol>
<li> 红黑树为了保持平衡有可能会调整很多结点甚至整个树，而跳表只要修改相邻结点更加的局部，跳表调整次数少性能也就高，同时并发加锁时，锁住的结点更少，可以减少竞争</li>
<li> 跳表的区间查询更高效，因为找到链表头结点顺序遍历就行了，红黑树需要中序遍历相对比较复杂</li>
<li> 跳表占用空间更少，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
</ol>
<h1 id="ConcurrentSkipListMap存在什么问题？"><a href="#ConcurrentSkipListMap存在什么问题？" class="headerlink" title="ConcurrentSkipListMap存在什么问题？"></a>ConcurrentSkipListMap存在什么问题？</h1><p>size方法求得链表长度要遍历整个链表，并且没有加锁，多线程高并发下这个方法返回值并不准确，高并发下使用size的意义不大。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yd2sOhmVtZeEkJ06cTE7qA"> 死磕 java集合之ConcurrentSkipListMap源码分析——发现个bug</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1811782/when-should-i-use-concurrentskiplistmap">When should I use ConcurrentSkipListMap?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20202931/answer/16086538">为啥 redis 使用跳表(skiplist)而不是使用 red-black？ - 于康的回答 - 知乎</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java集合类-ConcurrentHashMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-07 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-07T20:00:00+08:00">2018-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-ConcurrentHashMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>高性能且线程安全的哈希表。</p>
<h1 id="线程安全是怎么实现的？"><a href="#线程安全是怎么实现的？" class="headerlink" title="线程安全是怎么实现的？"></a>线程安全是怎么实现的？</h1><p>Java7中ConcurrentHashMap将哈希表分割成为多个段（Segment），每一个段继承ReentrantLock，对每一段进行加锁。每个Segment里类似又有一个小的HashMap，等于是双重哈希表。</p>
<p>Java8中采用了自旋CAS和synchronzied保证线程安全，锁的粒度调整为对table数组中每个元素进行加锁；put元素时，定位到桶位置后，通过synchronzied给桶中链表首节点或红黑树根节点加锁。这样多线程竞争哈希表同一个桶位置的几率又降低了。</p>
<p>java8的ConcurrentHashMap的数据结构参考java8的HashMap，采用数组+链表+红黑树。</p>
<ul>
<li><p>put方法里，是一个无限循环，即自旋，修改table数组都是通过cas操作，自旋锁的机制避免了阻塞和恢复线程的上下文切换开销。</p>
</li>
<li><p>只要当前桶位置没有元素，就先自旋CAS进行更新。</p>
</li>
<li><p>存在hash冲突或修改已有的值时，需要进入桶内部的链表或红黑树进行操作时，才开始用synchronized真正加锁。</p>
</li>
</ul>
<p>get是不加锁的，所以与CopyOnWriteArrayList一样，不保证读数据的实时性，数据是弱一致性。</p>
<p>size的求法和LongAdder里的思路一样，将大小数据分段累加，避免多线程竞争，用自旋cas保证数据更新的原子性。</p>
<h1 id="不能解决什么问题？"><a href="#不能解决什么问题？" class="headerlink" title="不能解决什么问题？"></a>不能解决什么问题？</h1><p>因为数据是弱一致性的，get时并不加锁，所以对读数据实时性要求高的需求不能满足。</p>
<p>例如线程1在某一时刻执行了put(key, value)，先线程2随后立即get(key)不一定能读取到线程1刚put的，因为put可能正在进行中还没结束。</p>
<h1 id="扩容机制是怎样的？"><a href="#扩容机制是怎样的？" class="headerlink" title="扩容机制是怎样的？"></a>扩容机制是怎样的？</h1><p>本来一个线程扩容时，其他线程应该都阻塞等待这个线程扩容完成后才能对哈希表进行读写，这就成了并发的瓶颈。</p>
<p>ConcurrentHashMap具体实现是，反正你闲着也是闲着，不如一起来扩容。</p>
<p>扩容时nextTable会指向扩容后的数组，扩容方法transfer里通过自旋进行。</p>
<p>多个线程通过sizeCtl判断当前所处状态，再通过transferIndex协调各线程应该操作哪一些桶。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">ConcurrentHashMap1.8 - 扩容详解（图文并茂）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lfs2640666960/p/9621461.html">深入理解HashMap+ConcurrentHashMap的扩容策略  </a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/487d00afe6ca">ConcurrentHashMap源码分析（JDK8） 扩容实现机制</a></li>
</ul>
<h1 id="跟同样是线程安全的Hashtable有何区别？"><a href="#跟同样是线程安全的Hashtable有何区别？" class="headerlink" title="跟同样是线程安全的Hashtable有何区别？"></a>跟同样是线程安全的Hashtable有何区别？</h1><p>Hashtable的线程安全是对整个哈希表上锁（在多数方法上加上sychronized），其中一个线程访问哈希表时，其他线程只能等待，很多没有必要上锁的场景也上锁，因此在多线程竞争激烈的情况下整体访问速度会变慢。</p>
<p>ConcurrentHashMap把哈希表分割成若干个段，修改每一段时仅针对访问的段上锁，不同的线程访问不同的段时互不干扰，减少了多个线程争抢同一把锁的几率，减少了线程等待的时间，所以提高了性能。</p>
<p>分段锁是怎么实现的？</p>
<p>get方法不加锁，结点类里的value设置了volatile保证了value在多线程下的可见性，保证get到value最新的修改值。</p>
<p>总结：</p>
<ol>
<li> 循环+CAS实现自旋锁，减少线程阻塞恢复的上下文切换消耗</li>
<li> size更新采用LongAdder分段锁思想，减少竞争</li>
<li> LongAdder机制中的字节填充解决伪共享</li>
<li> 多线程协同分组扩容。</li>
</ol>
<h1 id="与Collections-synchronizedMap-的区别？"><a href="#与Collections-synchronizedMap-的区别？" class="headerlink" title="与Collections.synchronizedMap()的区别？"></a>与Collections.synchronizedMap()的区别？</h1><p>Collections.synchronizedMap()对HashMap做了一层装饰，用synchronized锁住整个哈希表，以保证各操作的线程安全，锁的粒度比较大。<br>性能比ConcurrentHashMap更差，但可以保证读的实时性。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dee05ac6fb9a0163f77beb6">深入解析 ConcurrentHashMap 实现内幕，吊打面试官？没问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heqiyoujing/p/11143525.html">ConcurrentHashMap面试题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java集合类-HashMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-06 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-06T20:00:00+08:00">2018-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-HashMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>JDK 1.7：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java</a></li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java</a></li>
</ul>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ol>
<li> 非线程安全，所以存取速度快</li>
<li> 可以接受null的键和值</li>
<li> 不保证key有序</li>
<li> key的顺序会随时间变化（动态调整大小后会变化）</li>
</ol>
<h1 id="散列过程"><a href="#散列过程" class="headerlink" title="散列过程"></a>散列过程</h1><ol>
<li> 通过散列函数，用元素的key计算出元素在数组中的索引位置</li>
<li> 解决散列冲突，即相同散列值（数组索引位置）元素如何存取</li>
</ol>
<h1 id="散列函数的选取标准"><a href="#散列函数的选取标准" class="headerlink" title="散列函数的选取标准"></a>散列函数的选取标准</h1><ol>
<li> 易于计算</li>
<li> 均匀分布所有键</li>
</ol>
<h1 id="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"><a href="#拉链法查找一个元素的最少、最坏、平均次数分别是多少？" class="headerlink" title="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"></a>拉链法查找一个元素的最少、最坏、平均次数分别是多少？</h1><p>设哈希表大小为m，已存储的元素个数为n</p>
<p>如果散列函数把所有元素散列到一个位置，链表的长度就是n，最坏情况下就是查找链表中最后一个元素，查找次数是n</p>
<p>如果散列函数散列到哈希表每个位置的概率相同，此时元素分布最均匀，拉链法相当于把n个元素分为m组，那么每组（链表）长度最多为n/m，最坏情况下查找链表最后一个元素，需要n/m次</p>
<h1 id="桶（bucket）是什么意思？"><a href="#桶（bucket）是什么意思？" class="headerlink" title="桶（bucket）是什么意思？"></a>桶（bucket）是什么意思？</h1><p>HashMap内部的哈希表由数组实现，数组的每一个位置称为桶，存储一个链表的头结点，或红黑树的根节点，一个桶下所有元素key的hashCode都相同，元素存储在哪一个桶是根据元素key计算出数组索引位置而定的</p>
<h1 id="什么情况下会要求哈希表的大小要是质数？"><a href="#什么情况下会要求哈希表的大小要是质数？" class="headerlink" title="什么情况下会要求哈希表的大小要是质数？"></a>什么情况下会要求哈希表的大小要是质数？</h1><p>简述：</p>
<ul>
<li>关注哈希表的大小是因为求得元素在哈希表中存储存储位置是通过  key的hashCode % 哈希表大小  得到，如果散列函数计算结果不均匀，容易产生散列冲突，提高了查找次数。</li>
<li>质数不容易被整除，故而可以让计算出的索引分布的比较均匀。合数有公因子，计算出的索引位置容易聚集在公因数的位置，产生较多的散列冲突。</li>
</ul>
<p>key与哈希表大小互质，这样取模的结果就分散的比较均匀。</p>
<p>如果key可以整除哈希表大小，如果key容易在公因数的位置产生聚集，就会产生较多的散列冲突。</p>
<p>使用质数作为容量，可以使元素更分散，减少冲突；</p>
<p>如果用合数作为容量，会使元素聚集，增加冲突，增加查找次数。</p>
<p>一般是通过除留取余法确定元素在数组中存储索引位置，即：</p>
<p>元素在数组中的存储位置 = key的hashCode % 哈希表长度</p>
<p>假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。</p>
<p>例如2 4 6 8 10 12这6个数，如果对 6 取余  得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多，并且呈现以合数的因子为间隔增长；如果对 7取余  得到 2 4 6 1 3 5 得到6种HASH值，没有冲突。</p>
<p>用质数作为数组容量使得任何数想整除它是不可能的，因此探测序列最终会检查到所有单元，冲突较少。</p>
<p>当散列函数计算结果的均匀性较差时，最好使用质数作为哈希表大小可以在除留取余时使得计算出的索引位置分布的更均匀。</p>
<p>但是库一般都会提供散列比较均匀的散列函数，只要散列函数设计的均匀，什么数做桶的大小都行，有时为了方便支持桶的动态扩容或者避免使用除法，桶的大小使用2的幂。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？
</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">算法分析：哈希表的大小为何是素数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.moew.xyz/2019/07/29/%E4%B8%BA%E4%BD%95%E5%9C%A8%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%EF%BC%8C%E8%A6%81%E5%B0%BD%E9%87%8F%E5%8F%96%E7%B4%A0%E6%95%B0/">为何在散列表中除留余数法取模运算中，要尽量取素数
</a></li>
</ul>
<h1 id="为什么桶容量要是2的次方？"><a href="#为什么桶容量要是2的次方？" class="headerlink" title="为什么桶容量要是2的次方？"></a>为什么桶容量要是2的次方？</h1><p>散列表用数组实现时，要计算元素应当存储在数组的哪个位置（索引），应当将元素key的hashCode对散列表大小取模，取模结果就是元素要存放在数组的索引位置。</p>
<p>如果key的hashCode函数不能把key散列的均匀，就需要用质数作为哈希表大小，在除留取余的求数组索引时能够让元素分布的比较均匀。</p>
<p>如果key的hashCode能够散列的比较均匀，那么其实用什么数作为哈希表大小都可以。</p>
<p>桶容量为2的幂时取模的好处：<br>1.可以用位运算取模，计算速度更快，位运算也很方便。<br>2.可以让元素分布的均匀，减少散列冲突。<br>3.方便扩容计算，扩容也只需要乘以2，容量左移一位。</p>
<h1 id="为什么2的幂的容量可以让元素分布更均匀？"><a href="#为什么2的幂的容量可以让元素分布更均匀？" class="headerlink" title="为什么2的幂的容量可以让元素分布更均匀？"></a>为什么2的幂的容量可以让元素分布更均匀？</h1><p>位运算对2的幂取模过程：一个二进制数乘以2的n次方相当于将该数左移n位，一个二进制数除以2的n次方相当于将该数右移n位，右移出界的部分就是余数，其实也就是原数低n位，取低n位的数，只需要将原数跟低位是n个1的二进制数做与操作就可以得到，低位是n个1的二进制数可以由2的n次方再减1得到。</p>
<p>如果对不是2的幂的数进行位运算取模，假设这个数是x，x-1的二进制数一定不是全部都是1，而是含有0，此时x-1与原数做与操作后，那些有0的位置都会用不到，造成空间浪费，也增大了散列冲突。如果x-1全部是1的话，只要key的hashCode的二进制中的1在低n位分布均匀，就可以保证计算index的过程是分布均匀的，要求x-1的二进制全部是1，那么x就是2的幂。</p>
<h1 id="通过构造函数传入不是2的幂的容量值会怎样？"><a href="#通过构造函数传入不是2的幂的容量值会怎样？" class="headerlink" title="通过构造函数传入不是2的幂的容量值会怎样？"></a>通过构造函数传入不是2的幂的容量值会怎样？</h1><p>会找一个最接近传入容量的2的幂作为实际桶的容量。</p>
<h1 id="哈希表容量是2的幂会有什么问题？"><a href="#哈希表容量是2的幂会有什么问题？" class="headerlink" title="哈希表容量是2的幂会有什么问题？"></a>哈希表容量是2的幂会有什么问题？</h1><p>key的hash取余求索引时，会截断hash的高位，如果多个key的hash的低位比较固定，高位变化较大，那么最后计算的散列冲突就很多了。</p>
<p>所以需要扰动函数处理一下key的hash，把高位的变化信息传递到低位。</p>
<h1 id="扰动函数是什么，起到什么作用？"><a href="#扰动函数是什么，起到什么作用？" class="headerlink" title="扰动函数是什么，起到什么作用？"></a>扰动函数是什么，起到什么作用？</h1><p>存储一个元素时，需要决定该元素应该存储在table（桶）中哪一个位置，需要用元素的key的hashCode对桶容量做取模运算来获得要存储的数组索引位置。</p>
<p>如果桶容量较小，取模操作会仅对key.hashCode()的低位做运算，如果多个元素的key的hashCode()低位相同，只是高位不同，那么冲突就较多，所以需要将高位和低位结合起来取模，减少冲突，避免散列分布不均。</p>
<p>所以在对hashCode做取模运算之前，还需要让hashCode经过扰动函数扰动一下。</p>
<p>jdk1.8中对key的hashCode的扰动函数做了优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将key.hashCode()的低16位和高16位做异或运算。</p>
<p>仅仅异或一下做扰动，权衡了速度、性能、质量，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<h2 id="为什么是右移16位？"><a href="#为什么是右移16位？" class="headerlink" title="为什么是右移16位？"></a>为什么是右移16位？</h2><p>推测：因为java中int是32位的，高16位和低16位异或已经算是顾全到了数字的二进制的每一位。</p>
<p>实际：权衡了速度、性能、质量</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
</ul>
<h2 id="扰动函数为什么是异或运算？"><a href="#扰动函数为什么是异或运算？" class="headerlink" title="扰动函数为什么是异或运算？"></a>扰动函数为什么是异或运算？</h2><ol>
<li> 实现简单，运算快捷</li>
<li>对参与运算的两方的二进制的每一位都各自有50%的概率影响结果输出</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">Why is XOR the default way to combine hashes?</a></li>
</ul>
<h1 id="桶的最大容量为什么是2的30次方，不是2的31次方？"><a href="#桶的最大容量为什么是2的30次方，不是2的31次方？" class="headerlink" title="桶的最大容量为什么是2的30次方，不是2的31次方？"></a>桶的最大容量为什么是2的30次方，不是2的31次方？</h1><p>java中int是32位，理论上1可以最多左移31位，因为1不移动就占了1位，所以可以移动的位数是32-1=31位；而虚拟机规定int类型最高位是符号位，符号位不参与移动，可移动位数就是31-1=30位</p>
<h1 id="两个key对象的hashCode相同，如何获取value对象"><a href="#两个key对象的hashCode相同，如何获取value对象" class="headerlink" title="两个key对象的hashCode相同，如何获取value对象?"></a>两个key对象的hashCode相同，如何获取value对象?</h1><p>在遍历该桶的链表，链表中每个节点保存了键值对信息，将目标key与每个节点的key调用equals方法比较，相等的则为想要找到的节点，取其value对象。</p>
<h1 id="什么对象适合做为HashMap的key"><a href="#什么对象适合做为HashMap的key" class="headerlink" title="什么对象适合做为HashMap的key?"></a>什么对象适合做为HashMap的key?</h1><p>使用String，Integer等系统类比较好，因为他们的hashCode方法实现是比较均匀的，可以减少散列冲突。</p>
<p>其次这些类一旦创建都是不可变的，一来可以缓存hashCode，二来保证唯一性，三来线程安全。</p>
<h1 id="自定义对象实现hashCode-方法有什么注意事项？"><a href="#自定义对象实现hashCode-方法有什么注意事项？" class="headerlink" title="自定义对象实现hashCode()方法有什么注意事项？"></a>自定义对象实现hashCode()方法有什么注意事项？</h1><p><strong>原则：</strong><br>一个对象的hashCode应该认为有均等的机会得到2的32次方中的任意一个32位整数值。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205744.png" alt="《算法4》节选"></p>
<p>一个优秀的散列方法需要满足三个条件：</p>
<ul>
<li>一致性 - 等价的键必然产生相等的散列值</li>
<li>高效性 - 计算简便</li>
<li>均匀性 - 均匀地散列所有的键</li>
</ul>
<p>保证均匀性的最好办法也许是保证键的每一位都在散列值的计算中起到了相同的作用，实现散列函数最常见的错误是忽略了高位的键。</p>
<p>可以参考String的hashCode设计，kotlin的data class自动生成的hashCode以及集合类的hashCode算法都很相似。</p>
<p>需要使用不可变的属性实现hashCode()方法，因为：</p>
<ol>
<li> 可以在计算一次哈希值后缓存起来，提高哈希表的读取速度。</li>
<li> 如果key在放入哈希表时和取出哈希表时hashCode()发生变化，则会取不到之前存放的对象。</li>
<li> 不可变的属性是线程安全的。</li>
</ol>
<h1 id="装载因子是什么？"><a href="#装载因子是什么？" class="headerlink" title="装载因子是什么？"></a>装载因子是什么？</h1><p>哈希表中已存储元素个数与哈希表总大小比值，即已存储元素个数与桶个数比值。</p>
<p>装载因子越大，说明填充率高，空间利用率高，但是散列冲突可能性增大。</p>
<p>装载因子越小，说明填充率低，浪费很多空间，但是散列冲突可能性减小。</p>
<p>冲突越多，查找元素的时间越长，所以必须在时间和空间上进行权衡。</p>
<h1 id="装载因子有什么作用？"><a href="#装载因子有什么作用？" class="headerlink" title="装载因子有什么作用？"></a>装载因子有什么作用？</h1><p>装载因子 = 已存储的元素个数 / 桶大小</p>
<p>HashMap构造时可以传入一个装载因子，不传入的话会使用默认的装载因子0.75，构造时规定这个装载因子意思是装载因子的最大值。</p>
<p>随着哈希表中存储元素的个数增多，填充率越高，实际的装载因子会逐渐增大，当  实际装载因子  大于  预设装载因子  时，为了避免大量的散列冲突，要增大桶的数量，HashMap会将通大小调整为原来的两倍，因为桶大小要求是2的幂，所以就扩大2倍。</p>
<h1 id="桶容量是如何动态扩展的？"><a href="#桶容量是如何动态扩展的？" class="headerlink" title="桶容量是如何动态扩展的？"></a>桶容量是如何动态扩展的？</h1><p>当  已存储元素个数  超过  哈希表大小 * 装载因子，会扩容至原大小的两倍，并对部分元素重新散列。</p>
<p>当put元素时，发现已存储元素个数超过threshold时，会触发扩容。</p>
<p>threshold的首次赋值由构造HashMap时传入的初始容量和装载因子决定。</p>
<p>threshold = 初始容量 * 装载因子</p>
<p>每次扩容桶（table）大小会变为原来两倍，threshold也会变为原来的两倍。</p>
<h1 id="构造函数传入不是2的幂的初始容量会怎样？"><a href="#构造函数传入不是2的幂的初始容量会怎样？" class="headerlink" title="构造函数传入不是2的幂的初始容量会怎样？"></a>构造函数传入不是2的幂的初始容量会怎样？</h1><p>不管传什么初始容量，都会经由tableSizeFor()计算得到大于等于传入的初始容量的最小的2的幂作为桶的实际容量大小</p>
<p>在put()时触发resize()，threshold也会被重新赋值为桶容量乘以装载因子。</p>
<h1 id="tableSizeFor-算法过程是怎样的？"><a href="#tableSizeFor-算法过程是怎样的？" class="headerlink" title="tableSizeFor()算法过程是怎样的？"></a>tableSizeFor()算法过程是怎样的？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三种情况</p>
<ol>
<li>cap小于0，返回1</li>
<li>cap经过位运算后大于等于MAXIMUM_CAPACITY，返回MAXIMUM_CAPACITY</li>
<li>cap经过位运算后返回n+1</li>
</ol>
<p>先考虑正常的情况，对于一个给定的cap，分为两种情况，cap可能是2的幂或非2的幂。</p>
<ol>
<li>当cap不是2的幂，例如10，二进制为1010，cap - 1 = 1001，几个右移操作实际的结果就是从cap - 1的二进制的1的最高位开始到最低位全部变成1，最后返回n + 1就是2的幂了</li>
<li>当cap是2的幂，例如16，二进制为10000，cap-1 = 1111，右移操作后n还是为1111，n+1就还是16</li>
</ol>
<p>所以正常情况下tableSizeFor()得出的就是大于等于cap的数</p>
<p>如果cap一开始不减1，当cap是2的幂时，最后计算得出的就会是cap的2倍</p>
<p>cap小于0，没有实际的意义，不能表示桶容量，故而返回最小正整数1</p>
<p>cap大于等于MAXIMUM_CAPACITY时，MAXIMUM_CAPACITY是2的30次方，此时cap的二进制最高位1是在第31位，逻辑右移再加1会得到32个1，int中最高位（第32位）是符号位，最高位1表示负数了，没有意义，故而将最大值限定在2的30次方，2的30次方减1的二进制是从第1位到第30位全都是1</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）
</a></li>
</ul>
<h1 id="为什么要调整桶大小？"><a href="#为什么要调整桶大小？" class="headerlink" title="为什么要调整桶大小？"></a>为什么要调整桶大小？</h1><p>为了减少散列冲突，减少元素查找次数</p>
<h1 id="为什么桶初始容量是16？"><a href="#为什么桶初始容量是16？" class="headerlink" title="为什么桶初始容量是16？"></a>为什么桶初始容量是16？</h1><p>这个问题不好解答可以考虑边界情况，桶容量过大、过小会导致什么</p>
<p>桶容量过大会导致大量空间浪费</p>
<p>桶容量过小会导致频繁扩容，扩容一次是耗时的</p>
<p>16应当是一个权衡评估后得出的值</p>
<h1 id="默认装载因子为什么是0-75？"><a href="#默认装载因子为什么是0-75？" class="headerlink" title="默认装载因子为什么是0.75？"></a>默认装载因子为什么是0.75？</h1><p>可以先考虑装载因子过大和过小分别会有什么问题</p>
<p>装载因子过大，表明哈希表填充率高，但是散列冲突的可能性大，查找元素的次数多</p>
<p>装载因子过小，表明哈希表的空闲空间大，空间利用率低，但冲突较少，查找元素次数少</p>
<p>0.75乘以2的幂是整数，不需要再做四舍五入，计算方便</p>
<p>根据HashMap注释</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost(reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/reliveIT/article/details/82960063">HashMap defaultLoadFactor = 0.75和泊松分布没有关系
</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64f6de3ffcc1">HashMap的loadFactor为什么是0.75？
</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/31401836/2011291">StackOverflow: What is the significance of load factor in HashMap?
</a></li>
</ul>
<h1 id="resize-的大致过程"><a href="#resize-的大致过程" class="headerlink" title="resize()的大致过程"></a>resize()的大致过程</h1><p>根据resize()方法的注释所言，resize()会将桶容量扩充两倍，由于容量是2的幂，原来桶中的元素位置要么是原封不动，要么是再移动2的幂个位置。</p>
<p>求元素的在table中的索引依然是  元素key的hashCode &amp; (桶容量-1)</p>
<p>例如原来容量是16，二进制为10000，求元素索引时是 hashCode &amp; 1111</p>
<p>扩容两倍后容量是32，二进制位100000，求元素索引的计算变成了 hashCode &amp; 11111，比之前多了一个1，如果元素key的hashCode在该位也是1，等同于元素的索引位置增加了2的幂。</p>
<p>桶中是链表时，会将链表划分为两个链表，一个留在原桶，一个放入移动了2的幂的桶中。</p>
<p>为什么要这样调整？原封不动不行吗？</p>
<p>因为这样做是为了保证散列均匀，减少冲突。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现
</a></li>
</ul>
<h1 id="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"><a href="#为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"></a>为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？</h1><p>因为节点数过少时，红黑树的插入、删除的成本比链表要高很多。</p>
<p>在散列均匀的情况下，冲突较少，每个桶中链表的平均长度比较短，性能可接受。</p>
<h1 id="为什么链表的长度为8时变成红黑树？"><a href="#为什么链表的长度为8时变成红黑树？" class="headerlink" title="为什么链表的长度为8时变成红黑树？"></a>为什么链表的长度为8时变成红黑树？</h1><p>根据jdk1.8的HashMap中的注释所言，假设散列分布均匀，在负载因子为0.75的条件下，某一个桶中元素出现的频率满足λ为0.5的泊松分布。从概率来看，之所以链表长度超过 8 以后要变成红黑树，因为在散列分布均匀的情况下出现这种情况的概率小到忽略不计，一旦出现，几乎可以认为是散列函数设计有问题导致的，即散列不均匀。</p>
<p>所以红黑树是专门应对元素key糟糕的（分布不均匀）的散列函数而准备的。</p>
<p>二项分布：n次重复独立伯努利试验，一次伯努利实验只有两种对立的结果。</p>
<p>泊松分布：当二项分布的n很大，p很小时，可以近似为泊松分布。</p>
<p>算法第四版465页：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205936.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205952.png"></p>
<p>散列均匀时，每个桶的链表的平均长度为  实际元素总数  / 哈希表大小，这个就是装载因子λ</p>
<p>现在的问题就是，将N个元素随机放入M个桶，每个桶的元素平均个数为λ（N/M），求每个桶元素个数为k的概率。</p>
<p>对于某一个桶而言，一个元素放入桶中是一个二元结果，要么放入，要么不放入，散列均匀的情况下，不管有多少个桶，每个元素出现在同一个桶的概率是相同，每个桶中平均有λ个元素时，那么一个元素出现在同一个桶的概率就是λ/N，就是桶元素数量占元素总数的比值，理解很直观。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ysmull.cn/JCF/HashMap.html">谈谈 HashMap 实现中的若干数学问题
</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26263743">泊松分布 (Poisson Distributions) 的推导
</a></li>
</ul>
<h1 id="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"><a href="#为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？" class="headerlink" title="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"></a>为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？</h1><p>是为了防止频繁插入和删除元素时不停的在树和链表之间互相转换、降低性能，红黑树和链表之间的转换是有成本的。</p>
<h1 id="MIN-TREEIFY-CAPACITY是做什么的？"><a href="#MIN-TREEIFY-CAPACITY是做什么的？" class="headerlink" title="MIN_TREEIFY_CAPACITY是做什么的？"></a>MIN_TREEIFY_CAPACITY是做什么的？</h1><p>桶中元素超过TREEIFY_THRESHOLD个（8个）后，还要保证哈希表数组table的大小大于等于MIN_TREEIFY_CAPACITY才会把链表转红黑树，容量过小时使用红黑树性价比不高，用扩容来解决桶元素堆积的问题更适合。</p>
<p>这个值为什么要是4 * TREEIFY_THRESHOLD，是为了避免在resize和树化之间产生冲突，比如初始容量是16，装载因子0.75，存储元素有16*0.75=12个时就应该扩容，但是此时如果是4个元素在一个桶，8个元素在另外一个桶，是要先树化的，树化后再等resize扩容了，可能又要将红黑树链表化，这样反复来回影响性能。</p>
<h1 id="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"><a href="#平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？" class="headerlink" title="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"></a>平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？</h1><p>单次的插入和删除操作：</p>
<p>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</p>
<p>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</p>
<p>大量的插入和删除操作：</p>
<p>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</p>
<p>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</p>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16257761/difference-between-red-black-trees-and-avl-trees">Difference between red-black trees and AVL trees</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/21aspnet/article/details/88939297">为什么Java8中HashMap链表使用红黑树而不是AVL树
</a></li>
</ul>
<h1 id="put方法大致过程"><a href="#put方法大致过程" class="headerlink" title="put方法大致过程"></a>put方法大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>table数组为null则通过resize()初始化table，创建HashMap对象不会立刻初始化table数组</li>
<li>利用扰动后的hashCode除留取余求得元素在table中的索引</li>
<li>如果没有碰撞冲突，直接存入桶中</li>
<li>如果有碰撞冲突，桶中维护一个链表存储哈希值相同的元素，java7是头插法，java8是尾插法</li>
<li>链表长度超过TREEIFY_THRESHOLD，链表转为红黑树</li>
<li>如果元素已存在，替换value。元素存在先通过key的hashCode查看桶中是否有元素，没有则不存在，有元素需要依次遍历桶中元素，通过key的equals方法比较是否相等，有相等的则存在。</li>
<li> 哈希表实际存储元素数量超过了阈值threshold（哈希表大小 * 装载因子），调用resize()扩容。</li>
</ol>
<h1 id="get方法的大致过程"><a href="#get方法的大致过程" class="headerlink" title="get方法的大致过程"></a>get方法的大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>根据哈希值求得table索引</li>
<li>若桶中第一个元素命中，直接返回</li>
<li> 有冲突则依次遍历链表或红黑树，通过key的equals比较来寻找目标节点，找到了返回其value，没有找到返回null</li>
</ol>
<h1 id="HashMap为什么线程不安全？高并发下会产生什么问题？"><a href="#HashMap为什么线程不安全？高并发下会产生什么问题？" class="headerlink" title="HashMap为什么线程不安全？高并发下会产生什么问题？"></a>HashMap为什么线程不安全？高并发下会产生什么问题？</h1><p>一句话：jdk7的HashMap在扩容时会改变链表中元素原本的顺序，高并发情况下容易导致链表产生环，进而导致死循环，CPU占用率飙升到100%。</p>
<p>jdk7中扩容采用头插法是考虑到缓存的时间局部性原则，最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数。</p>
<p>jdk8中扩容改为尾插法，高并发情况下不会产生死循环了，但是resize依然不是原子性的，可能会产生数据丢失。</p>
<p>其他方法例如链表和红黑树互转的过程，都不是原子性的，都可能会产生数据丢失的问题。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2f75c8cce01">为什么HashMap线程不安全
</a></li>
</ul>
<h1 id="Java-8-对HashMap做出了哪些改进？"><a href="#Java-8-对HashMap做出了哪些改进？" class="headerlink" title="Java  8  对HashMap做出了哪些改进？"></a>Java  8  对HashMap做出了哪些改进？</h1><ol>
<li>桶中链表长度超过8将链表转为红黑树，以应对不均匀的散列函数导致的查询次数增多</li>
<li> 链表插入元素由头插法改为尾插法，以解决并发下插入元素时链表产生环进而导致的死循环</li>
</ol>
<h1 id="modCount是做什么的？"><a href="#modCount是做什么的？" class="headerlink" title="modCount是做什么的？"></a>modCount是做什么的？</h1><p>对哈希表做出了修改（添加和删除元素），modCount就会增加，表示修改的次数，使用迭代器迭代哈希表时一旦发现modCount变化了，就会立刻抛出ConcurrentModificationException，以避免迭代时的不确定性，这称为fail-fast机制。注意修改一个已存在的元素的value不改变modCount。</p>
<h1 id="HashMap的缺点是什么？想要用哈希表还有哪些选择？"><a href="#HashMap的缺点是什么？想要用哈希表还有哪些选择？" class="headerlink" title="HashMap的缺点是什么？想要用哈希表还有哪些选择？"></a>HashMap的缺点是什么？想要用哈希表还有哪些选择？</h1><p>缺点就是结构复杂，占用内存可能较多，对哈希表有简单需求的地方不需要这么复杂而完善的类</p>
<p>例如ThreadLocalMap就自己实现了一套简单的哈希表，采用开放定址法</p>
<p>还有Android上SparseArray、ArrayMap实现的内存消耗更低的哈希表</p>
<h1 id="HashMap与Hashtable的区别？"><a href="#HashMap与Hashtable的区别？" class="headerlink" title="HashMap与Hashtable的区别？"></a>HashMap与Hashtable的区别？</h1><ol>
<li> Hashtable的get、put、clear、contains、size等大部分方法上都加上了synchronized关键字，给整个对象上锁，HashMap非线程安全</li>
<li> Hashtable中没有红黑树仅有链表</li>
<li> Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li> Hashtable不允许null的key和value，而HashMap都允许</li>
<li> Hashtable求key的hashCode没有扰动</li>
<li> HashMap和Hashtable使用Iterator遍历元素过程中对哈希表添加或删除元素是会抛出异常的（fast-fail），但Hashtable用Enumeration迭代时不会fast-fail，因为通过Enumeration的nextElement()获取下一个元素时没有对modCount做判断，而Iterator的next方法对modCount做了判断。</li>
<li> Hashtable是jdk1添加的，HashMap是jdk2添加的</li>
</ol>
<p>Dictionary已被废弃，所以Hashtable已经被废弃，而且同步性能较差，大多数操作都会锁住整个对象。用jdk1.5引入的采用分段锁的ConcurrentHashMap同步性能更好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">句柄、直接指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 20:00:00" itemprop="dateCreated datePublished" datetime="2018-03-08T20:00:00+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:48" itemprop="dateModified" datetime="2021-08-26T17:48:48+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/句柄、直接指针/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄是什么？"><a href="#句柄是什么？" class="headerlink" title="句柄是什么？"></a>句柄是什么？</h1><p>指针的指针。</p>
<p>jvm中内存里的对象都有一个指针指向对象的开始地址，句柄就是指向对象的指针。</p>
<h1 id="句柄解决了什么问题"><a href="#句柄解决了什么问题" class="headerlink" title="句柄解决了什么问题?"></a>句柄解决了什么问题?</h1><p>对实际的对象资源做了一层代理，屏蔽细节，避免了直接操控资源可能的危险。</p>
<p>弄了句柄，对象实际位置在内存中可以随意变化，比如标记整理垃圾回收后对象被移动到其他地方。</p>
<p>虚拟内存机制，可能会将已经载入内存的数据换到外存硬盘上，这样对象的地址就会变动，其他地方引用这块被换走的地址也要更新，如果使用这块数据的地方引用的是句柄，这样实际数据在内存的位置可以随意变化，使用数据的地方还是引用固定的地址，不用更新。</p>
<p>Windows系统中有许多内核对象（这里的对象不完全等价于”面向对象程序设计”一词中的”对象”，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个”对象”的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p>
<ol>
<li><p>暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p>
</li>
<li><p>操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p>
</li>
</ol>
<p>所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p>
<p>在Windows系统中，这个编号就叫做”句柄”。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/klb561/p/10555571.html">句柄的概念</a></p>
<h1 id="为什么叫句柄这个名字？"><a href="#为什么叫句柄这个名字？" class="headerlink" title="为什么叫句柄这个名字？"></a>为什么叫句柄这个名字？</h1><p>从名字上说，handle是指中间媒介，例如门把手是door handle，刀柄是knife handle。</p>
<p>所以文件句柄file handle以即其他资源句柄，也是这个中间媒介的意思，通过这个媒介操作资源。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27656256/answer/943130123">句柄是什么？ - 黄兢成的回答 - 知乎 解释句柄这个词语的表面含义</a></li>
</ul>
<h1 id="JVM对象访问定位"><a href="#JVM对象访问定位" class="headerlink" title="JVM对象访问定位"></a>JVM对象访问定位</h1><p>JVM通过栈上的reference类型数据来操作堆上的具体对象。</p>
<p>由于reference数据只是规定了一个指向对象的引用，没有定义如何去定位访问对象的具体位置。</p>
<p>主流的实现方式有两种：</p>
<ul>
<li>句柄<br>  在堆中划分句柄池，reference存储对象的句柄地址，句柄包含对象实例数据和类型数据的各自具体地址信息。<ul>
<li>好处：reference中的数据是稳定的句柄地址 对象被移动只会改变句柄中的信息 不会改变句柄的地址 reference不需要变化。</li>
<li>坏处：增加了指针定位的开销。</li>
</ul>
</li>
<li>直接指针<br>  栈上reference类型数据槽中直接存储堆对象的地址。<ul>
<li>好处：直接访问对象 减少指针定位开销。</li>
<li>坏处：当对象内存地址发生变化 reference中数据也需要调整。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》 2.3.3 对象的访问定位 48页</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/" class="post-title-link" itemprop="url">Java静态分派、动态分派</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-07 20:00:00" itemprop="dateCreated datePublished" datetime="2018-03-07T20:00:00+08:00">2018-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 17:48:47" itemprop="dateModified" datetime="2021-08-26T17:48:47+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/Java静态分派、动态分派/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>静态类型：变量被声明时的类型；例如，Animal a = new Dog(), 静态类型为Animal, 实际类型为Dog</p>
<p>实际类型：变量所引用的对象的真实类型</p>
<p>重载方法是静态分派，即编译时多态</p>
<p>重写方法是动态分派，即运行时多态</p>
<h1 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h1><p>方法的接收者：一个方法所属的对象</p>
<p>宗量：方法的接收者和方法的参数，只有这两种宗量</p>
<p>单分派：根据一个宗量进行对方法的选择</p>
<p>多分派：根据多于一个的宗量对方法进行选择</p>
<p>单分派和多分派取决于宗量,  方法调用者和方法参数都是宗量.</p>
<p>静态分派的方法调用：首先确定调用者的静态类型是什么,然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个, 需要根据这两个宗量来编译, 所以是静态多分派(多个宗量确定).</p>
<p>动态分派的方法调用：在运行期间,虚拟机会根据调用者的实际类型调用对应的方法, 只需根据这一个宗量就可以确定要调用的方法,所以是动态单分派(一个宗量)</p>
<p>到目前为止，Java 语言还是一门 “静态多分派、动态单分派” 的语言，也就是说在执行静态分派时是根据多个宗量判断调用哪个方法的，因为在静态分派时要根据不同的静态类型和不同的方法描述符选择目标方法，在动态分派的时候，是根据单宗量选择目标方法的，因为在运行期，方法的描述符已经确定好，invokevirtual 字节码指令根据变量的实际类型选择目标方法。</p>
<p>方法的描述符：方法参数类型+返回值类型</p>
<h1 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">classStaticDispatch &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Humanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Manguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,man&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Womanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,woman&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123; </span><br><span class="line">        Humanman=newMan(); </span><br><span class="line">        Humanwoman=newWoman(); </span><br><span class="line">        StaticDispatchdispatch=newStaticDispatch(); </span><br><span class="line">        dispatch.sayHello(man); </span><br><span class="line">        dispatch.sayHello(woman); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>静态类型：是指对象 man 的 Human 类型， 静态类型本身是不会发送变化的，只有在使用时才会发送变化，静态类型在编译期间就可以确定一个变量的静态类型 </p>
<p>实际类型：是指对象 man 的 Man 类型，实际类型在编译期间是不可确定的，只有在运行期才可确定 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化 </span></span><br><span class="line">Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">man = <span class="keyword">new</span> Woman(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态类型变化 </span></span><br><span class="line">dispatch.sayHello((Man) man); </span><br><span class="line">dispatch.sayHello((Woman) man); </span><br></pre></td></tr></table></figure>

<p>所以第一段代码中，方法接收者是 StaticDispatch 对象，虽然两个变量的实际类型不同，但是静态类型是相同的都是 Human，虚拟机（准确的说是编译器）在实现重载时是通过参数的静态类型而不是实际类型做出判定的，并且在编译阶段，变量的静态类型是可以确定的，所以编译器会根据变量的静态类型决定使用哪个重载方法。 </p>
<p>所有依赖静态类型定位目标方法的分派动作称为静态分派，静态分派典型的应用就是方法的重载。静态分派发生在编译阶段，所以方法的静态分派动作是由编译器执行的。 </p>
<h1 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, man&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, woman&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/picportal/pic/raw/master/img/20200325235523.png"></p>
<p>从上图中，我们可以看到 main() 方法的字节码指令执行过程：</p>
<ul>
<li>0 ~ 7 句是调用 Man 类的实例构造器创建一个 Man 类的对象，并将对象的引用压入到局部变量表的第 1 个 Slot 中</li>
<li>8 ~ 15 句是调用 Woman 类的实例构造器创建一个 Woman 类的对象，并将对象的引用压入到局部变量表的第 2 个 Slot 中</li>
<li>16 ~ 17 句是将第 1 个 Slot 中的变量（也就是 man）加载到局部变量表中，并调用 sayHello() 方法，关键的就是第 17 句指令 invokevirtual</li>
</ul>
<p>虽然第 17 句指令调用的常量池中的 Human.sayHello() 方法，但是最终执行的却是 Man.sayHello() 方法，这就要从 invokevirtual 指令的多态查找说起，invokevirtual 的查找过程如下所示：</p>
<ul>
<li>找到操作数栈顶的引用所指的对象的实际类型，记做 C</li>
<li>在类型 C 中查找与常量中的描述符和简单名称相同的方法，如果找到则进行访问权限的判断，如果通过则返回这个方法的直接引用，查找结束；如果权限不通过，则返回 java.lang.IllegalAccessError 的异常</li>
<li>如果在 C 中没有找到描述符和简单名称都符合的方法，则按照继承关系从下往上依次在 C 的父类中进行查找和验证过程</li>
<li>如果最终还是没有找到该方法，则抛出 java.lang.AbstractMethodError 的异常</li>
</ul>
<p>在上述 invokespecial 查找方法的过程中，最重要的就是第一步，根据对象的引用确定对象的实际类型，这个方法重写的本质。如上所述，在运行期内，根据对象的实际类型确定方法执行版本的分派过程叫做动态分派。</p>
<h1 id="如何理解Java是静态多分派、动态单分派？"><a href="#如何理解Java是静态多分派、动态单分派？" class="headerlink" title="如何理解Java是静态多分派、动态单分派？"></a>如何理解Java是静态多分派、动态单分派？</h1><p>编译时期确定方法有两点依据：</p>
<ol>
<li>调用方法的静态类型</li>
<li>方法的参数</li>
</ol>
<p>所以说是静态多分派。</p>
<p>运行时期再确定方法只有一点依据,就是调用方法的实际类型,所以说是动态单分派。</p>
<p>所以最后实际的方法调用是编译和运行的结合,即调用方法的实际类型和参数(运行时期直接引用会根据调用方法的实际类型确定,编译时期调用方法的静态类型只不过是虚引用),按书上说法,在编译时期,方法名和参数就被确定了,运行时只需要确定调用者即可;所以方法选择上,编译时期缩小了范围,运行时期确定了具体的方法。</p>
<p>对于静态分派（重载），肯定会依赖接收者的静态类型与参数的静态类型（参数肯定存在，同名无参的方法只会有一个，不存在分派）。</p>
<p>对于动态分派（重写），虚拟机只会根据接收者的实际类型选择，而不会理睬参数的实际类型。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li>深入理解Java虚拟机（第2版）  第8章  虚拟机字节码执行引擎 8.3.2 分派</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎（读书笔记）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28462483/answer/398040520">如何理解java是一门静态多分派且动态单分派的语言？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
