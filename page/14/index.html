<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/14/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/" class="post-title-link" itemprop="url">https、TLS握手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-03 20:31:00" itemprop="dateCreated datePublished" datetime="2018-04-03T20:31:00+08:00">2018-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/https、TLS握手/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http传输数据存在哪些问题？"><a href="#http传输数据存在哪些问题？" class="headerlink" title="http传输数据存在哪些问题？"></a>http传输数据存在哪些问题？</h1><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。<br>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>Charles抓包就是中间人拦截监听。</p>
<h1 id="https新引入了什么？解决了什么问题？"><a href="#https新引入了什么？解决了什么问题？" class="headerlink" title="https新引入了什么？解决了什么问题？"></a>https新引入了什么？解决了什么问题？</h1><ol>
<li> 数据加密传输，防止窃听</li>
<li> 校验数据，防止篡改</li>
<li> 使用数字证书验证身份，防止身份被冒充</li>
</ol>
<h1 id="https缺点是什么？"><a href="#https缺点是什么？" class="headerlink" title="https缺点是什么？"></a>https缺点是什么？</h1><ol>
<li> TLS握手增加了建立连接的时间</li>
<li> 每次加密解密数据需要占用额外的时间和CPU资源</li>
</ol>
<h1 id="https如何保证数据的完整性？"><a href="#https如何保证数据的完整性？" class="headerlink" title="https如何保证数据的完整性？"></a>https如何保证数据的完整性？</h1><p>http验证数据完整性存在的问题：</p>
<p>http通信是不加密的，即使对报文做了哈希摘要，并放在报文中传输，http通信内容被拦截篡改后，一并把哈希摘要也改掉，客户端是没办法识别报文是否被篡改。</p>
<p>https改进：</p>
<p>对报文的哈希摘要进行加密，另一方接受到报文并重新计算报文的哈希摘要，再对比解密后的摘要，检查是否一致。</p>
<p>对摘要的加密用对称加密，对称加密的秘钥用非对称加密方式加解密。</p>
<h1 id="https加密过程是怎样的？"><a href="#https加密过程是怎样的？" class="headerlink" title="https加密过程是怎样的？"></a>https加密过程是怎样的？</h1><p>采用对称加密方式加密报文，对称加密的秘钥用非对称加密方式加密后传递给通信双方。</p>
<p>因为：</p>
<ol>
<li> 对称加密速度快，但是通信双方都需要同一个密钥，密钥在传输过程中被窃取泄露后就不安全了</li>
<li> 非对称加密速度慢，但私钥不公开，只传递公钥出去，可以保证安全性</li>
</ol>
<h1 id="https通信过程是怎样的？"><a href="#https通信过程是怎样的？" class="headerlink" title="https通信过程是怎样的？"></a>https通信过程是怎样的？</h1><ol>
<li> 客户端发起SSL/TLS连接</li>
<li> 客户端获取服务端数字证书，验证服务端身份</li>
<li> 两端生成随机数，由服务端根据随机数，用私钥加密得到对称加密密钥</li>
<li> http的请求和响应报文都用对称加密密钥加密后再传输</li>
</ol>
<h1 id="SSL-TLS握手过程是怎样的？"><a href="#SSL-TLS握手过程是怎样的？" class="headerlink" title="SSL/TLS握手过程是怎样的？"></a>SSL/TLS握手过程是怎样的？</h1><p>有四次握手</p>
<ol>
<li> 客户端请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA公钥加密，此时是明文传输。</li>
<li> 服务端回复一种客户端支持的加密方法、一个随机数–Server random、授信的服务器证书和非对称加密的公钥。</li>
<li> 客户端收到服务端的回复后利用服务端的公钥，加上新的随机数–Premaster secret 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li>
<li> 服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li>
</ol>
<p>此后的HTTP链接数据传输即通过对称加密方式进行加密传输。</p>
<h2 id="为什么需要3个随机数作为对称加密的密钥？"><a href="#为什么需要3个随机数作为对称加密的密钥？" class="headerlink" title="为什么需要3个随机数作为对称加密的密钥？"></a>为什么需要3个随机数作为对称加密的密钥？</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在，在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。</p>
<h1 id="还有什么密钥交换算法？"><a href="#还有什么密钥交换算法？" class="headerlink" title="还有什么密钥交换算法？"></a>还有什么密钥交换算法？</h1><p>ECDHE ：“短暂 - 椭圆曲线 - 迪菲 - 赫尔曼”算法（ephemeral Elliptic Curve Diffie–Hellman）。</p>
<p>RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。</p>
<p>客户端和服务端双方在一个可以被窥探的信道下给双方建立起一个相同的密钥。</p>
<p>发送公有的参数，保留私有的参数，双方经过计算可以得到一个一致的结果，一致的结果可以用作会话密钥，这个运算的逆运算复杂度很高，所以不会泄露。</p>
<p><strong>为什么参数被窥探后还能够达到保密的效果?</strong></p>
<p>Deffie-Hellman算法的有效性依赖于计算离散对数的难度。</p>
<h1 id="https总共有多少次握手了？"><a href="#https总共有多少次握手了？" class="headerlink" title="https总共有多少次握手了？"></a>https总共有多少次握手了？</h1><p>SSL是在TCP之上，在HTTP之下。</p>
<p>TCP先三次握手建立连接，然后SSL四次握手，最后进行HTTP通信。</p>
<h1 id="https的身份认证是如何实现的？"><a href="#https的身份认证是如何实现的？" class="headerlink" title="https的身份认证是如何实现的？"></a>https的身份认证是如何实现的？</h1><p>通过数字证书验证通信方身份。</p>
<h2 id="如何验证证书是否可信？"><a href="#如何验证证书是否可信？" class="headerlink" title="如何验证证书是否可信？"></a>如何验证证书是否可信？</h2><p>服务端证书都是向CA这类的权威机构申请的，CA颁发证书时会用根证书的私钥去给申请的证书的哈希摘要做加密作为申请的证书的签名。</p>
<p>客户端收到服务端的证书后，查询证书的颁发者，一直寻找到根证书，然后用根证书里的公钥去解密其颁发的证书的签名，对比证书文件的哈希摘要是否一致，这样就验证了身份没有被篡改。</p>
<h2 id="数字证书验证身份的过程是怎样的？"><a href="#数字证书验证身份的过程是怎样的？" class="headerlink" title="数字证书验证身份的过程是怎样的？"></a>数字证书验证身份的过程是怎样的？</h2><p>服务端向CA（数字证书认证机构）提交自己的公钥申请数字证书，CA颁发证书，并把服务端的公钥内嵌在颁发的证书中，再对整个证书计算哈希摘要，用一个私钥加密这个哈希摘要，确保了申请到的证书在传输过程中可以校验证书是否被篡改，校验是通过CA提供的根证书里的公钥解密服务端证书中的哈希摘要，再计算服务端证书文件的哈希摘要，对比两者是否一致，根证书一般已事先内嵌客户端。</p>
<p>证书可以有信任链。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827203913.png"></p>
<h1 id="https单向认证是什么？"><a href="#https单向认证是什么？" class="headerlink" title="https单向认证是什么？"></a>https单向认证是什么？</h1><ol>
<li> 客户端发起请求，传送支持的TLS版本、摘要算法、随机数等信息</li>
<li> 服务端返回确认的TLS版本、摘要算法，并再发送生成的随机数、服务端的证书</li>
<li> 客户端验证证书是否可信，不可信则弹窗警告，可信则用随机数生成一个用于对称加密的密钥，用于接下来加密报文，用服务端证书的公钥加密发送给服务端</li>
<li> 服务端接收到会话密钥，用私钥解密，得到会话密钥，返回ACK确认消息</li>
</ol>
<h1 id="https双向认证是什么？"><a href="#https双向认证是什么？" class="headerlink" title="https双向认证是什么？"></a>https双向认证是什么？</h1><p>单向认证是客户端验证服务端的证书来检验服务端身份是否合法。</p>
<p>双向认证是服务端也要求验证客户端的证书来检验客户端的身份是否合法。服务端会在发送证书给客户端时，要求客户端也发送证书给服务端。</p>
<p>双向认证使用场景：</p>
<p>使用网上银行可能需要在电脑上插U盾之类的东西，就是生成客户端证书的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">UDP与TCP区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-16 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-16T19:31:00+08:00">2018-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/UDP与TCP区别/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UDP报文头"><a href="#UDP报文头" class="headerlink" title="UDP报文头"></a>UDP报文头</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827230610.png"></p>
<p>UDP 协议头中只包含 4 个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占 16 比特，即 2 字节，这 4 个字段的作用如下：</p>
<ul>
<li>源端口是一个可选字段，它表示发送方进程的端口号，接收方可以使用该字段（不一定准确）向发送方发送信息；</li>
<li>目的端口是数据报接收方的端口号，它只在目标的 IP 地址下才有意义；</li>
<li>长度是协议头和数据报中数据长度的总和，表示整个数据报的大小；</li>
<li>  校验码使用 IP 首部、UDP 首部和数据报中的数据进行计算，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题。</li>
</ul>
<h1 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h1><p>简单高效：</p>
<ol>
<li> 面向无连接</li>
<li> 报文头简单，只有8字节</li>
<li> 对应用层数据不分段</li>
</ol>
<p>关于分段：</p>
<p>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。若报文太长，则到达IP层需要分片，降低效率。若太短，则传输效率会下降（举个例子，1字节的数据，加上20字节的UDP首部，再加上20字节的IP层首部，结果发了41字节的包只完成了1字节有用数据的交付）。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<h1 id="UDP和TCP区别？"><a href="#UDP和TCP区别？" class="headerlink" title="UDP和TCP区别？"></a>UDP和TCP区别？</h1><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/" class="post-title-link" itemprop="url">最大报文长度（MSS）与最大传输单元（MTU）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-15T19:31:00+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/最大报文长度（MSS）与最大传输单元（MTU）/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大报文长度（Maximum-Segment-Size）是什么？"><a href="#最大报文长度（Maximum-Segment-Size）是什么？" class="headerlink" title="最大报文长度（Maximum Segment Size）是什么？"></a>最大报文长度（Maximum Segment Size）是什么？</h1><p>TCP报文数据部分的最大长度，不包含TCP头。</p>
<p>这个MSS指的是TCP报文段中数据部分的最大长度，并不是整个TCP报文段长度。整个TCP报文段长度 = TCP首部长度 + TCP数据部分长度。</p>
<p>如果上层交付下来的数据太大，就对其进行数据分块。这个分块过程是在传输层完成的，在接收端的传输层对分块的TCP报文段的数据部分进行重组。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）存储在什么地方？"><a href="#最大报文长度（Maximum-Segment-Size）存储在什么地方？" class="headerlink" title="最大报文长度（Maximum Segment Size）存储在什么地方？"></a>最大报文长度（Maximum Segment Size）存储在什么地方？</h1><p>TCP首部中的Options字段</p>
<h1 id="为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？"><a href="#为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？" class="headerlink" title="为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？"></a>为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？</h1><p>当TCP数据长度超过MSS的时候，TCP会做分段。</p>
<p>这样是为了防止IP层对TCP报文分片。</p>
<h1 id="IP层对TCP报文进行分片会产生什么问题？"><a href="#IP层对TCP报文进行分片会产生什么问题？" class="headerlink" title="IP层对TCP报文进行分片会产生什么问题？"></a>IP层对TCP报文进行分片会产生什么问题？</h1><p>IP分片后，接收端需要等到所有IP包到达后，才能确定整个TCP报文收到了，然后发送ACK报文，这样比较低效，也增加了控制的复杂性。</p>
<p>IP分片后，如果有几个分片丢失了，只能重传所有分片，这样是很浪费流量的。</p>
<p>首先因为IP层没有超时重传机制，IP层是面向无连接的，所以IP层没有办法只重传丢失的分片。</p>
<p>其次IP分片后，只有第一片有TCP的报文头，后面的IP分片没有TCP报文头，所以TCP也没办法识别到底是哪一段丢失了，也就没办法做超时重传，也没办法确定顺序，如果TCP对报文分段，每段都有TCP报文头，报文丢失就知道丢失的是哪一个。</p>
<h1 id="为什么IP数据长度过长要分片？"><a href="#为什么IP数据长度过长要分片？" class="headerlink" title="为什么IP数据长度过长要分片？"></a>为什么IP数据长度过长要分片？</h1><p>IP分组达到数据链路层，整个IP分组被作为数据链路层以太网帧的数据部分。</p>
<p>以太网帧对数据部分有最大长度的限制，所以IP数据数据过长要分片。</p>
<p>数据链路层的以太网帧的数据部分的最大长度（最大IP包长）称为最大传输单元（Maximum Transmit Unit）</p>
<p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p>
<h1 id="TCP拆分数据的意义？"><a href="#TCP拆分数据的意义？" class="headerlink" title="TCP拆分数据的意义？"></a>TCP拆分数据的意义？</h1><p>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</p>
<h1 id="最大传输单元（Maximum-Transmit-Unit）是什么？"><a href="#最大传输单元（Maximum-Transmit-Unit）是什么？" class="headerlink" title="最大传输单元（Maximum Transmit Unit）是什么？"></a>最大传输单元（Maximum Transmit Unit）是什么？</h1><p>数据链路层的以太网帧的数据部分的最大长度（IP包长）</p>
<h1 id="为什么以太网MTU默认值被设定为1500？"><a href="#为什么以太网MTU默认值被设定为1500？" class="headerlink" title="为什么以太网MTU默认值被设定为1500？"></a>为什么以太网MTU默认值被设定为1500？</h1><p>MTU为什么不能太大呢？</p>
<p>以太网早期的拓扑结构是总线型结构，总线型传输有个特点就是，同一时刻只能有一个主机占用总线传输，如果一个以太网帧过长，这个主机就会一直占用总线，其他主机只能干等着，对于其他主机来说数据延迟就变大了。</p>
<p>而且传输的数据包越大，数据位出错的可能性越大，出错了就要重传，重传又要占用很长时间的带宽，降低了整体吞吐量。</p>
<p>所以MTU不能太大。</p>
<p>如果MTU太小，各种协议头也要占用数据包大小的，这样每个报文的实际有效传输效率也会很低。</p>
<p>所以MTU要搞一个适中值。</p>
<p>1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致丢包无法发送。</p>
<h1 id="为什么MTU最小为64字节？"><a href="#为什么MTU最小为64字节？" class="headerlink" title="为什么MTU最小为64字节？"></a>为什么MTU最小为64字节？</h1><p>以CSMA/CD作为MAC<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure">算法</a>的一类LAN称为以太网。CSMA/CD冲突避免的方法：先听后发、边听边发、随机延迟后重发。一旦发生冲突，必须让每台主机都能检测到。关于最小发送间隙和最小帧长的规定也是为了避免冲突。</p>
<p>考虑如下的情况，主机发送的帧很小，而两台冲突主机相距很远。在主机A发送的帧传输到B的前一刻，B开始发送帧。这样，当A的帧到达B时，B检测到冲突，于是发送冲突信号。假如在B的冲突信号传输到A之前，A的帧已经发送完毕，那么A将检测不到冲突而误认为已发送成功。由于信号传播是有时延的，因此检测冲突也需要一定的时间。这也是为什么必须有个最小帧长的限制。</p>
<p>按照标准，10Mbps以太网采用中继器时，连接的最大长度是2500米，最多经过4个中继器，因此规定对10Mbps以太网一帧的最小发送时间为51.2微秒。这段时间所能传输的数据为512位，因此也称该时间为512位时。这个时间定义为以太网时隙，或冲突时槽。512位＝64字节，这就是以太网帧最小64字节的原因。</p>
<p>512位时是主机捕获信道的时间。如果某主机发送一个帧的64字节仍无冲突，以后也就不会再发生冲突了，称此主机捕获了信道。</p>
<p>由于信道是所有主机共享的，如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的最大帧长为1500。</p>
<p>100Mbps以太网的时隙仍为512位时，以太网规定一帧的最小发送时间必须为5.12μs。</p>
<p>1000Mbps以太网的时隙增至512字节，即4096位时，4.096μs。</p>
<p>以太网数据帧（802.3）最大与最小长度。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）是怎么确定的？"><a href="#最大报文长度（Maximum-Segment-Size）是怎么确定的？" class="headerlink" title="最大报文长度（Maximum Segment Size）是怎么确定的？"></a>最大报文长度（Maximum Segment Size）是怎么确定的？</h1><p>MSS由设备的MTU确定，不能超过MTU，否则TCP报文会被IP层分片  </p>
<h1 id="TCP报文的长度在TCP三次握手中那一次确定的？"><a href="#TCP报文的长度在TCP三次握手中那一次确定的？" class="headerlink" title="TCP报文的长度在TCP三次握手中那一次确定的？"></a>TCP报文的长度在TCP三次握手中那一次确定的？</h1><p>MSS值只会出现在SYN报文中（不要问我为什么，我也不知道为什么只出现SYN报文中），即SYN=1时，才会有MSS字段值。</p>
<p>当客户端想要以TCP方式从服务器端下载数据时，</p>
<p>（1）首先客户端会发送一个SYN请求报文，这个SYN报文的“选项”字段中会有MSS值（MSS = MTU - IP首部长度 - TCP首部长度）。该MSS值是为了告知对方最大的发送数据大小。</p>
<p>（2）当服务器端收到SYN报文后，会向请求端返回SYN+ACK（同步确认报文）报文，其中的“选项”字段也会有MSS值。</p>
<p>（3）通信双方选择SYN和SYN+ACK报文中最小的MSS最为此次TCP连接的MSS，从而达到通信双发协商MSS的效果。</p>
<p>在第二次握手后就可以确定TCP中最大传输报文（MSS）大小。</p>
<h1 id="MTU是怎么确定的？"><a href="#MTU是怎么确定的？" class="headerlink" title="MTU是怎么确定的？"></a>MTU是怎么确定的？</h1><p>每一个物理设备都有自己的 MTU，最终的MTU由整个链路上 MTU 最小的物理设备决定。</p>
<p>路径MTU发现（PMTUD： Path MTU Discovery ）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP拥塞控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-13 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-13T19:31:00+08:00">2018-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP拥塞控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么情况下才算发生了网络拥塞？"><a href="#什么情况下才算发生了网络拥塞？" class="headerlink" title="什么情况下才算发生了网络拥塞？"></a>什么情况下才算发生了网络拥塞？</h1><p>发送方有TCP报文超时了没有收到ACK确认报文</p>
<h1 id="拥塞控制的过程是怎样的？"><a href="#拥塞控制的过程是怎样的？" class="headerlink" title="拥塞控制的过程是怎样的？"></a>拥塞控制的过程是怎样的？</h1><p>慢启动、拥塞避免、快重传、快恢复</p>
<p>拥塞窗口，拥塞窗口大小cwnd（congestion window）表示可以发送的报文字节数，单位是一个MSS（最大报文长度）</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>拥塞窗口初始大小为1，每收到一个ACK，拥塞窗口大小+1，实际效果就是每过一个RTT，拥塞窗口大小为原来的2倍，以指数增长率增长，先慢后快，达到慢开始门限ssthresh则停止慢开始，执行拥塞避免算法。</p>
<p>翻倍后如果大小超过阈值则窗口大小设为阈值。</p>
<p>例如：</p>
<p>初始窗口大小为1</p>
<p>发送第一个报文M0，收到ACK1后窗口大小+1，变为2</p>
<p>发送M1、M2，收到ACK2、ACK3后，窗口大小+2，变为4</p>
<p>再发送4个报文，收到4个ACK后，窗口大小+4，变为8</p>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>每过一个RTT（受到一个ACK），拥塞窗口大小+1</p>
<p>线性增长，避免增长过快</p>
<h2 id="发生拥塞"><a href="#发生拥塞" class="headerlink" title="发生拥塞"></a>发生拥塞</h2><p>发送方有报文超时，未收到ACK确认报文</p>
<p>无论是在慢开始阶段还是拥塞避免阶段，做出以下调整：</p>
<ol>
<li>把慢开始门限ssthresh设置为出现拥塞时发送方拥塞窗口大小的一半（不小于2）</li>
<li>拥塞窗口大小设为1，执行慢开始</li>
</ol>
<p>目的：</p>
<p>迅速减少发送方发送到网络的报文数，在发生拥塞时路由器有足够的时间把队列中挤压的报文发完</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825255523.jpeg"></p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，则不等待定时器结束就直接重传该序号的报文</p>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，慢开始门限设置为拥塞窗口大小的一半，拥塞窗口不设置为1，也设置为原窗口大小的一半，并执行拥塞避免算法，线性增大拥塞窗口。</p>
<p>因为跳过了拥塞窗口从1开始的慢开始过程，所以称为快恢复。</p>
<p>发送方窗口大小为  流量控制的滑动窗口和拥塞窗口  的较小值</p>
<h1 id="快速重传有什么问题？"><a href="#快速重传有什么问题？" class="headerlink" title="快速重传有什么问题？"></a>快速重传有什么问题？</h1><p>与基于定时器的超时重传拥有同样的问题，即：</p>
<p>不确定应该重发哪些序号的报文，如果只重发一个可能会拖慢整体传输时长，如果重发多个可能会浪费流量、增加整体传输时长，需要知道哪些序号的报文是丢失的，只重发丢失的报文。  </p>
<p>发送方收到同一个序号的多个ACK确认，发送方并不清楚这些ACK是由哪些序号的报文传输成功后ACK回来的，可能会重发接收方已经收到的报文，浪费流量。</p>
<h1 id="带选择确认的重传（SACK）解决了什么？"><a href="#带选择确认的重传（SACK）解决了什么？" class="headerlink" title="带选择确认的重传（SACK）解决了什么？"></a>带选择确认的重传（SACK）解决了什么？</h1><p>一端在发送ACK时通过在TCP报文头部增加SACK（Selective Acknowledgment）选项，告知对方已经收到的包序号区间范围，让对方只重传丢失的报文，并且可以一次性集中重传，避免了网络流量的浪费，也避免了长时间的超时等待。</p>
<p>SACK需要客户端和服务的都开启该功能</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP流量控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-12 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-12T19:31:00+08:00">2018-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP流量控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么要有流量控制？"><a href="#为什么要有流量控制？" class="headerlink" title="为什么要有流量控制？"></a>为什么要有流量控制？</h1><p>双端通信的时候，发送方发送数据速度和接收方处理数据速度不一定相等；</p>
<p>如果发送过快，接收方处理不过来，接收方只能把数据存在缓冲区，缓冲区满了后再收到数据就只能丢弃；</p>
<p>所以需要控制发送方发送数据的速率，让接收方与发送方处于一种动态的平衡中才好。</p>
<p>对于发送方发送速率的控制，称为流量控制。</p>
<h1 id="滑动窗口大小是如何确定的？"><a href="#滑动窗口大小是如何确定的？" class="headerlink" title="滑动窗口大小是如何确定的？"></a>滑动窗口大小是如何确定的？</h1><p>发送数据的一方收到对方发送的ACK报文，其报文头中的窗口大小表示对方的缓冲区大小还能存放多少字节的数据，发送方拿这个窗口大小与本身的拥塞窗口大小在一起取最小值，作为自己滑动窗口的大小。</p>
<p>达到：</p>
<ol>
<li>避免对方缓冲区存不下发送过多的数据而丢弃，进而浪费网络带宽和流量</li>
<li>避免产生网络拥塞</li>
</ol>
<h1 id="滑动窗口中的内容"><a href="#滑动窗口中的内容" class="headerlink" title="滑动窗口中的内容"></a>滑动窗口中的内容</h1><p>滑动窗口内包含两类报文</p>
<ol>
<li>已发送但未收到确认</li>
<li> 允许发送但尚未发送</li>
</ol>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180835235523.jpeg"></p>
<h1 id="滑动窗口什么时候开始滑动？"><a href="#滑动窗口什么时候开始滑动？" class="headerlink" title="滑动窗口什么时候开始滑动？"></a>滑动窗口什么时候开始滑动？</h1><p>窗口左侧的报文收到了ACK报文确认，窗口就往右滑动</p>
<h1 id="如果发送端滑动窗口大小为0，不发送数据了会怎样？"><a href="#如果发送端滑动窗口大小为0，不发送数据了会怎样？" class="headerlink" title="如果发送端滑动窗口大小为0，不发送数据了会怎样？"></a>如果发送端滑动窗口大小为0，不发送数据了会怎样？</h1><p>实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅包含一个字节来获取最新的窗口大小信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/" class="post-title-link" itemprop="url">TCP超时重传</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-11 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-11T19:31:00+08:00">2018-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP超时重传/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="超时重传的等待时间设置为多少合适？"><a href="#超时重传的等待时间设置为多少合适？" class="headerlink" title="超时重传的等待时间设置为多少合适？"></a>超时重传的等待时间设置为多少合适？</h1><p>超时重传的等待时间：Retransmission Time Out, RTO。</p>
<p>等待时间过长，若丢包严重，则传输的吞吐量低。</p>
<p>等待时间过短，会导致频繁的发包，增加网络拥堵，占用带宽。</p>
<p>等待时间只能尽可能的短，按照正常的节奏，一端发送报文到收到ACK报文的时间（往返时间Round Trip Time）就是最短的等待时间，RTO可以略微大于RTT，以增加一点容错范围。</p>
<p>但RTT并不是固定的，因为网络拥堵状况随时在发生变化，所以RTT应当不停的动态计算，有一系列的算法支持。</p>
<h1 id="基于定时器的超时重传存在什么问题？"><a href="#基于定时器的超时重传存在什么问题？" class="headerlink" title="基于定时器的超时重传存在什么问题？"></a>基于定时器的超时重传存在什么问题？</h1><p>会重发接收方已经收到的报文，浪费带宽，通信时间被拖长。</p>
<p>接收方发送的ACK报文中确认的报文序号有个特点，就是这个序号之前的报文接收方一定都已经收到了。</p>
<p>这样就会导致一个问题，如果发送方发了一系列序号连续的报文，接收方只有中间的几个报文没有收到，那么收到序号较大的报文后回应的ACK里的确认序号是较小的，这会导致发送方无法确认较大序号的报文接收方有没有收到。</p>
<p>此时发送方该重发哪些报文就成了问题，此时有两种策略：</p>
<p>一种策略是只重传ACK期待的序号的报文，序号较大报文暂时不重发，等待它们的定时器超时了再重发，如果较大序号的报文接收方都接受到了倒没问题，但如果较大序号的报文接收方都没收到，一个个等待报文超时无疑是拖慢了整体的传输时间。</p>
<p>另一种策略就是重传ACK序号后所有的报文，如果丢包严重，这种做法效率挺高，但如果丢包并不严重，这种做法会浪费很多流量。</p>
<p>如果能知道没有收到的报文序号是哪些就很好办了，用SACK可以解决这个问题。</p>
<p>例如发送方发了序号为1、2、3、4、5、6的报文，接收方收到了1、2、4、5、6，唯独为没有收到3（3可能卡在某个网络节点上），在接收到1后回应ACK 2，接收2后回应ACK 3，接收到4、5、6，也是回应ACK 3，此时发送方对3、4、5、6的定时器都会超时，然后都会重发3、4、5、6，但实际4、5、6已经接收到了，重发4、5、6其实是浪费带宽，也增加了整体传输时长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/" class="post-title-link" itemprop="url">TCP报文编号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-10 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-10T19:31:00+08:00">2018-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP报文编号/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP为什么要给报文编号？不编号会有什么问题？"><a href="#TCP为什么要给报文编号？不编号会有什么问题？" class="headerlink" title="TCP为什么要给报文编号？不编号会有什么问题？"></a>TCP为什么要给报文编号？不编号会有什么问题？</h1><p>保证报文的不重复、不丢失、不乱序。</p>
<p>作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。</p>
<h1 id="为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？"><a href="#为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？" class="headerlink" title="为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？"></a>为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？</h1><p>TCP把数据视为一个无结构但有序的字节流，序号建立在传输的字节流之上，而不建立在报文段之上。</p>
<p>接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p>因为TCP有窗口拥塞控制，窗口的拥塞是基于字节的，所以必须给字节编号，如果给数据包编号，拥塞窗口无法调节大小。</p>
<h1 id="TCP三次握手中的初始序号是固定的吗？"><a href="#TCP三次握手中的初始序号是固定的吗？" class="headerlink" title="TCP三次握手中的初始序号是固定的吗？"></a>TCP三次握手中的初始序号是固定的吗？</h1><p>不是固定的，是动态增长+随机选取，可以避免相邻的TCP会话的序列号有重叠，否则并不知道报文是旧连接的还是新连接的</p>
<p>如果初始序号是固定的，攻击者就可以很容易伪造TCP报文发起攻击，初始序号需要动态生成，提高攻击成本。</p>
<p>源IP地址、源端口、目标IP地址、目标端口唯一确定一个TCP会话，允许刚释放的TCP端口重用，如果旧会话中的分组报文仍然在网络中，新会话建立后可能会收到旧会话产生的分组报文，如果序号是一直递增的，就可以分辨出报文是属于旧会话的还是新会话的。</p>
<p>关于ISN的初始化。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p>
<h1 id="报文编号和确认应答机制存在什么问题？"><a href="#报文编号和确认应答机制存在什么问题？" class="headerlink" title="报文编号和确认应答机制存在什么问题？"></a>报文编号和确认应答机制存在什么问题？</h1><p>队头阻塞。</p>
<p>TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Okio%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Okio%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" class="post-title-link" itemprop="url">Okio解决了什么？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-09 20:52:00" itemprop="dateCreated datePublished" datetime="2018-03-09T20:52:00+08:00">2018-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Okio%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="源码分析/Okio解决了什么？/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="传统Blocking-IO存在什么问题？"><a href="#传统Blocking-IO存在什么问题？" class="headerlink" title="传统Blocking IO存在什么问题？"></a>传统Blocking IO存在什么问题？</h1><p>传统BIO不管是读入还是写出，缓冲区的存在必然涉及copy的过程，而如果涉及双流操作，比如从一个输入流读入，再写入到一个输出流，那么这种情况下，在缓冲存在的情况下，数据走向是：</p>
<p>-&gt; 从输入流读出到缓冲区</p>
<p>-&gt; 从输入流缓冲区copy到 b[]</p>
<p>-&gt; 将 b[] copy 到输出流缓冲区</p>
<p>-&gt; 输出流缓冲区读出数据到输出流</p>
<p>上面情况存在冗余copy操作。</p>
<h1 id="Okio解决了什么？"><a href="#Okio解决了什么？" class="headerlink" title="Okio解决了什么？"></a>Okio解决了什么？</h1><p>Okio减少了冗余的复制。</p>
<p>Okio从输入流读取到的数据用一个Segment链表存储，写入数据会把Segment链表中的结点拿过来，不用做中间拷贝。</p>
<p>Segment 实际上也是对 byte[] 进行封装，再通过各种属性来记录各种状态。在读写时，如果可以，将Segment整体作为数据传授媒介，这样就没有具体数据的copy过程，而是交换了对应的Segment引用，这是减少数据copy进而交换数据的关键。</p>
<p>Okio并没有打算优化底层IO方式以及替代原生IO方式，Okio优化了缓冲策略以减轻内存压力和性能消耗，并且对于部分IO场景，提供了更友好的API。</p>
<h1 id="Okio内部实现"><a href="#Okio内部实现" class="headerlink" title="Okio内部实现"></a>Okio内部实现</h1><p>Okio底层还是用Java标准的io流来操作，只是缓存机制是自己实现了一套，避免了减少一次中间拷贝过程。</p>
<p>不管是RealBufferedSource还是RealBufferedSink，内部本质上都是通过Buffer这个类来实现缓存功能，而Buffer内部又是通过Segment这个核心类来缓存读取到的数据，Buffer就是一个管理者用来调度Segment。</p>
<p>Segment是双向链表中的一个结点，Buffer类存储了链表的头结点。</p>
<p>Segment中有个byte数组存储了真正的数据，最大字节数是8K，还有一些指针，表明了有效数据的范围。</p>
<p>有数据超过8K，就会创建新的Segment，跟前面的Segment连起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedSource bufferedSource = Okio.buffer(Okio.source(src));</span><br><span class="line">BufferedSink bufferedSink = Okio.buffer(Okio.sink(dest));</span><br><span class="line">bufferedSink.writeAll(bufferedSource);</span><br><span class="line">bufferedSink.close();</span><br></pre></td></tr></table></figure>

<ol>
<li> 先从原始的Source对象读数据，到RealBufferedSource的buffer对象，通过尾插法创建Segment，数据依次填满一个个的Segment对象里的byte数组。</li>
<li> RealBufferedSource中的buffer中的Segment转移到RealBufferedSink中的buffer中</li>
<li> 最后遍历RealBufferedSink的buffer中Segment链表写到OutputStream中</li>
</ol>
<p>(1) Source中需要传递的数据是”满”的情况，也就是8k都是有效数据，这种情况直接从source的buffer中拿到Segment，然后添加到sink的buffer上即可，和java io流相比，省去了中间的一次临时buffer拷贝，从而提高的读写效率</p>
<p>(2) Source中需要传递的数据不”满”的情况，通过pos和limit可以定位到有效数据区间，和Sink中buffer的尾Segment有效数据进行对比，如果两个Segment中的有效数据可以合并到一个Segment中那么会进行数据整理，多余的Segment会被回收到。</p>
<p>如果两个Segment的有效数据总和超过8k，那么直接将Source中的Segment链接到Sink中buffer的尾部即可。</p>
<p>(3) Source的buffer中的Segment只是传递部分数据，如5K的数据值传递其中2K，okio内部会通过split方法将Segment分成2K和3K两个Segment，然后将2K的Segment参照第二种情况和Sink中的Segment进行合并。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-09 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-09T19:31:00+08:00">2018-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP四次挥手/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP断开连接为什么要四次挥手？为什么不能三次挥手？"><a href="#TCP断开连接为什么要四次挥手？为什么不能三次挥手？" class="headerlink" title="TCP断开连接为什么要四次挥手？为什么不能三次挥手？"></a>TCP断开连接为什么要四次挥手？为什么不能三次挥手？</h1><p>因为服务端接收到客户端断开连接的请求报文时，服务端可能还有数据要发送，要等待服务端把数据发送完了，才能向客户端发起断开连接的请求，此时服务端只能先回复客户端一个ACK报文，告知客户端我已经收到了断开连接的请求，你可以不用重复发送断开连接的请求了，等我把数据发完再通知你我可以断开连接。服务端的ACK和FIN指令必须分开发送，所以需要四次挥手，而不能三次。</p>
<h1 id="TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME-WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？"><a href="#TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME-WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？" class="headerlink" title="TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME_WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？"></a>TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME_WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？</h1><ol>
<li>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</li>
<li>保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；</li>
</ol>
<h2 id="阻止延迟报文"><a href="#阻止延迟报文" class="headerlink" title="阻止延迟报文"></a>阻止延迟报文</h2><p>TCP断开连接时，如果客户端在接收到服务端的FIN自己发送完ACK后直接关闭连接，服务端可能没有收到ACK，会超时重传FIN，此时由于客户端已经关闭了连接，如果客户端有新的程序需要向该服务端的同一个端口传输数据，会重新建立TCP连接，并且这个新TCP连接无法和上一个关闭的TCP连接区分开来，因为源IP地址、源端口、目标IP地址、目标端口都一样，此时新连接传输数据过程中如果收到上次连接的传来的FIN，新连接的状态就异常了，新连接SYN握手会失败，服务端会发送RST阻止客户端连接的建立，因为旧的连接并没有关闭。。也有可能会收到其他服务端发送的报文。</p>
<h2 id="保证连接关闭"><a href="#保证连接关闭" class="headerlink" title="保证连接关闭"></a>保证连接关闭</h2><p>服务端发送FIN报文后，如果没有接收到ACK会超时重传FIN，直到收到ACK了才会关闭连接。服务端要等待什么时候超时重传呢？服务端发送FIN后，最多经过一个MSL到达客户端，客户端发送ACK最多经过一个MSL到达服务端，所以服务端等待2MSL没有收到ACK就重发FIN报文，FIN报文最多经过一个MSL到达客户端，所以从客户端发送ACK给服务端要至少等待2MSL，以取保服务端收到了自己发送的ACK，不会超时重传FIN</p>
<h1 id="为什么TIME-WAIT要等待2MSL？"><a href="#为什么TIME-WAIT要等待2MSL？" class="headerlink" title="为什么TIME_WAIT要等待2MSL？"></a>为什么TIME_WAIT要等待2MSL？</h1><p>MSL（Maximum Segment Lifetime，最大报文生存时间）是指任何报文在网络上存在的最长时间，超过这个时间的报文都会被丢弃。</p>
<p>网络中可能存在来自发送方的报文，接收方收到后需要回ACK，一来一回两个MSL，等待两个MSL可以确保网络中一定不存在报文。</p>
<p>服务端发送FIN后，会计时等待接受ACK，等待的时间大约是一个RTT多一点的时间，也就是2MSL左右，如果FIN没丢失，客户端发送ACK，发送ACK时服务端已经等待了一个MSL左右，如果ACK丢失了，服务端再等待一个MSL，超时未收到ACK，则会重传FIN，FIN再次到达客户端也需要一个MSL左右，这样客户端至少得等待2MSL，以让服务端重传的FIN达到，如果2MSL后没有收到服务端的FIN，说明服务端已经接收到ACK了，服务端已经关闭连接，同时网络也不可能有此次连接的任何报文了，客户端就可以安全的关闭连接。</p>
<h1 id="进入TIME-WAIT有什么问题？"><a href="#进入TIME-WAIT有什么问题？" class="headerlink" title="进入TIME_WAIT有什么问题？"></a>进入TIME_WAIT有什么问题？</h1><p>大并发量的短时间传输的连接，会造成连接等待时间变长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">句柄、直接指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 20:00:00" itemprop="dateCreated datePublished" datetime="2018-03-08T20:00:00+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 14:29:32" itemprop="dateModified" datetime="2021-09-02T14:29:32+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/句柄、直接指针/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄是什么？"><a href="#句柄是什么？" class="headerlink" title="句柄是什么？"></a>句柄是什么？</h1><p>指针的指针。</p>
<p>jvm中内存里的对象都有一个指针指向对象的开始地址，句柄就是指向对象的指针。</p>
<h1 id="句柄解决了什么问题"><a href="#句柄解决了什么问题" class="headerlink" title="句柄解决了什么问题?"></a>句柄解决了什么问题?</h1><p>对实际的对象资源做了一层代理，屏蔽细节，避免了直接操控资源可能的危险。</p>
<p>弄了句柄，对象实际位置在内存中可以随意变化，比如标记整理垃圾回收后对象被移动到其他地方。</p>
<p>虚拟内存机制，可能会将已经载入内存的数据换到外存硬盘上，这样对象的地址就会变动，其他地方引用这块被换走的地址也要更新，如果使用这块数据的地方引用的是句柄，这样实际数据在内存的位置可以随意变化，使用数据的地方还是引用固定的地址，不用更新。</p>
<p>Windows系统中有许多内核对象（这里的对象不完全等价于”面向对象程序设计”一词中的”对象”，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个”对象”的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p>
<ol>
<li><p>暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p>
</li>
<li><p>操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p>
</li>
</ol>
<p>所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p>
<p>在Windows系统中，这个编号就叫做”句柄”。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/klb561/p/10555571.html">句柄的概念</a></p>
<h1 id="为什么叫句柄这个名字？"><a href="#为什么叫句柄这个名字？" class="headerlink" title="为什么叫句柄这个名字？"></a>为什么叫句柄这个名字？</h1><p>从名字上说，handle是指中间媒介，例如门把手是door handle，刀柄是knife handle。</p>
<p>所以文件句柄file handle以即其他资源句柄，也是这个中间媒介的意思，通过这个媒介操作资源。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27656256/answer/943130123">句柄是什么？ - 黄兢成的回答 - 知乎 解释句柄这个词语的表面含义</a></li>
</ul>
<h1 id="JVM对象访问定位"><a href="#JVM对象访问定位" class="headerlink" title="JVM对象访问定位"></a>JVM对象访问定位</h1><p>JVM通过栈上的reference类型数据来操作堆上的具体对象。</p>
<p>由于reference数据只是规定了一个指向对象的引用，没有定义如何去定位访问对象的具体位置。</p>
<p>主流的实现方式有两种：</p>
<ul>
<li>句柄<br>  在堆中划分句柄池，reference存储对象的句柄地址，句柄包含对象实例数据和类型数据的各自具体地址信息。<ul>
<li>好处：reference中的数据是稳定的句柄地址 对象被移动只会改变句柄中的信息 不会改变句柄的地址 reference不需要变化。</li>
<li>坏处：增加了指针定位的开销。</li>
</ul>
</li>
<li>直接指针<br>  栈上reference类型数据槽中直接存储堆对象的地址。<ul>
<li>好处：直接访问对象 减少指针定位开销。</li>
<li>坏处：当对象内存地址发生变化 reference中数据也需要调整。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》 2.3.3 对象的访问定位 48页</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">186</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">251</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
