<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/14/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/" class="post-title-link" itemprop="url">最大报文长度（MSS）与最大传输单元（MTU）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-15T19:31:00+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/最大报文长度（MSS）与最大传输单元（MTU）/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大报文长度（Maximum-Segment-Size）是什么？"><a href="#最大报文长度（Maximum-Segment-Size）是什么？" class="headerlink" title="最大报文长度（Maximum Segment Size）是什么？"></a>最大报文长度（Maximum Segment Size）是什么？</h1><p>TCP报文数据部分的最大长度，不包含TCP头。</p>
<p>这个MSS指的是TCP报文段中数据部分的最大长度，并不是整个TCP报文段长度。整个TCP报文段长度 = TCP首部长度 + TCP数据部分长度。</p>
<p>如果上层交付下来的数据太大，就对其进行数据分块。这个分块过程是在传输层完成的，在接收端的传输层对分块的TCP报文段的数据部分进行重组。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）存储在什么地方？"><a href="#最大报文长度（Maximum-Segment-Size）存储在什么地方？" class="headerlink" title="最大报文长度（Maximum Segment Size）存储在什么地方？"></a>最大报文长度（Maximum Segment Size）存储在什么地方？</h1><p>TCP首部中的Options字段</p>
<h1 id="为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？"><a href="#为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？" class="headerlink" title="为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？"></a>为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？</h1><p>当TCP数据长度超过MSS的时候，TCP会做分段。</p>
<p>这样是为了防止IP层对TCP报文分片。</p>
<h1 id="IP层对TCP报文进行分片会产生什么问题？"><a href="#IP层对TCP报文进行分片会产生什么问题？" class="headerlink" title="IP层对TCP报文进行分片会产生什么问题？"></a>IP层对TCP报文进行分片会产生什么问题？</h1><p>IP分片后，接收端需要等到所有IP包到达后，才能确定整个TCP报文收到了，然后发送ACK报文，这样比较低效，也增加了控制的复杂性。</p>
<p>IP分片后，如果有几个分片丢失了，只能重传所有分片，这样是很浪费流量的。</p>
<p>首先因为IP层没有超时重传机制，IP层是面向无连接的，所以IP层没有办法只重传丢失的分片。</p>
<p>其次IP分片后，只有第一片有TCP的报文头，后面的IP分片没有TCP报文头，所以TCP也没办法识别到底是哪一段丢失了，也就没办法做超时重传，也没办法确定顺序，如果TCP对报文分段，每段都有TCP报文头，报文丢失就知道丢失的是哪一个。</p>
<h1 id="为什么IP数据长度过长要分片？"><a href="#为什么IP数据长度过长要分片？" class="headerlink" title="为什么IP数据长度过长要分片？"></a>为什么IP数据长度过长要分片？</h1><p>IP分组达到数据链路层，整个IP分组被作为数据链路层以太网帧的数据部分。</p>
<p>以太网帧对数据部分有最大长度的限制，所以IP数据数据过长要分片。</p>
<p>数据链路层的以太网帧的数据部分的最大长度（最大IP包长）称为最大传输单元（Maximum Transmit Unit）</p>
<p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p>
<h1 id="TCP拆分数据的意义？"><a href="#TCP拆分数据的意义？" class="headerlink" title="TCP拆分数据的意义？"></a>TCP拆分数据的意义？</h1><p>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</p>
<h1 id="最大传输单元（Maximum-Transmit-Unit）是什么？"><a href="#最大传输单元（Maximum-Transmit-Unit）是什么？" class="headerlink" title="最大传输单元（Maximum Transmit Unit）是什么？"></a>最大传输单元（Maximum Transmit Unit）是什么？</h1><p>数据链路层的以太网帧的数据部分的最大长度（IP包长）</p>
<h1 id="为什么以太网MTU默认值被设定为1500？"><a href="#为什么以太网MTU默认值被设定为1500？" class="headerlink" title="为什么以太网MTU默认值被设定为1500？"></a>为什么以太网MTU默认值被设定为1500？</h1><p>MTU为什么不能太大呢？</p>
<p>以太网早期的拓扑结构是总线型结构，总线型传输有个特点就是，同一时刻只能有一个主机占用总线传输，如果一个以太网帧过长，这个主机就会一直占用总线，其他主机只能干等着，对于其他主机来说数据延迟就变大了。</p>
<p>而且传输的数据包越大，数据位出错的可能性越大，出错了就要重传，重传又要占用很长时间的带宽，降低了整体吞吐量。</p>
<p>所以MTU不能太大。</p>
<p>如果MTU太小，各种协议头也要占用数据包大小的，这样每个报文的实际有效传输效率也会很低。</p>
<p>所以MTU要搞一个适中值。</p>
<p>1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致丢包无法发送。</p>
<h1 id="为什么MTU最小为64字节？"><a href="#为什么MTU最小为64字节？" class="headerlink" title="为什么MTU最小为64字节？"></a>为什么MTU最小为64字节？</h1><p>以CSMA/CD作为MAC<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure">算法</a>的一类LAN称为以太网。CSMA/CD冲突避免的方法：先听后发、边听边发、随机延迟后重发。一旦发生冲突，必须让每台主机都能检测到。关于最小发送间隙和最小帧长的规定也是为了避免冲突。</p>
<p>考虑如下的情况，主机发送的帧很小，而两台冲突主机相距很远。在主机A发送的帧传输到B的前一刻，B开始发送帧。这样，当A的帧到达B时，B检测到冲突，于是发送冲突信号。假如在B的冲突信号传输到A之前，A的帧已经发送完毕，那么A将检测不到冲突而误认为已发送成功。由于信号传播是有时延的，因此检测冲突也需要一定的时间。这也是为什么必须有个最小帧长的限制。</p>
<p>按照标准，10Mbps以太网采用中继器时，连接的最大长度是2500米，最多经过4个中继器，因此规定对10Mbps以太网一帧的最小发送时间为51.2微秒。这段时间所能传输的数据为512位，因此也称该时间为512位时。这个时间定义为以太网时隙，或冲突时槽。512位＝64字节，这就是以太网帧最小64字节的原因。</p>
<p>512位时是主机捕获信道的时间。如果某主机发送一个帧的64字节仍无冲突，以后也就不会再发生冲突了，称此主机捕获了信道。</p>
<p>由于信道是所有主机共享的，如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的最大帧长为1500。</p>
<p>100Mbps以太网的时隙仍为512位时，以太网规定一帧的最小发送时间必须为5.12μs。</p>
<p>1000Mbps以太网的时隙增至512字节，即4096位时，4.096μs。</p>
<p>以太网数据帧（802.3）最大与最小长度。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）是怎么确定的？"><a href="#最大报文长度（Maximum-Segment-Size）是怎么确定的？" class="headerlink" title="最大报文长度（Maximum Segment Size）是怎么确定的？"></a>最大报文长度（Maximum Segment Size）是怎么确定的？</h1><p>MSS由设备的MTU确定，不能超过MTU，否则TCP报文会被IP层分片  </p>
<h1 id="TCP报文的长度在TCP三次握手中那一次确定的？"><a href="#TCP报文的长度在TCP三次握手中那一次确定的？" class="headerlink" title="TCP报文的长度在TCP三次握手中那一次确定的？"></a>TCP报文的长度在TCP三次握手中那一次确定的？</h1><p>MSS值只会出现在SYN报文中（不要问我为什么，我也不知道为什么只出现SYN报文中），即SYN=1时，才会有MSS字段值。</p>
<p>当客户端想要以TCP方式从服务器端下载数据时，</p>
<p>（1）首先客户端会发送一个SYN请求报文，这个SYN报文的“选项”字段中会有MSS值（MSS = MTU - IP首部长度 - TCP首部长度）。该MSS值是为了告知对方最大的发送数据大小。</p>
<p>（2）当服务器端收到SYN报文后，会向请求端返回SYN+ACK（同步确认报文）报文，其中的“选项”字段也会有MSS值。</p>
<p>（3）通信双方选择SYN和SYN+ACK报文中最小的MSS最为此次TCP连接的MSS，从而达到通信双发协商MSS的效果。</p>
<p>在第二次握手后就可以确定TCP中最大传输报文（MSS）大小。</p>
<h1 id="MTU是怎么确定的？"><a href="#MTU是怎么确定的？" class="headerlink" title="MTU是怎么确定的？"></a>MTU是怎么确定的？</h1><p>每一个物理设备都有自己的 MTU，最终的MTU由整个链路上 MTU 最小的物理设备决定。</p>
<p>路径MTU发现（PMTUD： Path MTU Discovery ）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP拥塞控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-13 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-13T19:31:00+08:00">2018-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP拥塞控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么情况下才算发生了网络拥塞？"><a href="#什么情况下才算发生了网络拥塞？" class="headerlink" title="什么情况下才算发生了网络拥塞？"></a>什么情况下才算发生了网络拥塞？</h1><p>发送方有TCP报文超时了没有收到ACK确认报文</p>
<h1 id="拥塞控制的过程是怎样的？"><a href="#拥塞控制的过程是怎样的？" class="headerlink" title="拥塞控制的过程是怎样的？"></a>拥塞控制的过程是怎样的？</h1><p>慢启动、拥塞避免、快重传、快恢复</p>
<p>拥塞窗口，拥塞窗口大小cwnd（congestion window）表示可以发送的报文字节数，单位是一个MSS（最大报文长度）</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>拥塞窗口初始大小为1，每收到一个ACK，拥塞窗口大小+1，实际效果就是每过一个RTT，拥塞窗口大小为原来的2倍，以指数增长率增长，先慢后快，达到慢开始门限ssthresh则停止慢开始，执行拥塞避免算法。</p>
<p>翻倍后如果大小超过阈值则窗口大小设为阈值。</p>
<p>例如：</p>
<p>初始窗口大小为1</p>
<p>发送第一个报文M0，收到ACK1后窗口大小+1，变为2</p>
<p>发送M1、M2，收到ACK2、ACK3后，窗口大小+2，变为4</p>
<p>再发送4个报文，收到4个ACK后，窗口大小+4，变为8</p>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>每过一个RTT（受到一个ACK），拥塞窗口大小+1</p>
<p>线性增长，避免增长过快</p>
<h2 id="发生拥塞"><a href="#发生拥塞" class="headerlink" title="发生拥塞"></a>发生拥塞</h2><p>发送方有报文超时，未收到ACK确认报文</p>
<p>无论是在慢开始阶段还是拥塞避免阶段，做出以下调整：</p>
<ol>
<li>把慢开始门限ssthresh设置为出现拥塞时发送方拥塞窗口大小的一半（不小于2）</li>
<li>拥塞窗口大小设为1，执行慢开始</li>
</ol>
<p>目的：</p>
<p>迅速减少发送方发送到网络的报文数，在发生拥塞时路由器有足够的时间把队列中挤压的报文发完</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825255523.jpeg"></p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，则不等待定时器结束就直接重传该序号的报文</p>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，慢开始门限设置为拥塞窗口大小的一半，拥塞窗口不设置为1，也设置为原窗口大小的一半，并执行拥塞避免算法，线性增大拥塞窗口。</p>
<p>因为跳过了拥塞窗口从1开始的慢开始过程，所以称为快恢复。</p>
<p>发送方窗口大小为  流量控制的滑动窗口和拥塞窗口  的较小值</p>
<h1 id="快速重传有什么问题？"><a href="#快速重传有什么问题？" class="headerlink" title="快速重传有什么问题？"></a>快速重传有什么问题？</h1><p>与基于定时器的超时重传拥有同样的问题，即：</p>
<p>不确定应该重发哪些序号的报文，如果只重发一个可能会拖慢整体传输时长，如果重发多个可能会浪费流量、增加整体传输时长，需要知道哪些序号的报文是丢失的，只重发丢失的报文。  </p>
<p>发送方收到同一个序号的多个ACK确认，发送方并不清楚这些ACK是由哪些序号的报文传输成功后ACK回来的，可能会重发接收方已经收到的报文，浪费流量。</p>
<h1 id="带选择确认的重传（SACK）解决了什么？"><a href="#带选择确认的重传（SACK）解决了什么？" class="headerlink" title="带选择确认的重传（SACK）解决了什么？"></a>带选择确认的重传（SACK）解决了什么？</h1><p>一端在发送ACK时通过在TCP报文头部增加SACK（Selective Acknowledgment）选项，告知对方已经收到的包序号区间范围，让对方只重传丢失的报文，并且可以一次性集中重传，避免了网络流量的浪费，也避免了长时间的超时等待。</p>
<p>SACK需要客户端和服务的都开启该功能</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP流量控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-12 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-12T19:31:00+08:00">2018-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP流量控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么要有流量控制？"><a href="#为什么要有流量控制？" class="headerlink" title="为什么要有流量控制？"></a>为什么要有流量控制？</h1><p>双端通信的时候，发送方发送数据速度和接收方处理数据速度不一定相等；</p>
<p>如果发送过快，接收方处理不过来，接收方只能把数据存在缓冲区，缓冲区满了后再收到数据就只能丢弃；</p>
<p>所以需要控制发送方发送数据的速率，让接收方与发送方处于一种动态的平衡中才好。</p>
<p>对于发送方发送速率的控制，称为流量控制。</p>
<h1 id="滑动窗口大小是如何确定的？"><a href="#滑动窗口大小是如何确定的？" class="headerlink" title="滑动窗口大小是如何确定的？"></a>滑动窗口大小是如何确定的？</h1><p>发送数据的一方收到对方发送的ACK报文，其报文头中的窗口大小表示对方的缓冲区大小还能存放多少字节的数据，发送方拿这个窗口大小与本身的拥塞窗口大小在一起取最小值，作为自己滑动窗口的大小。</p>
<p>达到：</p>
<ol>
<li>避免对方缓冲区存不下发送过多的数据而丢弃，进而浪费网络带宽和流量</li>
<li>避免产生网络拥塞</li>
</ol>
<h1 id="滑动窗口中的内容"><a href="#滑动窗口中的内容" class="headerlink" title="滑动窗口中的内容"></a>滑动窗口中的内容</h1><p>滑动窗口内包含两类报文</p>
<ol>
<li>已发送但未收到确认</li>
<li> 允许发送但尚未发送</li>
</ol>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180835235523.jpeg"></p>
<h1 id="滑动窗口什么时候开始滑动？"><a href="#滑动窗口什么时候开始滑动？" class="headerlink" title="滑动窗口什么时候开始滑动？"></a>滑动窗口什么时候开始滑动？</h1><p>窗口左侧的报文收到了ACK报文确认，窗口就往右滑动</p>
<h1 id="如果发送端滑动窗口大小为0，不发送数据了会怎样？"><a href="#如果发送端滑动窗口大小为0，不发送数据了会怎样？" class="headerlink" title="如果发送端滑动窗口大小为0，不发送数据了会怎样？"></a>如果发送端滑动窗口大小为0，不发送数据了会怎样？</h1><p>实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅包含一个字节来获取最新的窗口大小信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/" class="post-title-link" itemprop="url">TCP超时重传</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-11 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-11T19:31:00+08:00">2018-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP超时重传/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="超时重传的等待时间设置为多少合适？"><a href="#超时重传的等待时间设置为多少合适？" class="headerlink" title="超时重传的等待时间设置为多少合适？"></a>超时重传的等待时间设置为多少合适？</h1><p>超时重传的等待时间：Retransmission Time Out, RTO。</p>
<p>等待时间过长，若丢包严重，则传输的吞吐量低。</p>
<p>等待时间过短，会导致频繁的发包，增加网络拥堵，占用带宽。</p>
<p>等待时间只能尽可能的短，按照正常的节奏，一端发送报文到收到ACK报文的时间（往返时间Round Trip Time）就是最短的等待时间，RTO可以略微大于RTT，以增加一点容错范围。</p>
<p>但RTT并不是固定的，因为网络拥堵状况随时在发生变化，所以RTT应当不停的动态计算，有一系列的算法支持。</p>
<h1 id="基于定时器的超时重传存在什么问题？"><a href="#基于定时器的超时重传存在什么问题？" class="headerlink" title="基于定时器的超时重传存在什么问题？"></a>基于定时器的超时重传存在什么问题？</h1><p>会重发接收方已经收到的报文，浪费带宽，通信时间被拖长。</p>
<p>接收方发送的ACK报文中确认的报文序号有个特点，就是这个序号之前的报文接收方一定都已经收到了。</p>
<p>这样就会导致一个问题，如果发送方发了一系列序号连续的报文，接收方只有中间的几个报文没有收到，那么收到序号较大的报文后回应的ACK里的确认序号是较小的，这会导致发送方无法确认较大序号的报文接收方有没有收到。</p>
<p>此时发送方该重发哪些报文就成了问题，此时有两种策略：</p>
<p>一种策略是只重传ACK期待的序号的报文，序号较大报文暂时不重发，等待它们的定时器超时了再重发，如果较大序号的报文接收方都接受到了倒没问题，但如果较大序号的报文接收方都没收到，一个个等待报文超时无疑是拖慢了整体的传输时间。</p>
<p>另一种策略就是重传ACK序号后所有的报文，如果丢包严重，这种做法效率挺高，但如果丢包并不严重，这种做法会浪费很多流量。</p>
<p>如果能知道没有收到的报文序号是哪些就很好办了，用SACK可以解决这个问题。</p>
<p>例如发送方发了序号为1、2、3、4、5、6的报文，接收方收到了1、2、4、5、6，唯独为没有收到3（3可能卡在某个网络节点上），在接收到1后回应ACK 2，接收2后回应ACK 3，接收到4、5、6，也是回应ACK 3，此时发送方对3、4、5、6的定时器都会超时，然后都会重发3、4、5、6，但实际4、5、6已经接收到了，重发4、5、6其实是浪费带宽，也增加了整体传输时长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/" class="post-title-link" itemprop="url">TCP报文编号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-10 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-10T19:31:00+08:00">2018-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP报文编号/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP为什么要给报文编号？不编号会有什么问题？"><a href="#TCP为什么要给报文编号？不编号会有什么问题？" class="headerlink" title="TCP为什么要给报文编号？不编号会有什么问题？"></a>TCP为什么要给报文编号？不编号会有什么问题？</h1><p>保证报文的不重复、不丢失、不乱序。</p>
<p>作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。</p>
<h1 id="为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？"><a href="#为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？" class="headerlink" title="为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？"></a>为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？</h1><p>TCP把数据视为一个无结构但有序的字节流，序号建立在传输的字节流之上，而不建立在报文段之上。</p>
<p>接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p>因为TCP有窗口拥塞控制，窗口的拥塞是基于字节的，所以必须给字节编号，如果给数据包编号，拥塞窗口无法调节大小。</p>
<h1 id="TCP三次握手中的初始序号是固定的吗？"><a href="#TCP三次握手中的初始序号是固定的吗？" class="headerlink" title="TCP三次握手中的初始序号是固定的吗？"></a>TCP三次握手中的初始序号是固定的吗？</h1><p>不是固定的，是动态增长+随机选取，可以避免相邻的TCP会话的序列号有重叠，否则并不知道报文是旧连接的还是新连接的</p>
<p>如果初始序号是固定的，攻击者就可以很容易伪造TCP报文发起攻击，初始序号需要动态生成，提高攻击成本。</p>
<p>源IP地址、源端口、目标IP地址、目标端口唯一确定一个TCP会话，允许刚释放的TCP端口重用，如果旧会话中的分组报文仍然在网络中，新会话建立后可能会收到旧会话产生的分组报文，如果序号是一直递增的，就可以分辨出报文是属于旧会话的还是新会话的。</p>
<p>关于ISN的初始化。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p>
<h1 id="报文编号和确认应答机制存在什么问题？"><a href="#报文编号和确认应答机制存在什么问题？" class="headerlink" title="报文编号和确认应答机制存在什么问题？"></a>报文编号和确认应答机制存在什么问题？</h1><p>队头阻塞。</p>
<p>TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-09 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-09T19:31:00+08:00">2018-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP四次挥手/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP断开连接为什么要四次挥手？为什么不能三次挥手？"><a href="#TCP断开连接为什么要四次挥手？为什么不能三次挥手？" class="headerlink" title="TCP断开连接为什么要四次挥手？为什么不能三次挥手？"></a>TCP断开连接为什么要四次挥手？为什么不能三次挥手？</h1><p>因为服务端接收到客户端断开连接的请求报文时，服务端可能还有数据要发送，要等待服务端把数据发送完了，才能向客户端发起断开连接的请求，此时服务端只能先回复客户端一个ACK报文，告知客户端我已经收到了断开连接的请求，你可以不用重复发送断开连接的请求了，等我把数据发完再通知你我可以断开连接。服务端的ACK和FIN指令必须分开发送，所以需要四次挥手，而不能三次。</p>
<h1 id="TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME-WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？"><a href="#TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME-WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？" class="headerlink" title="TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME_WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？"></a>TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME_WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？</h1><ol>
<li>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</li>
<li>保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；</li>
</ol>
<h2 id="阻止延迟报文"><a href="#阻止延迟报文" class="headerlink" title="阻止延迟报文"></a>阻止延迟报文</h2><p>TCP断开连接时，如果客户端在接收到服务端的FIN自己发送完ACK后直接关闭连接，服务端可能没有收到ACK，会超时重传FIN，此时由于客户端已经关闭了连接，如果客户端有新的程序需要向该服务端的同一个端口传输数据，会重新建立TCP连接，并且这个新TCP连接无法和上一个关闭的TCP连接区分开来，因为源IP地址、源端口、目标IP地址、目标端口都一样，此时新连接传输数据过程中如果收到上次连接的传来的FIN，新连接的状态就异常了，新连接SYN握手会失败，服务端会发送RST阻止客户端连接的建立，因为旧的连接并没有关闭。。也有可能会收到其他服务端发送的报文。</p>
<h2 id="保证连接关闭"><a href="#保证连接关闭" class="headerlink" title="保证连接关闭"></a>保证连接关闭</h2><p>服务端发送FIN报文后，如果没有接收到ACK会超时重传FIN，直到收到ACK了才会关闭连接。服务端要等待什么时候超时重传呢？服务端发送FIN后，最多经过一个MSL到达客户端，客户端发送ACK最多经过一个MSL到达服务端，所以服务端等待2MSL没有收到ACK就重发FIN报文，FIN报文最多经过一个MSL到达客户端，所以从客户端发送ACK给服务端要至少等待2MSL，以取保服务端收到了自己发送的ACK，不会超时重传FIN</p>
<h1 id="为什么TIME-WAIT要等待2MSL？"><a href="#为什么TIME-WAIT要等待2MSL？" class="headerlink" title="为什么TIME_WAIT要等待2MSL？"></a>为什么TIME_WAIT要等待2MSL？</h1><p>MSL（Maximum Segment Lifetime，最大报文生存时间）是指任何报文在网络上存在的最长时间，超过这个时间的报文都会被丢弃。</p>
<p>网络中可能存在来自发送方的报文，接收方收到后需要回ACK，一来一回两个MSL，等待两个MSL可以确保网络中一定不存在报文。</p>
<p>服务端发送FIN后，会计时等待接受ACK，等待的时间大约是一个RTT多一点的时间，也就是2MSL左右，如果FIN没丢失，客户端发送ACK，发送ACK时服务端已经等待了一个MSL左右，如果ACK丢失了，服务端再等待一个MSL，超时未收到ACK，则会重传FIN，FIN再次到达客户端也需要一个MSL左右，这样客户端至少得等待2MSL，以让服务端重传的FIN达到，如果2MSL后没有收到服务端的FIN，说明服务端已经接收到ACK了，服务端已经关闭连接，同时网络也不可能有此次连接的任何报文了，客户端就可以安全的关闭连接。</p>
<h1 id="进入TIME-WAIT有什么问题？"><a href="#进入TIME-WAIT有什么问题？" class="headerlink" title="进入TIME_WAIT有什么问题？"></a>进入TIME_WAIT有什么问题？</h1><p>大并发量的短时间传输的连接，会造成连接等待时间变长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">句柄、直接指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 20:00:00" itemprop="dateCreated datePublished" datetime="2018-03-08T20:00:00+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/句柄、直接指针/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄是什么？"><a href="#句柄是什么？" class="headerlink" title="句柄是什么？"></a>句柄是什么？</h1><p>指针的指针。</p>
<p>jvm中内存里的对象都有一个指针指向对象的开始地址，句柄就是指向对象的指针。</p>
<h1 id="句柄解决了什么问题"><a href="#句柄解决了什么问题" class="headerlink" title="句柄解决了什么问题?"></a>句柄解决了什么问题?</h1><p>对实际的对象资源做了一层代理，屏蔽细节，避免了直接操控资源可能的危险。</p>
<p>弄了句柄，对象实际位置在内存中可以随意变化，比如标记整理垃圾回收后对象被移动到其他地方。</p>
<p>虚拟内存机制，可能会将已经载入内存的数据换到外存硬盘上，这样对象的地址就会变动，其他地方引用这块被换走的地址也要更新，如果使用这块数据的地方引用的是句柄，这样实际数据在内存的位置可以随意变化，使用数据的地方还是引用固定的地址，不用更新。</p>
<p>Windows系统中有许多内核对象（这里的对象不完全等价于”面向对象程序设计”一词中的”对象”，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个”对象”的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p>
<ol>
<li><p>暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p>
</li>
<li><p>操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p>
</li>
</ol>
<p>所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p>
<p>在Windows系统中，这个编号就叫做”句柄”。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/klb561/p/10555571.html">句柄的概念</a></p>
<h1 id="为什么叫句柄这个名字？"><a href="#为什么叫句柄这个名字？" class="headerlink" title="为什么叫句柄这个名字？"></a>为什么叫句柄这个名字？</h1><p>从名字上说，handle是指中间媒介，例如门把手是door handle，刀柄是knife handle。</p>
<p>所以文件句柄file handle以即其他资源句柄，也是这个中间媒介的意思，通过这个媒介操作资源。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27656256/answer/943130123">句柄是什么？ - 黄兢成的回答 - 知乎 解释句柄这个词语的表面含义</a></li>
</ul>
<h1 id="JVM对象访问定位"><a href="#JVM对象访问定位" class="headerlink" title="JVM对象访问定位"></a>JVM对象访问定位</h1><p>JVM通过栈上的reference类型数据来操作堆上的具体对象。</p>
<p>由于reference数据只是规定了一个指向对象的引用，没有定义如何去定位访问对象的具体位置。</p>
<p>主流的实现方式有两种：</p>
<ul>
<li>句柄<br>  在堆中划分句柄池，reference存储对象的句柄地址，句柄包含对象实例数据和类型数据的各自具体地址信息。<ul>
<li>好处：reference中的数据是稳定的句柄地址 对象被移动只会改变句柄中的信息 不会改变句柄的地址 reference不需要变化。</li>
<li>坏处：增加了指针定位的开销。</li>
</ul>
</li>
<li>直接指针<br>  栈上reference类型数据槽中直接存储堆对象的地址。<ul>
<li>好处：直接访问对象 减少指针定位开销。</li>
<li>坏处：当对象内存地址发生变化 reference中数据也需要调整。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》 2.3.3 对象的访问定位 48页</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="post-title-link" itemprop="url">TCP三次握手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-08T19:31:00+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP三次握手/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP为什么要三次握手？为什么不能两次握手或四次握手？"><a href="#TCP为什么要三次握手？为什么不能两次握手或四次握手？" class="headerlink" title="TCP为什么要三次握手？为什么不能两次握手或四次握手？"></a>TCP为什么要三次握手？为什么不能两次握手或四次握手？</h1><ol>
<li>三次握手是确认客户端和服务端的发送和接受报文的能力是否正常。</li>
<li>如果是两次握手，服务端受到客户端的历史SYN报文就建立连接，会空耗服务端资源。</li>
<li>确认双方发送数据的初始序号，因为都要给对方发送确认报文，表达已知悉。</li>
</ol>
<p>三次握手是确认客户端和服务端的发送和接受报文的能力是否正常。三次握手足够判断这一点了，四次握手其实多余了，没有必要浪费时间去发送没有意义的报文。</p>
<p>如果不加确认，进行两次握手，服务端收到客户端的SYN报文就直接建立连接，有可能客户端的SYN报文发生了网络拥堵，客户端进行了超时重传，随后拥堵的报文又成功传到了服务端，服务端判断不了这是新的连接请求报文还是历史连接报文，如果服务端收到SYN报文直接建立连接，接受到了客户端历史的SYN报文，会发生空等待，消耗服务端的资源。</p>
<h1 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h1><ol>
<li>客户端发送SYN报文，告知对方初始序号，是否会告知窗口大小</li>
<li>服务端收到后，回应SYN+ACK报文，告知对方初始序号</li>
<li>客户端收到后，回应ACK报文，客户端建立连接，服务端收到ACK后建立连接</li>
</ol>
<p>RFC 793 - Transmission Control Protocol 其实就指出了 TCP 连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
<p>如果是两次握手，正常流程就是，客户端发送SYN，服务端接收到SYN开始建立连接，并发送ACK给客户端，客户端收到ACK开始建立连接。</p>
<p>客户端发送SYN后，可能发生拥堵，然后客户端超时重传SYN，接下来按照正常流程建立连接，然后过了一会服务端又收到了之前拥堵发过来的SYN，并不能确定它历史的连接还是新的连接，如果此时建立新连接就会一直等待客户端发送数据，而这只是一条历史的连接报文，客户端不会发送数据，服务端就会空等，浪费了资源。</p>
<p>如果是三次握手，服务端接收到SYN后，会发送SYN+ACK给客户端，由客户端来判断是否是历史连接，如果序号过期，则认为是历史连接，向服务端发送RST取消连接的建立。服务端是没办法判断客户端的序号是否过期。</p>
<p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>
<ul>
<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>
<li>『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>
</ul>
<h1 id="TCP三次握手中，服务端发送了SYN-ACK后，一直没有收到客户端的ACK会怎样？"><a href="#TCP三次握手中，服务端发送了SYN-ACK后，一直没有收到客户端的ACK会怎样？" class="headerlink" title="TCP三次握手中，服务端发送了SYN+ACK后，一直没有收到客户端的ACK会怎样？"></a>TCP三次握手中，服务端发送了SYN+ACK后，一直没有收到客户端的ACK会怎样？</h1><p>server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p>
<h1 id="TCP为什么要先建立连接才能传输数据？"><a href="#TCP为什么要先建立连接才能传输数据？" class="headerlink" title="TCP为什么要先建立连接才能传输数据？"></a>TCP为什么要先建立连接才能传输数据？</h1><p>因为如果不确定对方能够正常的接受和发送数据，一方单方面发送数据就是无意义的资源浪费。</p>
<h1 id="TCP建立连接时做了什么事？"><a href="#TCP建立连接时做了什么事？" class="headerlink" title="TCP建立连接时做了什么事？"></a>TCP建立连接时做了什么事？</h1><ol>
<li>确认双方的发送能力、接受能力是否正常</li>
<li>确定双方发送报文的初始编号</li>
<li>确定窗口大小</li>
<li>确定MSS-最大传输包大小</li>
<li>确定是否使用SACK</li>
</ol>
<h1 id="TCP什么时候可以传输数据？"><a href="#TCP什么时候可以传输数据？" class="headerlink" title="TCP什么时候可以传输数据？"></a>TCP什么时候可以传输数据？</h1><p>第三次握手客户端就可以携带数据了，因为受到服务端的SYN+ACK报文，确认了服务端的接受能力和发送能力是正常的</p>
<h1 id="TCP建立连接时的SYN指令是做什么的？"><a href="#TCP建立连接时的SYN指令是做什么的？" class="headerlink" title="TCP建立连接时的SYN指令是做什么的？"></a>TCP建立连接时的SYN指令是做什么的？</h1><p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p>
<h1 id="什么是SYN攻击？"><a href="#什么是SYN攻击？" class="headerlink" title="什么是SYN攻击？"></a>什么是SYN攻击？</h1><p>客户端发送SYN报文后，服务端会进入SYN_RCVD状态，但服务端发送出去的SYN+ACK报文没有应答，SYN报文发送多了后，会占满服务端的半连接队列</p>
<h1 id="RST消息是什么时候发送？"><a href="#RST消息是什么时候发送？" class="headerlink" title="RST消息是什么时候发送？"></a>RST消息是什么时候发送？</h1><p>建立连接出现错误就会发送RST报文关闭连接</p>
<p>1、端口未打开</p>
<p>2、请求超时</p>
<p>3、提前关闭</p>
<p>4、在一个已关闭的socket上收到数据</p>
<p>5、用于拒绝一个非法连接</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/" class="post-title-link" itemprop="url">Java静态分派、动态分派</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-07 20:00:00" itemprop="dateCreated datePublished" datetime="2018-03-07T20:00:00+08:00">2018-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/Java静态分派、动态分派/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>静态类型：变量被声明时的类型；例如，Animal a = new Dog(), 静态类型为Animal, 实际类型为Dog</p>
<p>实际类型：变量所引用的对象的真实类型</p>
<p>重载方法是静态分派，即编译时多态</p>
<p>重写方法是动态分派，即运行时多态</p>
<h1 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h1><p>方法的接收者：一个方法所属的对象</p>
<p>宗量：方法的接收者和方法的参数，只有这两种宗量</p>
<p>单分派：根据一个宗量进行对方法的选择</p>
<p>多分派：根据多于一个的宗量对方法进行选择</p>
<p>单分派和多分派取决于宗量,  方法调用者和方法参数都是宗量.</p>
<p>静态分派的方法调用：首先确定调用者的静态类型是什么,然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个, 需要根据这两个宗量来编译, 所以是静态多分派(多个宗量确定).</p>
<p>动态分派的方法调用：在运行期间,虚拟机会根据调用者的实际类型调用对应的方法, 只需根据这一个宗量就可以确定要调用的方法,所以是动态单分派(一个宗量)</p>
<p>到目前为止，Java 语言还是一门 “静态多分派、动态单分派” 的语言，也就是说在执行静态分派时是根据多个宗量判断调用哪个方法的，因为在静态分派时要根据不同的静态类型和不同的方法描述符选择目标方法，在动态分派的时候，是根据单宗量选择目标方法的，因为在运行期，方法的描述符已经确定好，invokevirtual 字节码指令根据变量的实际类型选择目标方法。</p>
<p>方法的描述符：方法参数类型+返回值类型</p>
<h1 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">classStaticDispatch &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Humanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Manguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,man&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Womanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,woman&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123; </span><br><span class="line">        Humanman=newMan(); </span><br><span class="line">        Humanwoman=newWoman(); </span><br><span class="line">        StaticDispatchdispatch=newStaticDispatch(); </span><br><span class="line">        dispatch.sayHello(man); </span><br><span class="line">        dispatch.sayHello(woman); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>静态类型：是指对象 man 的 Human 类型， 静态类型本身是不会发送变化的，只有在使用时才会发送变化，静态类型在编译期间就可以确定一个变量的静态类型 </p>
<p>实际类型：是指对象 man 的 Man 类型，实际类型在编译期间是不可确定的，只有在运行期才可确定 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化 </span></span><br><span class="line">Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">man = <span class="keyword">new</span> Woman(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态类型变化 </span></span><br><span class="line">dispatch.sayHello((Man) man); </span><br><span class="line">dispatch.sayHello((Woman) man); </span><br></pre></td></tr></table></figure>

<p>所以第一段代码中，方法接收者是 StaticDispatch 对象，虽然两个变量的实际类型不同，但是静态类型是相同的都是 Human，虚拟机（准确的说是编译器）在实现重载时是通过参数的静态类型而不是实际类型做出判定的，并且在编译阶段，变量的静态类型是可以确定的，所以编译器会根据变量的静态类型决定使用哪个重载方法。 </p>
<p>所有依赖静态类型定位目标方法的分派动作称为静态分派，静态分派典型的应用就是方法的重载。静态分派发生在编译阶段，所以方法的静态分派动作是由编译器执行的。 </p>
<h1 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, man&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, woman&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/picportal/pic/raw/master/img/20200325235523.png"></p>
<p>从上图中，我们可以看到 main() 方法的字节码指令执行过程：</p>
<ul>
<li>0 ~ 7 句是调用 Man 类的实例构造器创建一个 Man 类的对象，并将对象的引用压入到局部变量表的第 1 个 Slot 中</li>
<li>8 ~ 15 句是调用 Woman 类的实例构造器创建一个 Woman 类的对象，并将对象的引用压入到局部变量表的第 2 个 Slot 中</li>
<li>16 ~ 17 句是将第 1 个 Slot 中的变量（也就是 man）加载到局部变量表中，并调用 sayHello() 方法，关键的就是第 17 句指令 invokevirtual</li>
</ul>
<p>虽然第 17 句指令调用的常量池中的 Human.sayHello() 方法，但是最终执行的却是 Man.sayHello() 方法，这就要从 invokevirtual 指令的多态查找说起，invokevirtual 的查找过程如下所示：</p>
<ul>
<li>找到操作数栈顶的引用所指的对象的实际类型，记做 C</li>
<li>在类型 C 中查找与常量中的描述符和简单名称相同的方法，如果找到则进行访问权限的判断，如果通过则返回这个方法的直接引用，查找结束；如果权限不通过，则返回 java.lang.IllegalAccessError 的异常</li>
<li>如果在 C 中没有找到描述符和简单名称都符合的方法，则按照继承关系从下往上依次在 C 的父类中进行查找和验证过程</li>
<li>如果最终还是没有找到该方法，则抛出 java.lang.AbstractMethodError 的异常</li>
</ul>
<p>在上述 invokespecial 查找方法的过程中，最重要的就是第一步，根据对象的引用确定对象的实际类型，这个方法重写的本质。如上所述，在运行期内，根据对象的实际类型确定方法执行版本的分派过程叫做动态分派。</p>
<h1 id="如何理解Java是静态多分派、动态单分派？"><a href="#如何理解Java是静态多分派、动态单分派？" class="headerlink" title="如何理解Java是静态多分派、动态单分派？"></a>如何理解Java是静态多分派、动态单分派？</h1><p>编译时期确定方法有两点依据：</p>
<ol>
<li>调用方法的静态类型</li>
<li>方法的参数</li>
</ol>
<p>所以说是静态多分派。</p>
<p>运行时期再确定方法只有一点依据,就是调用方法的实际类型,所以说是动态单分派。</p>
<p>所以最后实际的方法调用是编译和运行的结合,即调用方法的实际类型和参数(运行时期直接引用会根据调用方法的实际类型确定,编译时期调用方法的静态类型只不过是虚引用),按书上说法,在编译时期,方法名和参数就被确定了,运行时只需要确定调用者即可;所以方法选择上,编译时期缩小了范围,运行时期确定了具体的方法。</p>
<p>对于静态分派（重载），肯定会依赖接收者的静态类型与参数的静态类型（参数肯定存在，同名无参的方法只会有一个，不存在分派）。</p>
<p>对于动态分派（重写），虚拟机只会根据接收者的实际类型选择，而不会理睬参数的实际类型。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li>深入理解Java虚拟机（第2版）  第8章  虚拟机字节码执行引擎 8.3.2 分派</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎（读书笔记）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28462483/answer/398040520">如何理解java是一门静态多分派且动态单分派的语言？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="post-title-link" itemprop="url">TCP如何保证可靠性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-07 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-07T19:31:00+08:00">2018-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 12:55:32" itemprop="dateModified" datetime="2021-08-31T12:55:32+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP如何保证可靠性/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP是什么？"><a href="#TCP是什么？" class="headerlink" title="TCP是什么？"></a>TCP是什么？</h1><p>面向连接、保证可靠性传输、基于字节流的传输层通信协议</p>
<h1 id="TCP协议解决的是什么问题？"><a href="#TCP协议解决的是什么问题？" class="headerlink" title="TCP协议解决的是什么问题？"></a>TCP协议解决的是什么问题？</h1><p>保证端到端数据传输的可靠性</p>
<h1 id="TCP如何保证可靠性？"><a href="#TCP如何保证可靠性？" class="headerlink" title="TCP如何保证可靠性？"></a>TCP如何保证可靠性？</h1><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制： 当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>建立连接三次握手，客户端SYN、服务端SYN+ACK、客户端ACK。</p>
<p>断开连接四次握手，客户端FIN、服务端ACK、服务端FIN+ACK、客户端ACK。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>IP报文头的校验和只校验IP首部，TCP报文头的校验和校验的是首部和数据。</p>
<p>tcp报文头部有校验和，发送方生成校验和，接收方检验校验和，传输过程检验到报文有差错直接丢弃。</p>
<h2 id="报文编号"><a href="#报文编号" class="headerlink" title="报文编号"></a>报文编号</h2><ol>
<li>检测丢失：接收方可以知道少了哪些数据。</li>
<li>检测乱序：发送方的报文可能因为网络拥堵乱序到达接收方，接收方可以按照序号重新排序拼接报文，再转交完整的数据给应用层。</li>
<li>检测重复：接收方可以根据编号丢弃已经收到的报文，因为同一个编号的报文可能会因为超时重传机制多次发送。</li>
</ol>
<h2 id="确认应答"><a href="#确认应答" class="headerlink" title="确认应答"></a>确认应答</h2><p>每次接收方收到数据后，会回应ACK确认应答报文给发送方，发送方就知道了这个包没有丢失，而是已经传输成功了。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>每个报文发送后都会开启一个定时器，超时前收到该编号报文确认应答的报文时则取消计时，如果不能及时收到确认则会重新发送这个报文。</p>
<p>超时重传有两种情况，一种是发送的报文未达到接收方，一种是接收方发送的ACK确认报文未达到发送方；前者的情况在接收方收到报文后会正常的发送ACK报文；后者的情况会丢弃编号重复的报文直接发送ACK确认报文。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>如果发送方发生数据过快，接收方来不及处理，接受方只能丢弃数据，这样浪费了流量，增加了不必要的消耗，接收方要告诉发送方自己能接受处理数据的最大数据量是多少，别多发不能处理的数据。</p>
<p>是通过ACK报文头中的窗口大小字段来告知对方自己还能接受多少数据，要发送数据的一方的发送窗口大小就是这个ACK报文头中的窗口大小与拥塞窗口大小的较小值</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制是假设网络不拥堵，只考虑两端数据处理能力，但是整个网络如果发生拥堵，还需另外的处理，即拥塞控制。</p>
<p>拥塞控制主要是四个算法：慢启动、拥塞避免、快重传、快恢复</p>
<h1 id="面向字节流是什么意思？"><a href="#面向字节流是什么意思？" class="headerlink" title="面向字节流是什么意思？"></a>面向字节流是什么意思？</h1><p>消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p>
<h1 id="TCP报文头格式是怎样的？"><a href="#TCP报文头格式是怎样的？" class="headerlink" title="TCP报文头格式是怎样的？"></a>TCP报文头格式是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205955.png"></p>
<p>TCP报文头部最大为60字节，头部固定20个字节，TCP Options最大为40字节</p>
<p>包含源端口、目的端口、序列号、确认号、数据偏移、保留位、控制位、窗口大小、校验和、紧急指针、选项等</p>
<p>控制位：</p>
<p>CWR：用于 IP 首部的 ECN 字段。ECE 为 1 时，则通知对方已将拥塞窗口缩小。<br>ECE：在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设置为 1，表示从对方到这边的网络有拥塞。<br>URG：紧急模式<br>ACK：确认<br>PSH：推送，接收方应尽快给应用程序传送这个数据。没用到<br>RST：该位为 1 表示 TCP 连接中出现异常必须强制断开连接。<br>SYN：初始化一个连接的同步序列号<br>FIN：该位为 1 表示今后不会有数据发送，希望断开连接。</p>
<h1 id="为什么-TCP-协议有性能问题？"><a href="#为什么-TCP-协议有性能问题？" class="headerlink" title="为什么 TCP 协议有性能问题？"></a>为什么 TCP 协议有性能问题？</h1><p>在弱网环境下（丢包率高）影响 TCP 性能的三个原因：</p>
<ol>
<li>TCP 的拥塞控制算法会在丢包时主动降低吞吐量；</li>
<li>TCP 的三次握手增加了数据传输的延迟和额外开销；</li>
<li>TCP 的累计应答机制导致了数据段的传输；</li>
</ol>
<h2 id="如何唯一的标识和确认一个TCP连接？"><a href="#如何唯一的标识和确认一个TCP连接？" class="headerlink" title="如何唯一的标识和确认一个TCP连接？"></a>如何唯一的标识和确认一个TCP连接？</h2><p>四元组。</p>
<p>源IP地址、源端口号、目的IP地址、目的端口号。</p>
<h2 id="TCP最大连接数是多少？"><a href="#TCP最大连接数是多少？" class="headerlink" title="TCP最大连接数是多少？"></a>TCP最大连接数是多少？</h2><p>服务端固定监听某个端口。</p>
<p>源IP地址在IP报文头中是32位。</p>
<p>源端口号在TCP报文头是16位。</p>
<p>不考虑其他因素，理论最大连接数是 <code>2^32 * 2^16</code>。</p>
<h1 id="为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？"><a href="#为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？" class="headerlink" title="为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？"></a>为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？</h1><p>TCP数据长度 = IP总长度 - IP首部长度 - TCP首部长度</p>
<p>UDP数据长度 = IP总长度 - IP首部长度 - UDP首部长度</p>
<p>UDP数据长度是可以通过IP总长度减去报文头长度算出来了的。</p>
<p>UDP报文头里有数据长度，是为了网络设备硬件设计和处理方便，首部长度需要是4字节的整数倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">239</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
