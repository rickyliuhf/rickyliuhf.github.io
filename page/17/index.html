<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/17/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">数据库索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-15 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-15T20:31:00+08:00">2017-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:58:09" itemprop="dateModified" datetime="2021-08-28T21:58:09+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/数据库索引/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库建立索引是干什么的？"><a href="#数据库建立索引是干什么的？" class="headerlink" title="数据库建立索引是干什么的？"></a>数据库建立索引是干什么的？</h1><p>按某列的条件做查询后（where子句中访问的列），需要线性扫描全表太慢了。</p>
<p>用B+树实现索引可以在对数时间内完成查询。</p>
<h1 id="索引为什么不用平衡二叉查找树，要用B树或B-树做索引？"><a href="#索引为什么不用平衡二叉查找树，要用B树或B-树做索引？" class="headerlink" title="索引为什么不用平衡二叉查找树，要用B树或B+树做索引？"></a>索引为什么不用平衡二叉查找树，要用B树或B+树做索引？</h1><p>B树又称多路平衡二叉查找树，一个结点存储多个值，可以降低树的高度，即降低了访问结点的次数，一次访问可以认为是一次IO，降低了IO次数就会提高整体的访问速度。</p>
<h1 id="为什么不用哈希表做索引？查询时间复杂度不是O-1"><a href="#为什么不用哈希表做索引？查询时间复杂度不是O-1" class="headerlink" title="为什么不用哈希表做索引？查询时间复杂度不是O(1)?"></a>为什么不用哈希表做索引？查询时间复杂度不是O(1)?</h1><ol>
<li> 哈希索引对于范围查询和排序却无法很好地支持，最终导致全表扫描</li>
<li> 哈希索引不支持多列联合索引的最左匹配规则</li>
<li> 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li>
</ol>
<h1 id="为什么用B-树做索引而不用B树？"><a href="#为什么用B-树做索引而不用B树？" class="headerlink" title="为什么用B+树做索引而不用B树？"></a>为什么用B+树做索引而不用B树？</h1><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</p>
<p> B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。</p>
<p>而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间。</p>
<h1 id="使用B树做索引的好处？"><a href="#使用B树做索引的好处？" class="headerlink" title="使用B树做索引的好处？"></a>使用B树做索引的好处？</h1><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h1 id="索引有什么缺点？"><a href="#索引有什么缺点？" class="headerlink" title="索引有什么缺点？"></a>索引有什么缺点？</h1><ol>
<li> 占用空间，因为会把列的信息都复制一遍</li>
<li> 插入、修改、删除时需要额外花时间更新索引</li>
</ol>
<h1 id="索引适用场景？"><a href="#索引适用场景？" class="headerlink" title="索引适用场景？"></a>索引适用场景？</h1><p>适用查询非常频繁而更新不频繁的列。</p>
<h2 id="where子句中对列的访问"><a href="#where子句中对列的访问" class="headerlink" title="where子句中对列的访问"></a>where子句中对列的访问</h2><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p>
<h1 id="为什么外键要加索引？"><a href="#为什么外键要加索引？" class="headerlink" title="为什么外键要加索引？"></a>为什么外键要加索引？</h1><p>避免子表上的全表扫描。（外键在子表上，外键对应主表的主键）</p>
<p>假设删除departments主表id=10的记录，如果employees子表的department_id外键没有索引，那么就会全表扫描employees子表，以确认是否存在department id=10的记录。</p>
<h1 id="联合索引是什么？"><a href="#联合索引是什么？" class="headerlink" title="联合索引是什么？"></a>联合索引是什么？</h1><p>对多个字段联合创建的索引。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232210.png"></p>
<p>只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p>
<p>通俗理解：</p>
<p>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</p>
<p>所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p>
<p>查英语字典、汉语字典也是这样。</p>
<h1 id="联合索引的底层实现是怎样的？"><a href="#联合索引的底层实现是怎样的？" class="headerlink" title="联合索引的底层实现是怎样的？"></a>联合索引的底层实现是怎样的？</h1><p>索引的底层是一颗B+树，联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。</p>
<p>构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。</p>
<p>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232238.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p>联合索引会对最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序，以此类推。</p>
<p>所以如果要利用到联合索引中靠后列的索引，前面列就必须相等，如果前面列不相等（比如用范围查询），那么后面的列没办法保证顺序，后面列的顺序都是在前面列相等的情况下才保持顺序的。</p>
<h1 id="为什么表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么表必须有主键，并且推荐使用整型的自增主键？"></a>为什么表必须有主键，并且推荐使用整型的自增主键？</h1><p>不建主键不代表没有主键，没有建主键innodb会帮你选一个字段，一个可以标识唯一的字段，选为默认字段，如果这个字段唯一的话，不重复，可一键唯一索引的话，就会作为类似于唯一索引，用这个字段来作为唯一索引来维护整个表的数据。如果没有，mysql会生成一个唯一的列，类似于rowid，只不过你看不到，他会用生成的这个唯一列，维护B+Tree的结构，查数据的时候还是用B+Tree的结构去查找。</p>
<h2 id="为什么推荐整型呢？"><a href="#为什么推荐整型呢？" class="headerlink" title="为什么推荐整型呢？"></a>为什么推荐整型呢？</h2><p>我们想象一下查找过程，是把节点load到内存然后在内存里去比较大小，也就是在查找的过程中要不断的去进行数据的比对。假设UUID，既不自增也不是整形。问一下，是整形的1&lt;2比较的效率高还是字符串的“abc”和“abe”比较的效率高呢？显然是前者，因为字符串的比较是转换成ASICI一位一位的比，如果最后一位不一样，比到最后才比较出大小，就比整形比较慢多了，存储空间来说，整形更小。索引越节约资源越好。</p>
<p>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232458.png"></p>
<p>所以建议使用int的auto_increment作为主键。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232514.png"><br>主键的值是顺序的，所以每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p>
<h2 id="为什么是自增的呢？"><a href="#为什么是自增的呢？" class="headerlink" title="为什么是自增的呢？"></a>为什么是自增的呢？</h2><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h1 id="聚簇索引是什么？"><a href="#聚簇索引是什么？" class="headerlink" title="聚簇索引是什么？"></a>聚簇索引是什么？</h1><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>数据库表数据是用B+树来存储组织的，那么这个B+树可以认为是一种索引，这就是聚簇索引。</p>
<p>索引是针对某一列而言的，一般的聚簇索引就是主键列。</p>
<p>聚簇索引确定了表数据的物理存储顺序，聚簇索引B+树的叶子结点存储的是整个行数据</p>
<p>由于聚簇索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚簇索引。</p>
<p>聚簇索引类似于电话簿，按姓氏排列数据。汉语字典也是聚簇索引的典型应用，在汉语字典里，索引项是字母+声调，字典正文也是按照先字母再声调的顺序排列。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<p>如果是普通的索引，B+树的叶子结点存储的行的主键，然后需要再去聚簇索引下去查询一遍，找到完整的行数据，有一个回表查询的过程，所以在聚簇索引上查询会少了回表查询的过程，查询速度快。</p>
<p>MySQL官方对聚簇索引的解释：</p>
<p><strong>The InnoDB term for a primary key index</strong>. InnoDB table storage is organized based on the values of the primary key columns, to speed up queries and sorts involving the primary key columns. For best performance, choose the primary key columns carefully based on the most performance-critical queries. Because modifying the columns of the clustered index is an expensive operation, choose primary columns that are rarely or never updated.</p>
<p>注意标黑的那段话，聚簇索引就是主键的一种术语。</p>
<h1 id="聚簇索引有什么用？"><a href="#聚簇索引有什么用？" class="headerlink" title="聚簇索引有什么用？"></a>聚簇索引有什么用？</h1><p>聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">聚集索引</a>可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚簇（物理排序），避免每次查询该列时都进行排序，从而节省成本。</p>
<p>在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查(between、&lt;、&lt;=、&gt;、&gt;=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大大提高查询速度。</p>
<h1 id="为什么非聚簇索引结构叶子节点存储的是主键值？"><a href="#为什么非聚簇索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非聚簇索引结构叶子节点存储的是主键值？"></a>为什么非聚簇索引结构叶子节点存储的是主键值？</h1><p>为了一致性和节省存储空间。已经维护了一套主键索引+数据的B+Tree结构，如果再有其他的非主键索引的话，索引的叶子节点存储的是主键，这是为了节省空间，因为继续存数据的话，那就会导致一份数据存了多份，空间占用就会翻倍。另一方面也是一致性的考虑，都通过主键索引来找到最终的数据，避免维护多份数据导致不一致的情况。</p>
<h1 id="哪些列适合作为聚簇索引？"><a href="#哪些列适合作为聚簇索引？" class="headerlink" title="哪些列适合作为聚簇索引？"></a>哪些列适合作为聚簇索引？</h1><p>1、主键列,该列在where子句中使用并且插入是随机的。</p>
<p>2、按范围存取的列，如pri_order &gt; 100 and pri_order &lt; 200。</p>
<p>3、在group by或order by中使用的列。</p>
<p>4、不经常修改的列。</p>
<p>5、在连接操作中使用的列。</p>
<h1 id="聚簇索引的优点和缺点？"><a href="#聚簇索引的优点和缺点？" class="headerlink" title="聚簇索引的优点和缺点？"></a>聚簇索引的优点和缺点？</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li> 适合范围查询</li>
<li> 适配排序</li>
<li> 当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引只能定位到对应主键，然后要再回表查询聚簇索引，才能找到完整的行数据。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p>
<p>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
<p>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
<p>4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
<h1 id="二级索引是什么？"><a href="#二级索引是什么？" class="headerlink" title="二级索引是什么？"></a>二级索引是什么？</h1><p>表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p>
<p>除了聚簇索引以外的所有索引都称为二级索引，二级索引的叶子节点内容是主键的值。</p>
<p>二级索引没有存储全部的数据，假如二级索引满足查询需求，则直接返回，即为覆盖索引，反之则需要回表去主键索引(聚簇索引)查询。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233004.png"></p>
<h1 id="何时使用聚簇索引与非聚簇索引？"><a href="#何时使用聚簇索引与非聚簇索引？" class="headerlink" title="何时使用聚簇索引与非聚簇索引？"></a>何时使用聚簇索引与非聚簇索引？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233032.png"></p>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><p>（1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列，即较频繁作为查询条件的字段才去创建索引</p>
<p>（2）取值离散小、查询中很少涉及、重复值比较多的列，索引效果较差，没有必要在此列建立索引</p>
<p>（3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p>
<p>（4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<p>（5）更新频繁字段不适合创建索引。</p>
<h1 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h1><ol>
<li> 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li> 存储引擎不能使用索引范围条件右边的列</li>
<li> 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</li>
<li> mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li> is null,is not null也无法使用索引</li>
<li> like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/" class="post-title-link" itemprop="url">关系型数据库-范式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-12 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-12T20:31:00+08:00">2017-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:58:09" itemprop="dateModified" datetime="2021-08-28T21:58:09+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/关系型数据库-范式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="范式解决的是什么问题？"><a href="#范式解决的是什么问题？" class="headerlink" title="范式解决的是什么问题？"></a>范式解决的是什么问题？</h1><p>消除数据冗余，提高增删改查的性能。</p>
<h1 id="范式的优缺点？"><a href="#范式的优缺点？" class="headerlink" title="范式的优缺点？"></a>范式的优缺点？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231020.png"></p>
<p>参考：《高性能MySQL》 4.3.1 范式的优点和缺点。</p>
<h1 id="反范式的优缺点？"><a href="#反范式的优缺点？" class="headerlink" title="反范式的优缺点？"></a>反范式的优缺点？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231049.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231057.png"></p>
<p>参考：《高性能MySQL》 4.3.2 反范式的优点和缺点</p>
<h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>确保每列保持原子性。</p>
<p>每列不可再分割，符合原子性特征，不分割的话你增删改查特定的数据发现不是单独的一列就不方便。</p>
<p>违反第一范式：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231130.png"></p>
<p>符合第一范式：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231142.png"></p>
<h2 id="满足第一范式后还存在什么问题？"><a href="#满足第一范式后还存在什么问题？" class="headerlink" title="满足第一范式后还存在什么问题？"></a>满足第一范式后还存在什么问题？</h2><p>但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231343.png"></p>
<ol>
<li> 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大</li>
<li> 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 ——插入异常</li>
<li> 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常</li>
<li> 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常。</li>
</ol>
<h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>确保每列都和主键相关。</p>
<p>每列依赖于全部的主键而非部分主键，这样才可以唯一确定一行记录，消除一部分冗余。</p>
<h2 id="怎样判断表是否符合第二范式？"><a href="#怎样判断表是否符合第二范式？" class="headerlink" title="怎样判断表是否符合第二范式？"></a>怎样判断表是否符合第二范式？</h2><p>第一步：找出数据表中所有的码（单主键或联合主键）。</p>
<p>第二步：根据第一步所得到的码，找出所有的主属性（主键中的属性）。</p>
<p>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。</p>
<p>第四步：查看是否存在非主属性对码的部分函数依赖，根据上下文分析属性间依赖关系</p>
<h2 id="违反第二范式会怎样？"><a href="#违反第二范式会怎样？" class="headerlink" title="违反第二范式会怎样？"></a>违反第二范式会怎样？</h2><p>为了满足第二范式，会把表进行拆分，这样可以消除表中的冗余信息、插入异常、删除异常、修改异常。</p>
<p>违反第二范式的表：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231441.png"></p>
<p>属性间依赖关系：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231449.png"></p>
<p>满足第二范式后表情况：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231504.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231512.png"></p>
<p>运用第二范式后结果：</p>
<ol>
<li>李小明转系到法律系<br> 只需要修改一次李小明对应的系的值即可。——有改进</li>
<li>数据冗余是否减少了？<br> 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
<li>删除某个系中所有的学生记录<br> 该系的信息仍然全部丢失。——无改进</li>
<li>插入一个尚无学生的新系的信息。<br> 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
</ol>
<h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>确保每列都和主键直接相关而非间接相关。</p>
<p>非主键列之间不应该有依赖关系，这样可以消除冗余信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231541.png"></p>
<p>对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231553.png"></p>
<p>对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。</p>
<p>为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：</p>
<ul>
<li>选课（学号，课名，分数）</li>
<li>学生（学号，姓名，系名）</li>
<li>系（系名，系主任）</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231621.png"></p>
<p>结果：</p>
<ol>
<li>删除某个系中所有的学生记录<br> 该系的信息不会丢失。——有改进</li>
<li>插入一个尚无学生的新系的信息。<br> 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
<li> 数据冗余更加少了。——有改进</li>
</ol>
<h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><p>消除多值依赖，不能有多个主键</p>
<p>符合第三范式的表：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231650.png"></p>
<ol>
<li> 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li> 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量</p>
<p>码：（管理员，物品名），（仓库名，物品名）</p>
<p>主属性：仓库名、管理员、物品名</p>
<p>非主属性：数量</p>
<p>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
<ol>
<li> 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
<li> 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li>
<li> 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li>
</ol>
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
<p>造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）</p>
<p>库存（仓库名，物品名，数量）</p>
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
<h1 id="严格遵守范式会有什么问题？"><a href="#严格遵守范式会有什么问题？" class="headerlink" title="严格遵守范式会有什么问题？"></a>严格遵守范式会有什么问题？</h1><p>一般达到2范式就可以，为了性能和灵活性不需要严格的遵守范式，允许存在冗余，可以带来其他的便利，但是最好要知道是怎么回事。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20028672">数据库第一二三范式到底在说什么？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">序列化：Serializable与Parceable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-05 21:03:00" itemprop="dateCreated datePublished" datetime="2016-08-05T21:03:00+08:00">2016-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:58:09" itemprop="dateModified" datetime="2021-08-28T21:58:09+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java/Java Serializable序列化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="序列化的意义和价值是什么？"><a href="#序列化的意义和价值是什么？" class="headerlink" title="序列化的意义和价值是什么？"></a>序列化的意义和价值是什么？</h1><p>序列化就是把对象转换为字节序列。</p>
<p>反序列化就是把字节序列还原为对象。</p>
<p>对象是程序运行时的信息载体，序列化机制使得对象信息可以脱离程序的运行而独立存在，这样便于进行网络传输或持久性存储到磁盘。</p>
<h1 id="序列化考量的重点是什么？"><a href="#序列化考量的重点是什么？" class="headerlink" title="序列化考量的重点是什么？"></a>序列化考量的重点是什么？</h1><ol>
<li> 协议是否跨平台</li>
<li> 序列化速度</li>
<li> 字节序列大小</li>
</ol>
<h1 id="Serializable底层运作机制是怎样的？"><a href="#Serializable底层运作机制是怎样的？" class="headerlink" title="Serializable底层运作机制是怎样的？"></a>Serializable底层运作机制是怎样的？</h1><p>查看ObjectInputStream的readObject方法  和 ObjectOutputStream的writeObject的代码。</p>
<p>主要运用了反射。</p>
<h1 id="Serializable如何自定义决定哪些字段写入和读取？"><a href="#Serializable如何自定义决定哪些字段写入和读取？" class="headerlink" title="Serializable如何自定义决定哪些字段写入和读取？"></a>Serializable如何自定义决定哪些字段写入和读取？</h1><ol>
<li> 通过transient关键字修饰属性，排除在序列化之外</li>
<li> 在类中增加writeObejct和readObject方法，JDK中的ArrayList、HashMap等都复写了writeObject</li>
<li> 在类中增加writeReplace和readResolve方法，提供了writeReplace就不会执行writeObject，提供了readResolve就不会执行readObject</li>
<li> 实现Externalizable接口，显式实现readExternal和writeExternal</li>
</ol>
<p>Java为用户定义了默认的序列化、反序列化方法，其实就是ObjectOutputStream的defaultWriteObject方法和ObjectInputStream的defaultReadObject方法。</p>
<p>为什么HashMap要自定义序列化逻辑呢？<br>可能的原因是，存储数据的数组table，一般都是不满的（因为HashMap的负载因子默认0.75，超过就会扩容），里面肯定会有很多null，如果是默认的序列化，这些null也会被被序列化，显然这些null是没有必要的做序列化的。</p>
<p>ArrayList自定义序列化方法，也是因为elementData数组可能没存满。</p>
<h1 id="serialVersionUID是干什么的？"><a href="#serialVersionUID是干什么的？" class="headerlink" title="serialVersionUID是干什么的？"></a>serialVersionUID是干什么的？</h1><p>反序列化需要指定一个类，但是类的结构会变更，如何保证已经序列化的字节序列与当前的类结构是对应上的，可以在字节序列和类中分别存储一个版本号，只有版本号相同，就当做是可转行的，版本号不同反序列化就报错。</p>
<p>类中指定版本号是使用private static final long serialVersionUID属性，值为任意。如果不声明这个属性，虚拟机会根据类信息自动生成一个版本号。</p>
<p>这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</p>
<h1 id="什么情况下需要修改serialVersionUID呢？"><a href="#什么情况下需要修改serialVersionUID呢？" class="headerlink" title="什么情况下需要修改serialVersionUID呢？"></a>什么情况下需要修改serialVersionUID呢？</h1><p>分三种情况：</p>
<ol>
<li> 如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li>
<li> 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li>
<li> 如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li>
</ol>
<h1 id="Serializable序列化会有什么问题？"><a href="#Serializable序列化会有什么问题？" class="headerlink" title="Serializable序列化会有什么问题？"></a>Serializable序列化会有什么问题？</h1><p>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</p>
<p>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</p>
<h1 id="Serializable反序列化会有什么问题？"><a href="#Serializable反序列化会有什么问题？" class="headerlink" title="Serializable反序列化会有什么问题？"></a>Serializable反序列化会有什么问题？</h1><p>反序列化不会调用类的构造函数，会调用第一个非序列化父类的无参构造函数</p>
<p>这点可以通过 ObjectInputSteam -&gt; readObject -&gt; readObject0 -&gt; readOrdinaryObject -&gt; desc.newInstance() 得知，desc是ObjectStreamClass的实例，ObjectStreamClass.newInstance()的注释是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new instance of the represented class.  If the class is</span><br><span class="line"> * externalizable, invokes its public no-arg constructor; otherwise, if the</span><br><span class="line"> * class is serializable, invokes the no-arg constructor of the first</span><br><span class="line"> * non-serializable superclass.  Throws UnsupportedOperationException if</span><br><span class="line"> * this class descriptor is not associated with a class, if the associated</span><br><span class="line"> * class is non-serializable or if the appropriate no-arg constructor is</span><br><span class="line"> * inaccessible/unavailable.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>这样设计的目的是什么？</p>
<p>推测是因为如果调用了类的构造函数，如果构造函数中有改变类属性状态的代码，反序列化后就得不到序列化时的状态了，所以不能调用。</p>
<h1 id="Serializable的具体序列化执行过程中哪些地方用到了大量的反射？"><a href="#Serializable的具体序列化执行过程中哪些地方用到了大量的反射？" class="headerlink" title="Serializable的具体序列化执行过程中哪些地方用到了大量的反射？"></a>Serializable的具体序列化执行过程中哪些地方用到了大量的反射？</h1><p>因为没有在代码层面手动写入特定字段，序列化都是全自动化的，在ObjectOutputStream底层都是通过反射获取类的字段信息，defaultWriteFields()读取类的属性字段是通过Field，Field从ObjectStreamClass的getFields()得来，getFields()内部还是反射。</p>
<p>ObjectInputStream也通过反射创建类。</p>
<h1 id="Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？"><a href="#Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？" class="headerlink" title="Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？"></a>Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？</h1><p>创建大量的临时对象会引发频繁的垃圾回收，垃圾回收会stop the world，进而引起进程的卡顿。</p>
<p>Serializable的序列化过程比较复杂，有很多对象参与工作，例如ObjectStreamClass。</p>
<h1 id="Parceable底层运作机制是怎样的？"><a href="#Parceable底层运作机制是怎样的？" class="headerlink" title="Parceable底层运作机制是怎样的？"></a>Parceable底层运作机制是怎样的？</h1><p>Interface for classes whose instances can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field called CREATOR of a type that implements the Parcelable.Creator interface.<br>A typical implementation of Parcelable is:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mData;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(mData);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;MyParcelable&gt; CREATOR</span><br><span class="line">            = <span class="keyword">new</span> Parcelable.Creator&lt;MyParcelable&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyParcelable <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable(in);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> MyParcelable[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        mData = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parcelable通过Parcel的一系列read和write方法实现序列化，Parcel的read和write方法都是在native层实现。</p>
<p>Parcel把对象数据直接序列化输出在内存，并且数据结构很紧凑，几乎只存储数据值，不存储额外的信息，而Serializable会存储很多额外的信息，所以Parcel序列化的输出的信息量就比Serializable少，同时没有用反射，而是直接操作内存指针，因此速度更快。<br>缺点：<br>    1. 由于数据紧凑，没有存储必要的判断信息，不能用于持久化存储，因为反序列化时，缺乏足够的信息来保证数据恢复的正确性。<br>    2. 需要手动指定哪些字段写入，并且写入顺序和读入顺序要一致</p>
<h1 id="Parceable与Serializable有什么区别？"><a href="#Parceable与Serializable有什么区别？" class="headerlink" title="Parceable与Serializable有什么区别？"></a>Parceable与Serializable有什么区别？</h1><p>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作。</p>
<p>Parcelable  自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828174331.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Android ViewDragHelper源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-05-21 17:58:17" itemprop="dateCreated datePublished" datetime="2015-05-21T17:58:17+08:00">2015-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:58:09" itemprop="dateModified" datetime="2021-08-28T21:58:09+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android ViewDragHelper源码解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">202</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
