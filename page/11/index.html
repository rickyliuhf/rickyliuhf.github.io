<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/11/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/" class="post-title-link" itemprop="url">红黑树、AVL树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-04 20:00:00" itemprop="dateCreated datePublished" datetime="2019-07-04T20:00:00+08:00">2019-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/黑树、AVL树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"><a href="#普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？" class="headerlink" title="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"></a>普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？</h2><p>普通的二叉查找树最坏情况下会退化为一个链表，查找元素的时间复杂度由log_2{n}退化到n。</p>
<p>解决时间复杂度退化，就是要让树的高度始终保持尽可能的小，平衡二叉查找树就是让任意节点的左右子树高度都平衡（差的不多）的二叉查找树，这样查找元素的平均时间复杂度可以保持在log_2{n}，</p>
<h2 id="有哪些平衡二叉查找树？"><a href="#有哪些平衡二叉查找树？" class="headerlink" title="有哪些平衡二叉查找树？"></a>有哪些平衡二叉查找树？</h2><p>AVL树、2-3树、红黑树</p>
<h2 id="为什么流行的主要是这几个树？"><a href="#为什么流行的主要是这几个树？" class="headerlink" title="为什么流行的主要是这几个树？"></a>为什么流行的主要是这几个树？</h2><p>因为逻辑比较简单，易于实现，效率也就高。</p>
<h2 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h2><p>任意结点左右子树高度差小于或等于1。</p>
<p>由Adelson-Velskii 以及 Landis发明，故而叫AVL。</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>定义：</p>
<ul>
<li>在满足二叉查找树的性质基础上，一个结点最多可以存储2个键，可以有3个孩子结点。</li>
<li>2结点里存储1个键，可以有2个孩子结点</li>
<li>3结点里存储2个键，可以有3个孩子结点</li>
</ul>
<p>特点</p>
<ul>
<li>2-3树是完美平衡的，任意结点的左右子树高度相等，这可以分析所有插入的情况来证明。</li>
</ul>
<p>自下而上生长：</p>
<ul>
<li>插入位置在2结点中，直接插入，变为3结点。</li>
<li>插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）。<ul>
<li>如果父结点本来是2结点，现在就变成了3结点。</li>
<li>如果父结点本来是3结点，现在就变成了4结点，继续提升的过程。</li>
<li>如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点。</li>
</ul>
</li>
</ul>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1。</p>
<p>一颗含有n个节点的2-3树的高度在log_3{n}（全是3结点）到log_2{n}（全是2结点）之间。</p>
<p>每次插入后调整结点都是局部的，最坏情况下，一条路径上都是3结点，从叶结点插入新键后，会从叶结点一直调整到根结点，调整次数不会超过对数级别。</p>
<p>10亿个结点的2-3树高度仅在19到30之间，性能较高。</p>
<p>各种操作实现较为复杂。</p>
<h2 id="为什么2-3树可以保持完美平衡？"><a href="#为什么2-3树可以保持完美平衡？" class="headerlink" title="为什么2-3树可以保持完美平衡？"></a>为什么2-3树可以保持完美平衡？</h2><p>这可以分析所有插入的情况来证明。</p>
<p>自下而上生长</p>
<ol>
<li><p> 插入位置在2结点中，直接插入，变为3结点</p>
</li>
<li><p> 插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）</p>
</li>
<li><p> 如果父结点本来是2结点，现在就变成了3结点</p>
</li>
<li><p> 如果父结点本来是3结点，现在就变成了4结点，继续提升的过程</p>
</li>
<li><p> 如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点</p>
</li>
</ol>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>实现较为简单，综合性能好。</p>
<p>把2-3树的3结点表示为左斜的红色链接相连的两个2结点，其中一个结点是另一个结点的左子结点，其他链接为黑色链接。</p>
<p>红黑树既是二叉查找树也是2-3树。</p>
<p>等价定义（《算法》第4版 275页 3.3.2.1）：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>红黑树的几条定义都是为了让红黑树满足2-3树的结构。</p>
<p>如果让2-3树中所有链接都为黑色，由于2-3树是完美平衡的，红黑树中红色链接代表3结点，所以红黑树中的黑色链接是完美平衡的。</p>
<p>再把2-3树中的3结点都分解为两个用红色链接相连的2结点，那么不会存在一个结点同时与两条红色链接相连，这一点保证了红色链接是3结点。</p>
<p>对红黑树插入、删除元素后，不满足红黑树的定义，都要通过旋转操作来修正。</p>
<p>红黑树的旋转操作修正，都是符合2-3树的修正的规则的，理解记住了2-3树的各种调整规则，就知道了红黑树各种操作的意义。</p>
<h2 id="红黑树是怎么发明出来的？"><a href="#红黑树是怎么发明出来的？" class="headerlink" title="红黑树是怎么发明出来的？"></a>红黑树是怎么发明出来的？</h2><p>它在1972年由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%B2%81%E9%81%93%E5%A4%AB%C2%B7%E8%B4%9D%E5%B0%94">鲁道夫·贝尔</a>发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Robert_Sedgewick">Robert Sedgewick</a>于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1978%E5%B9%B4">1978年</a>写的一篇论文。</p>
<p>红黑树等同于2-3-4树，是2-3-4树的二叉表现形式。</p>
<p>2-3-4树是B树的一种情况。</p>
<p>红黑树结点的颜色表明了当前结点是否属于2-3-4树中的3结点或4结点。</p>
<p>2-3-4树的情况讨论比较复杂，  用2-3树讨论情况较少，可以方便理解。</p>
<hr>
<h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>《算法》第4版 275页 3.3.2.1 定义：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>《算法导论》273页  第13章  红黑树  定义：</p>
<ol>
<li> 节点是红色或黑色</li>
<li> 根节点是黑色</li>
<li> 叶节点是黑色</li>
<li> 红节点的两个子节点都是黑色</li>
<li> 任意节点到叶节点的所有路径上的黑色节点数相同</li>
</ol>
<h2 id="红黑树为什么要这样定义？"><a href="#红黑树为什么要这样定义？" class="headerlink" title="红黑树为什么要这样定义？"></a>红黑树为什么要这样定义？</h2><p>红黑树的几条定义都是为了让红黑树满足2-3树的结构，红黑树是2-3树的一种表示形式，而2-3树是完美平衡的，这样红黑树也是黑色平衡的，2-3树比较难以实现，红黑树比较方便实现。</p>
<h2 id="为什么要用红黑树表示2-3树？"><a href="#为什么要用红黑树表示2-3树？" class="headerlink" title="为什么要用红黑树表示2-3树？"></a>为什么要用红黑树表示2-3树？</h2><ul>
<li>因为2-3树是完美平衡的，任意结点的子树没有高度差。</li>
<li>2-3树的实现较为复杂，红黑树的实现较为简单。</li>
</ul>
<h2 id="红黑树的数据结构如何定义？"><a href="#红黑树的数据结构如何定义？" class="headerlink" title="红黑树的数据结构如何定义？"></a>红黑树的数据结构如何定义？</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">Key : Comparable&lt;Key</span>&gt;, <span class="type">Value&gt;</span></span>(</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 父结点指向本结点的链接颜色，用以标明本结点对应2-3树中的2结点还是3结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> color: Color,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字。用于比较来确定数据的顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> key: Key,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关联的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> value: Value,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> left: Node&lt;Key, Value&gt;? = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> right: Node&lt;Key, Value&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    BLACK, RED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树插入新元素后调整结点的操作规则是怎样的？"><a href="#红黑树插入新元素后调整结点的操作规则是怎样的？" class="headerlink" title="红黑树插入新元素后调整结点的操作规则是怎样的？"></a>红黑树插入新元素后调整结点的操作规则是怎样的？</h2><p>原则：所有操作跟2-3树能逐一对应，保证树的有序性和完美平衡性。</p>
<p>插入新结点先按普通的二叉查找树插入新结点那样进行插入。</p>
<p>普通的二叉查找树插入新元素有三种情况：</p>
<ol>
<li> 树中没有结点，插入的新结点作为根结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的左子结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的右子结点</li>
</ol>
<p>在红黑树中，结点h又可以分为两种情况</p>
<ol>
<li> 结点h是2结点</li>
<li>结点h位于3结点中<ol>
<li> 结点h是红链接左下的结点</li>
<li> 结点h是红链接右上的结点</li>
</ol>
</li>
</ol>
<p>插入新结点要默认新结点的颜色是红色，表示新结点到父节点的链接是红色，这样与2-3树的插入就可以对应上。</p>
<p>在2-3树中如果插入在2结点中，2结点变为3结点，就不再调整；如果插入的在3结点中，3结点临时变为4结点，再把4结点的中间键放入父结点中，左右两边的键分解为两个2结点与父结点相连。</p>
<p>处理这些情况的组合，就是所有的插入情况，针对不符合2-3树的结构的情况进行调整。</p>
<ul>
<li>结点h是2结点<ul>
<li>新结点是h的左子结点，相当于新结点和结点h组成了2-3树中的3结点，符合2-3树的结构，无需调整</li>
<li>新结点是h的右子结点，相当于新结点和结点h组成了2-3树中的3结点，但我们规定红链接要保持左斜，以减少考虑的情况数量，所以要进行左旋转</li>
</ul>
</li>
<li>结点h位于3结点中，新结点的位置有三种情况：左、中、右<ul>
<li>结点h是红链接左下的结点<ul>
<li>新结点是h的左子结点，此时有了两条连续的红链接，连接的3个结点对应2-3树中临时的4结点，需要把中间的键放入父结点，再把两边的键拆为两个2结点分别与父结点相连，所以操作是先右旋，再变换颜色</li>
<li>新结点是h的右子结点</li>
</ul>
</li>
<li>结点h是红链接右上的结点<ul>
<li>新结点是h的右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有三种标准操作：左旋、右旋、颜色转换</p>
<h2 id="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"><a href="#为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？" class="headerlink" title="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"></a>为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？</h2><p>只允许红色的左链接可以减少讨论的情景数量，进而简化代码的实现。</p>
<h2 id="红黑树最坏情况下高度是多少？"><a href="#红黑树最坏情况下高度是多少？" class="headerlink" title="红黑树最坏情况下高度是多少？"></a>红黑树最坏情况下高度是多少？</h2><p>有n个结点的红黑树高度最多为 $2 * log_2{n}$</p>
<p>由于2-3树中的3结点是由左斜红链接连接的两个结点表示的，最坏情况下最左侧路径全部都是红链接，对应2-3树中最左侧都是3结点，其他结点都是2结点。</p>
<p>参考《算法导论》中的证明：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lanchunhui/java/article/details/75905478">红黑树相关定理及其证明
</a></p>
<h2 id="红黑树的各种操作的时间复杂度是多少？"><a href="#红黑树的各种操作的时间复杂度是多少？" class="headerlink" title="红黑树的各种操作的时间复杂度是多少？"></a>红黑树的各种操作的时间复杂度是多少？</h2><p>设红黑树有n个结点，查找、插入、修改、删除操作的时间复杂度均为O(log n)</p>
<p>查找：</p>
<ul>
<li>最长路径长度不会超过最短路径长度的2倍，查找仍然是对数级别</li>
</ul>
<p>插入：</p>
<ul>
<li>最坏情况下待插入的位置在叶结点，需要从根结点遍历到叶结点，同时最坏情况下遍历的路径都是红链接（路径上都是3结点），此时会从叶结点一直回溯调整结点到根结点，访问次数是2倍的树的高度，而树的高度为log_2{n}</li>
</ul>
<h2 id="红黑树较于AVL树有什么优点？"><a href="#红黑树较于AVL树有什么优点？" class="headerlink" title="红黑树较于AVL树有什么优点？"></a>红黑树较于AVL树有什么优点？</h2><p>单次操作：</p>
<ul>
<li>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</li>
<li>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</li>
</ul>
<p>大量的插入和删除操作：</p>
<ul>
<li>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</li>
<li>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</li>
</ul>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎 </a></li>
</ul>
<h2 id="什么时候用AVL树？"><a href="#什么时候用AVL树？" class="headerlink" title="什么时候用AVL树？"></a>什么时候用AVL树？</h2><p>AVL树平衡性非常好，左右子树高度差不超过1，所以查找次数少。</p>
<p>对于查找非常频繁，插入、修改、删除不频繁的场景，可以使用AVL树。</p>
<h2 id="并发下的问题"><a href="#并发下的问题" class="headerlink" title="并发下的问题"></a>并发下的问题</h2><p>并发情况下，由于平衡搜索树的调整可能要锁整个树。</p>
<p>用跳表这种性能接近于平衡树的数据结构，操作更加局部性，不会锁住太多结点，有利于并发的性能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuchanming/p/4444961.html">面试题——轻松搞定面试中的红黑树问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/6111175.html">从2-3-4树到红黑树（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30527705/answer/259948086">AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？ - 韦易笑的回答 - 知乎 </a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">LZ77算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-03 20:00:00" itemprop="dateCreated datePublished" datetime="2019-07-03T20:00:00+08:00">2019-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/LZ77算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"><a href="#LZ77和哈夫曼编码区别？适用场景上有有什么不同？" class="headerlink" title="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"></a>LZ77和哈夫曼编码区别？适用场景上有有什么不同？</h2><p>哈夫曼编码是基于统计的数据压缩编码，需要先获得信息源的字符出现频率，然后再进行压缩。</p>
<p>但是，如果信息源是流式传输的，就没办法预先做统计，需要换一种思路。</p>
<p>LZ77利用数据的重复结构信息来进行数据压缩，是基于字典的压缩算法，可以做流逝压缩。</p>
<p>GZIP压缩的过程就是先用LZ77算法进行流式压缩，再对结果做哈夫曼编码压缩。</p>
<h2 id="为什么叫LZ77"><a href="#为什么叫LZ77" class="headerlink" title="为什么叫LZ77?"></a>为什么叫LZ77?</h2><p>由以色列的两位大神Jacob Ziv与Abraham Lempel在1977年发表的论文《A Universal Algorithm for Sequential Data Compression》中提出。</p>
<h2 id="LZ77算法思想概述"><a href="#LZ77算法思想概述" class="headerlink" title="LZ77算法思想概述"></a>LZ77算法思想概述</h2><p>核心思想：利用短语表示数据的重复结构信息来进行数据压缩。</p>
<p>LZ77算法一般称为“滑动窗口压缩”，算法的核心是在前面的历史数据中寻找重复字符串。</p>
<p>通过滑动窗口实现动态字典，用前面出现过的字符串作为字典通过映射（与前一个字符串的距离和字符串长度）替代后面重复出现的字符串。</p>
<p>重复现象是具有局部性的，它的基本假设是，如果一个字符串要重复，那么也是在附近重复，远的地方就不用找了，因此设置了一个滑动窗口。</p>
<p>其方式就是把数据中一些可以组织成短语(最长字符)的字符加入字典，然后再有相同字符出现采用标记来代替字典中的短语，如此通过标记代替多数重复出现的方式以进行压缩。</p>
<p>滑动窗口越大，压缩的效果越好，因为编码的短语越多，但是压缩速度越慢，因为要计算的短语数量越多。</p>
<h2 id="基于字典是什么意思？"><a href="#基于字典是什么意思？" class="headerlink" title="基于字典是什么意思？"></a>基于字典是什么意思？</h2><p>滑动窗口内的字符都是已经出现过的字符，已经出现过的字符会编码为字典短语，后面前向缓冲窗口中的字符如果和字典中的短语相同，就用距离和字符串长度来表示，以达到压缩的目的。</p>
<h2 id="LZ77压缩效果"><a href="#LZ77压缩效果" class="headerlink" title="LZ77压缩效果"></a>LZ77压缩效果</h2><p>大多数情况下LZ77压缩算法的压缩比相当高。</p>
<p>实际压缩率和选择的滑动窗口大小、前向缓冲区大小、数据熵有关系。</p>
<h2 id="LZ77缺点"><a href="#LZ77缺点" class="headerlink" title="LZ77缺点"></a>LZ77缺点</h2><p>压缩过程是比较耗时，因为要花费很多时间寻找滑动窗口中的短语匹配。</p>
<p>不过解压过程很快，因为每个标记都明确告知在哪个位置可以读取了。</p>
<h2 id="什么特征的文本用LZ77压缩效果好？"><a href="#什么特征的文本用LZ77压缩效果好？" class="headerlink" title="什么特征的文本用LZ77压缩效果好？"></a>什么特征的文本用LZ77压缩效果好？</h2><p>压缩就是用更短的符号来表示重复出现的字符串。</p>
<p>压缩就是寻找文本的内容分布概率，将出现频率高的部分代替成更短的形式。</p>
<p>内容越是重复，就可以压缩的更小。</p>
<p>内容如果毫无重复，就很难压缩。</p>
<h2 id="LZ77详细原理"><a href="#LZ77详细原理" class="headerlink" title="LZ77详细原理"></a>LZ77详细原理</h2><p>参见： <a target="_blank" rel="noopener" href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></p>
<h2 id="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"><a href="#为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？" class="headerlink" title="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"></a>为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？</h2><p>LZ77编码后得到的是，距离（distance）和长度（length），还有未匹配到短语字典的原始字符（literal）。</p>
<p>比较短的距离和长度可能是频繁出现的，就可以用变长编码来压缩，且文本已经确定下来不会变动，可以做词频统计，就可以用到哈夫曼编码了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/en-heng/p/4992916.html">【数据压缩】LZ77算法原理及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/en-heng/p/4992916.html">LZ77算法原理以及实现</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">哈夫曼编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-02 20:00:00" itemprop="dateCreated datePublished" datetime="2019-07-02T20:00:00+08:00">2019-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/哈夫曼编码/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是哈夫曼编码"><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是哈夫曼编码</h2><p>出现频次越高的字符，编码长度越小。</p>
<h2 id="哈夫曼编码的价值"><a href="#哈夫曼编码的价值" class="headerlink" title="哈夫曼编码的价值"></a>哈夫曼编码的价值</h2><p>变长编码，使得编码的平均长度最短，实现压缩率大的无损压缩。</p>
<p>因为哈夫曼树是最优的，每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<h2 id="哈夫曼编码过程"><a href="#哈夫曼编码过程" class="headerlink" title="哈夫曼编码过程"></a>哈夫曼编码过程</h2><ul>
<li>把文本中字符按出现的频次排序。</li>
<li>每个字符作为一个结点放入一个集合。</li>
<li>取集合最小的两个频次的结点，为左右子结点，生成一个父结点，父结点的频次是两个子结点频次之和，把父结点再加入到集合中。</li>
<li>重复这个构造过程，生成一个最优二叉树。</li>
<li>给二叉树所有左边设置0，所有右边设置1。</li>
<li>字符都在叶子结点。</li>
<li>根结点到叶子结点路径上的0和1组成的码字就是该字符的编码。</li>
</ul>
<p>因为所有字符都出现在叶子结点，保证了哈夫曼编码当中的任何一个字符的编码都不能是另一个字符编码的前缀。也就是说哈夫曼编码是一种前缀编码。</p>
<hr>
<h2 id="如何证明哈夫曼编码是最优的？"><a href="#如何证明哈夫曼编码是最优的？" class="headerlink" title="如何证明哈夫曼编码是最优的？"></a>如何证明哈夫曼编码是最优的？</h2><p>哈夫曼编码过程每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<p>其正确性证明依赖于贪心选择性质和最优子结构。</p>
<hr>
<h2 id="哈夫曼编码的特点"><a href="#哈夫曼编码的特点" class="headerlink" title="哈夫曼编码的特点"></a>哈夫曼编码的特点</h2><ol>
<li> 编码非等长</li>
<li> 编码前缀不重复</li>
</ol>
<h2 id="哈夫曼编码的压缩效果？"><a href="#哈夫曼编码的压缩效果？" class="headerlink" title="哈夫曼编码的压缩效果？"></a>哈夫曼编码的压缩效果？</h2><p>哈夫曼编码可以很有效的压缩数据，具体压缩率依赖于数据本身的特性。</p>
<p>齐夫定律：</p>
<p>发现某一单词出现的频率与其在频率表里名次的常数次幂成反比，也就是说极少数的单词会被经常使用，而绝大多数单词很少被提及，这种20/80法则在很多领域都被逐步发现，这种幂律分布被称为“齐夫定律”（Zipf’s law）</p>
<p>一般信息的分配都是幂率分布。</p>
<p>所以用哈夫曼编码压缩的比例一般都挺高的，70%以上。</p>
<h2 id="信息压缩的极限在哪？"><a href="#信息压缩的极限在哪？" class="headerlink" title="信息压缩的极限在哪？"></a>信息压缩的极限在哪？</h2><p>香农第一定理给出了无损的情况下数据压缩的临界值。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/08/information-theory.html">信息论入门教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法（冒泡、选择、插入、希尔、快速、归并、堆、计数）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-01 20:00:00" itemprop="dateCreated datePublished" datetime="2019-07-01T20:00:00+08:00">2019-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/排序算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>左侧无序区域中的最大数字交换到右侧已排序区域的最左侧。</p>
<h3 id="冒泡排序代码"><a href="#冒泡排序代码" class="headerlink" title="冒泡排序代码"></a>冒泡排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// nums[0, n - 1 - i]是无序区域，初始时整个数组无序</span></span><br><span class="line">            <span class="comment">// nums[n - i,n - 1]是有序区域，是数组中大的数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一趟冒泡是否有交换发生</span></span><br><span class="line">            <span class="keyword">var</span> isNotSwapped = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为要比较当前和下一个数大小，所以j只能取到n - 1 - i的前一个数</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span> - i) &#123;</span><br><span class="line">                <span class="comment">// 不是升序，就要交换一下</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换</span></span><br><span class="line">                    <span class="keyword">val</span> tmp = nums[j + <span class="number">1</span>]</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">                    nums[j] = tmp</span><br><span class="line">                    <span class="comment">// 标记有交换</span></span><br><span class="line">                    isNotSwapped = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有交换，说明无序区域已经有序，那么整个数组也是有序的了</span></span><br><span class="line">            <span class="keyword">if</span> (isNotSwapped) <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>冒泡排序是稳定的</strong>。</p>
<p>因为交换是当前数大于下一个数才会交换。</p>
<p>如果有<code>x1 == x2</code>，<code>x1</code>在<code>x2</code>左边，<code>x1</code>始终不会被交换到<code>x2</code>右边。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="一句话描述-1"><a href="#一句话描述-1" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>右侧未排序区域选取一个最小的数，交换到前面已排序区域的末尾。</p>
<h3 id="选择排序代码"><a href="#选择排序代码" class="headerlink" title="选择排序代码"></a>选择排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// s[0,i-1]为已排序区域，s[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序取一个最小的放入已排序区域的末尾  </span></span><br><span class="line">  <span class="keyword">var</span> minIndex = i  </span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;  </span><br><span class="line">                    minIndex = j  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 将未排序区域中最小值与已排序区域末尾的下一个位置的数字交换  </span></span><br><span class="line">  <span class="comment">// 已排序区域末尾的下一个位置就是i了，最小值索引是minIndex  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[minIndex]  </span><br><span class="line">            nums[minIndex] = nums[i]  </span><br><span class="line">            nums[i] = tmp  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>选择排序不稳定</strong>，因为发生了位置交换。</p>
<p>由于每次会在后面的未排序区域选择最小的数字与前面的已排序区域末尾元素交换，如果未排序区域交换的位置的前面有与已排序区域末尾元素相等的元素，这两个元素的相对位置就变了。</p>
<p>例如[2, 3, 4, 2, 1]，第一趟选择会把最小的1放到最前面，第一个2交换到最后面，这样两个2的相对顺序就变了。</p>
<p>如何不发生位置交换呢？</p>
<p>有两种做法：</p>
<ul>
<li>一个是开辟一个新数组，把最小的放到第一个位置上，把第二小的放到第二个位置上等等。空间复杂度是O(n)。</li>
<li>一个是使用链表，空间复杂度是O(1)。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>交换次数比冒泡排序少，交换次数是跟数组长度呈线性关系。</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h3 id="一句话描述-2"><a href="#一句话描述-2" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>扑克牌拿牌后插牌的排序：把数组右侧未排序区域的最左侧元素插入数组左侧已排序区域中。</p>
<h3 id="直接插入排序代码"><a href="#直接插入排序代码" class="headerlink" title="直接插入排序代码"></a>直接插入排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="comment">// 初始时未排序区域共有n个数，每次向左侧已排序区域插入一个数，总共需要插入n次  </span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// nums[0,i-1]为已排序区域  </span></span><br><span class="line">  <span class="comment">// nums[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序区域第一个元素开始，从后往前一个个跟已排序区域数字比较，相邻两个数字顺序不对就交换，直至顺序正确  </span></span><br><span class="line">  <span class="comment">// 由于要比较当前数字和前一个数字的大小，所以索引j最少只能取到第2个元素位置即索引1  </span></span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果相邻两个数不是升序则需要交换  </span></span><br><span class="line">  <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                    <span class="comment">// 交换元素  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[j]  </span><br><span class="line">                    nums[j] = nums[j - <span class="number">1</span>]  </span><br><span class="line">                    nums[j - <span class="number">1</span>] = tmp  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>已排序区域寻找插入位置可以使用二分查找。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适合部分有序的数组，这样比较次数就会大大减少，从而提高效率。</p>
<p>对于大规模乱序的数组，插入排序很慢，因为只会交换相邻的元素，元素只能一步一步的从数组的一端移动到另一端。</p>
<p>例如，如果是升序排序，数组最小的元素在数组末尾，那么移动到开头就要交换N-1次。如果有一个完全降序的数组，用插入排序变为升序的话，要做的事情太多了。</p>
<p>给定一个10万个元素的数组，部分有序，部分无序，选择哪一种排序算法最好？</p>
<p>用插入排序，插入排序在已排序区域寻找插入位置可以用二分法加快寻找</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h3 id="一句话描述-3"><a href="#一句话描述-3" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>先大步再小步的插入排序。</p>
<p>大步插入排序使得用很少的交换次数让数组变得部分有序，从而在小步排序时发挥插入排序的优势，达到总体的比较和交换次数变少。</p>
<h3 id="希尔排序代码"><a href="#希尔排序代码" class="headerlink" title="希尔排序代码"></a>希尔排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (d &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            d = <span class="number">3</span> * d + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> d until n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo d step d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[j - d]) &#123;</span><br><span class="line">                        <span class="keyword">val</span> tmp = nums[j]</span><br><span class="line">                        nums[j] = nums[j - d]</span><br><span class="line">                        nums[j - d] = tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递增序列如何选择？不同的递增序列有什么影响？"><a href="#递增序列如何选择？不同的递增序列有什么影响？" class="headerlink" title="递增序列如何选择？不同的递增序列有什么影响？"></a>递增序列如何选择？不同的递增序列有什么影响？</h3><blockquote>
<p>《算法（第4版）》</p>
<p>如何选择递增序列呢？要回答这个问题并不简单。算法的性能不仅取决于h，还取决于h 之间的数学性质，比如它们的公因子等。</p>
<p>有很多论文研究了各种不同的递增序列，但都无法证明某个序列是 “ 最好的” 。</p>
<p>算法2.3中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。但可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。</p>
</blockquote>
<p>一个简单的序列选择：<br>从1开始，一直 d * 3 + 1，直到小于 n / 3。</p>
<h3 id="希尔排序更高效的原因？"><a href="#希尔排序更高效的原因？" class="headerlink" title="希尔排序更高效的原因？"></a>希尔排序更高效的原因？</h3><p>希尔排序权衡了数组的规模和有序性。</p>
<p>排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p>
<p>子数组部分有序的程度取决于递增序列的选择。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>在大规模乱序的情况下，希尔排序可以减少元素交换的次数，数组越大优势越大。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>选取一个轴心元素，将数组划分成比这个数小的和比这个数字大的两个子数组，分别对两个子数组递归调用划分。</p>
<h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">val</span> pivotIndex = partition(nums, low, high)</span><br><span class="line">        quickSort(nums, low, pivotIndex - <span class="number">1</span>)</span><br><span class="line">        quickSort(nums, pivotIndex + <span class="number">1</span>, high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start = low</span><br><span class="line">    <span class="keyword">var</span> end = high</span><br><span class="line">    <span class="keyword">val</span> pivot = nums[start]</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] &gt;= pivot) &#123;</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] &lt;= pivot) &#123;</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[end] = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么partition()里的while判断条件里low不能等于high？</strong></p>
<p>因为一开始取pivot就已经挖空了一个位置。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>每次划分，轴心元素就在最终排序完成后的位置上。</p>
<h3 id="快排为什么是O-n-log-n-复杂度？"><a href="#快排为什么是O-n-log-n-复杂度？" class="headerlink" title="快排为什么是O(n log n)复杂度？"></a>快排为什么是O(n log n)复杂度？</h3><p>根据主定理推导。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22393997/answer/406278523">如何证明快速排序法的平均复杂度为 O(nlogn)？ - 知乎 </a></p>
<h3 id="什么会影响时间复杂度？"><a href="#什么会影响时间复杂度？" class="headerlink" title="什么会影响时间复杂度？"></a>什么会影响时间复杂度？</h3><p>用于划分数组的中枢元素的选择会影响时间复杂度，划分的左右子数组数量越接近效果越好，否则会让整个快速排序退化到O(n^2)级别。</p>
<p>具体怎么划分要根据数组本身的数据分布特性来决定</p>
<p>以下情况会变得低效：</p>
<p>（1）近乎有序的数列</p>
<p>对于一个近乎有序的数列，当直接使用第一个元素作为基准点的时候，将会导致划分的子数组大小差距太大，进而无法发挥快排划分的优势</p>
<p>（2）含有大量重复数据的数列</p>
<p>選取的數字如果是重複較多的數字，划分出的两个子数组有一边的长度会很大，因为移动指针的时候，判断条件是大于等于和小于等于枢纽元素</p>
<h3 id="如何优化时间复杂度？"><a href="#如何优化时间复杂度？" class="headerlink" title="如何优化时间复杂度？"></a>如何优化时间复杂度？</h3><p>针对近乎有序的数组：</p>
<p><strong>三数取中法</strong></p>
<p>选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间大的数交换到数列首位的位置，之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">LeetCode.75.颜色分类（中等）</a>正好就是用到这种方法。</p>
<p><strong>随机交换法</strong></p>
<p>选取基准点之前设计随机种子，通过随机函数得到一个在数列长度内的数，将这个随机数作为索引所指的数和第一个元素进行交换，之后将首位元素作为基准点。即随机选一个数放到首位的地方。这样一来，第一次就将最小的数交换到首位的概率是非常小的，第二次将次小的数交换到首位的概率依然非常的小。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h3 id="一句话说明"><a href="#一句话说明" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>堆就是一个完全二叉树，堆排序两步走：<br>建堆：从最后一个非叶子节点到根结点不停的向下调整堆。<br>排序调整：堆顶元素与数组末尾元素交换，再向下调整堆顶元素。</p>
<h3 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        buildHeap(nums)</span><br><span class="line">        <span class="comment">// 堆顶最大的元素与数组末尾的数字进行交换</span></span><br><span class="line">        <span class="comment">// 堆大小减1</span></span><br><span class="line">        <span class="comment">// 新的堆顶元素可能破坏最大堆性质，需要向下调整，把缩小后的堆的最大的元素放到堆顶</span></span><br><span class="line">        <span class="comment">// 重复如此最后堆大小缩减为0，原数组从末尾开始向前填充大的数，最后得到升序数组</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> nums.size downTo <span class="number">1</span>) &#123;</span><br><span class="line">            nums.swap(<span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">            sink(nums, <span class="number">1</span>, length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildHeap</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 给数组元素从1到n编号，最后一个非叶节点的编号为n/2</span></span><br><span class="line">        <span class="comment">// 从最后一个非叶节点开始往前不停的向下调整堆</span></span><br><span class="line">        <span class="comment">// 如果一个结点的左右子树已经是堆，从该结点向下调整后该结点为根结点的二叉树依然保持着堆的性质</span></span><br><span class="line">        <span class="comment">// 所以可以从下往上不停的向下调整</span></span><br><span class="line">        <span class="keyword">for</span> (parent <span class="keyword">in</span> n / <span class="number">2</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            sink(nums, parent, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对[nums]的第[k]个元素为根结点的子堆进行向下调整，把大的元素放到堆顶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要从[k]向下调整是因为[k]与孩子结点可能不满足堆性质</span></span><br><span class="line"><span class="comment">     * 初始时已经建立了堆，交换前我们可以认定k的左右子树都已经满足最大堆的性质，即k的左右子结点一定比它下面的所有结点值都大</span></span><br><span class="line"><span class="comment">     * 如果k当前比左右孩子最大的一个要小，当把k的左右孩子结点与k交换，依然满足k大于所有其孩子结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sink</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> parent = k</span><br><span class="line">        <span class="comment">// 最后一个非叶节点编号是length/2</span></span><br><span class="line">        <span class="comment">// parent初始时是在上层的结点，一直会往下遍历，一直遍历到最后一个非叶节点</span></span><br><span class="line">        <span class="keyword">while</span> (parent &lt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 找出较小的孩子结点child</span></span><br><span class="line">            <span class="keyword">var</span> child = parent * <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果child不是最后一个元素，对比下其相邻的孩子谁更大，取更大的孩子结点，以便接下来跟其父结点parent比较，检查是否满足最大堆的性质</span></span><br><span class="line">            <span class="keyword">if</span> (child &lt; length &amp;&amp; nums[child - <span class="number">1</span>] &lt; nums[child]) child++</span><br><span class="line">            <span class="comment">// 因为初始已经建了最大堆，我们可以认定parent的左右子树都已经满足堆的性质</span></span><br><span class="line">            <span class="comment">// 如果当前parent与child也满足堆性质，则不用继续调整了</span></span><br><span class="line">            <span class="comment">// 这里构建的是大顶堆，要求父结点比孩子结点要大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[parent - <span class="number">1</span>] &gt;= nums[child - <span class="number">1</span>]) <span class="keyword">break</span></span><br><span class="line">            <span class="comment">// 父结点比孩子结点小，不满足最大堆性质，交换父结点和孩子结点的值，以满足最大堆性质</span></span><br><span class="line">            nums.swap(parent - <span class="number">1</span>, child - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 交换后，以孩子结点child为根的子堆可能不满足最大堆性质，继续向下检查调整</span></span><br><span class="line">            parent = child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组IntArray的扩展函数swap，用以交换数组内两个位置[i]和[j]的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？"><a href="#堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？" class="headerlink" title="堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？"></a>堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？</h3><p>因为堆是一种完全二叉树，访问的数据不在内存中连续的区域，空间访问局部性效果不太好，缓存命中率低，进而降低了程序运行速度。</p>
<p>快速排序会访问数组相邻的元素，空间访问局部性比较好，程序运行速度快。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="一句话说明-1"><a href="#一句话说明-1" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>归并两个子数组为一个有序数组。</p>
<p>可以自顶向下递归进行，也可以自底向上迭代进行。</p>
<h3 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h3><p>自顶向下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下，分而治之</span></span><br><span class="line"><span class="comment">     * 类似于二叉树后序遍历的写法，理解二叉树后续遍历这个递归写法就好理解对应上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素的时候，low与high相等，只有一个数字的子数组认定是有序的，不需要再排序了</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            mergeSort(nums, low, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自底向上：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 从最小的子数组开始向上归并，最小的子数组长度是1，每次向上归并后子数组大小变为原来的两倍</span></span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (size &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 按照子数组的大小将长度为n的数组划分为n/size个子数组</span></span><br><span class="line">            <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 依次归并 n/size 个子数组</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; n - size) &#123;</span><br><span class="line">                <span class="comment">// 第一个子数组的右边界索引（包含）</span></span><br><span class="line">                <span class="keyword">val</span> mid = low + size - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 第二个子数组的右边界索引（包含），最后一个子数组可能只包含的元素个数较少，需要防止数组越界</span></span><br><span class="line">                <span class="keyword">val</span> high = min(low + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 归并两个子数组</span></span><br><span class="line">                merge(nums, low, mid, high)</span><br><span class="line">                <span class="comment">// 每次归并2个子数组，所以下一次归并发生在第三个子数组的位置</span></span><br><span class="line">                low += size * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            size *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h3 id="一句话说明-2"><a href="#一句话说明-2" class="headerlink" title="一句话说明"></a>一句话说明</h3><ol>
<li> 记录待排序数组每个取值的个数</li>
<li> 用一个数组累加记录有多少数是小于等于当前索引I</li>
<li> 逆序输出</li>
</ol>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> w = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [nums]取值范围在1到w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> copied = nums.copyOf()</span><br><span class="line">        <span class="keyword">val</span> count = IntArray(w + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 统计每个取值有多少个</span></span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            count[num]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加计数</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.w) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序遍历原数组，保持元素相对顺序不变</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> index = count[copied[i]] - <span class="number">1</span></span><br><span class="line">            nums[index] = copied[i]</span><br><span class="line">            count[copied[i]]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么最后要逆序遍历原数组？"><a href="#为什么最后要逆序遍历原数组？" class="headerlink" title="为什么最后要逆序遍历原数组？"></a>为什么最后要逆序遍历原数组？</h3><ol>
<li> 这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边，从而保证排序的稳定性</li>
<li> 如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法，但如果不关注稳定性，那么结果还是正确的</li>
</ol>
<p>保证相同的数字还是按照原数组中的顺序，保证稳定性</p>
<p>比如[1,2,3,4,5,5,5]</p>
<p>最后从后向前遍历原数组，3个5的输出顺序还是跟原数组的顺序是一致的</p>
<p>如果是从前向后输出，3个5的位置正好倒过来了，因为最终排序的索引是通过计数来得到的，计数是从大到小的，所以最后相同值的索引位置的计算是从大到小的，也就是说相同值的索引位置是从后往前的，如果顺序遍历原数组，遇到几个相同的数字，会先把前面的数字先放到后面了</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>O(n)时间复杂度</p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>数组取值范围是常数范围。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ACRA%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ACRA%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">崩溃收集 - ACRA原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-15 20:37:00" itemprop="dateCreated datePublished" datetime="2019-06-15T20:37:00+08:00">2019-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ACRA%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="源码分析/ACRA原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么选择ACRA做崩溃收集？"><a href="#为什么选择ACRA做崩溃收集？" class="headerlink" title="为什么选择ACRA做崩溃收集？"></a>为什么选择ACRA做崩溃收集？</h1><p>项目主页：<a target="_blank" rel="noopener" href="https://github.com/ACRA/acra">https://github.com/ACRA/acra</a></p>
<ol>
<li> ACRA历史悠久，github显示最早的4.2.3的版本是2011年7月2日。</li>
<li> Issues里不停的有人报问题，也在不停的发新的release，项目处于积极的持续维护的状态。</li>
<li>自定义性很强，框架所有功能都是可配置自定义的，也提供了服务端的标准实现。</li>
<li>使用广泛。ACRA is used in 1.57% (<a target="_blank" rel="noopener" href="https://www.appbrain.com/stats/libraries/details/acra/acra">See AppBrain/stats</a>) of all apps on Google Play as of June 2020. That’s over  <strong>13 thousand apps</strong>  and over  <strong>5 billion downloads</strong>  including ACRA.</li>
</ol>
<h1 id="Android上捕获崩溃的基本原理是什么？"><a href="#Android上捕获崩溃的基本原理是什么？" class="headerlink" title="Android上捕获崩溃的基本原理是什么？"></a>Android上捕获崩溃的基本原理是什么？</h1><p>通过Thread.setDefaultUncaughtExceptionHandler()设置一个UncaughtExceptionHandler，当有未捕获的异常出现时，会调用UncaughtExceptionHandler的uncaughtException(Thread,Throwable)</p>
<h1 id="ACRA框架大致原理"><a href="#ACRA框架大致原理" class="headerlink" title="ACRA框架大致原理"></a>ACRA框架大致原理</h1><ul>
<li>通过Thread.setDefaultUncaughtExceptionHandler()捕获崩溃异常对象。</li>
<li>调用配置的多个Collector收集崩溃发生时的环境信息，可以通过SPI注入自定义Collector收集想要的数据。</li>
<li>把异常堆栈和环境信息存储到文件。</li>
<li>立即开启新的进程上传文件。</li>
</ul>
<h1 id="为什么采用文件存储？"><a href="#为什么采用文件存储？" class="headerlink" title="为什么采用文件存储？"></a>为什么采用文件存储？</h1><p>这是跟崩溃的场景有关。</p>
<p>崩溃数据不会频繁产生，并且崩溃后立即上传，存储到文件直接上传文件是最方便的。</p>
<p>数据库存储主要针对批量查询或者复杂约束条件的场景，否则发挥不出来明显优势。<br>甚至有一定劣势，比如数据库如果损坏，所有信息都读取不到了，单个崩溃产生的文件如果损坏了不影响其他文件。</p>
<h1 id="为什么上传错误要在单独的进程里执行？"><a href="#为什么上传错误要在单独的进程里执行？" class="headerlink" title="为什么上传错误要在单独的进程里执行？"></a>为什么上传错误要在单独的进程里执行？</h1><p>因为崩溃要立刻上传，但是当前进程已经要停止了，网络请求耗时的话可能没有请求完就结束了，所以单独开一个进程做上传，不受崩溃进程的影响。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/ACRA/acra/issues/375">https://github.com/ACRA/acra/issues/375</a></p>
<h1 id="如何对崩溃做唯一标识以便统计崩溃次数？"><a href="#如何对崩溃做唯一标识以便统计崩溃次数？" class="headerlink" title="如何对崩溃做唯一标识以便统计崩溃次数？"></a>如何对崩溃做唯一标识以便统计崩溃次数？</h1><p>后端要对上传的崩溃做唯一性识别以统计同一个崩溃的次数。</p>
<p>把异常对象传递给 StacktraceCollector.getStackTraceHash(Throwable) 返回一个字符串，作为这个异常对象的唯一标识。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getStackTraceHash</span><span class="params">(<span class="meta">@Nullable</span> Throwable th)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Throwable cause = th;</span><br><span class="line">    <span class="keyword">while</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> StackTraceElement[] stackTraceElements = cause.getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> StackTraceElement e : stackTraceElements) &#123;</span><br><span class="line">            res.append(e.getClassName());</span><br><span class="line">            res.append(e.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">        cause = cause.getCause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Integer.toHexString(res.toString().hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历StackTraceElement数组，把每一个StackTraceElement的类名和方法名拼接为字符串，以字符串的hashCode为唯一标识。</p>
<p>也就是异常里的方法调用栈中的所有类名和方法名作为异常唯一标识。</p>
<h1 id="程序入口在哪？"><a href="#程序入口在哪？" class="headerlink" title="程序入口在哪？"></a>程序入口在哪？</h1><p>在自定义的Application的attachBaseContext()中调用ACRA.init(application);</p>
<h1 id="ACRA-init-application-做了什么？"><a href="#ACRA-init-application-做了什么？" class="headerlink" title="ACRA.init(application)做了什么？"></a>ACRA.init(application)做了什么？</h1><p>主要是在非崩溃发送的进程中，创建ErrorReporterImpl对象，保存为单例</p>
<h1 id="ErrorReporterImpl构造函数里做了什么？"><a href="#ErrorReporterImpl构造函数里做了什么？" class="headerlink" title="ErrorReporterImpl构造函数里做了什么？"></a>ErrorReporterImpl构造函数里做了什么？</h1><p>主要执行的逻辑：</p>
<ol>
<li> 创建了CrashReportDataFactory，并调用其collectStartUp()，收集App启动时的信息，如App启动时间</li>
<li> 调用了Thread.setDefaultUncaughtExceptionHandler()拦截崩溃处理</li>
<li> 如果checkReportsOnApplicationStart为true，就创建一个StartupProcessorExecutor，调用其processReports()，进行崩溃信息上报</li>
</ol>
<h1 id="CrashReportDataFactory-collectStartUp-做了什么？"><a href="#CrashReportDataFactory-collectStartUp-做了什么？" class="headerlink" title="CrashReportDataFactory.collectStartUp()做了什么？"></a>CrashReportDataFactory.collectStartUp()做了什么？</h1><p>CrashReportDataFactory构造函数里通过<code>CoreConfiguration.pluginLoader().loadEnabled(config,Collector.class)</code>加载出一个<code>List&lt;Collector&gt;</code>。</p>
<p>collectStartUp()在Collector列表中寻找ApplicationStartupCollector调用其collectApplicationStartUp()。</p>
<h1 id="Collector是什么？"><a href="#Collector是什么？" class="headerlink" title="Collector是什么？"></a>Collector是什么？</h1><p>所有崩溃相关的信息都是通过Collector来收集，实现类都在org.acra.collector包下，收集如线程信息、内存信息、堆栈信息等。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210829162713.png"></p>
<h1 id="ApplicationStartupCollector-collectApplicationStartUp-是做什么的？"><a href="#ApplicationStartupCollector-collectApplicationStartUp-是做什么的？" class="headerlink" title="ApplicationStartupCollector.collectApplicationStartUp()是做什么的？"></a>ApplicationStartupCollector.collectApplicationStartUp()是做什么的？</h1><p>在application启动时收集必要的信息，例如app启动时间</p>
<h1 id="CoreConfiguration-pluginLoader-loadEnabled-config-Collector-class-底层原理是什么？"><a href="#CoreConfiguration-pluginLoader-loadEnabled-config-Collector-class-底层原理是什么？" class="headerlink" title="CoreConfiguration.pluginLoader().loadEnabled(config,Collector.class)底层原理是什么？"></a>CoreConfiguration.pluginLoader().loadEnabled(config,Collector.class)底层原理是什么？</h1><h2 id="CoreConfiguration-pluginLoader-获取的是什么类？"><a href="#CoreConfiguration-pluginLoader-获取的是什么类？" class="headerlink" title="CoreConfiguration.pluginLoader()获取的是什么类？"></a>CoreConfiguration.pluginLoader()获取的是什么类？</h2><p>ACRA.init(application)里会创建一个CoreConfigurationBuilder对象，CoreConfigurationBuilder构造函数里会创建一个BaseCoreConfigurationBuilder，BaseCoreConfigurationBuilder构造函数里会创建一个ServicePluginLoader，这是默认的pluginLoader，外部可以通过CoreConfigurationBuilder.setPluginLoader来设置其他的pluginLoader。</p>
<h2 id="ServicePluginLoader-loadEnabled-做了什么？"><a href="#ServicePluginLoader-loadEnabled-做了什么？" class="headerlink" title="ServicePluginLoader.loadEnabled()做了什么？"></a>ServicePluginLoader.loadEnabled()做了什么？</h2><p>通过ServiceLoader.load(clazz, getClass().getClassLoader())利用ServiceLoader的SPI机制加载所有的Collector的实现类，只保留Collector.enabled()返回true的Collector，汇总成一个Collector列表，并返回。</p>
<h2 id="ServiceLoader机制是怎样的？"><a href="#ServiceLoader机制是怎样的？" class="headerlink" title="ServiceLoader机制是怎样的？"></a>ServiceLoader机制是怎样的？</h2><p>ServiceLoader.load(org.acra.collector.Collector.class)会去META-INF/services目录下寻找文件名为org.acra.collector.Collector的文件，文件里每一行都是org.acra.collector.Collector实现类的全限定名，然后ServiceLoader会把所有这个文件里指定的类都创建出来并返回。</p>
<p>用AutoService框架可以通过注解在实现类上标明接口，就可以避免自己手动创建META-INF/services下文件的繁琐过程，ACRA使用了AutoService，在所有Collector的实现类上都标明了@AutoService(Collector.class)。</p>
<h1 id="StartupProcessorExecutor的processReports-做了什么？"><a href="#StartupProcessorExecutor的processReports-做了什么？" class="headerlink" title="StartupProcessorExecutor的processReports()做了什么？"></a>StartupProcessorExecutor的processReports()做了什么？</h1><ol>
<li><p> StartupProcessorExecutor构造函数会创建ReportLocator对象，通过reportLocator.getUnapprovedReports()和reportLocator.getApprovedReports()获取待上传的崩溃信息的文件。</p>
</li>
<li><p> 通过config.pluginLoader().loadEnabled(config,StartupProcessor.class)获取一个List<StartupProcessor>，遍历调用processReports(reports)</p>
</li>
<li><p> StartupProcessor有两个子类，LimiterStartupProcessor、UnapprovedStartupProcessor</p>
</li>
<li><p> approved文件夹下有文件，就依次调用SchedulerStarter.scheduleReports() -&gt; DefaultSenderScheduler.scheduleReportSending() -&gt; SendingConductor.sendReports() -&gt; ReportDistributor.distribute() -&gt; ReportDistributor.sendCrashReport()，遍历所有的ReportSender并调用其send()发送上报</p>
</li>
</ol>
<p>根据ReportExecutor.execute(reportBuilder)的逻辑，approved目录下有文件，说明是要上报发送文件的，但是可能因为各种原因没有上报成功，所以这里重新发送。</p>
<h2 id="reportLocator-getUnapprovedReports-和reportLocator-getApprovedReports-的区别？"><a href="#reportLocator-getUnapprovedReports-和reportLocator-getApprovedReports-的区别？" class="headerlink" title="reportLocator.getUnapprovedReports()和reportLocator.getApprovedReports()的区别？"></a>reportLocator.getUnapprovedReports()和reportLocator.getApprovedReports()的区别？</h2><p>关于ACRA对日志文件位置的处理主要是ReportLocator来设置的。</p>
<p>acra内部使用文件对崩溃日志进行保存，该类用来获取文件夹的名字。</p>
<p>内部有两个文件夹acra-unapproved(未处理)，acra-approved(处理过)分别用来保存未处理及处理过的崩溃文件。</p>
<h2 id="unapproved和approved的崩溃文件分别是什么情况会产生？什么状态算approved？什么状态算unapproved？"><a href="#unapproved和approved的崩溃文件分别是什么情况会产生？什么状态算approved？什么状态算unapproved？" class="headerlink" title="unapproved和approved的崩溃文件分别是什么情况会产生？什么状态算approved？什么状态算unapproved？"></a>unapproved和approved的崩溃文件分别是什么情况会产生？什么状态算approved？什么状态算unapproved？</h2><p>通过Thread.UncaughtExceptionHandler拦截到崩溃异常后，会收集崩溃相关所有信息，存储到一个文件，文件位于unapproved文件夹下；</p>
<p>当决定要发送上传崩溃信息文件了，就会把崩溃信息文件从unapproved文件夹移动到approved文件夹，再上传approved文件夹下的文件里的信息。</p>
<p>ErrorReporterImpl实现了Thread.UncaughtExceptionHandler，具体做了什么？</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(<span class="meta">@Nullable</span> Thread t, <span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Generate and send crash report</span></span><br><span class="line">    <span class="keyword">new</span> ReportBuilder()</span><br><span class="line">            .uncaughtExceptionThread(t)</span><br><span class="line">            .exception(e)</span><br><span class="line">            .customData(customData)</span><br><span class="line">            .endApplication()</span><br><span class="line">            .build(reportExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReportBuilder的build()里其实是执行了reportExecutor.execute(reportBuilder)，在这个方法里实现了崩溃信息上报。</p>
<h1 id="ReportExecutor-execute-reportBuilder-做了什么？"><a href="#ReportExecutor-execute-reportBuilder-做了什么？" class="headerlink" title="ReportExecutor.execute(reportBuilder)做了什么？"></a>ReportExecutor.execute(reportBuilder)做了什么？</h1><p>常规逻辑主要如下：<br>    1. crashReportDataFactory.createCrashData(reportBuilder) 创建崩溃数据项<br>    2. saveCrashReportFile(reportFile, crashReportData) 保存崩溃数据到本地文件中<br>    3. sendReport(reportFile, executor.hasInteractions()) 根据初始化的配置是否立刻上报发送崩溃信息</p>
<h2 id="crashReportDataFactory-createCrashData-reportBuilder-做了什么？"><a href="#crashReportDataFactory-createCrashData-reportBuilder-做了什么？" class="headerlink" title="crashReportDataFactory.createCrashData(reportBuilder)做了什么？"></a>crashReportDataFactory.createCrashData(reportBuilder)做了什么？</h2><p>遍历所有的启用的Collector实现类，在单独的线程池里并发调用Collector的collect()方法收集信息，结果存到CrashReportData类中，CrashReportData以json存储信息。</p>
<h2 id="saveCrashReportFile-reportFile-crashReportData-做了什么？"><a href="#saveCrashReportFile-reportFile-crashReportData-做了什么？" class="headerlink" title="saveCrashReportFile(reportFile, crashReportData) 做了什么？"></a>saveCrashReportFile(reportFile, crashReportData) 做了什么？</h2><p>把crashReportData转为json字符串，写入ACRA-unapproved目录下的文件中</p>
<h2 id="sendReport-reportFile-executor-hasInteractions-做了什么？"><a href="#sendReport-reportFile-executor-hasInteractions-做了什么？" class="headerlink" title="sendReport(reportFile, executor.hasInteractions()) 做了什么？"></a>sendReport(reportFile, executor.hasInteractions()) 做了什么？</h2><p>把崩溃信息文件从ACRA-unapproved目录移动到ACRA-approved下</p>
<p>通过CoreConfiguration.reportSenderFactoryClasses()或CoreConfiguration.pluginLoader().loadEnabled(ReportSenderFactory.class)去加载ReportSenderFactory实现类，再创建ReportSender实例。</p>
<p>调用SchedulerStarter.scheduleReports() -&gt; DefaultSenderScheduler.scheduleReportSending() 。</p>
<p>如果ReportSender是要后台发送的就用JobSenderService执行，JobSenderService是运行在单独的:acra进程中，JobSenderService做的就是创建一个SendingConductor对象，并调用SendingConductor.sendReports() 。</p>
<p>如果是前台发送的就再依次调用SendingConductor.sendReports() -&gt; ReportDistributor.distribute() -&gt; ReportDistributor.sendCrashReport()，遍历所有的ReportSender并调用其send()发送上报。</p>
<p>ReportSender默认的实现有<br>    1. EmailIntentSender，通过Intent调起邮件App发送，前台发送<br>    2. HttpSender，Http网络请求发送上传，后台发送</p>
<h2 id="次要的逻辑有什么？"><a href="#次要的逻辑有什么？" class="headerlink" title="次要的逻辑有什么？"></a>次要的逻辑有什么？</h2><p>先获取所有ReportingAdministrator的实现类，ReportingAdministrator是控制是否应该发送崩溃报告，这里起作用的是LimitingReportAdministrator。</p>
<p>先调用ReportingAdministrator.shouldStartCollecting(context,config,reportBuilder)决定是否允许收集信息，也就是记录通过Thead.setDefaultUncaughtExceptionHandler()拦截到的崩溃异常，返回true表示允许，返回false表示不允许。允许的话就会调用crashReportDataFactory.createCrashData(reportBuilder)。</p>
<p>允许收集信息后，再调用ReportingAdministrator.shouldSendReport(crashReportData)决定是否应该上报，这里会把前面收集到的信息封装为crashReportData，传给shouldSendReport()决定是否应该上报这个崩溃信息。</p>
<p>如果ReportingAdministrator.shouldSendReport(crashReportData)返回false，即不允许发送崩溃报告，则调用ReportingAdministrator.notifyReportDropped()通知外部崩溃报告被丢弃，没有上报。</p>
<p><strong>ReportingAdministrator总体来说起到了发送崩溃报告时的拦截器的作用。</strong></p>
<h1 id="对特定功能处理过程交给拦截器处理，拦截器可以动态注入"><a href="#对特定功能处理过程交给拦截器处理，拦截器可以动态注入" class="headerlink" title="对特定功能处理过程交给拦截器处理，拦截器可以动态注入"></a>对特定功能处理过程交给拦截器处理，拦截器可以动态注入</h1><p>通过PluginLoader动态注入加载创建各种用户可扩展类，例如Collector、ConfigurationBuilderFactory、ReportingAdministrator、ReportInteraction、SenderSchedulerFactory、ReportSenderFactory、StartupProcessor。</p>
<p>PluginLoader可以在运行时手动load class（SimplePluginLoader），也可以通过ServiceLoad机制去动态加载（ServicePluginLoader）。</p>
<h1 id="Log、EventLog、DropboxLog之间的区别？"><a href="#Log、EventLog、DropboxLog之间的区别？" class="headerlink" title="Log、EventLog、DropboxLog之间的区别？"></a>Log、EventLog、DropboxLog之间的区别？</h1><p>在Logcat输出的日志主要是给App开发者看的。</p>
<p>EventLog和DropboxLog输出的日志主要是给平台开发者看的，区别在于EventLog不会保存到文件，DropBoxLog会保存到文件。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4434192/dropboxmanager-use-cases">https://stackoverflow.com/questions/4434192/dropboxmanager-use-cases</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B4%A9%E6%BA%83%E6%94%B6%E9%9B%86SDK%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B4%A9%E6%BA%83%E6%94%B6%E9%9B%86SDK%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F/" class="post-title-link" itemprop="url">设计一个崩溃收集SDK应该考虑哪些因素？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-15 20:37:00" itemprop="dateCreated datePublished" datetime="2019-06-15T20:37:00+08:00">2019-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B4%A9%E6%BA%83%E6%94%B6%E9%9B%86SDK%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="系统设计/设计一个崩溃收集SDK应该考虑哪些因素？/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计一个崩溃收集SDK应该考虑哪些因素？"><a href="#设计一个崩溃收集SDK应该考虑哪些因素？" class="headerlink" title="设计一个崩溃收集SDK应该考虑哪些因素？"></a>设计一个崩溃收集SDK应该考虑哪些因素？</h1><h2 id="包体积"><a href="#包体积" class="headerlink" title="包体积"></a>包体积</h2><p>核心框架保持尽可能精简，不依赖任何第三方库，保证增大集成SDK的App的体积。</p>
<p>需要依赖第三方库的功能，尽量设计为可插拔，让用户可选自行决策。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>作为一个全局性SDK，首先保证对App主功能没有影响。</p>
<p>其中最主要的是SDK绝对不能自己崩溃，所以不放心可以在关键逻辑都try catch。</p>
<p>其次是对CPU占用、网络带宽占用、电量消耗等App性能指标的影响要最低，保证SDK性能最高。</p>
<p>由于崩溃收集的逻辑，主要是运行在崩溃发生之后，所以对App常规使用是没有太大影响的。</p>
<h2 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h2><p>崩溃是很严重的事情，所以要尽可能早的把错误发送到服务端，最好是崩溃后立即上传数据。</p>
<h3 id="崩溃后上传数据没有网络怎么办？"><a href="#崩溃后上传数据没有网络怎么办？" class="headerlink" title="崩溃后上传数据没有网络怎么办？"></a>崩溃后上传数据没有网络怎么办？</h3><p>需要把数据持久化，下次一启动App就上传，保证尽可能的早。</p>
<h3 id="进程崩溃被杀，无法完成网络请求怎么办？"><a href="#进程崩溃被杀，无法完成网络请求怎么办？" class="headerlink" title="进程崩溃被杀，无法完成网络请求怎么办？"></a>进程崩溃被杀，无法完成网络请求怎么办？</h3><p>单独开一个进程做网络上传。</p>
<p>所以数据需要能够跨进程访问，可以把数据先持久化。</p>
<h2 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h2><p>由于上传数据时可能没有网络，就需要暂存数据。</p>
<p>由于崩溃的发生大多数情况下并不会很频繁，应当用文件存储，上传时直接上传文件，这样客户端实现很简单，后端存储和解析也都比较简单。</p>
<p>数据库对于大批量的数据插入、查询有优化，不是大批量数据优势就发挥的不明显。<br>并且如果数据库损坏，所有信息都查询不了。单个文件损坏，不会影响其他文件。</p>
<h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><p>文件中数据格式可以使用JSON或者ProtocolBuffer等紧凑的数据格式，减少数据流量。</p>
<p>key-value形式的存储，key可以用单词的缩写，减少数据占用。</p>
<p>在Android里使用ProtocolBuffer需要引入第三方库，会增大SDK体积；<br>虽然ProtocolBuffer比JSON序列化后占用空间更小，但是数据量不大，优势就不明显。并且网络上传时可以用GZIP压缩，压缩率也比较可观。<br>所以考虑使用JSON。</p>
<h2 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h2><p>作为任何一个需要上报数据的SDK，都需要考虑隐私性，主要是不能泄露用户隐私，上传用户个人识别信息。</p>
<p>那么有哪些泄露用户隐私的可能呢？</p>
<p>如果是SDK外部传入的参数，SDK本身没法控制，只能由SDK外部去控制，比如：</p>
<ul>
<li>可以自定义lint检查规则，禁止调用SDK的API时传入特定方法的返回值。</li>
<li>把隐私信息字符串构建为字典树，在传入参数的时候做匹配，然后过滤掉敏感词。</li>
</ul>
<p>但这两种方式都不能100%完全禁止泄露隐私信息，比如用户年龄、身高体重都是纯数字，字典树匹配很容易误杀，所以可能得先统一外部的API调用，这样方便做严格的集中控制，这又涉及到外部项目的代码规范了，这也是SDK倒逼项目规范的很好的需求。</p>
<p>在SDK内部可能有：</p>
<h3 id="异常message"><a href="#异常message" class="headerlink" title="异常message"></a>异常message</h3><p>异常堆栈里的异常message是用户可以自己传的，能自定义就有可能传递用户个人信息，最保险的做法是把message直接移除掉，Google Play管理后台和Google Anlaytics就是这么干的。</p>
<p>但这样很多时候不方便判断异常到底表示什么意思。</p>
<p>如果是手动抛出的异常，可以自定义一个异常类，表示特定类型的错误，这样方便识别具体错误。</p>
<h3 id="用户id"><a href="#用户id" class="headerlink" title="用户id"></a>用户id</h3><p>SDK层面如果需要区分用户，可以使用随机生成的UUID并保存到文件作为安装id来代替用户id，这是谷歌官方推荐的做法。</p>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>作为SDK</p>
<ul>
<li>核心逻辑要少改动才能保证不易出错、方便追查错误。</li>
<li>功能逻辑保持模块化、可配置，这样最灵活，可以使用JDK内置的SPI机制实现配置注入，或者通过Builder模式传入模块的Class来配置。</li>
</ul>
<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><h3 id="网络请求框架的选择"><a href="#网络请求框架的选择" class="headerlink" title="网络请求框架的选择"></a>网络请求框架的选择</h3><h5 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h5><p>从Android 4.4开始，HttpURLConnection内部实现通过调用okhttp完成。</p>
<p>Android源码：<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/okhttp/+/master">https://android.googlesource.com/platform/external/okhttp/+/master</a>.</p>
<h5 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h5><ul>
<li>底层基于Socket重新实现了一遍。</li>
<li>支持http2。</li>
<li>自动处理常见的网络问题。</li>
<li>API使用方便。</li>
</ul>
<h5 id="微信Mars"><a href="#微信Mars" class="headerlink" title="微信Mars"></a>微信Mars</h5><p>C实现，Android、iOS公用。<br>基于socket的解决方案，在网络调优方面具有跟强的主动性和可控性：</p>
<ul>
<li>  提供长连、短连两种网络通道；</li>
<li>  常规的网络能力，例如 DNS 防劫持、动态 IP 下发、就近接入、容灾恢复等；</li>
<li>  贴合移动互联网的网络层解决方案；</li>
<li>  贴合移动终端的平台特性：前后台、活跃态、休眠、省电、省流量等。</li>
</ul>
<h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><p>对性能不是有很严格的要求，可以选择HttpURLConnection，Okhttp的优化它都有。</p>
<h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ul>
<li>gzip压缩</li>
<li>httpdns防劫持、降低访问延迟。</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>设计思路、关键点罗列清楚，代码注释清晰，方便其他人排查问题、接手、改进。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>要保证SDK能适配各种机型的情况，所以要统计各种异常数据情况，针对性遇到的每个问题解决优化。</p>
<p>可以在灰度测试收集错误信息进行修正。</p>
<p>验证问题后，针对每一个错误编写单元测试，每次发布前自动化测试，保证过往问题不再重复出错。</p>
<p>减少错误就提高了准确性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%20%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%20%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">Kotlin 泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 20:23:00" itemprop="dateCreated datePublished" datetime="2018-12-06T20:23:00+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%20%E6%B3%9B%E5%9E%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin 泛型/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reified解决的是什么问题"><a href="#reified解决的是什么问题" class="headerlink" title="reified解决的是什么问题?"></a>reified解决的是什么问题?</h1><p>泛型会在编译后类型擦除，在运行时无法获得泛型类型T的类型信息。</p>
<p>想要在运行时获取泛型类型信息，需要使用reified和inline配合。</p>
<p>Kotlin编译器会将reified方法内联(inline)到调用的地方(call-site)。</p>
<p>方法被内联到调用的地方后，泛型T会被替换成具体的类型。</p>
<p>所以 reified 使得泛型的方法假装在运行时能够获取泛型的类信息。</p>
<p>这样不用为了获取泛型的类型再单独给方法传一个Class参数。</p>
<h1 id="协变是什么意思？"><a href="#协变是什么意思？" class="headerlink" title="协变是什么意思？"></a>协变是什么意思？</h1><p>带 extends 限定（上界）的通配符类型使得类型是协变的（covariant）。</p>
<h1 id="逆变是什么意思？"><a href="#逆变是什么意思？" class="headerlink" title="逆变是什么意思？"></a>逆变是什么意思？</h1><p>super限定的下界通配符使得类型是逆变的（contravariance）。</p>
<p>在 Java 中有 <code>List&lt;? super String&gt;</code> 是 <code>List&lt;Object&gt;</code>、<code>List&lt;String&gt;</code> 的一个超类。</p>
<h1 id="in和out关键字是做什么的？"><a href="#in和out关键字是做什么的？" class="headerlink" title="in和out关键字是做什么的？"></a>in和out关键字是做什么的？</h1><p>使用关键字 out 来支持协变，等同于 Java 中的上界通配符 ? extends。</p>
<p>使用关键字 in 来支持逆变，等同于 Java 中的下界通配符 ? super。</p>
<p>上界通配符用于读取，是产出东西给外面用，所以是out。</p>
<p>下界通配符用于修改，是生产东西存到容器里，所以是in。</p>
<p>消费者 in, 生产者 out。</p>
<h1 id="kotlin泛型中的where有什么作用？"><a href="#kotlin泛型中的where有什么作用？" class="headerlink" title="kotlin泛型中的where有什么作用？"></a>kotlin泛型中的where有什么作用？</h1><p>Java 中声明类或接口的时候，可以使用 extends 来设置边界，将泛型类型参数限制为某个类型的子集：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T的类型必须是 Animal 的子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="type">T extends Animal</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个和前面讲的声明变量时的泛型类型声明是不同的东西，这里并没有 ?。<br>同时这个边界是可以设置多个，用 &amp; 符号连接：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 的类型必须同时是 Animal 和 Food 的子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="type">T extends Animal &amp; Food</span>&gt;</span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin 只是把 extends 换成了 : 冒号。<br><code>class Monster&lt;T : Animal&gt;</code><br>设置多个边界可以使用 where 关键字：<br><code>class Monster&lt;T&gt; where T : Animal, T : Food</code><br>有人在看文档的时候觉得这个 where 是个新东西，其实虽然 Java 里没有 where ，但它并没有带来新功能，只是把一个老功能换了个新写法。</p>
<p>不过笔者觉得 Kotlin 里 where 这样的写法可读性更符合英文里的语法，尤其是如果 Monster 本身还有继承的时候：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="type">T</span>&gt; : <span class="type">MonsterParent</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">    <span class="keyword">where</span> T : Animal</span><br></pre></td></tr></table></figure>

<h1 id="实现一个-fill-函数，传入一个-Array-和一个对象，将对象填充到-Array-中，要求-Array-参数的泛型支持逆变（假设-Array-size-为-1）"><a href="#实现一个-fill-函数，传入一个-Array-和一个对象，将对象填充到-Array-中，要求-Array-参数的泛型支持逆变（假设-Array-size-为-1）" class="headerlink" title="实现一个 fill 函数，传入一个 Array 和一个对象，将对象填充到 Array 中，要求 Array 参数的泛型支持逆变（假设 Array size 为 1）"></a>实现一个 fill 函数，传入一个 Array 和一个对象，将对象填充到 Array 中，要求 Array 参数的泛型支持逆变（假设 Array size 为 1）</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">fill</span><span class="params">(to: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, from: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    to[<span class="number">0</span>] = from</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现一个-copy-函数，传入两个-Array-参数，将一个-Array-中的元素复制到另外个-Array-中，要求-Array-参数的泛型分别支持协变和逆变。"><a href="#实现一个-copy-函数，传入两个-Array-参数，将一个-Array-中的元素复制到另外个-Array-中，要求-Array-参数的泛型分别支持协变和逆变。" class="headerlink" title="实现一个 copy 函数，传入两个 Array 参数，将一个 Array 中的元素复制到另外个 Array 中，要求 Array 参数的泛型分别支持协变和逆变。"></a>实现一个 copy 函数，传入两个 Array 参数，将一个 Array 中的元素复制到另外个 Array 中，要求 Array 参数的泛型分别支持协变和逆变。</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    assert(from.size == to.size)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> from.indices) &#123;</span><br><span class="line">        to[i] = from[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%E5%86%85%E8%81%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%E5%86%85%E8%81%94/" class="post-title-link" itemprop="url">Kotlin 内联</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 21:15:00" itemprop="dateCreated datePublished" datetime="2018-12-05T21:15:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%E5%86%85%E8%81%94/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin内联/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="inline、noinline、crossline区别？"><a href="#inline、noinline、crossline区别？" class="headerlink" title="inline、noinline、crossline区别？"></a>inline、noinline、crossline区别？</h1><p>inline：编译时把inline函数的代码拷贝到调用处</p>
<p>noinline：修饰inline标记的函数的形参，不希望内联lambda</p>
<p>crossline：inline函数中的lambda表达式不允许返回到外部函数，只能返回到lambda表达式</p>
<h1 id="inline作用"><a href="#inline作用" class="headerlink" title="inline作用"></a>inline作用</h1><p>Java中没有函数的概念，Kotlin中的lambda表达式在Java中对应的是一个FunctionN的单个方法的接口类，创建一个lambda表达式相当于创建一个类。</p>
<p>inline可以修饰函数，inline修饰的函数的形参中有lambda表达式，编译时不会创建对应的FunctionN类，而是直接把lambda表达式代码拷贝到调用处，这样</p>
<ol>
<li> 在循环等高频使用一个函数的场景下，内联lambda表达式避免了频繁创建对象，不仅节约了内存，也避免了频繁的垃圾回收，减少系统卡顿</li>
<li> 减少了函数调用层级，函数调用栈少了一层，减少了性能损耗</li>
</ol>
<h1 id="inline会造成什么问题？"><a href="#inline会造成什么问题？" class="headerlink" title="inline会造成什么问题？"></a>inline会造成什么问题？</h1><ol>
<li> 调用处的代码变多，所以不能内联代码量过大的函数，只适用于内联代码量小的函数</li>
<li> 我们可以在inline函数形参的 lambda 表达式 中调用return直接返回外部函数，可能会导致inline函数之后的代码无法执行；需要使用return@label的语法，返回到lambda开始执行的位置</li>
<li> 内联后的lambda表达式已经不是对象了，所以无法作为参数传递、存储在字段中、作为返回值return，需要加noinline解决</li>
</ol>
<h1 id="noinline作用"><a href="#noinline作用" class="headerlink" title="noinline作用"></a>noinline作用</h1><p>修饰inline函数的形参中的lambda表达式，表示禁止该lambda表达式内联</p>
<h1 id="noinline禁止lambda表达式内联的意义是什么？"><a href="#noinline禁止lambda表达式内联的意义是什么？" class="headerlink" title="noinline禁止lambda表达式内联的意义是什么？"></a>noinline禁止lambda表达式内联的意义是什么？</h1><p>内联后的lambda表达式已经不是对象了，所以无法作为对象使用，也就是无法对其进行参数传递、存储在字段中、作为返回值return，需要加noinline解决</p>
<h1 id="crossinline作用"><a href="#crossinline作用" class="headerlink" title="crossinline作用"></a>crossinline作用</h1><p>既想让内联函数形参中的 lambda 也被 inline，但是又不想让 lambda 对调用方的控制流程产生影响（lambda中return会影响），就用crossline</p>
<p>crossinline依然是内联的</p>
<p>直接在lambda表达式中返回外部函数的情况称为非局部返回。</p>
<p>crossinline修饰的lambda禁止了非局部返回</p>
<h1 id="crossinline为什么要禁止非局部返回？不禁止会有什么问题？"><a href="#crossinline为什么要禁止非局部返回？不禁止会有什么问题？" class="headerlink" title="crossinline为什么要禁止非局部返回？不禁止会有什么问题？"></a>crossinline为什么要禁止非局部返回？不禁止会有什么问题？</h1><p>内联函数形参中的lambda表达式可能会在另外一个调用栈中执行，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(<span class="keyword">crossinline</span> body: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f = <span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = body()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下内联的lambda允许非局部返回，返回的是内联函数调用处的函数，但是不在一个调用栈中，非局部返回就无法做到这样的返回，所以必须禁止，用crossinline来禁止非局部返回，但仍然保持内联的特性，把lambda表达式的代码展开铺平。</p>
<h1 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h1><ul>
<li>内联函数，可以消除函数调用的开销。</li>
<li>内联类，则是可以消除创建对象的开销。</li>
</ul>
<p>用途：</p>
<ul>
<li>严格的类型别名</li>
<li>任何你想得到的包装类（wrapper）</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://aisia.moe/2018/07/03/inline-class/">Kotlin 1.3 前瞻之 Inline Class</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%E7%A9%BA%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%E7%A9%BA%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">Kotlin 空安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-03 20:13:00" itemprop="dateCreated datePublished" datetime="2018-12-03T20:13:00+08:00">2018-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%E7%A9%BA%E5%AE%89%E5%85%A8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin空安全/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kotlin调Java可能返回为空的函数"><a href="#Kotlin调Java可能返回为空的函数" class="headerlink" title="Kotlin调Java可能返回为空的函数"></a>Kotlin调Java可能返回为空的函数</h1><p>Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。</p>
<p>当把一个平台值赋值给一个 Kotlin 变量时，可以选择我们期望的类型（可空或非空类型）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nullable: String? = item <span class="comment">// 允许，没有问题</span></span><br><span class="line"><span class="keyword">val</span> notNull: String = item <span class="comment">// 允许，运行时可能失败</span></span><br></pre></td></tr></table></figure>
<p>如果我们选择非空类型，编译器会在赋值时触发一个断言。这防止 Kotlin 的非空变量保存空值。当我们把平台值传递给期待非空值等的 Kotlin 函数时，也会触发断言。 总的来说，编译器尽力阻止空值通过程序向远传播（尽管鉴于泛型的原因，有时这不可能完全消除）。</p>
<p>如果我们选择非空类型，编译器会在赋值时触发一个断言。这防止 Kotlin 的非空变量保存空值。当我们把平台值传递给期待非空值等的 Kotlin 函数时，也会触发断言。 总的来说，编译器尽力阻止空值通过程序向远传播。</p>
<p>只有在Java层给方法加上<code>@Nullable</code>之后才会提示返回值可空。</p>
<h1 id="空安全实际遇到的问题"><a href="#空安全实际遇到的问题" class="headerlink" title="空安全实际遇到的问题"></a>空安全实际遇到的问题</h1><p>一开始有一个Java的旧类，一直没有改动过，但是有需求要有不同的实现，所以需要把类的各个方法抽象为接口，接口类用Kotlin实现，接口的实现类还是原来的Java类，其中有个方法在Kotlin的接口中返回值是非空的String，java实现类中返回值是String，但是没有加@NotNull的注解，也就是可空的。</p>
<p>在实际调用这个方法的时候，当java实现类中返回null，就会报空指针异常。</p>
<h1 id="Nullable注解应该是哪个库哪个包的注解？"><a href="#Nullable注解应该是哪个库哪个包的注解？" class="headerlink" title="Nullable注解应该是哪个库哪个包的注解？"></a>Nullable注解应该是哪个库哪个包的注解？</h1><p>具有可空性注解的Java类型并不表示为平台类型，而是表示为实际可空或非空的 Kotlin 类型。编译器支持多种可空性注解，包括：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html">JetBrains</a> （org.jetbrains.annotations 包中的 @Nullable 和 @NotNull）</p>
</li>
<li><p>  Android（com.android.annotations 和 android.support.annotations)</p>
</li>
<li><p>  JSR-305（javax.annotation，详见下文）</p>
</li>
<li><p>  FindBugs（edu.umd.cs.findbugs.annotations）</p>
</li>
<li><p>  Eclipse（org.eclipse.jdt.annotation）</p>
</li>
<li><p>  Lombok（lombok.NonNull）。</p>
</li>
</ul>
<p>你可以在 <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt">Kotlin 编译器源代码</a>中找到完整的列表。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/java-interop.html#%E7%A9%BA%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B">Kotlin官方文档：空安全和平台类型</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%E4%B8%BA%E4%BD%95%E5%BA%9F%E5%BC%83checked%E5%BC%82%E5%B8%B8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%E4%B8%BA%E4%BD%95%E5%BA%9F%E5%BC%83checked%E5%BC%82%E5%B8%B8%EF%BC%9F/" class="post-title-link" itemprop="url">Kotlin为何废弃checked异常？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-02 20:13:00" itemprop="dateCreated datePublished" datetime="2018-12-02T20:13:00+08:00">2018-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 23:38:24" itemprop="dateModified" datetime="2021-08-31T23:38:24+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%E4%B8%BA%E4%BD%95%E5%BA%9F%E5%BC%83checked%E5%BC%82%E5%B8%B8%EF%BC%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin为何废弃checked异常？/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？"><a href="#kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？" class="headerlink" title="kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？"></a>kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？</h1><p>Kotlin 在官网给出了一些解释，大概的意思是Checked Exception 在项目小的时候确实能够提升效率和代码质量，但是在大型项目中却会降低代码质量。</p>
<p>关于CE，Anders Hejlsberg认为它带来了两个问题版本问题和扩展问题。</p>
<h2 id="所谓的版本问题是什么意思呢？"><a href="#所谓的版本问题是什么意思呢？" class="headerlink" title="所谓的版本问题是什么意思呢？"></a>所谓的版本问题是什么意思呢？</h2><p>Anders Hejlsberg举了一个例子：</p>
<p>假设有一个方法foo，它声明了抛出异常A、B和C，在下一个版本设计的时候，foo增加了一个新的特性，可能会抛出异常D。对于设计者来说，很明显这是一个大的改变，几乎可以确定的是，客户程序员不会去处理这个异常。为了避免出现问题，设计者不得不声明一个新的方法foo2，抛出一个新的异常。然后，客户程序员可以将针对foo的逻辑处理切换到foo2。</p>
<h2 id="所谓的扩展问题又是什么意思呢？"><a href="#所谓的扩展问题又是什么意思呢？" class="headerlink" title="所谓的扩展问题又是什么意思呢？"></a>所谓的扩展问题又是什么意思呢？</h2><p>以下来自Anders Hejlsberg的原话翻译并整理：</p>
<p>如果你在设计一个很小的系统，声明一个方法抛出一个异常，这很棒。可是，如果你尝试构建一个大的系统，其中包含了四、五个小系统的时候，问题来了。假设每个子系统可能抛出四到五个异常，而每上升一个系统，就犹如爬阶梯，异常数量会指数倍增加，最终你可能处理的异常将达到40个甚至80个。很显然，这是一个很糟糕的设计！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上，异常其实是发生在实现阶段，而不是定义阶段，既要在明确实现阶段的异常又要有灵活的实现是相悖的。</p>
<p>所以 Kotlin 选择抛弃 Checked Exception，靠工程师来处理，这的确增加了 Kotlin 编写的难度，但也对大型项目更加友好，并且可以增加开发速度。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/exceptions.html">https://www.kotlincn.net/docs/reference/exceptions.html</a></li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/exceptions.html">https://kotlinlang.org/docs/reference/exceptions.html</a></li>
<li><a target="_blank" rel="noopener" href="http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">Java’s checked exceptions were a mistake</a> (Rod Waldhoff)</li>
<li><a target="_blank" rel="noopener" href="http://www.artima.com/intv/handcuffs.html">The Trouble with Checked Exceptions</a> (Anders Hejlsberg)</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/58639126/whats-the-idea-behind-kotlin-removing-checked-exceptions">What’s the idea behind Kotlin removing checked exceptions?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">184</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">240</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
