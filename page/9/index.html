<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/9/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/B%E6%A0%91%E3%80%81B+%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/B%E6%A0%91%E3%80%81B+%E6%A0%91/" class="post-title-link" itemprop="url">B树、B+树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-05 20:00:00" itemprop="dateCreated datePublished" datetime="2020-07-05T20:00:00+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/B%E6%A0%91%E3%80%81B+%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/B树、B+树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="B和B-里的B是什么意思"><a href="#B和B-里的B是什么意思" class="headerlink" title="B和B+里的B是什么意思?"></a>B和B+里的B是什么意思?</h1><p>B是Balanced的缩写，平衡的意思。</p>
<p>全称可以叫多路（多叉）平衡查找（搜索）树。</p>
<h2 id="多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？"><a href="#多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？" class="headerlink" title="多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？"></a>多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？</h2><p>由于平衡二叉查找树只有两个分叉，查询叶子结点需要访问$log_2{n}$次节点，即树的高度。</p>
<p>如果要减少查找次数，就要让树变矮一点。</p>
<p>那么一个节点有多个分叉，同时让一个节点存储多个值，就可以降低树的高度，进而减少节点平均的访问次数。</p>
<h2 id="减少节点的访问次数有什么好处？"><a href="#减少节点的访问次数有什么好处？" class="headerlink" title="减少节点的访问次数有什么好处？"></a>减少节点的访问次数有什么好处？</h2><p>访问节点的成本可能非常大，减少访问节点的次数，就可以降低总的访问成本。</p>
<p>例如访问IO比访问内存要慢的多，文件系统中普遍采用多路平衡查找树作为存储数据的结构。</p>
<h2 id="B树与B-的区别？"><a href="#B树与B-的区别？" class="headerlink" title="B树与B+的区别？"></a>B树与B+的区别？</h2><p>B树与B+共同点：</p>
<ol>
<li> 都是一个节点按顺序存储多个值</li>
<li> 每个节点可以有多个分叉</li>
</ol>
<p>B树独有：</p>
<ol>
<li> 非叶子节点存储了数据，非叶子节点占用空间更大</li>
</ol>
<p>B+树独有：</p>
<ol>
<li> 非叶子节点不存数据只存索引信息，数据全部在叶子节点，非叶子节点占用空间更小</li>
<li> 叶子结点用双向链表相连，便于顺序查找</li>
</ol>
<h2 id="B-树作为数据库索引有什么优势？"><a href="#B-树作为数据库索引有什么优势？" class="headerlink" title="B+树作为数据库索引有什么优势？"></a>B+树作为数据库索引有什么优势？</h2><p>非叶子结点的大小可以设置为一页，内存从外存读取数据是按页读取的，这样就减少了IO访问次数。</p>
<p>结点内部是有序的，可以再用二分查找去查找元素。</p>
<p>B+树的非叶子结点不存储数据，只存键，这样同样空间大小可以存的键就更多，非叶子结点的数量就会减少，IO访问次数也就变少了。</p>
<p>B+树的叶子结点用双链表链接，这样对区间查询友好，只需要通过非叶结点查找到区间范围，然后顺序遍历即可，可以减少对非叶结点的访问，进而减少IO访问次数。因为由于虚拟内存机制，非叶结点加载到内存后，可能也会被置换到外存，减少对非叶结点的访问次数，也就降低了置换次数，置换是需要IO访问的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">为什么 MySQL 使用 B+ 树</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/svL_yNmNJ-wj9aGjtO_Yww">拜托，别再问我什么是B+树 了</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21993785/java/article/details/80580679">B+Tree在数据库索引上拥有独特优势的原因（为什么比红黑树更合适）</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/" class="post-title-link" itemprop="url">红黑树、AVL树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-04 20:00:00" itemprop="dateCreated datePublished" datetime="2020-07-04T20:00:00+08:00">2020-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/黑树、AVL树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"><a href="#普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？" class="headerlink" title="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"></a>普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？</h2><p>普通的二叉查找树最坏情况下会退化为一个链表，查找元素的时间复杂度由log_2{n}退化到n。</p>
<p>解决时间复杂度退化，就是要让树的高度始终保持尽可能的小，平衡二叉查找树就是让任意节点的左右子树高度都平衡（差的不多）的二叉查找树，这样查找元素的平均时间复杂度可以保持在log_2{n}，</p>
<h2 id="有哪些平衡二叉查找树？"><a href="#有哪些平衡二叉查找树？" class="headerlink" title="有哪些平衡二叉查找树？"></a>有哪些平衡二叉查找树？</h2><p>AVL树、2-3树、红黑树</p>
<h2 id="为什么流行的主要是这几个树？"><a href="#为什么流行的主要是这几个树？" class="headerlink" title="为什么流行的主要是这几个树？"></a>为什么流行的主要是这几个树？</h2><p>因为逻辑比较简单，易于实现，效率也就高。</p>
<h2 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h2><p>任意结点左右子树高度差小于或等于1。</p>
<p>由Adelson-Velskii 以及 Landis发明，故而叫AVL。</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>定义：</p>
<ul>
<li>在满足二叉查找树的性质基础上，一个结点最多可以存储2个键，可以有3个孩子结点。</li>
<li>2结点里存储1个键，可以有2个孩子结点</li>
<li>3结点里存储2个键，可以有3个孩子结点</li>
</ul>
<p>特点</p>
<ul>
<li>2-3树是完美平衡的，任意结点的左右子树高度相等，这可以分析所有插入的情况来证明。</li>
</ul>
<p>自下而上生长：</p>
<ul>
<li>插入位置在2结点中，直接插入，变为3结点。</li>
<li>插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）。<ul>
<li>如果父结点本来是2结点，现在就变成了3结点。</li>
<li>如果父结点本来是3结点，现在就变成了4结点，继续提升的过程。</li>
<li>如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点。</li>
</ul>
</li>
</ul>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1。</p>
<p>一颗含有n个节点的2-3树的高度在log_3{n}（全是3结点）到log_2{n}（全是2结点）之间。</p>
<p>每次插入后调整结点都是局部的，最坏情况下，一条路径上都是3结点，从叶结点插入新键后，会从叶结点一直调整到根结点，调整次数不会超过对数级别。</p>
<p>10亿个结点的2-3树高度仅在19到30之间，性能较高。</p>
<p>各种操作实现较为复杂。</p>
<h2 id="为什么2-3树可以保持完美平衡？"><a href="#为什么2-3树可以保持完美平衡？" class="headerlink" title="为什么2-3树可以保持完美平衡？"></a>为什么2-3树可以保持完美平衡？</h2><p>这可以分析所有插入的情况来证明。</p>
<p>自下而上生长</p>
<ol>
<li><p> 插入位置在2结点中，直接插入，变为3结点</p>
</li>
<li><p> 插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）</p>
</li>
<li><p> 如果父结点本来是2结点，现在就变成了3结点</p>
</li>
<li><p> 如果父结点本来是3结点，现在就变成了4结点，继续提升的过程</p>
</li>
<li><p> 如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点</p>
</li>
</ol>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>实现较为简单，综合性能好。</p>
<p>把2-3树的3结点表示为左斜的红色链接相连的两个2结点，其中一个结点是另一个结点的左子结点，其他链接为黑色链接。</p>
<p>红黑树既是二叉查找树也是2-3树。</p>
<p>等价定义（《算法》第4版 275页 3.3.2.1）：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>红黑树的几条定义都是为了让红黑树满足2-3树的结构。</p>
<p>如果让2-3树中所有链接都为黑色，由于2-3树是完美平衡的，红黑树中红色链接代表3结点，所以红黑树中的黑色链接是完美平衡的。</p>
<p>再把2-3树中的3结点都分解为两个用红色链接相连的2结点，那么不会存在一个结点同时与两条红色链接相连，这一点保证了红色链接是3结点。</p>
<p>对红黑树插入、删除元素后，不满足红黑树的定义，都要通过旋转操作来修正。</p>
<p>红黑树的旋转操作修正，都是符合2-3树的修正的规则的，理解记住了2-3树的各种调整规则，就知道了红黑树各种操作的意义。</p>
<h2 id="红黑树是怎么发明出来的？"><a href="#红黑树是怎么发明出来的？" class="headerlink" title="红黑树是怎么发明出来的？"></a>红黑树是怎么发明出来的？</h2><p>它在1972年由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%B2%81%E9%81%93%E5%A4%AB%C2%B7%E8%B4%9D%E5%B0%94">鲁道夫·贝尔</a>发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Robert_Sedgewick">Robert Sedgewick</a>于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1978%E5%B9%B4">1978年</a>写的一篇论文。</p>
<p>红黑树等同于2-3-4树，是2-3-4树的二叉表现形式。</p>
<p>2-3-4树是B树的一种情况。</p>
<p>红黑树结点的颜色表明了当前结点是否属于2-3-4树中的3结点或4结点。</p>
<p>2-3-4树的情况讨论比较复杂，  用2-3树讨论情况较少，可以方便理解。</p>
<hr>
<h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>《算法》第4版 275页 3.3.2.1 定义：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>《算法导论》273页  第13章  红黑树  定义：</p>
<ol>
<li> 节点是红色或黑色</li>
<li> 根节点是黑色</li>
<li> 叶节点是黑色</li>
<li> 红节点的两个子节点都是黑色</li>
<li> 任意节点到叶节点的所有路径上的黑色节点数相同</li>
</ol>
<h2 id="红黑树为什么要这样定义？"><a href="#红黑树为什么要这样定义？" class="headerlink" title="红黑树为什么要这样定义？"></a>红黑树为什么要这样定义？</h2><p>红黑树的几条定义都是为了让红黑树满足2-3树的结构，红黑树是2-3树的一种表示形式，而2-3树是完美平衡的，这样红黑树也是黑色平衡的，2-3树比较难以实现，红黑树比较方便实现。</p>
<h2 id="为什么要用红黑树表示2-3树？"><a href="#为什么要用红黑树表示2-3树？" class="headerlink" title="为什么要用红黑树表示2-3树？"></a>为什么要用红黑树表示2-3树？</h2><ul>
<li>因为2-3树是完美平衡的，任意结点的子树没有高度差。</li>
<li>2-3树的实现较为复杂，红黑树的实现较为简单。</li>
</ul>
<h2 id="红黑树的数据结构如何定义？"><a href="#红黑树的数据结构如何定义？" class="headerlink" title="红黑树的数据结构如何定义？"></a>红黑树的数据结构如何定义？</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">Key : Comparable&lt;Key</span>&gt;, <span class="type">Value&gt;</span></span>(</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 父结点指向本结点的链接颜色，用以标明本结点对应2-3树中的2结点还是3结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> color: Color,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字。用于比较来确定数据的顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> key: Key,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关联的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> value: Value,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> left: Node&lt;Key, Value&gt;? = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> right: Node&lt;Key, Value&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    BLACK, RED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树插入新元素后调整结点的操作规则是怎样的？"><a href="#红黑树插入新元素后调整结点的操作规则是怎样的？" class="headerlink" title="红黑树插入新元素后调整结点的操作规则是怎样的？"></a>红黑树插入新元素后调整结点的操作规则是怎样的？</h2><p>原则：所有操作跟2-3树能逐一对应，保证树的有序性和完美平衡性。</p>
<p>插入新结点先按普通的二叉查找树插入新结点那样进行插入。</p>
<p>普通的二叉查找树插入新元素有三种情况：</p>
<ol>
<li> 树中没有结点，插入的新结点作为根结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的左子结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的右子结点</li>
</ol>
<p>在红黑树中，结点h又可以分为两种情况</p>
<ol>
<li> 结点h是2结点</li>
<li>结点h位于3结点中<ol>
<li> 结点h是红链接左下的结点</li>
<li> 结点h是红链接右上的结点</li>
</ol>
</li>
</ol>
<p>插入新结点要默认新结点的颜色是红色，表示新结点到父节点的链接是红色，这样与2-3树的插入就可以对应上。</p>
<p>在2-3树中如果插入在2结点中，2结点变为3结点，就不再调整；如果插入的在3结点中，3结点临时变为4结点，再把4结点的中间键放入父结点中，左右两边的键分解为两个2结点与父结点相连。</p>
<p>处理这些情况的组合，就是所有的插入情况，针对不符合2-3树的结构的情况进行调整。</p>
<ul>
<li>结点h是2结点<ul>
<li>新结点是h的左子结点，相当于新结点和结点h组成了2-3树中的3结点，符合2-3树的结构，无需调整</li>
<li>新结点是h的右子结点，相当于新结点和结点h组成了2-3树中的3结点，但我们规定红链接要保持左斜，以减少考虑的情况数量，所以要进行左旋转</li>
</ul>
</li>
<li>结点h位于3结点中，新结点的位置有三种情况：左、中、右<ul>
<li>结点h是红链接左下的结点<ul>
<li>新结点是h的左子结点，此时有了两条连续的红链接，连接的3个结点对应2-3树中临时的4结点，需要把中间的键放入父结点，再把两边的键拆为两个2结点分别与父结点相连，所以操作是先右旋，再变换颜色</li>
<li>新结点是h的右子结点</li>
</ul>
</li>
<li>结点h是红链接右上的结点<ul>
<li>新结点是h的右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有三种标准操作：左旋、右旋、颜色转换</p>
<h2 id="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"><a href="#为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？" class="headerlink" title="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"></a>为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？</h2><p>只允许红色的左链接可以减少讨论的情景数量，进而简化代码的实现。</p>
<h2 id="红黑树最坏情况下高度是多少？"><a href="#红黑树最坏情况下高度是多少？" class="headerlink" title="红黑树最坏情况下高度是多少？"></a>红黑树最坏情况下高度是多少？</h2><p>有n个结点的红黑树高度最多为 $2 * log_2{n}$</p>
<p>由于2-3树中的3结点是由左斜红链接连接的两个结点表示的，最坏情况下最左侧路径全部都是红链接，对应2-3树中最左侧都是3结点，其他结点都是2结点。</p>
<p>参考《算法导论》中的证明：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lanchunhui/java/article/details/75905478">红黑树相关定理及其证明
</a></p>
<h2 id="红黑树的各种操作的时间复杂度是多少？"><a href="#红黑树的各种操作的时间复杂度是多少？" class="headerlink" title="红黑树的各种操作的时间复杂度是多少？"></a>红黑树的各种操作的时间复杂度是多少？</h2><p>设红黑树有n个结点，查找、插入、修改、删除操作的时间复杂度均为O(log n)</p>
<p>查找：</p>
<ul>
<li>最长路径长度不会超过最短路径长度的2倍，查找仍然是对数级别</li>
</ul>
<p>插入：</p>
<ul>
<li>最坏情况下待插入的位置在叶结点，需要从根结点遍历到叶结点，同时最坏情况下遍历的路径都是红链接（路径上都是3结点），此时会从叶结点一直回溯调整结点到根结点，访问次数是2倍的树的高度，而树的高度为log_2{n}</li>
</ul>
<h2 id="红黑树较于AVL树有什么优点？"><a href="#红黑树较于AVL树有什么优点？" class="headerlink" title="红黑树较于AVL树有什么优点？"></a>红黑树较于AVL树有什么优点？</h2><p>单次操作：</p>
<ul>
<li>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</li>
<li>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</li>
</ul>
<p>大量的插入和删除操作：</p>
<ul>
<li>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</li>
<li>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</li>
</ul>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎 </a></li>
</ul>
<h2 id="什么时候用AVL树？"><a href="#什么时候用AVL树？" class="headerlink" title="什么时候用AVL树？"></a>什么时候用AVL树？</h2><p>AVL树平衡性非常好，左右子树高度差不超过1，所以查找次数少。</p>
<p>对于查找非常频繁，插入、修改、删除不频繁的场景，可以使用AVL树。</p>
<h2 id="并发下的问题"><a href="#并发下的问题" class="headerlink" title="并发下的问题"></a>并发下的问题</h2><p>并发情况下，由于平衡搜索树的调整可能要锁整个树。</p>
<p>用跳表这种性能接近于平衡树的数据结构，操作更加局部性，不会锁住太多结点，有利于并发的性能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuchanming/p/4444961.html">面试题——轻松搞定面试中的红黑树问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/6111175.html">从2-3-4树到红黑树（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30527705/answer/259948086">AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？ - 韦易笑的回答 - 知乎 </a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">LZ77算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-03 20:00:00" itemprop="dateCreated datePublished" datetime="2020-07-03T20:00:00+08:00">2020-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/LZ77算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"><a href="#LZ77和哈夫曼编码区别？适用场景上有有什么不同？" class="headerlink" title="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"></a>LZ77和哈夫曼编码区别？适用场景上有有什么不同？</h2><p>哈夫曼编码是基于统计的数据压缩编码，需要先获得信息源的字符出现频率，然后再进行压缩。</p>
<p>但是，如果信息源是流式传输的，就没办法预先做统计，需要换一种思路。</p>
<p>LZ77利用数据的重复结构信息来进行数据压缩，是基于字典的压缩算法，可以做流逝压缩。</p>
<p>GZIP压缩的过程就是先用LZ77算法进行流式压缩，再对结果做哈夫曼编码压缩。</p>
<h2 id="为什么叫LZ77"><a href="#为什么叫LZ77" class="headerlink" title="为什么叫LZ77?"></a>为什么叫LZ77?</h2><p>由以色列的两位大神Jacob Ziv与Abraham Lempel在1977年发表的论文《A Universal Algorithm for Sequential Data Compression》中提出。</p>
<h2 id="LZ77算法思想概述"><a href="#LZ77算法思想概述" class="headerlink" title="LZ77算法思想概述"></a>LZ77算法思想概述</h2><p>核心思想：利用短语表示数据的重复结构信息来进行数据压缩。</p>
<p>LZ77算法一般称为“滑动窗口压缩”，算法的核心是在前面的历史数据中寻找重复字符串。</p>
<p>通过滑动窗口实现动态字典，用前面出现过的字符串作为字典通过映射（与前一个字符串的距离和字符串长度）替代后面重复出现的字符串。</p>
<p>重复现象是具有局部性的，它的基本假设是，如果一个字符串要重复，那么也是在附近重复，远的地方就不用找了，因此设置了一个滑动窗口。</p>
<p>其方式就是把数据中一些可以组织成短语(最长字符)的字符加入字典，然后再有相同字符出现采用标记来代替字典中的短语，如此通过标记代替多数重复出现的方式以进行压缩。</p>
<p>滑动窗口越大，压缩的效果越好，因为编码的短语越多，但是压缩速度越慢，因为要计算的短语数量越多。</p>
<h2 id="基于字典是什么意思？"><a href="#基于字典是什么意思？" class="headerlink" title="基于字典是什么意思？"></a>基于字典是什么意思？</h2><p>滑动窗口内的字符都是已经出现过的字符，已经出现过的字符会编码为字典短语，后面前向缓冲窗口中的字符如果和字典中的短语相同，就用距离和字符串长度来表示，以达到压缩的目的。</p>
<h2 id="LZ77压缩效果"><a href="#LZ77压缩效果" class="headerlink" title="LZ77压缩效果"></a>LZ77压缩效果</h2><p>大多数情况下LZ77压缩算法的压缩比相当高。</p>
<p>实际压缩率和选择的滑动窗口大小、前向缓冲区大小、数据熵有关系。</p>
<h2 id="LZ77缺点"><a href="#LZ77缺点" class="headerlink" title="LZ77缺点"></a>LZ77缺点</h2><p>压缩过程是比较耗时，因为要花费很多时间寻找滑动窗口中的短语匹配。</p>
<p>不过解压过程很快，因为每个标记都明确告知在哪个位置可以读取了。</p>
<h2 id="什么特征的文本用LZ77压缩效果好？"><a href="#什么特征的文本用LZ77压缩效果好？" class="headerlink" title="什么特征的文本用LZ77压缩效果好？"></a>什么特征的文本用LZ77压缩效果好？</h2><p>压缩就是用更短的符号来表示重复出现的字符串。</p>
<p>压缩就是寻找文本的内容分布概率，将出现频率高的部分代替成更短的形式。</p>
<p>内容越是重复，就可以压缩的更小。</p>
<p>内容如果毫无重复，就很难压缩。</p>
<h2 id="LZ77详细原理"><a href="#LZ77详细原理" class="headerlink" title="LZ77详细原理"></a>LZ77详细原理</h2><p>参见： <a target="_blank" rel="noopener" href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></p>
<h2 id="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"><a href="#为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？" class="headerlink" title="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"></a>为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？</h2><p>LZ77编码后得到的是，距离（distance）和长度（length），还有未匹配到短语字典的原始字符（literal）。</p>
<p>比较短的距离和长度可能是频繁出现的，就可以用变长编码来压缩，且文本已经确定下来不会变动，可以做词频统计，就可以用到哈夫曼编码了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/en-heng/p/4992916.html">【数据压缩】LZ77算法原理及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/en-heng/p/4992916.html">LZ77算法原理以及实现</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">哈夫曼编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-02 20:00:00" itemprop="dateCreated datePublished" datetime="2020-07-02T20:00:00+08:00">2020-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/哈夫曼编码/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是哈夫曼编码"><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是哈夫曼编码</h2><p>出现频次越高的字符，编码长度越小。</p>
<h2 id="哈夫曼编码的价值"><a href="#哈夫曼编码的价值" class="headerlink" title="哈夫曼编码的价值"></a>哈夫曼编码的价值</h2><p>变长编码，使得编码的平均长度最短，实现压缩率大的无损压缩。</p>
<p>因为哈夫曼树是最优的，每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<h2 id="哈夫曼编码过程"><a href="#哈夫曼编码过程" class="headerlink" title="哈夫曼编码过程"></a>哈夫曼编码过程</h2><ul>
<li>把文本中字符按出现的频次排序。</li>
<li>每个字符作为一个结点放入一个集合。</li>
<li>取集合最小的两个频次的结点，为左右子结点，生成一个父结点，父结点的频次是两个子结点频次之和，把父结点再加入到集合中。</li>
<li>重复这个构造过程，生成一个最优二叉树。</li>
<li>给二叉树所有左边设置0，所有右边设置1。</li>
<li>字符都在叶子结点。</li>
<li>根结点到叶子结点路径上的0和1组成的码字就是该字符的编码。</li>
</ul>
<p>因为所有字符都出现在叶子结点，保证了哈夫曼编码当中的任何一个字符的编码都不能是另一个字符编码的前缀。也就是说哈夫曼编码是一种前缀编码。</p>
<hr>
<h2 id="如何证明哈夫曼编码是最优的？"><a href="#如何证明哈夫曼编码是最优的？" class="headerlink" title="如何证明哈夫曼编码是最优的？"></a>如何证明哈夫曼编码是最优的？</h2><p>哈夫曼编码过程每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<p>其正确性证明依赖于贪心选择性质和最优子结构。</p>
<hr>
<h2 id="哈夫曼编码的特点"><a href="#哈夫曼编码的特点" class="headerlink" title="哈夫曼编码的特点"></a>哈夫曼编码的特点</h2><ol>
<li> 编码非等长</li>
<li> 编码前缀不重复</li>
</ol>
<h2 id="哈夫曼编码的压缩效果？"><a href="#哈夫曼编码的压缩效果？" class="headerlink" title="哈夫曼编码的压缩效果？"></a>哈夫曼编码的压缩效果？</h2><p>哈夫曼编码可以很有效的压缩数据，具体压缩率依赖于数据本身的特性。</p>
<p>齐夫定律：</p>
<p>发现某一单词出现的频率与其在频率表里名次的常数次幂成反比，也就是说极少数的单词会被经常使用，而绝大多数单词很少被提及，这种20/80法则在很多领域都被逐步发现，这种幂律分布被称为“齐夫定律”（Zipf’s law）</p>
<p>一般信息的分配都是幂率分布。</p>
<p>所以用哈夫曼编码压缩的比例一般都挺高的，70%以上。</p>
<h2 id="信息压缩的极限在哪？"><a href="#信息压缩的极限在哪？" class="headerlink" title="信息压缩的极限在哪？"></a>信息压缩的极限在哪？</h2><p>香农第一定理给出了无损的情况下数据压缩的临界值。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/08/information-theory.html">信息论入门教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法（冒泡、选择、插入、希尔、快速、归并、堆、计数）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-01 20:00:00" itemprop="dateCreated datePublished" datetime="2020-07-01T20:00:00+08:00">2020-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="算法/排序算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>左侧无序区域中的最大数字交换到右侧已排序区域的最左侧。</p>
<h3 id="冒泡排序代码"><a href="#冒泡排序代码" class="headerlink" title="冒泡排序代码"></a>冒泡排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// nums[0, n - 1 - i]是无序区域，初始时整个数组无序</span></span><br><span class="line">            <span class="comment">// nums[n - i,n - 1]是有序区域，是数组中大的数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一趟冒泡是否有交换发生</span></span><br><span class="line">            <span class="keyword">var</span> isNotSwapped = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为要比较当前和下一个数大小，所以j只能取到n - 1 - i的前一个数</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span> - i) &#123;</span><br><span class="line">                <span class="comment">// 不是升序，就要交换一下</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换</span></span><br><span class="line">                    <span class="keyword">val</span> tmp = nums[j + <span class="number">1</span>]</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">                    nums[j] = tmp</span><br><span class="line">                    <span class="comment">// 标记有交换</span></span><br><span class="line">                    isNotSwapped = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有交换，说明无序区域已经有序，那么整个数组也是有序的了</span></span><br><span class="line">            <span class="keyword">if</span> (isNotSwapped) <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>冒泡排序是稳定的</strong>。</p>
<p>因为交换是当前数大于下一个数才会交换。</p>
<p>如果有<code>x1 == x2</code>，<code>x1</code>在<code>x2</code>左边，<code>x1</code>始终不会被交换到<code>x2</code>右边。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="一句话描述-1"><a href="#一句话描述-1" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>右侧未排序区域选取一个最小的数，交换到前面已排序区域的末尾。</p>
<h3 id="选择排序代码"><a href="#选择排序代码" class="headerlink" title="选择排序代码"></a>选择排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// s[0,i-1]为已排序区域，s[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序取一个最小的放入已排序区域的末尾  </span></span><br><span class="line">  <span class="keyword">var</span> minIndex = i  </span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;  </span><br><span class="line">                    minIndex = j  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 将未排序区域中最小值与已排序区域末尾的下一个位置的数字交换  </span></span><br><span class="line">  <span class="comment">// 已排序区域末尾的下一个位置就是i了，最小值索引是minIndex  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[minIndex]  </span><br><span class="line">            nums[minIndex] = nums[i]  </span><br><span class="line">            nums[i] = tmp  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>选择排序不稳定</strong>，因为发生了位置交换。</p>
<p>由于每次会在后面的未排序区域选择最小的数字与前面的已排序区域末尾元素交换，如果未排序区域交换的位置的前面有与已排序区域末尾元素相等的元素，这两个元素的相对位置就变了。</p>
<p>例如[2, 3, 4, 2, 1]，第一趟选择会把最小的1放到最前面，第一个2交换到最后面，这样两个2的相对顺序就变了。</p>
<p>如何不发生位置交换呢？</p>
<p>有两种做法：</p>
<ul>
<li>一个是开辟一个新数组，把最小的放到第一个位置上，把第二小的放到第二个位置上等等。空间复杂度是O(n)。</li>
<li>一个是使用链表，空间复杂度是O(1)。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>交换次数比冒泡排序少，交换次数是跟数组长度呈线性关系。</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h3 id="一句话描述-2"><a href="#一句话描述-2" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>扑克牌拿牌后插牌的排序：把数组右侧未排序区域的最左侧元素插入数组左侧已排序区域中。</p>
<h3 id="直接插入排序代码"><a href="#直接插入排序代码" class="headerlink" title="直接插入排序代码"></a>直接插入排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="comment">// 初始时未排序区域共有n个数，每次向左侧已排序区域插入一个数，总共需要插入n次  </span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// nums[0,i-1]为已排序区域  </span></span><br><span class="line">  <span class="comment">// nums[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序区域第一个元素开始，从后往前一个个跟已排序区域数字比较，相邻两个数字顺序不对就交换，直至顺序正确  </span></span><br><span class="line">  <span class="comment">// 由于要比较当前数字和前一个数字的大小，所以索引j最少只能取到第2个元素位置即索引1  </span></span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果相邻两个数不是升序则需要交换  </span></span><br><span class="line">  <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                    <span class="comment">// 交换元素  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[j]  </span><br><span class="line">                    nums[j] = nums[j - <span class="number">1</span>]  </span><br><span class="line">                    nums[j - <span class="number">1</span>] = tmp  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>已排序区域寻找插入位置可以使用二分查找。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适合部分有序的数组，这样比较次数就会大大减少，从而提高效率。</p>
<p>对于大规模乱序的数组，插入排序很慢，因为只会交换相邻的元素，元素只能一步一步的从数组的一端移动到另一端。</p>
<p>例如，如果是升序排序，数组最小的元素在数组末尾，那么移动到开头就要交换N-1次。如果有一个完全降序的数组，用插入排序变为升序的话，要做的事情太多了。</p>
<p>给定一个10万个元素的数组，部分有序，部分无序，选择哪一种排序算法最好？</p>
<p>用插入排序，插入排序在已排序区域寻找插入位置可以用二分法加快寻找</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h3 id="一句话描述-3"><a href="#一句话描述-3" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>先大步再小步的插入排序。</p>
<p>大步插入排序使得用很少的交换次数让数组变得部分有序，从而在小步排序时发挥插入排序的优势，达到总体的比较和交换次数变少。</p>
<h3 id="希尔排序代码"><a href="#希尔排序代码" class="headerlink" title="希尔排序代码"></a>希尔排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (d &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            d = <span class="number">3</span> * d + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> d until n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo d step d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[j - d]) &#123;</span><br><span class="line">                        <span class="keyword">val</span> tmp = nums[j]</span><br><span class="line">                        nums[j] = nums[j - d]</span><br><span class="line">                        nums[j - d] = tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递增序列如何选择？不同的递增序列有什么影响？"><a href="#递增序列如何选择？不同的递增序列有什么影响？" class="headerlink" title="递增序列如何选择？不同的递增序列有什么影响？"></a>递增序列如何选择？不同的递增序列有什么影响？</h3><blockquote>
<p>《算法（第4版）》</p>
<p>如何选择递增序列呢？要回答这个问题并不简单。算法的性能不仅取决于h，还取决于h 之间的数学性质，比如它们的公因子等。</p>
<p>有很多论文研究了各种不同的递增序列，但都无法证明某个序列是 “ 最好的” 。</p>
<p>算法2.3中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。但可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。</p>
</blockquote>
<p>一个简单的序列选择：<br>从1开始，一直 d * 3 + 1，直到小于 n / 3。</p>
<h3 id="希尔排序更高效的原因？"><a href="#希尔排序更高效的原因？" class="headerlink" title="希尔排序更高效的原因？"></a>希尔排序更高效的原因？</h3><p>希尔排序权衡了数组的规模和有序性。</p>
<p>排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p>
<p>子数组部分有序的程度取决于递增序列的选择。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>在大规模乱序的情况下，希尔排序可以减少元素交换的次数，数组越大优势越大。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>选取一个轴心元素，将数组划分成比这个数小的和比这个数字大的两个子数组，分别对两个子数组递归调用划分。</p>
<h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">val</span> pivotIndex = partition(nums, low, high)</span><br><span class="line">        quickSort(nums, low, pivotIndex - <span class="number">1</span>)</span><br><span class="line">        quickSort(nums, pivotIndex + <span class="number">1</span>, high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start = low</span><br><span class="line">    <span class="keyword">var</span> end = high</span><br><span class="line">    <span class="keyword">val</span> pivot = nums[start]</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] &gt;= pivot) &#123;</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] &lt;= pivot) &#123;</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[end] = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么partition()里的while判断条件里low不能等于high？</strong></p>
<p>因为一开始取pivot就已经挖空了一个位置。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>每次划分，轴心元素就在最终排序完成后的位置上。</p>
<h3 id="快排为什么是O-n-log-n-复杂度？"><a href="#快排为什么是O-n-log-n-复杂度？" class="headerlink" title="快排为什么是O(n log n)复杂度？"></a>快排为什么是O(n log n)复杂度？</h3><p>根据主定理推导。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22393997/answer/406278523">如何证明快速排序法的平均复杂度为 O(nlogn)？ - 知乎 </a></p>
<h3 id="什么会影响时间复杂度？"><a href="#什么会影响时间复杂度？" class="headerlink" title="什么会影响时间复杂度？"></a>什么会影响时间复杂度？</h3><p>用于划分数组的中枢元素的选择会影响时间复杂度，划分的左右子数组数量越接近效果越好，否则会让整个快速排序退化到O(n^2)级别。</p>
<p>具体怎么划分要根据数组本身的数据分布特性来决定</p>
<p>以下情况会变得低效：</p>
<p>（1）近乎有序的数列</p>
<p>对于一个近乎有序的数列，当直接使用第一个元素作为基准点的时候，将会导致划分的子数组大小差距太大，进而无法发挥快排划分的优势</p>
<p>（2）含有大量重复数据的数列</p>
<p>選取的數字如果是重複較多的數字，划分出的两个子数组有一边的长度会很大，因为移动指针的时候，判断条件是大于等于和小于等于枢纽元素</p>
<h3 id="如何优化时间复杂度？"><a href="#如何优化时间复杂度？" class="headerlink" title="如何优化时间复杂度？"></a>如何优化时间复杂度？</h3><p>针对近乎有序的数组：</p>
<p><strong>三数取中法</strong></p>
<p>选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间大的数交换到数列首位的位置，之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">LeetCode.75.颜色分类（中等）</a>正好就是用到这种方法。</p>
<p><strong>随机交换法</strong></p>
<p>选取基准点之前设计随机种子，通过随机函数得到一个在数列长度内的数，将这个随机数作为索引所指的数和第一个元素进行交换，之后将首位元素作为基准点。即随机选一个数放到首位的地方。这样一来，第一次就将最小的数交换到首位的概率是非常小的，第二次将次小的数交换到首位的概率依然非常的小。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h3 id="一句话说明"><a href="#一句话说明" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>堆就是一个完全二叉树，堆排序两步走：<br>建堆：从最后一个非叶子节点到根结点不停的向下调整堆。<br>排序调整：堆顶元素与数组末尾元素交换，再向下调整堆顶元素。</p>
<h3 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        buildHeap(nums)</span><br><span class="line">        <span class="comment">// 堆顶最大的元素与数组末尾的数字进行交换</span></span><br><span class="line">        <span class="comment">// 堆大小减1</span></span><br><span class="line">        <span class="comment">// 新的堆顶元素可能破坏最大堆性质，需要向下调整，把缩小后的堆的最大的元素放到堆顶</span></span><br><span class="line">        <span class="comment">// 重复如此最后堆大小缩减为0，原数组从末尾开始向前填充大的数，最后得到升序数组</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> nums.size downTo <span class="number">1</span>) &#123;</span><br><span class="line">            nums.swap(<span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">            sink(nums, <span class="number">1</span>, length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildHeap</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 给数组元素从1到n编号，最后一个非叶节点的编号为n/2</span></span><br><span class="line">        <span class="comment">// 从最后一个非叶节点开始往前不停的向下调整堆</span></span><br><span class="line">        <span class="comment">// 如果一个结点的左右子树已经是堆，从该结点向下调整后该结点为根结点的二叉树依然保持着堆的性质</span></span><br><span class="line">        <span class="comment">// 所以可以从下往上不停的向下调整</span></span><br><span class="line">        <span class="keyword">for</span> (parent <span class="keyword">in</span> n / <span class="number">2</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            sink(nums, parent, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对[nums]的第[k]个元素为根结点的子堆进行向下调整，把大的元素放到堆顶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要从[k]向下调整是因为[k]与孩子结点可能不满足堆性质</span></span><br><span class="line"><span class="comment">     * 初始时已经建立了堆，交换前我们可以认定k的左右子树都已经满足最大堆的性质，即k的左右子结点一定比它下面的所有结点值都大</span></span><br><span class="line"><span class="comment">     * 如果k当前比左右孩子最大的一个要小，当把k的左右孩子结点与k交换，依然满足k大于所有其孩子结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sink</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> parent = k</span><br><span class="line">        <span class="comment">// 最后一个非叶节点编号是length/2</span></span><br><span class="line">        <span class="comment">// parent初始时是在上层的结点，一直会往下遍历，一直遍历到最后一个非叶节点</span></span><br><span class="line">        <span class="keyword">while</span> (parent &lt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 找出较小的孩子结点child</span></span><br><span class="line">            <span class="keyword">var</span> child = parent * <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果child不是最后一个元素，对比下其相邻的孩子谁更大，取更大的孩子结点，以便接下来跟其父结点parent比较，检查是否满足最大堆的性质</span></span><br><span class="line">            <span class="keyword">if</span> (child &lt; length &amp;&amp; nums[child - <span class="number">1</span>] &lt; nums[child]) child++</span><br><span class="line">            <span class="comment">// 因为初始已经建了最大堆，我们可以认定parent的左右子树都已经满足堆的性质</span></span><br><span class="line">            <span class="comment">// 如果当前parent与child也满足堆性质，则不用继续调整了</span></span><br><span class="line">            <span class="comment">// 这里构建的是大顶堆，要求父结点比孩子结点要大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[parent - <span class="number">1</span>] &gt;= nums[child - <span class="number">1</span>]) <span class="keyword">break</span></span><br><span class="line">            <span class="comment">// 父结点比孩子结点小，不满足最大堆性质，交换父结点和孩子结点的值，以满足最大堆性质</span></span><br><span class="line">            nums.swap(parent - <span class="number">1</span>, child - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 交换后，以孩子结点child为根的子堆可能不满足最大堆性质，继续向下检查调整</span></span><br><span class="line">            parent = child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组IntArray的扩展函数swap，用以交换数组内两个位置[i]和[j]的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？"><a href="#堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？" class="headerlink" title="堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？"></a>堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？</h3><p>因为堆是一种完全二叉树，访问的数据不在内存中连续的区域，空间访问局部性效果不太好，缓存命中率低，进而降低了程序运行速度。</p>
<p>快速排序会访问数组相邻的元素，空间访问局部性比较好，程序运行速度快。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="一句话说明-1"><a href="#一句话说明-1" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>归并两个子数组为一个有序数组。</p>
<p>可以自顶向下递归进行，也可以自底向上迭代进行。</p>
<h3 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h3><p>自顶向下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下，分而治之</span></span><br><span class="line"><span class="comment">     * 类似于二叉树后序遍历的写法，理解二叉树后续遍历这个递归写法就好理解对应上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素的时候，low与high相等，只有一个数字的子数组认定是有序的，不需要再排序了</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            mergeSort(nums, low, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自底向上：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 从最小的子数组开始向上归并，最小的子数组长度是1，每次向上归并后子数组大小变为原来的两倍</span></span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (size &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 按照子数组的大小将长度为n的数组划分为n/size个子数组</span></span><br><span class="line">            <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 依次归并 n/size 个子数组</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; n - size) &#123;</span><br><span class="line">                <span class="comment">// 第一个子数组的右边界索引（包含）</span></span><br><span class="line">                <span class="keyword">val</span> mid = low + size - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 第二个子数组的右边界索引（包含），最后一个子数组可能只包含的元素个数较少，需要防止数组越界</span></span><br><span class="line">                <span class="keyword">val</span> high = min(low + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 归并两个子数组</span></span><br><span class="line">                merge(nums, low, mid, high)</span><br><span class="line">                <span class="comment">// 每次归并2个子数组，所以下一次归并发生在第三个子数组的位置</span></span><br><span class="line">                low += size * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            size *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h3 id="一句话说明-2"><a href="#一句话说明-2" class="headerlink" title="一句话说明"></a>一句话说明</h3><ol>
<li> 记录待排序数组每个取值的个数</li>
<li> 用一个数组累加记录有多少数是小于等于当前索引I</li>
<li> 逆序输出</li>
</ol>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> w = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [nums]取值范围在1到w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> copied = nums.copyOf()</span><br><span class="line">        <span class="keyword">val</span> count = IntArray(w + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 统计每个取值有多少个</span></span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            count[num]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加计数</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.w) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序遍历原数组，保持元素相对顺序不变</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> index = count[copied[i]] - <span class="number">1</span></span><br><span class="line">            nums[index] = copied[i]</span><br><span class="line">            count[copied[i]]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么最后要逆序遍历原数组？"><a href="#为什么最后要逆序遍历原数组？" class="headerlink" title="为什么最后要逆序遍历原数组？"></a>为什么最后要逆序遍历原数组？</h3><ol>
<li> 这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边，从而保证排序的稳定性</li>
<li> 如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法，但如果不关注稳定性，那么结果还是正确的</li>
</ol>
<p>保证相同的数字还是按照原数组中的顺序，保证稳定性</p>
<p>比如[1,2,3,4,5,5,5]</p>
<p>最后从后向前遍历原数组，3个5的输出顺序还是跟原数组的顺序是一致的</p>
<p>如果是从前向后输出，3个5的位置正好倒过来了，因为最终排序的索引是通过计数来得到的，计数是从大到小的，所以最后相同值的索引位置的计算是从大到小的，也就是说相同值的索引位置是从后往前的，如果顺序遍历原数组，遇到几个相同的数字，会先把前面的数字先放到后面了</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>O(n)时间复杂度</p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>数组取值范围是常数范围。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/" class="post-title-link" itemprop="url">ASM字节码插桩</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-08 20:00:00" itemprop="dateCreated datePublished" datetime="2019-08-08T20:00:00+08:00">2019-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/ASM字节码插桩/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ASM是干什么的？"><a href="#ASM是干什么的？" class="headerlink" title="ASM是干什么的？"></a>ASM是干什么的？</h1><p>ASM 是一个 Java 字节码操控框架。</p>
<p>ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。</p>
<p>Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。</p>
<p>ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p>
<p>ASM的应用场景有AOP（CGLIB就是基于ASM）、热部署、修改其他jar包中的类等。</p>
<h1 id="用ASM修改类的好处？"><a href="#用ASM修改类的好处？" class="headerlink" title="用ASM修改类的好处？"></a>用ASM修改类的好处？</h1><ul>
<li>类的修改是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。</li>
<li>越过Java常规语法限制，做出代码编写无法实现的事情。</li>
</ul>
<h1 id="字节码操纵操作工具很多，ASM有什么优势？"><a href="#字节码操纵操作工具很多，ASM有什么优势？" class="headerlink" title="字节码操纵操作工具很多，ASM有什么优势？"></a>字节码操纵操作工具很多，ASM有什么优势？</h1><p>常见的字节码操作工具有：</p>
<ul>
<li>ASM</li>
<li>JavaAssist</li>
<li>AspectJ（基于BCEL）</li>
<li>CGLIB（基于ASM）</li>
<li>ByteBuddy（基于ASM）</li>
</ul>
<p>ASM优势：</p>
<ul>
<li>体积小</li>
<li>性能高</li>
</ul>
<p>ASM劣势：</p>
<ul>
<li>需要熟悉字节码原理，API易用性低</li>
</ul>
<p>JavaAssist优势：</p>
<ul>
<li>不需要熟悉字节码原理，API易用性高</li>
</ul>
<p>JavaAssist劣势：</p>
<ul>
<li>体积大</li>
<li>性能差</li>
</ul>
<p>所以ASM适用于对性能和体积敏感的场景。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9167436/dynamic-java-bytecode-manipulation-framework-comparison">Dynamic Java Bytecode Manipulation Framework Comparison</a></li>
</ul>
<h1 id="Visitor模式怎么理解？"><a href="#Visitor模式怎么理解？" class="headerlink" title="Visitor模式怎么理解？"></a>Visitor模式怎么理解？</h1><p>把可变的和不变的分离。</p>
<p>具体而言，被访问者是不变的，而访问者是可变的。举个例子来说，我是不变的，而不同的人看我会有不同的眼光，这个看我的眼光是可变的。</p>
<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。</p>
<p>访问者模式适用于数据结构相对稳定，算法又易变化的系统。<br>因为访问者模式使得算法操作增加变得容易。</p>
<p>若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。</p>
<p>访问者模式的优点：</p>
<p>增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。</p>
<p>访问者模式的缺点：</p>
<p>增加新的数据结构很困难。</p>
<p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://codeleading.com/article/42914263436/">设计模式之 Visitor（访问者模式）通俗理解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a></li>
<li><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/mybeautiful-1160374">Visitor模式通俗化</a></li>
</ul>
<h1 id="ASM为什么用Visitor模式？"><a href="#ASM为什么用Visitor模式？" class="headerlink" title="ASM为什么用Visitor模式？"></a>ASM为什么用Visitor模式？</h1><p>.class 文件的结构是固定的，主要有常量池、字段表、方法表、属性表等内容，通过使用访问者模式在扫描 .class 文件中各个表的内容时，就可以修改这些内容了。</p>
<h1 id="ASM的思想是什么？"><a href="#ASM的思想是什么？" class="headerlink" title="ASM的思想是什么？"></a>ASM的思想是什么？</h1><p>ClassReader 的 accept 方法中传进来了一个参数ClassVisitor。在内部，ClassVisitor会不断的读取ClassReader的二进制byte[]，然后在解析后通过参数classVisitor的抽象visitXXX方法将属性全部转发出去。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825235523.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825235623.png"></p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSqingchen/article/details/106483693">Android 中使用ASM，对Activity生命周期打点统计</a></li>
</ul>
<h1 id="ASM-API"><a href="#ASM-API" class="headerlink" title="ASM API"></a>ASM API</h1><p>分为核心API和树形API</p>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：</p>
<ul>
<li>ClassReader：用于读取已经编译好的.class文件。</li>
<li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li>
<li>  各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。</li>
</ul>
<h2 id="树形API"><a href="#树形API" class="headerlink" title="树形API"></a>树形API</h2><p>ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</p>
<h1 id="Intellij-Idea-中-ASM-Bytecode-Outline-插件"><a href="#Intellij-Idea-中-ASM-Bytecode-Outline-插件" class="headerlink" title="Intellij Idea 中 ASM Bytecode Outline 插件"></a>Intellij Idea 中 ASM Bytecode Outline 插件</h1><p>可以把java代码转为ASM框架的代码。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ForwardSailing/article/details/106494116">Android Studio 使用 ASM Bytecode Outline 插件来研究Java字节码</a></li>
</ul>
<h1 id="ASM如何使用？"><a href="#ASM如何使用？" class="headerlink" title="ASM如何使用？"></a>ASM如何使用？</h1><p>ClassWriter是ClassVistor的实现类。</p>
<p>处理逻辑都写自定义ClassVisitor里。</p>
<p>模板的拦截代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">&quot;meituan/bytecode/asm/Base&quot;</span>);</span><br><span class="line">ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理</span></span><br><span class="line">ClassVisitor classVisitor = <span class="keyword">new</span> MyClassVisitor(classWriter);</span><br><span class="line">classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"><span class="keyword">byte</span>[] data = classWriter.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;/classes/meituan/bytecode/asm/Base.class&quot;</span>);</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">fout.write(data);</span><br><span class="line">fout.close();</span><br></pre></td></tr></table></figure>

<p>代码示例：在一个方法前后分别插入方法</p>
<p>例如有一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">halloAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AopInterceptor.beforeInvoke();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Aop&quot;</span>);</span><br><span class="line">        AopInterceptor.afterInvoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要插入AopInterceptor的beforeInvoke()和afterInvoke()在TestBean的halloAop()的执行前后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义ClassVisitor的visitMethod方法中拦截halloAop方法，对不是halloAop的方法返回null表示不处理，对halloAop的拦截处理交给AopMethod类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopClassAdapter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopClassAdapter</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">    String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&lt;init&gt;&quot;</span>.equals(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//放弃原有类中所有构造方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;halloAop&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 只对halloAop方法执行代理</span></span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AopMethod(<span class="keyword">this</span>.api, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodVisitor中</p>
<p>visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，重写visitCode方法，将AOP中的前置逻辑就放在这里。</p>
<p>每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法。我们判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将AOP的后置逻辑放在该方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopMethod</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopMethod</span><span class="params">(<span class="keyword">int</span> api, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitCode();    </span><br><span class="line">        <span class="keyword">this</span>.visitMethodInsn(INVOKESTATIC,<span class="string">&quot;org/more/test/asm/AopInterceptor&quot;</span>, <span class="string">&quot;beforeInvoke&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == RETURN) &#123;<span class="comment">//在返回之前安插after 代码。</span></span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;org/more/test/asm/AopInterceptor&quot;</span>, <span class="string">&quot;afterInvoke&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/ta8210/blog/162796">深入字节码 – 使用 ASM 实现 AOP</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/s127838498/article/details/107968840">Android 通过ASM实现多次点击拦截</a></li>
</ul>
<h1 id="invokevirtual指令执行方法后，方法的返回值存放在哪？"><a href="#invokevirtual指令执行方法后，方法的返回值存放在哪？" class="headerlink" title="invokevirtual指令执行方法后，方法的返回值存放在哪？"></a>invokevirtual指令执行方法后，方法的返回值存放在哪？</h1><p>存放在栈帧的操作栈中。</p>
<blockquote>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p>
<p>举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p>
</blockquote>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode instruction listings 中对指令的descrpitoin</a></li>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2015/10/24/jvm-bytecode-grammar/">Jvm系列3—字节码指令</a></li>
</ul>
<h1 id="局部变量表的执行过程？"><a href="#局部变量表的执行过程？" class="headerlink" title="局部变量表的执行过程？"></a>局部变量表的执行过程？</h1><p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎</a></li>
<li>深入理解Java虚拟机（第2版）第8章  虚拟机字节码执行引擎<ul>
<li>8.2.1 局部变量表</li>
<li>8.4.3 基于栈的解释器的执行过程</li>
</ul>
</li>
</ul>
<h1 id="MethodNode有什么作用？"><a href="#MethodNode有什么作用？" class="headerlink" title="MethodNode有什么作用？"></a>MethodNode有什么作用？</h1><p>可以获取方法体内部的字节码指令等方法的一切信息</p>
<h1 id="MethodNode有什么使用场景？"><a href="#MethodNode有什么使用场景？" class="headerlink" title="MethodNode有什么使用场景？"></a>MethodNode有什么使用场景？</h1><p><a target="_blank" rel="noopener" href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">微信Android客户端卡顿检测工具：Matrix-Android-TraceCanary</a></p>
<h2 id="判断一个方法是空方法？"><a href="#判断一个方法是空方法？" class="headerlink" title="判断一个方法是空方法？"></a>判断一个方法是空方法？</h2><p>遍历字节码指令，没有有效的字节码指令就是空</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmptyMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();  </span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();  </span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断扫描的函数是否只含有-PUT-READ-FIELD-等简单的指令"><a href="#判断扫描的函数是否只含有-PUT-READ-FIELD-等简单的指令" class="headerlink" title="判断扫描的函数是否只含有 PUT/READ FIELD 等简单的指令"></a>判断扫描的函数是否只含有 PUT/READ FIELD 等简单的指令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGetSetMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ignoreCount = <span class="number">0</span>;</span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();</span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opcode != Opcodes.GETFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.GETSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_GETFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_GETSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.RETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.ARETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.DRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.FRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.LRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.IRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.PUTFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.PUTSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_PUTFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_PUTSTATIC</span><br><span class="line">                &amp;&amp; opcode &gt; Opcodes.SALOAD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConstructor &amp;&amp; opcode == Opcodes.INVOKESPECIAL) &#123;</span><br><span class="line">                ignoreCount++;</span><br><span class="line">                <span class="keyword">if</span> (ignoreCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="判断一个方法是不是仅调用另外一个方法"><a href="#判断一个方法是不是仅调用另外一个方法" class="headerlink" title="判断一个方法是不是仅调用另外一个方法"></a>判断一个方法是不是仅调用另外一个方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSingleMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();</span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Opcodes.INVOKEVIRTUAL &lt;= opcode &amp;&amp; opcode &lt;= Opcodes.INVOKEDYNAMIC) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索（付ASM简易教程）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903721789292558">从 Java 字节码到 ASM 实践</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903831646502920">Android Transform + ASM 初探</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903725937475592">自定义 gradle plugin，教你如何 hook 系统 task 和字节码</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904029886087181">详解Android Gradle生成字节码流程</a></li>
<li><a target="_blank" rel="noopener" href="http://quinnchen.cn/2018/09/13/2018-09-13-asm-transform/">一起玩转Android项目中的字节码</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSqingchen/article/details/106483693">Android 中使用ASM，对Activity生命周期打点统计</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e5062d62a3d1">认识 .class 文件的字节码结构</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0cf9aa251921">理解 JVM 中的类加载机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎</a></li>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-asm">asm官网（内附教程）</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/j-lo-asm30/">AOP 的利器：ASM 3.0 介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905be2a9a700">ASM 库的介绍和使用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905be2a9a700">ASM 库的介绍和使用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2c1d350d245">从 Java 字节码到 ASM 实践</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Gradle/Gradle%E4%B9%8BTransform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Gradle/Gradle%E4%B9%8BTransform/" class="post-title-link" itemprop="url">Gradle之Transform</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 20:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T20:00:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Gradle/" itemprop="url" rel="index"><span itemprop="name">Gradle</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Gradle/Gradle%E4%B9%8BTransform/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Gradle/Gradle之Transform/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AOP两种方式实现"><a href="#AOP两种方式实现" class="headerlink" title="AOP两种方式实现"></a>AOP两种方式实现</h1><ol>
<li> 通过gradle提供的transform api</li>
<li> 通过Java Instrument机制hook dx.jar，拦截gradle编译把class转为dex的过程</li>
</ol>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c202853059b4">Android AOP之字节码插桩</a></li>
</ul>
<h1 id="Transform-API-有什么用？"><a href="#Transform-API-有什么用？" class="headerlink" title="Transform API 有什么用？"></a>Transform API 有什么用？</h1><p>transform拦截jar转为dex的过程。</p>
<p>jar转为dex时先经过transform处理。</p>
<p>jar -&gt; transform -&gt; dex</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825195255.png"></p>
<h1 id="Transform-API如何使用？"><a href="#Transform-API如何使用？" class="headerlink" title="Transform API如何使用？"></a>Transform API如何使用？</h1><p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903831646502920">Android Transform + ASM 初探</a></li>
</ul>
<p>不管你修不修改输入，都必须要把类复制到指定的transform输出位置。</p>
<p>步骤：</p>
<ul>
<li>com.android.build.api.transform.Transform是android gradle plugin里的类，引用Transform需要先引入agp的依赖。<br>implementation(“com.android.tools.build:gradle:xxx”)</li>
<li>实现一个自定义的类继承Transform，然后将其注册到agp中即可。</li>
<li>注册到agp，先要获得android的扩展，通过project.extensions.findByType(BaseExtension::class.java)<br>来获取。</li>
<li>再调用BaseExtension中的registerTransform()添加自定义的Transform。</li>
</ul>
<p>一个通过自定义插件添加自定义Transform的示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        project.extensions.findByType(BaseExtension::<span class="keyword">class</span>.java)</span><br><span class="line">            ?.registerTransform(MyTransform())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> : <span class="type">Transform</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyTransform&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInputTypes</span><span class="params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getScopes</span><span class="params">()</span></span>: MutableSet&lt;<span class="keyword">in</span> QualifiedContent.Scope&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isIncremental</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(transformInvocation: <span class="type">TransformInvocation</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.transform(transformInvocation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Transform类中各方法的作用"><a href="#Transform类中各方法的作用" class="headerlink" title="Transform类中各方法的作用"></a>Transform类中各方法的作用</h1><h2 id="getName-String"><a href="#getName-String" class="headerlink" title="getName(): String"></a><code>getName(): String</code></h2><p>本Transform的名称</p>
<h2 id="getInputTypes-Set-lt-ContentType-gt"><a href="#getInputTypes-Set-lt-ContentType-gt" class="headerlink" title="getInputTypes(): Set&lt;ContentType&gt;"></a><code>getInputTypes(): Set&lt;ContentType&gt;</code></h2><ul>
<li>处理的输入类型</li>
<li>分为class文件或者java资源</li>
<li>class文件来自于jar或者文件夹</li>
<li>资源就是标准的java资源，默认约定位于src/main/resources目录下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DefaultContentType</span> <span class="keyword">implements</span> <span class="title">ContentType</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The content is compiled Java code. This can be in a Jar file or in a folder. If</span></span><br><span class="line"><span class="comment">       * in a folder, it is expected to in sub-folders matching package names.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      CLASSES(<span class="number">0x01</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The content is standard Java resources.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      RESOURCES(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getScopes-Set-lt-super-Scope-gt"><a href="#getScopes-Set-lt-super-Scope-gt" class="headerlink" title="getScopes(): Set&lt;? super Scope&gt;"></a><code>getScopes(): Set&lt;? super Scope&gt;</code></h2><p>输入文件所属的范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Scope</span> <span class="keyword">implements</span> <span class="title">ScopeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Only the project content */</span></span><br><span class="line">    PROJECT(<span class="number">0x01</span>), <span class="comment">//只是当前工程的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the project&#x27;s local dependencies (local jars) */</span></span><br><span class="line">    PROJECT_LOCAL_DEPS(<span class="number">0x02</span>), <span class="comment">// 工程的本地jar</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the sub-projects. */</span></span><br><span class="line">    SUB_PROJECTS(<span class="number">0x04</span>),  <span class="comment">// 只包含子工工程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the sub-projects&#x27;s local dependencies (local jars). */</span></span><br><span class="line">    SUB_PROJECTS_LOCAL_DEPS(<span class="number">0x08</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the external libraries */</span></span><br><span class="line">    EXTERNAL_LIBRARIES(<span class="number">0x10</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Code that is being tested by the current variant, including dependencies */</span></span><br><span class="line">    TESTED_CODE(<span class="number">0x20</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local or remote dependencies that are provided-only */</span></span><br><span class="line">    PROVIDED_ONLY(<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransformManager预定了一些SCOPE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_PROJECT =</span><br><span class="line">            ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);</span><br></pre></td></tr></table></figure>

<h2 id="isIncremental-Boolean"><a href="#isIncremental-Boolean" class="headerlink" title="isIncremental(): Boolean"></a><code>isIncremental(): Boolean</code></h2><p>是否是增量编译。</p>
<h2 id="transform-TransformInvocation"><a href="#transform-TransformInvocation" class="headerlink" title="transform(TransformInvocation)"></a>transform(TransformInvocation)</h2><p>input的内容将会打包成一个TransformInvocation对象，交给方法体处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransformInvocation</span> </span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getReferencedInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;SecondaryInput&gt; <span class="title">getSecondaryInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TransformOutputProvider <span class="title">getOutputProvider</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transform方法中如何处理TransformInput的JarInput和DirectoryInput？"><a href="#transform方法中如何处理TransformInput的JarInput和DirectoryInput？" class="headerlink" title="transform方法中如何处理TransformInput的JarInput和DirectoryInput？"></a>transform方法中如何处理TransformInput的JarInput和DirectoryInput？</h2><p>DirectoryInput 进行ASM插桩（参考<a target="_blank" rel="noopener" href="https://github.com/lijiankun24/Koala/blob/master/buildSrc/src/main/groovy/com/lijiankun24/koala/plugin/PreClass.groovy">koala - PreClass.groovy</a>）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDirectoryInput</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    directoryInput: <span class="type">DirectoryInput</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    outputProvider: <span class="type">TransformOutputProvider</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directoryInput.file.isDirectory) &#123;</span><br><span class="line">        directoryInput.file.walkTopDown().forEach &#123; file -&gt;</span><br><span class="line">            <span class="keyword">val</span> name = file.name</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; name != <span class="string">&quot;R.class&quot;</span></span><br><span class="line">                &amp;&amp; !name.startsWith(<span class="string">&quot;R\$&quot;</span>) &amp;&amp; name != <span class="string">&quot;BuildConfig.class&quot;</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">val</span> reader = ClassReader(file.readBytes())</span><br><span class="line">                <span class="keyword">val</span> writer = ClassWriter(reader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                <span class="keyword">val</span> visitor = MyClassVisitor(writer)</span><br><span class="line">                reader.accept(visitor, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                <span class="keyword">val</span> code = writer.toByteArray()</span><br><span class="line">                <span class="keyword">val</span> classPath = file.parentFile.absolutePath + File.separator + name</span><br><span class="line">                <span class="keyword">val</span> fos = FileOutputStream(classPath)</span><br><span class="line">                fos.write(code)</span><br><span class="line">                fos.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完输入文件之后，要把输出给下一个任务</span></span><br><span class="line">    <span class="keyword">val</span> dest = outputProvider.getContentLocation(</span><br><span class="line">        directoryInput.name,</span><br><span class="line">        directoryInput.contentTypes, directoryInput.scopes,</span><br><span class="line">        Format.DIRECTORY</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JarInput 不处理（参考<a target="_blank" rel="noopener" href="https://github.com/lijiankun24/Koala/blob/master/buildSrc/src/main/groovy/com/lijiankun24/koala/plugin/PreClass.groovy">koala - PreClass.groovy</a>）：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">    <span class="keyword">def</span> jarName = jarInput.name</span><br><span class="line">    <span class="keyword">def</span> md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">    <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">        jarName = jarName.substring(<span class="number">0</span>, jarName.length() - <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> dest = transformInvocation.outputProvider.getContentLocation(jarName + md5Name,</span><br><span class="line">            jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line"></span><br><span class="line">    FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>JarInput 处理ASM：<br>参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chenenyu/Router/blob/master/gradle-plugin/src/main/groovy/com/chenenyu/router/RouterTransform.groovy">Router - RouterTransform.groovy</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chenenyu/Router/blob/master/gradle-plugin/src/main/groovy/com/chenenyu/router/Scanner.groovy">Router - Scanner.groovy</a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleJarInput</span><span class="params">(jarInput: <span class="type">JarInput</span>, outputProvider: <span class="type">TransformOutputProvider</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//重名名输出文件,因为可能同名,会覆盖</span></span><br><span class="line">    <span class="keyword">var</span> jarName = jarInput.name</span><br><span class="line">    <span class="keyword">val</span> md5Name = DigestUtils.md5Hex(jarInput.file.absolutePath)</span><br><span class="line">    <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">        jarName = jarName.substring(<span class="number">0</span>, jarName.length - <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt; 处理输入的jar文件中的class，输出到一个临时的jar文件</span></span><br><span class="line">    <span class="keyword">val</span> jarFile = JarFile(jarInput.file)</span><br><span class="line">    <span class="keyword">val</span> enumeration = jarFile.entries()</span><br><span class="line">    <span class="keyword">val</span> tmpFile = File(jarInput.file.parent + File.separator + <span class="string">&quot;classes_temp.jar&quot;</span>)</span><br><span class="line">    <span class="comment">// 避免上次的缓存被重复插入</span></span><br><span class="line">    <span class="keyword">if</span> (tmpFile.exists()) &#123;</span><br><span class="line">        tmpFile.delete()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jarOutputStream = JarOutputStream(FileOutputStream(tmpFile))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存</span></span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">        <span class="keyword">val</span> jarEntry = enumeration?.nextElement() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> entryName = jarEntry.name</span><br><span class="line">        <span class="keyword">val</span> zipEntry = ZipEntry(entryName)</span><br><span class="line">        <span class="keyword">val</span> inputStream = jarFile.getInputStream(jarEntry)</span><br><span class="line">        <span class="comment">// 插桩class</span></span><br><span class="line">        <span class="keyword">if</span> (entryName.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; !entryName.startsWith(<span class="string">&quot;R\$&quot;</span>)</span><br><span class="line">            &amp;&amp; <span class="string">&quot;R.class&quot;</span> != entryName &amp;&amp; <span class="string">&quot;BuildConfig.class&quot;</span> != entryName</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">//class文件处理</span></span><br><span class="line">            println(<span class="string">&quot;----------- deal with jar class file &lt;&#x27; + <span class="variable">$entryName</span> + &#x27;&gt; -----------&quot;</span>)</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            <span class="keyword">val</span> classReader = ClassReader(inputStream)</span><br><span class="line">            <span class="keyword">val</span> classWriter = ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">            <span class="keyword">val</span> cv = MyClassVisitor(classWriter)</span><br><span class="line">            classReader.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">            <span class="keyword">val</span> code = classWriter.toByteArray()</span><br><span class="line">            jarOutputStream.write(code)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            jarOutputStream.write(inputStream.readBytes())</span><br><span class="line">        &#125;</span><br><span class="line">        jarOutputStream.closeEntry()</span><br><span class="line">    &#125;</span><br><span class="line">    jarOutputStream.close()</span><br><span class="line">    jarFile.close()</span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt; 处理输入的jar文件中的class，输出到一个临时的jar文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt; 处理过class的临时jar文件输出到目标位置</span></span><br><span class="line">    <span class="keyword">val</span> dest = outputProvider.getContentLocation(</span><br><span class="line">        jarName + md5Name,</span><br><span class="line">        jarInput.contentTypes, jarInput.scopes, Format.JAR</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyFile(tmpFile, dest)</span><br><span class="line">    tmpFile.delete()</span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt; 处理过class的临时jar文件输出到目标位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Java-Agent和Instrument机制是什么？有什么用？大概如何使用？"><a href="#Java-Agent和Instrument机制是什么？有什么用？大概如何使用？" class="headerlink" title="Java Agent和Instrument机制是什么？有什么用？大概如何使用？"></a>Java Agent和Instrument机制是什么？有什么用？大概如何使用？</h1><p>JavaAgent使用指南</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickiyang/p/11368932.html">https://www.cnblogs.com/rickiyang/p/11368932.html</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903780916396039">【Android】函数插桩（Gradle + ASM）</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java集合类-ConcurrentHashMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-07 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-07T20:00:00+08:00">2018-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-ConcurrentHashMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ConcurrentHashMap特点"><a href="#ConcurrentHashMap特点" class="headerlink" title="ConcurrentHashMap特点"></a>ConcurrentHashMap特点</h1><p>高性能且线程安全的哈希表。</p>
<h1 id="ConcurrentHashMap线程安全是怎么实现的？"><a href="#ConcurrentHashMap线程安全是怎么实现的？" class="headerlink" title="ConcurrentHashMap线程安全是怎么实现的？"></a>ConcurrentHashMap线程安全是怎么实现的？</h1><p>Java7中ConcurrentHashMap将哈希表分割成为多个段（Segment），每一个段继承ReentrantLock，对每一段进行加锁。每个Segment里类似又有一个小的HashMap，等于是双重哈希表。</p>
<p>Java8中采用了自旋CAS和synchronzied保证线程安全，锁的粒度调整为对table数组中每个元素进行加锁；put元素时，定位到桶位置后，通过synchronzied给桶中链表首节点或红黑树根节点加锁。这样多线程竞争哈希表同一个桶位置的几率又降低了。</p>
<p>java8的ConcurrentHashMap的数据结构参考java8的HashMap，采用数组+链表+红黑树。</p>
<ul>
<li><p>put方法里，是一个无限循环，即自旋，修改table数组都是通过cas操作，自旋锁的机制避免了阻塞和恢复线程的上下文切换开销。</p>
</li>
<li><p>只要当前桶位置没有元素，就先自旋CAS进行更新。</p>
</li>
<li><p>存在hash冲突或修改已有的值时，需要进入桶内部的链表或红黑树进行操作时，才开始用synchronized真正加锁。</p>
</li>
</ul>
<p>get是不加锁的，所以与CopyOnWriteArrayList一样，不保证读数据的实时性，数据是弱一致性。</p>
<p>size的求法和LongAdder里的思路一样，将大小数据分段累加，避免多线程竞争，用自旋cas保证数据更新的原子性。</p>
<h1 id="ConcurrentHashMap不能解决什么问题？"><a href="#ConcurrentHashMap不能解决什么问题？" class="headerlink" title="ConcurrentHashMap不能解决什么问题？"></a>ConcurrentHashMap不能解决什么问题？</h1><p>因为数据是弱一致性的，get时并不加锁，所以对读数据实时性要求高的需求不能满足</p>
<p>例如线程1在某一时刻执行了put(key, value)，先线程2随后立即get(key)不一定能读取到线程1刚put的，因为put可能正在进行中还没结束。</p>
<h1 id="扩容机制是怎样的？"><a href="#扩容机制是怎样的？" class="headerlink" title="扩容机制是怎样的？"></a>扩容机制是怎样的？</h1><p>本来一个线程扩容时，其他线程应该都阻塞等待这个线程扩容完成后才能对哈希表进行读写，这就成了并发的瓶颈。</p>
<p>ConcurrentHashMap具体实现是，反正你闲着也是闲着，不如一起来扩容。</p>
<p>扩容时nextTable会指向扩容后的数组，扩容方法transfer里通过自旋进行。</p>
<p>多个线程通过sizeCtl判断当前所处状态，再通过transferIndex协调各线程应该操作哪一些桶。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">ConcurrentHashMap1.8 - 扩容详解（图文并茂）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lfs2640666960/p/9621461.html">深入理解HashMap+ConcurrentHashMap的扩容策略  </a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/487d00afe6ca">ConcurrentHashMap源码分析（JDK8） 扩容实现机制</a></li>
</ul>
<h1 id="跟同样是线程安全的Hashtable有何区别？"><a href="#跟同样是线程安全的Hashtable有何区别？" class="headerlink" title="跟同样是线程安全的Hashtable有何区别？"></a>跟同样是线程安全的Hashtable有何区别？</h1><p>Hashtable的线程安全是对整个哈希表上锁（在多数方法上加上sychronized），其中一个线程访问哈希表时，其他线程只能等待，很多没有必要上锁的场景也上锁，因此在多线程竞争激烈的情况下整体访问速度会变慢。</p>
<p>ConcurrentHashMap把哈希表分割成若干个段，修改每一段时仅针对访问的段上锁，不同的线程访问不同的段时互不干扰，减少了多个线程争抢同一把锁的几率，减少了线程等待的时间，所以提高了性能。</p>
<p>分段锁是怎么实现的？</p>
<p>get方法不加锁，结点类里的value设置了volatile保证了value在多线程下的可见性，保证get到value最新的修改值。</p>
<p>总结：</p>
<ol>
<li> 循环+CAS实现自旋锁，减少线程阻塞恢复的上下文切换消耗</li>
<li> size更新采用LongAdder分段锁思想，减少竞争</li>
<li> LongAdder机制中的字节填充解决伪共享</li>
<li> 多线程协同分组扩容。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dee05ac6fb9a0163f77beb6">深入解析 ConcurrentHashMap 实现内幕，吊打面试官？没问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heqiyoujing/p/11143525.html">ConcurrentHashMap面试题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java集合类-HashMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-06 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-06T20:00:00+08:00">2018-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-HashMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>JDK 1.7：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java</a></li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java</a></li>
</ul>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ol>
<li> 非线程安全，所以存取速度快</li>
<li> 可以接受null的键和值</li>
<li> 不保证key有序</li>
<li> key的顺序会随时间变化（动态调整大小后会变化）</li>
</ol>
<h1 id="散列过程"><a href="#散列过程" class="headerlink" title="散列过程"></a>散列过程</h1><ol>
<li> 通过散列函数，用元素的key计算出元素在数组中的索引位置</li>
<li> 解决散列冲突，即相同散列值（数组索引位置）元素如何存取</li>
</ol>
<h1 id="散列函数的选取标准"><a href="#散列函数的选取标准" class="headerlink" title="散列函数的选取标准"></a>散列函数的选取标准</h1><ol>
<li> 易于计算</li>
<li> 均匀分布所有键</li>
</ol>
<h1 id="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"><a href="#拉链法查找一个元素的最少、最坏、平均次数分别是多少？" class="headerlink" title="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"></a>拉链法查找一个元素的最少、最坏、平均次数分别是多少？</h1><p>设哈希表大小为m，已存储的元素个数为n</p>
<p>如果散列函数把所有元素散列到一个位置，链表的长度就是n，最坏情况下就是查找链表中最后一个元素，查找次数是n</p>
<p>如果散列函数散列到哈希表每个位置的概率相同，此时元素分布最均匀，拉链法相当于把n个元素分为m组，那么每组（链表）长度最多为n/m，最坏情况下查找链表最后一个元素，需要n/m次</p>
<h1 id="桶（bucket）是什么意思？"><a href="#桶（bucket）是什么意思？" class="headerlink" title="桶（bucket）是什么意思？"></a>桶（bucket）是什么意思？</h1><p>HashMap内部的哈希表由数组实现，数组的每一个位置称为桶，存储一个链表的头结点，或红黑树的根节点，一个桶下所有元素key的hashCode都相同，元素存储在哪一个桶是根据元素key计算出数组索引位置而定的</p>
<h1 id="什么情况下会要求哈希表的大小要是质数？"><a href="#什么情况下会要求哈希表的大小要是质数？" class="headerlink" title="什么情况下会要求哈希表的大小要是质数？"></a>什么情况下会要求哈希表的大小要是质数？</h1><p>简述：</p>
<ul>
<li>关注哈希表的大小是因为求得元素在哈希表中存储存储位置是通过  key的hashCode % 哈希表大小  得到，如果散列函数计算结果不均匀，容易产生散列冲突，提高了查找次数。</li>
<li>质数不容易被整除，故而可以让计算出的索引分布的比较均匀。合数有公因子，计算出的索引位置容易聚集在公因数的位置，产生较多的散列冲突。</li>
</ul>
<p>key与哈希表大小互质，这样取模的结果就分散的比较均匀。</p>
<p>如果key可以整除哈希表大小，如果key容易在公因数的位置产生聚集，就会产生较多的散列冲突。</p>
<p>使用质数作为容量，可以使元素更分散，减少冲突；</p>
<p>如果用合数作为容量，会使元素聚集，增加冲突，增加查找次数。</p>
<p>一般是通过除留取余法确定元素在数组中存储索引位置，即：</p>
<p>元素在数组中的存储位置 = key的hashCode % 哈希表长度</p>
<p>假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。</p>
<p>例如2 4 6 8 10 12这6个数，如果对 6 取余  得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多，并且呈现以合数的因子为间隔增长；如果对 7取余  得到 2 4 6 1 3 5 得到6种HASH值，没有冲突。</p>
<p>用质数作为数组容量使得任何数想整除它是不可能的，因此探测序列最终会检查到所有单元，冲突较少。</p>
<p>当散列函数计算结果的均匀性较差时，最好使用质数作为哈希表大小可以在除留取余时使得计算出的索引位置分布的更均匀。</p>
<p>但是库一般都会提供散列比较均匀的散列函数，只要散列函数设计的均匀，什么数做桶的大小都行，有时为了方便支持桶的动态扩容或者避免使用除法，桶的大小使用2的幂。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？
</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">算法分析：哈希表的大小为何是素数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.moew.xyz/2019/07/29/%E4%B8%BA%E4%BD%95%E5%9C%A8%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%EF%BC%8C%E8%A6%81%E5%B0%BD%E9%87%8F%E5%8F%96%E7%B4%A0%E6%95%B0/">为何在散列表中除留余数法取模运算中，要尽量取素数
</a></li>
</ul>
<h1 id="为什么桶容量要是2的次方？"><a href="#为什么桶容量要是2的次方？" class="headerlink" title="为什么桶容量要是2的次方？"></a>为什么桶容量要是2的次方？</h1><p>散列表用数组实现时，要计算元素应当存储在数组的哪个位置（索引），应当将元素key的hashCode对散列表大小取模，取模结果就是元素要存放在数组的索引位置。</p>
<p>如果key的hashCode函数不能把key散列的均匀，就需要用质数作为哈希表大小，在除留取余的求数组索引时能够让元素分布的比较均匀。</p>
<p>如果key的hashCode能够散列的比较均匀，那么其实用什么数作为哈希表大小都可以。</p>
<p>桶容量为2的幂时取模的好处：<br>1.可以用位运算取模，计算速度更快，位运算也很方便。<br>2.可以让元素分布的均匀，减少散列冲突。<br>3.方便扩容计算，扩容也只需要乘以2，容量左移一位。</p>
<h1 id="为什么2的幂的容量可以让元素分布更均匀？"><a href="#为什么2的幂的容量可以让元素分布更均匀？" class="headerlink" title="为什么2的幂的容量可以让元素分布更均匀？"></a>为什么2的幂的容量可以让元素分布更均匀？</h1><p>位运算对2的幂取模过程：一个二进制数乘以2的n次方相当于将该数左移n位，一个二进制数除以2的n次方相当于将该数右移n位，右移出界的部分就是余数，其实也就是原数低n位，取低n位的数，只需要将原数跟低位是n个1的二进制数做与操作就可以得到，低位是n个1的二进制数可以由2的n次方再减1得到。</p>
<p>如果对不是2的幂的数进行位运算取模，假设这个数是x，x-1的二进制数一定不是全部都是1，而是含有0，此时x-1与原数做与操作后，那些有0的位置都会用不到，造成空间浪费，也增大了散列冲突。如果x-1全部是1的话，只要key的hashCode的二进制中的1在低n位分布均匀，就可以保证计算index的过程是分布均匀的，要求x-1的二进制全部是1，那么x就是2的幂。</p>
<h1 id="通过构造函数传入不是2的幂的容量值会怎样？"><a href="#通过构造函数传入不是2的幂的容量值会怎样？" class="headerlink" title="通过构造函数传入不是2的幂的容量值会怎样？"></a>通过构造函数传入不是2的幂的容量值会怎样？</h1><p>会找一个最接近传入容量的2的幂作为实际桶的容量。</p>
<h1 id="哈希表容量是2的幂会有什么问题？"><a href="#哈希表容量是2的幂会有什么问题？" class="headerlink" title="哈希表容量是2的幂会有什么问题？"></a>哈希表容量是2的幂会有什么问题？</h1><p>key的hash取余求索引时，会截断hash的高位，如果多个key的hash的低位比较固定，高位变化较大，那么最后计算的散列冲突就很多了。</p>
<p>所以需要扰动函数处理一下key的hash，把高位的变化信息传递到低位。</p>
<h1 id="扰动函数是什么，起到什么作用？"><a href="#扰动函数是什么，起到什么作用？" class="headerlink" title="扰动函数是什么，起到什么作用？"></a>扰动函数是什么，起到什么作用？</h1><p>存储一个元素时，需要决定该元素应该存储在table（桶）中哪一个位置，需要用元素的key的hashCode对桶容量做取模运算来获得要存储的数组索引位置。</p>
<p>如果桶容量较小，取模操作会仅对key.hashCode()的低位做运算，如果多个元素的key的hashCode()低位相同，只是高位不同，那么冲突就较多，所以需要将高位和低位结合起来取模，减少冲突，避免散列分布不均。</p>
<p>所以在对hashCode做取模运算之前，还需要让hashCode经过扰动函数扰动一下。</p>
<p>jdk1.8中对key的hashCode的扰动函数做了优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将key.hashCode()的低16位和高16位做异或运算。</p>
<p>仅仅异或一下做扰动，权衡了速度、性能、质量，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<h2 id="为什么是右移16位？"><a href="#为什么是右移16位？" class="headerlink" title="为什么是右移16位？"></a>为什么是右移16位？</h2><p>推测：因为java中int是32位的，高16位和低16位异或已经算是顾全到了数字的二进制的每一位。</p>
<p>实际：权衡了速度、性能、质量</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
</ul>
<h2 id="扰动函数为什么是异或运算？"><a href="#扰动函数为什么是异或运算？" class="headerlink" title="扰动函数为什么是异或运算？"></a>扰动函数为什么是异或运算？</h2><ol>
<li> 实现简单，运算快捷</li>
<li>对参与运算的两方的二进制的每一位都各自有50%的概率影响结果输出</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">Why is XOR the default way to combine hashes?</a></li>
</ul>
<h1 id="桶的最大容量为什么是2的30次方，不是2的31次方？"><a href="#桶的最大容量为什么是2的30次方，不是2的31次方？" class="headerlink" title="桶的最大容量为什么是2的30次方，不是2的31次方？"></a>桶的最大容量为什么是2的30次方，不是2的31次方？</h1><p>java中int是32位，理论上1可以最多左移31位，因为1不移动就占了1位，所以可以移动的位数是32-1=31位；而虚拟机规定int类型最高位是符号位，符号位不参与移动，可移动位数就是31-1=30位</p>
<h1 id="两个key对象的hashCode相同，如何获取value对象"><a href="#两个key对象的hashCode相同，如何获取value对象" class="headerlink" title="两个key对象的hashCode相同，如何获取value对象?"></a>两个key对象的hashCode相同，如何获取value对象?</h1><p>在遍历该桶的链表，链表中每个节点保存了键值对信息，将目标key与每个节点的key调用equals方法比较，相等的则为想要找到的节点，取其value对象。</p>
<h1 id="什么对象适合做为HashMap的key"><a href="#什么对象适合做为HashMap的key" class="headerlink" title="什么对象适合做为HashMap的key?"></a>什么对象适合做为HashMap的key?</h1><p>使用String，Integer等系统类比较好，因为他们的hashCode方法实现是比较均匀的，可以减少散列冲突。</p>
<p>其次这些类一旦创建都是不可变的，一来可以缓存hashCode，二来保证唯一性，三来线程安全。</p>
<h1 id="自定义对象实现hashCode-方法有什么注意事项？"><a href="#自定义对象实现hashCode-方法有什么注意事项？" class="headerlink" title="自定义对象实现hashCode()方法有什么注意事项？"></a>自定义对象实现hashCode()方法有什么注意事项？</h1><p><strong>原则：</strong><br>一个对象的hashCode应该认为有均等的机会得到2的32次方中的任意一个32位整数值。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205744.png" alt="《算法4》节选"></p>
<p>一个优秀的散列方法需要满足三个条件：</p>
<ul>
<li>一致性 - 等价的键必然产生相等的散列值</li>
<li>高效性 - 计算简便</li>
<li>均匀性 - 均匀地散列所有的键</li>
</ul>
<p>保证均匀性的最好办法也许是保证键的每一位都在散列值的计算中起到了相同的作用，实现散列函数最常见的错误是忽略了高位的键。</p>
<p>可以参考String的hashCode设计，kotlin的data class自动生成的hashCode以及集合类的hashCode算法都很相似。</p>
<p>需要使用不可变的属性实现hashCode()方法，因为：</p>
<ol>
<li> 可以在计算一次哈希值后缓存起来，提高哈希表的读取速度。</li>
<li> 如果key在放入哈希表时和取出哈希表时hashCode()发生变化，则会取不到之前存放的对象。</li>
<li> 不可变的属性是线程安全的。</li>
</ol>
<h1 id="装载因子是什么？"><a href="#装载因子是什么？" class="headerlink" title="装载因子是什么？"></a>装载因子是什么？</h1><p>哈希表中已存储元素个数与哈希表总大小比值，即已存储元素个数与桶个数比值。</p>
<p>装载因子越大，说明填充率高，空间利用率高，但是散列冲突可能性增大。</p>
<p>装载因子越小，说明填充率低，浪费很多空间，但是散列冲突可能性减小。</p>
<p>冲突越多，查找元素的时间越长，所以必须在时间和空间上进行权衡。</p>
<h1 id="装载因子有什么作用？"><a href="#装载因子有什么作用？" class="headerlink" title="装载因子有什么作用？"></a>装载因子有什么作用？</h1><p>装载因子 = 已存储的元素个数 / 桶大小</p>
<p>HashMap构造时可以传入一个装载因子，不传入的话会使用默认的装载因子0.75，构造时规定这个装载因子意思是装载因子的最大值。</p>
<p>随着哈希表中存储元素的个数增多，填充率越高，实际的装载因子会逐渐增大，当  实际装载因子  大于  预设装载因子  时，为了避免大量的散列冲突，要增大桶的数量，HashMap会将通大小调整为原来的两倍，因为桶大小要求是2的幂，所以就扩大2倍。</p>
<h1 id="桶容量是如何动态扩展的？"><a href="#桶容量是如何动态扩展的？" class="headerlink" title="桶容量是如何动态扩展的？"></a>桶容量是如何动态扩展的？</h1><p>当  已存储元素个数  超过  哈希表大小 * 装载因子，会扩容至原大小的两倍，并对部分元素重新散列。</p>
<p>当put元素时，发现已存储元素个数超过threshold时，会触发扩容。</p>
<p>threshold的首次赋值由构造HashMap时传入的初始容量和装载因子决定。</p>
<p>threshold = 初始容量 * 装载因子</p>
<p>每次扩容桶（table）大小会变为原来两倍，threshold也会变为原来的两倍。</p>
<h1 id="构造函数传入不是2的幂的初始容量会怎样？"><a href="#构造函数传入不是2的幂的初始容量会怎样？" class="headerlink" title="构造函数传入不是2的幂的初始容量会怎样？"></a>构造函数传入不是2的幂的初始容量会怎样？</h1><p>不管传什么初始容量，都会经由tableSizeFor()计算得到大于等于传入的初始容量的最小的2的幂作为桶的实际容量大小</p>
<p>在put()时触发resize()，threshold也会被重新赋值为桶容量乘以装载因子。</p>
<h1 id="tableSizeFor-算法过程是怎样的？"><a href="#tableSizeFor-算法过程是怎样的？" class="headerlink" title="tableSizeFor()算法过程是怎样的？"></a>tableSizeFor()算法过程是怎样的？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三种情况</p>
<ol>
<li>cap小于0，返回1</li>
<li>cap经过位运算后大于等于MAXIMUM_CAPACITY，返回MAXIMUM_CAPACITY</li>
<li>cap经过位运算后返回n+1</li>
</ol>
<p>先考虑正常的情况，对于一个给定的cap，分为两种情况，cap可能是2的幂或非2的幂。</p>
<ol>
<li>当cap不是2的幂，例如10，二进制为1010，cap - 1 = 1001，几个右移操作实际的结果就是从cap - 1的二进制的1的最高位开始到最低位全部变成1，最后返回n + 1就是2的幂了</li>
<li>当cap是2的幂，例如16，二进制为10000，cap-1 = 1111，右移操作后n还是为1111，n+1就还是16</li>
</ol>
<p>所以正常情况下tableSizeFor()得出的就是大于等于cap的数</p>
<p>如果cap一开始不减1，当cap是2的幂时，最后计算得出的就会是cap的2倍</p>
<p>cap小于0，没有实际的意义，不能表示桶容量，故而返回最小正整数1</p>
<p>cap大于等于MAXIMUM_CAPACITY时，MAXIMUM_CAPACITY是2的30次方，此时cap的二进制最高位1是在第31位，逻辑右移再加1会得到32个1，int中最高位（第32位）是符号位，最高位1表示负数了，没有意义，故而将最大值限定在2的30次方，2的30次方减1的二进制是从第1位到第30位全都是1</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）
</a></li>
</ul>
<h1 id="为什么要调整桶大小？"><a href="#为什么要调整桶大小？" class="headerlink" title="为什么要调整桶大小？"></a>为什么要调整桶大小？</h1><p>为了减少散列冲突，减少元素查找次数</p>
<h1 id="为什么桶初始容量是16？"><a href="#为什么桶初始容量是16？" class="headerlink" title="为什么桶初始容量是16？"></a>为什么桶初始容量是16？</h1><p>这个问题不好解答可以考虑边界情况，桶容量过大、过小会导致什么</p>
<p>桶容量过大会导致大量空间浪费</p>
<p>桶容量过小会导致频繁扩容，扩容一次是耗时的</p>
<p>16应当是一个权衡评估后得出的值</p>
<h1 id="默认装载因子为什么是0-75？"><a href="#默认装载因子为什么是0-75？" class="headerlink" title="默认装载因子为什么是0.75？"></a>默认装载因子为什么是0.75？</h1><p>可以先考虑装载因子过大和过小分别会有什么问题</p>
<p>装载因子过大，表明哈希表填充率高，但是散列冲突的可能性大，查找元素的次数多</p>
<p>装载因子过小，表明哈希表的空闲空间大，空间利用率低，但冲突较少，查找元素次数少</p>
<p>0.75乘以2的幂是整数，不需要再做四舍五入，计算方便</p>
<p>根据HashMap注释</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost(reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/reliveIT/article/details/82960063">HashMap defaultLoadFactor = 0.75和泊松分布没有关系
</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64f6de3ffcc1">HashMap的loadFactor为什么是0.75？
</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/31401836/2011291">StackOverflow: What is the significance of load factor in HashMap?
</a></li>
</ul>
<h1 id="resize-的大致过程"><a href="#resize-的大致过程" class="headerlink" title="resize()的大致过程"></a>resize()的大致过程</h1><p>根据resize()方法的注释所言，resize()会将桶容量扩充两倍，由于容量是2的幂，原来桶中的元素位置要么是原封不动，要么是再移动2的幂个位置。</p>
<p>求元素的在table中的索引依然是  元素key的hashCode &amp; (桶容量-1)</p>
<p>例如原来容量是16，二进制为10000，求元素索引时是 hashCode &amp; 1111</p>
<p>扩容两倍后容量是32，二进制位100000，求元素索引的计算变成了 hashCode &amp; 11111，比之前多了一个1，如果元素key的hashCode在该位也是1，等同于元素的索引位置增加了2的幂。</p>
<p>桶中是链表时，会将链表划分为两个链表，一个留在原桶，一个放入移动了2的幂的桶中。</p>
<p>为什么要这样调整？原封不动不行吗？</p>
<p>因为这样做是为了保证散列均匀，减少冲突。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现
</a></li>
</ul>
<h1 id="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"><a href="#为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"></a>为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？</h1><p>因为节点数过少时，红黑树的插入、删除的成本比链表要高很多。</p>
<p>在散列均匀的情况下，冲突较少，每个桶中链表的平均长度比较短，性能可接受。</p>
<h1 id="为什么链表的长度为8时变成红黑树？"><a href="#为什么链表的长度为8时变成红黑树？" class="headerlink" title="为什么链表的长度为8时变成红黑树？"></a>为什么链表的长度为8时变成红黑树？</h1><p>根据jdk1.8的HashMap中的注释所言，假设散列分布均匀，在负载因子为0.75的条件下，某一个桶中元素出现的频率满足λ为0.5的泊松分布。从概率来看，之所以链表长度超过 8 以后要变成红黑树，因为在散列分布均匀的情况下出现这种情况的概率小到忽略不计，一旦出现，几乎可以认为是散列函数设计有问题导致的，即散列不均匀。</p>
<p>所以红黑树是专门应对元素key糟糕的（分布不均匀）的散列函数而准备的。</p>
<p>二项分布：n次重复独立伯努利试验，一次伯努利实验只有两种对立的结果。</p>
<p>泊松分布：当二项分布的n很大，p很小时，可以近似为泊松分布。</p>
<p>算法第四版465页：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205936.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205952.png"></p>
<p>散列均匀时，每个桶的链表的平均长度为  实际元素总数  / 哈希表大小，这个就是装载因子λ</p>
<p>现在的问题就是，将N个元素随机放入M个桶，每个桶的元素平均个数为λ（N/M），求每个桶元素个数为k的概率。</p>
<p>对于某一个桶而言，一个元素放入桶中是一个二元结果，要么放入，要么不放入，散列均匀的情况下，不管有多少个桶，每个元素出现在同一个桶的概率是相同，每个桶中平均有λ个元素时，那么一个元素出现在同一个桶的概率就是λ/N，就是桶元素数量占元素总数的比值，理解很直观。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ysmull.cn/JCF/HashMap.html">谈谈 HashMap 实现中的若干数学问题
</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26263743">泊松分布 (Poisson Distributions) 的推导
</a></li>
</ul>
<h1 id="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"><a href="#为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？" class="headerlink" title="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"></a>为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？</h1><p>是为了防止频繁插入和删除元素时不停的在树和链表之间互相转换、降低性能，红黑树和链表之间的转换是有成本的。</p>
<h1 id="MIN-TREEIFY-CAPACITY是做什么的？"><a href="#MIN-TREEIFY-CAPACITY是做什么的？" class="headerlink" title="MIN_TREEIFY_CAPACITY是做什么的？"></a>MIN_TREEIFY_CAPACITY是做什么的？</h1><p>桶中元素超过TREEIFY_THRESHOLD个（8个）后，还要保证哈希表数组table的大小大于等于MIN_TREEIFY_CAPACITY才会把链表转红黑树，容量过小时使用红黑树性价比不高，用扩容来解决桶元素堆积的问题更适合。</p>
<p>这个值为什么要是4 * TREEIFY_THRESHOLD，是为了避免在resize和树化之间产生冲突，比如初始容量是16，装载因子0.75，存储元素有16*0.75=12个时就应该扩容，但是此时如果是4个元素在一个桶，8个元素在另外一个桶，是要先树化的，树化后再等resize扩容了，可能又要将红黑树链表化，这样反复来回影响性能。</p>
<h1 id="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"><a href="#平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？" class="headerlink" title="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"></a>平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？</h1><p>单次的插入和删除操作：</p>
<p>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</p>
<p>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</p>
<p>大量的插入和删除操作：</p>
<p>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</p>
<p>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</p>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16257761/difference-between-red-black-trees-and-avl-trees">Difference between red-black trees and AVL trees</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/21aspnet/article/details/88939297">为什么Java8中HashMap链表使用红黑树而不是AVL树
</a></li>
</ul>
<h1 id="put方法大致过程"><a href="#put方法大致过程" class="headerlink" title="put方法大致过程"></a>put方法大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>table数组为null则通过resize()初始化table，创建HashMap对象不会立刻初始化table数组</li>
<li>利用扰动后的hashCode除留取余求得元素在table中的索引</li>
<li>如果没有碰撞冲突，直接存入桶中</li>
<li>如果有碰撞冲突，桶中维护一个链表存储哈希值相同的元素，java7是头插法，java8是尾插法</li>
<li>链表长度超过TREEIFY_THRESHOLD，链表转为红黑树</li>
<li>如果元素已存在，替换value。元素存在先通过key的hashCode查看桶中是否有元素，没有则不存在，有元素需要依次遍历桶中元素，通过key的equals方法比较是否相等，有相等的则存在。</li>
<li> 哈希表实际存储元素数量超过了阈值threshold（哈希表大小 * 装载因子），调用resize()扩容。</li>
</ol>
<h1 id="get方法的大致过程"><a href="#get方法的大致过程" class="headerlink" title="get方法的大致过程"></a>get方法的大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>根据哈希值求得table索引</li>
<li>若桶中第一个元素命中，直接返回</li>
<li> 有冲突则依次遍历链表或红黑树，通过key的equals比较来寻找目标节点，找到了返回其value，没有找到返回null</li>
</ol>
<h1 id="HashMap为什么线程不安全？高并发下会产生什么问题？"><a href="#HashMap为什么线程不安全？高并发下会产生什么问题？" class="headerlink" title="HashMap为什么线程不安全？高并发下会产生什么问题？"></a>HashMap为什么线程不安全？高并发下会产生什么问题？</h1><p>一句话：jdk7的HashMap在扩容时会改变链表中元素原本的顺序，高并发情况下容易导致链表产生环，进而导致死循环，CPU占用率飙升到100%。</p>
<p>jdk7中扩容采用头插法是考虑到缓存的时间局部性原则，最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数。</p>
<p>jdk8中扩容改为尾插法，高并发情况下不会产生死循环了，但是resize依然不是原子性的，可能会产生数据丢失。</p>
<p>其他方法例如链表和红黑树互转的过程，都不是原子性的，都可能会产生数据丢失的问题。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2f75c8cce01">为什么HashMap线程不安全
</a></li>
</ul>
<h1 id="Java-8-对HashMap做出了哪些改进？"><a href="#Java-8-对HashMap做出了哪些改进？" class="headerlink" title="Java  8  对HashMap做出了哪些改进？"></a>Java  8  对HashMap做出了哪些改进？</h1><ol>
<li>桶中链表长度超过8将链表转为红黑树，以应对不均匀的散列函数导致的查询次数增多</li>
<li> 链表插入元素由头插法改为尾插法，以解决并发下插入元素时链表产生环进而导致的死循环</li>
</ol>
<h1 id="modCount是做什么的？"><a href="#modCount是做什么的？" class="headerlink" title="modCount是做什么的？"></a>modCount是做什么的？</h1><p>对哈希表做出了修改（添加和删除元素），modCount就会增加，表示修改的次数，使用迭代器迭代哈希表时一旦发现modCount变化了，就会立刻抛出ConcurrentModificationException，以避免迭代时的不确定性，这称为fail-fast机制。注意修改一个已存在的元素的value不改变modCount。</p>
<h1 id="HashMap的缺点是什么？想要用哈希表还有哪些选择？"><a href="#HashMap的缺点是什么？想要用哈希表还有哪些选择？" class="headerlink" title="HashMap的缺点是什么？想要用哈希表还有哪些选择？"></a>HashMap的缺点是什么？想要用哈希表还有哪些选择？</h1><p>缺点就是结构复杂，占用内存可能较多，对哈希表有简单需求的地方不需要这么复杂而完善的类</p>
<p>例如ThreadLocalMap就自己实现了一套简单的哈希表，采用开放定址法</p>
<p>还有Android上SparseArray、ArrayMap实现的内存消耗更低的哈希表</p>
<h1 id="HashMap与Hashtable的区别？"><a href="#HashMap与Hashtable的区别？" class="headerlink" title="HashMap与Hashtable的区别？"></a>HashMap与Hashtable的区别？</h1><ol>
<li> Hashtable的get、put、clear、contains、size等大部分方法上都加上了synchronized关键字，给整个对象上锁，HashMap非线程安全</li>
<li> Hashtable中没有红黑树仅有链表</li>
<li> Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li> Hashtable不允许null的key和value，而HashMap都允许</li>
<li> Hashtable求key的hashCode没有扰动</li>
<li> HashMap和Hashtable使用Iterator遍历元素过程中对哈希表添加或删除元素是会抛出异常的（fast-fail），但Hashtable用Enumeration迭代时不会fast-fail，因为通过Enumeration的nextElement()获取下一个元素时没有对modCount做判断，而Iterator的next方法对modCount做了判断。</li>
<li> Hashtable是jdk1添加的，HashMap是jdk2添加的</li>
</ol>
<p>Dictionary已被废弃，所以Hashtable已经被废弃，而且同步性能较差，大多数操作都会锁住整个对象。用jdk1.5引入的采用分段锁的ConcurrentHashMap同步性能更好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">句柄、直接指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 20:00:00" itemprop="dateCreated datePublished" datetime="2018-03-08T20:00:00+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 21:19:51" itemprop="dateModified" datetime="2021-08-25T21:19:51+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="虚拟机/句柄、直接指针/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄是什么？"><a href="#句柄是什么？" class="headerlink" title="句柄是什么？"></a>句柄是什么？</h1><p>指针的指针。</p>
<p>jvm中内存里的对象都有一个指针指向对象的开始地址，句柄就是指向对象的指针。</p>
<h1 id="句柄解决了什么问题"><a href="#句柄解决了什么问题" class="headerlink" title="句柄解决了什么问题?"></a>句柄解决了什么问题?</h1><p>对实际的对象资源做了一层代理，屏蔽细节，避免了直接操控资源可能的危险。</p>
<p>弄了句柄，对象实际位置在内存中可以随意变化，比如标记整理垃圾回收后对象被移动到其他地方。</p>
<p>虚拟内存机制，可能会将已经载入内存的数据换到外存硬盘上，这样对象的地址就会变动，其他地方引用这块被换走的地址也要更新，如果使用这块数据的地方引用的是句柄，这样实际数据在内存的位置可以随意变化，使用数据的地方还是引用固定的地址，不用更新。</p>
<p>Windows系统中有许多内核对象（这里的对象不完全等价于”面向对象程序设计”一词中的”对象”，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个”对象”的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p>
<ol>
<li><p>暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p>
</li>
<li><p>操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p>
</li>
</ol>
<p>所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p>
<p>在Windows系统中，这个编号就叫做”句柄”。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/klb561/p/10555571.html">句柄的概念</a></p>
<h1 id="为什么叫句柄这个名字？"><a href="#为什么叫句柄这个名字？" class="headerlink" title="为什么叫句柄这个名字？"></a>为什么叫句柄这个名字？</h1><p>从名字上说，handle是指中间媒介，例如门把手是door handle，刀柄是knife handle。</p>
<p>所以文件句柄file handle以即其他资源句柄，也是这个中间媒介的意思，通过这个媒介操作资源。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27656256/answer/943130123">句柄是什么？ - 黄兢成的回答 - 知乎 解释句柄这个词语的表面含义</a></li>
</ul>
<h1 id="JVM对象访问定位"><a href="#JVM对象访问定位" class="headerlink" title="JVM对象访问定位"></a>JVM对象访问定位</h1><p>JVM通过栈上的reference类型数据来操作堆上的具体对象。</p>
<p>由于reference数据只是规定了一个指向对象的引用，没有定义如何去定位访问对象的具体位置。</p>
<p>主流的实现方式有两种：</p>
<ul>
<li>句柄<br>  在堆中划分句柄池，reference存储对象的句柄地址，句柄包含对象实例数据和类型数据的各自具体地址信息。<ul>
<li>好处：reference中的数据是稳定的句柄地址 对象被移动只会改变句柄中的信息 不会改变句柄的地址 reference不需要变化。</li>
<li>坏处：增加了指针定位的开销。</li>
</ul>
</li>
<li>直接指针<br>  栈上reference类型数据槽中直接存储堆对象的地址。<ul>
<li>好处：直接访问对象 减少指针定位开销。</li>
<li>坏处：当对象内存地址发生变化 reference中数据也需要调整。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》 2.3.3 对象的访问定位 48页</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
