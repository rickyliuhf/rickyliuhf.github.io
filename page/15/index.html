<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/15/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/" class="post-title-link" itemprop="url">Java并发-ReadWriteLock、StampedLock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-17 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-17T20:00:00+08:00">2017-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-ReadWriteLock、StampedLock/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="读写锁存在的意义？解决了什么问题？"><a href="#读写锁存在的意义？解决了什么问题？" class="headerlink" title="读写锁存在的意义？解决了什么问题？"></a>读写锁存在的意义？解决了什么问题？</h1><p>synchronzied和ReentraintLock的锁是排他锁，同一时刻只允许一个线程访问同一个资源。</p>
<p>然而在读多写少的情况下，排他锁会让多个并发的读之间互斥，但多个线程同时读不会影响数据的一致性，写的时候保证获取的是排他锁保证数据一致性即可。</p>
<p>也就是读与读之间不互斥，写与读、写与写之间互斥。</p>
<p>这样的话就提高了系统整体的吞吐量。</p>
<h1 id="ReentraintReadWriteLock实现原理是什么？"><a href="#ReentraintReadWriteLock实现原理是什么？" class="headerlink" title="ReentraintReadWriteLock实现原理是什么？"></a>ReentraintReadWriteLock实现原理是什么？</h1><p>内部有ReadLock和WriteLock两个类，分别实现读锁和写锁。</p>
<p>两个Lock类里是通过Sync来实现锁的语义，Sync类继承AQS，并且分为非公平实现和公平的实现。</p>
<p>由于AQS的state是int类型的变量，在内存中占用4个字节，也就是32位。将其拆分为两部分：高16位和低16位，其中高16位用来表示读锁的个数，低16位用来表示写锁重入次数。</p>
<p>当设置读锁成功时，就将高16位加1，释放读锁时，将高16位减1；当设置写锁成功时，就将低16位加1，释放写锁时，将第16位减1。如下图所示。</p>
<p>这样读锁和写锁就可以都通过CAS去操作同一个state变量，实现读和写之间的互斥。</p>
<h1 id="读写锁适用场景？"><a href="#读写锁适用场景？" class="headerlink" title="读写锁适用场景？"></a>读写锁适用场景？</h1><p>读多写少，又需要保持线程安全，可以有效提高吞吐量。</p>
<h1 id="StampedLock解决了什么问题？"><a href="#StampedLock解决了什么问题？" class="headerlink" title="StampedLock解决了什么问题？"></a>StampedLock解决了什么问题？</h1><p>ReentraintReadWriteLock读写锁在读多写少的情况下，必须要等待所有读锁释放才能获取写锁，可能会导致写饥饿，写可能要等待很久，这是一种悲观的读锁。</p>
<p>正确的做法应该是，如果检测到有写入，已经获取读锁的线程不应该继续读了，把读锁让出来，给写入线程优先执行，写入完成了再读，这样就不会写饥饿了。</p>
<p>StampedLock做的就是，先不加锁的读数据，读完了检测一下是否有线程写过数据了，有写过数据则需要重新读最新的数据，并且要加悲观读锁读，以阻止新的写入锁获取，确保读的数据一定是最新修改的。</p>
<p>更通俗的讲就是在读锁没有释放的时候是可以获取到一个写锁，获取到写锁之后，读锁阻塞，这一点和读写锁一致，唯一的区别在于读写锁不支持在没有释放读锁的时候获取写锁。</p>
<h1 id="StampedLock如何检测是否有数据写入？"><a href="#StampedLock如何检测是否有数据写入？" class="headerlink" title="StampedLock如何检测是否有数据写入？"></a>StampedLock如何检测是否有数据写入？</h1><p>在第一次读数据之前先从StampedLock获取一个stamp，如果有数据写入，StampedLock里的stamp就会变，然后第一次读数据后，检测stamp变了说明有写入。</p>
<h1 id="StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？"><a href="#StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？" class="headerlink" title="StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？"></a>StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？</h1><p>确实面临同样的问题，但这种情况发生的概率很小，因为StampedLock使用场景就是读多写少，检测到有写操作后，可以认为大概率之后的一段时间是不会有写操作发生的。</p>
<h1 id="StampedLock如何解决ABA问题？"><a href="#StampedLock如何解决ABA问题？" class="headerlink" title="StampedLock如何解决ABA问题？"></a>StampedLock如何解决ABA问题？</h1><p>StampedLock用一个long类型的state变量保存锁的状态，其中state的低7位存储读锁的个数，第8位存储写锁的标志，第8位为0表示没有获取到写锁，第8位为1表示已获取到写锁。</p>
<p>每次获取和释放写锁，都会给state加上1000 0000，也就是在state的第8位上加1，这样在高位就产生了进位，每次获取写锁后state的值都不一样，这样就可以知道发生了ABA。</p>
<p>long总共有64位，高位一共有64-8=56位，一共可以记录2的55次方种状态。</p>
<h1 id="StampedLock为什么不设计为可重入？"><a href="#StampedLock为什么不设计为可重入？" class="headerlink" title="StampedLock为什么不设计为可重入？"></a>StampedLock为什么不设计为可重入？</h1><p>StampedLock为了解决ABA问题，state变量低7位记录读锁个数，第8位记录是否获取了写锁，第9位到第64位记录了写锁的状态，没有地方存储写锁的重入次数。</p>
<p>对比ReentraintReadWriteLock的实现原理，其实也可以在state的高位中划分一部分区域记录写锁的重入次数。</p>
<h1 id="StampedLock的锁升级是为了解决什么问题？"><a href="#StampedLock的锁升级是为了解决什么问题？" class="headerlink" title="StampedLock的锁升级是为了解决什么问题？"></a>StampedLock的锁升级是为了解决什么问题？</h1><p>有时候写数据只在数据处于特定的条件下才去更改，也就是有可能不修改数据，那如果一开始先获取写锁就会阻碍读锁的获取，吞吐量降低，所以得先获取读锁，判断符合特定条件后，确定需要写入了，再获取写锁，此时就是锁的升级，把读锁释放升级为写锁，前提是当前只有一个读锁；</p>
<p>如果有多个读锁，升级就失败，转为获取正常的写锁，获取不到就阻塞当前线程。</p>
<h1 id="StampedLock有什么缺点？"><a href="#StampedLock有什么缺点？" class="headerlink" title="StampedLock有什么缺点？"></a>StampedLock有什么缺点？</h1><ol>
<li> 不可重入</li>
<li> 不支持Condition</li>
<li> 不支持公平竞争</li>
</ol>
<p>所以也不能完全替代synchronized和ReentrantLock。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/" class="post-title-link" itemprop="url">Java并发-条件变量、wait()与notify()、await()与signal()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-16 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-16T20:00:00+08:00">2017-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-wait()、notify()、notifyAll()/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Object-wait-为什么要配合while使用？"><a href="#Object-wait-为什么要配合while使用？" class="headerlink" title="Object.wait()为什么要配合while使用？"></a>Object.wait()为什么要配合while使用？</h1><p>wait之前一般都是要判断某个条件成立才会wait，这个判断条件需要写成while：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (check pass) &#123;</span><br><span class="line">	wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果写成if，wait过后当前线程交出锁，等当前线程重新被唤起后，条件是否满足是不知道的，其他线程可能修改了条件的状态，要重新判断一下，否则可能条件未满足就继续执行了。</p>
<p>以生产者消费者模型为例。</p>
<ul>
<li>有1个生产者往缓冲区加数据，有2个消费者从缓冲区取数据。</li>
<li>消费者取数据前会检查缓冲区是否为空，不为空才能取数据，为空的话要等待。</li>
<li>假设两个消费者线程都等待了。</li>
<li>然后生产者往缓冲区添加数据后做notifyAll唤醒所有消费者，会唤醒两个等待的消费者线程，让消费者线程从监视器的等待队列移动到锁竞争队列，两者竞争锁。</li>
<li>其中一个线程竞争到锁后，消费了缓冲区数据，缓冲区没有数据了，释放锁后另外一个消费者获得到了锁，开始取从缓冲区取数据，而没有再做条件检查了。</li>
</ul>
<p>这种现象叫做虚假唤醒。</p>
<h1 id="Object的notify-和notifyAll-有什么区别？"><a href="#Object的notify-和notifyAll-有什么区别？" class="headerlink" title="Object的notify()和notifyAll()有什么区别？"></a>Object的notify()和notifyAll()有什么区别？</h1><p>每一个对象都有一个内部锁，即监视器（Monitor），虚拟机会给每个对象维护两个线程集合（可能是队列），一个叫Entry Set（入口集），另外一个叫Wait Set（等待集），对于任意对象object，object的Entry Set用于存储等待获取object内部锁的所有线程，object的Wait Set存储执行了object.wait()和object.wait(long timeout)的线程。</p>
<ul>
<li>notify()会唤醒Wait Set里的一个线程。</li>
<li>notifyAll()会唤醒Wait Set里的所有线程，线程被唤醒后去竞争获取锁，没有获取锁的线程进入Entry Set。</li>
</ul>
<h1 id="什么时候用notify-？什么时候用notifyAll"><a href="#什么时候用notify-？什么时候用notifyAll" class="headerlink" title="什么时候用notify()？什么时候用notifyAll()?"></a>什么时候用notify()？什么时候用notifyAll()?</h1><p>如果所有线程都在等待相同的条件，并且一次只有一个线程可以从条件变为true，则可以使用notify。</p>
<p>在这种情况下，notify是优于notifyAll 因为唤醒所有这些因为我们知道只有一个线程会受益而所有其他线程将再次等待，所以调用notifyAll方法只是浪费CPU。</p>
<p>虽然这看起来很合理，但仍有一个警告，即无意中的接收者吞下了关键通知。通过使用notifyAll，我们确保所有收件人都会收到通知。</p>
<h1 id="Object的wait-notifyAll-和Condition的await-signalAll-的区别？"><a href="#Object的wait-notifyAll-和Condition的await-signalAll-的区别？" class="headerlink" title="Object的wait()/notifyAll()和Condition的await()/signalAll()的区别？"></a>Object的wait()/notifyAll()和Condition的await()/signalAll()的区别？</h1><p>以生产者消费者模型为例。</p>
<ul>
<li>使用wait()、notify()/notifyAll()的缺点在于在生产者唤醒消费者、或者消费者唤醒生产者时，由于生产者和消费者使用同一个锁，所以生产者也会将生产者唤醒，消费者也会将消费者唤醒。</li>
<li>如果能让消费者只唤醒生产者，或者生产者只唤醒消费者，就没有性能浪费了。</li>
<li>所以一个ReentrantLock支持创建多个Condition，以应对这种场景。</li>
<li>synchronized的锁对象没有提供多条件唤醒。</li>
</ul>
<p>ArrayBlockingQueue是典型的生产者消费者的例子，源码是很好的参考。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/" class="post-title-link" itemprop="url">Java并发-synchronized、ReentrantLock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-15T20:00:00+08:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-synchronized、锁升级、wait和notify/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h1><p>让一段代码在多线程之间互斥访问，保证原子性、有序性、可见性，并且是可重入的。</p>
<h1 id="synchronized使用方式"><a href="#synchronized使用方式" class="headerlink" title="synchronized使用方式"></a>synchronized使用方式</h1><ul>
<li>synchronized修饰代码块时需要传入一个对象作为锁，这个对象可以是任意的，进入同步代码块前要获取这个锁，没有获得锁的线程就要阻塞等待，同步代码块执行完释放锁。</li>
<li>修饰成员方法时，锁是对象实例。</li>
<li>修饰静态方法时，锁是类的class实例。</li>
</ul>
<h1 id="synchronized原理综述"><a href="#synchronized原理综述" class="headerlink" title="synchronized原理综述"></a>synchronized原理综述</h1><p>每个Java对象都关联一个监视器锁对象，同步代码块在字节码层面是通过在代码块的指令前后加上monitorenter和monitorexit指令来标识的。</p>
<p>当线程执行到monitorenter指令时，当前线程试图获取监视器对象所有权，如果未加锁或者已被当前线程持有，就把锁计数加1；执行到monitorexit指令的时候，锁计数减1。锁计数为0时，锁就被释放了。</p>
<p>如果当前线程获取监视器对象失败，线程会阻塞等待，线程会作为一个结点存入监视器对象的锁池队列中，等待唤醒。</p>
<p>监视器对象还有一个等待池队列，在同步代码块中调用锁对象的wait方法的时候，线程会阻塞，并被封装为一个结点，进入监视器对象的等待池队列，调用锁对象的notify和notifyAll的时候，会把等待池队列中的线程放入锁池队列中，只有锁池中的线程才能参与竞争锁。</p>
<p>wait和notify用来线程之间同步过程的，比如实现生产者消费者模型。</p>
<p>监视器锁底层是通过操作系统的互斥锁实现的，操作系统做线程切换需要从用户态转换到内核态，所以比较消耗性能。这种依赖于操作系统互斥锁而实现的锁叫做重量级锁。</p>
<p>如果线程竞争并不激烈，切换线程的开销是不划算的，特别是多个线程在不同的时段获取同一把锁，可以用自旋锁，就是CAS+循环，CAS由硬件之间实现，开销比切换线程开销要小，这就是轻量级锁，在JDK6引入。</p>
<p>锁信息具体存储在对象头的MarkWord里，一个对象在虚拟机的内存布局分为三部分，对象头、实例数据、对齐填充，其中对象头又分为MarkWord、类型指针、数组长度，MarkWord存储了锁相关的信息、hashCode、垃圾回收的分代年龄等。</p>
<p>轻量级锁的CAS操作具体修改的是锁对象头的mark word，修改为指向当前线程栈帧中的锁记录的指针。虚拟机会为每个线程在当前线程栈帧中创建一块锁记录空间，存储锁对象的对象头中的mark word的拷贝。</p>
<p>如果CAS修改成功，当前线程就获得了轻量级锁。</p>
<p>如果更新失败，说明有线程竞争，开始自旋，自旋超过一定次数，升级为重量级锁。避免竞争激烈的情况下自旋空耗CPU。</p>
<p>如果压根都没有线程竞争，只有单线程访问同步代码块，其实每次进行CAS操作获取轻量级锁也是没有必要的开销，所以JDK6又引入了偏向锁，只在第一次申请锁的时候，对Java对象头的MARK WORD做CAS操作，记录下当前申请锁的线程ID，退出同步代码块后，也不释放锁，锁对象的对象头中记录的还是当前的线程ID，同一个线程再次进入这个锁的同步代码块的时候，检查锁的对象头中记录的线程ID是否还是自己，是的话就直接进入，不用再CAS了。当有多个线程要申请锁的时候，就会升级到轻量级锁。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<h1 id="ReentrantLock与synchronized的区别？"><a href="#ReentrantLock与synchronized的区别？" class="headerlink" title="ReentrantLock与synchronized的区别？"></a>ReentrantLock与synchronized的区别？</h1><p>ReentrantLock与synchronized有相同的功能和语义，添加了更多灵活的功能。<br>synchronized能干的ReentrantLock都能干，ReentrantLock能干synchronized不一定能干。</p>
<p>最主要区别有三点：支持等待可中断、可实现公平锁、锁可以绑定多个条件。</p>
<p>详细区别：<br>|   |ReentrantLock|synchronized<br>|—|—|—|<br>|底层实现|继承AQS|监视器模式<br>|灵活性|支持响应中断、超时、尝试获取锁|不灵活<br>|释放锁形式|必须显式调用unlock()释放锁，可跨方法调用|自动释放监视器，不可跨方法释放<br>|锁类型|公平锁和非公平锁|非公平锁<br>|条件队列|可关联多个条件队列|只有一个条件队列<br>|错误排查|没有释放锁，很追溯发生错误的位置，因为没有记录应该释放锁的时间和位置难度|synchronized加锁解锁过程有完整的日志</p>
<h1 id="该用ReentrantLock还是synchronized？"><a href="#该用ReentrantLock还是synchronized？" class="headerlink" title="该用ReentrantLock还是synchronized？"></a>该用ReentrantLock还是synchronized？</h1><p>除非需要ReentrantLock的特定的功能，否则还是应该优先使用synchronized，因为简单易用，不会忘记释放锁。</p>
<h1 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h1><p>底层通过继承AbstractQueuedSynchronizer实现。</p>
<p>大致过程：</p>
<ul>
<li>先通过cas修改int类型的state变量，修改成功则获取互斥锁成功。</li>
<li>cas修改失败则把当前线程生成一个节点，放入一个等待队列中，线程被挂起。<ul>
<li>等待队列操作也都是通过cas加自旋的方式来完成，避免同步开销。</li>
</ul>
</li>
<li>释放锁后，会唤醒队列去自旋CAS去修改state来获取互斥锁。</li>
</ul>
<p>state变量记录锁的重入次数。</p>
<h1 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h1><ul>
<li>jdk1.6之前synchronized直接就上重量级锁。</li>
<li>jdk1.6开始synchronized会先由无锁转为偏向锁，再转为轻量级锁，再转为重量级锁，锁只能升级不能降级。</li>
</ul>
<p>偏向锁、轻量级锁是针对synchronized优化。</p>
<h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h1><p>JVM中，对象在内存中除了存储对象本身的数据，还会额外存储关于对象的一些附加信息。</p>
<ul>
<li>普通对象的对象头中存储mark word和类型指针（指向对象所属类的指针）。</li>
<li>数组对象还会存储数组长度。</li>
</ul>
<p>mark word存储对象的hashcode、GC分代年龄、锁状态等信息。</p>
<p>mark word长度在32位系统上为32位，64位系统上长度为64位。</p>
<p>为了在有限的空间存储较多的信息，其数据格式不固定，数据位共享复用。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210826195541.png"></p>
<p>当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；</p>
<p>当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；</p>
<p>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>研究发现，大多数情况下不仅不存在锁竞争，而且总是由同一个线程多次重入，为了让同一个线程多次重入获取锁的代价更低，就引入了偏向锁的概念。</p>
<p>偏向锁获取过程：</p>
<ol>
<li> 当前线程访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认是否为可偏向状态。</li>
<li> 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>
<li> 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li>
<li> 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致当前获得偏向锁的线程被暂停）</li>
<li> 执行同步代码。</li>
</ol>
<p>偏向锁的释放：</p>
<p>偏向锁只有当遇到其他线程也尝试获取偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。（也就是对于获取偏向锁的线程 只有lock的动作，没有unlock的动作，这是因偏向的需要，即使可能这个线程已经死亡。）偏向锁的撤销步骤如下：</p>
<ol>
<li> 等到全局安全点（在这个时间点上没有正在执行的字节码）。</li>
<li> 暂停持有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果线程不处于活动状态，则将对象头设置为无锁状态。争抢锁的线程会再走生成偏向锁的过程，然后成为偏向锁的拥有者。</li>
<li> 如果持有偏向锁的线程还处于活动状态，则将锁升级为轻量级锁。</li>
</ol>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>轻量级锁实现是自旋锁，没有抢到锁的线程将自旋，即不停的循环判断是否能获取到锁，不会让线程阻塞。获取锁的操作就是通过CAS修改对象头的锁标记位。</p>
<p>长时间的循环是很占用CPU的，一个线程持有锁，其他线程只能原地空耗CPU，不执行任何有效的任务，这种现象称为busy-waiting。</p>
<p>利用短时间的busy-waiting换取线程的阻塞和唤醒在用户态和内核态切换的开销。</p>
<p>busy-waiting是有限度的（JVM可以设置参数调节循环次数上限），如果锁竞争激烈，自旋超过一定次数，就升级为重量级锁。</p>
<p>具体的CAS过程：</p>
<ul>
<li>  当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>
<li>  若CAS操作成功，则轻量级锁的上锁过程成功；</li>
<li>  若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>
</ul>
<p>轻量级锁比重量级锁性能更高的前提是：</p>
<ul>
<li>在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>
</ul>
<p>轻量级锁是为了在线程交替执行同步块时提高性能。</p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>阻塞所有竞争锁但未获得锁的线程。</p>
<p>实现依赖于操作系统的同步函数，在linux上使用mutex互斥锁，涉及到用户态和内核态的切换、进程线程上下文的切换，成本较高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/" class="post-title-link" itemprop="url">Java并发-CAS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-13 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-13T20:00:00+08:00">2017-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-CAS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源</p>
<p>所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁更新方式认为：在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。</p>
<p>但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。</p>
<p>CAS机制就是乐观锁的典型实现。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p>
<ul>
<li>  主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li>
<li>  工作内存中共享变量的副本值，也叫预期值：A</li>
<li>  需要将共享变量更新到的最新值：B</li>
</ul>
<h1 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h1><ol>
<li> 可以保证变量操作的原子性；</li>
<li> 并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li>
<li> 在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li>
</ol>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p>
<h2 id="可能会消耗较高的CPU"><a href="#可能会消耗较高的CPU" class="headerlink" title="可能会消耗较高的CPU"></a>可能会消耗较高的CPU</h2><p>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
<h2 id="不能保证代码块的原子性"><a href="#不能保证代码块的原子性" class="headerlink" title="不能保证代码块的原子性"></a>不能保证代码块的原子性</h2><p>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/" class="post-title-link" itemprop="url">Android中数据库相关的类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-19 20:22:00" itemprop="dateCreated datePublished" datetime="2017-03-19T20:22:00+08:00">2017-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/Android中数据库相关的类/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android中数据库相关类"><a href="#Android中数据库相关类" class="headerlink" title="Android中数据库相关类"></a>Android中数据库相关类</h1><ul>
<li>  SQLiteOpenHelper：管理SQLite的帮助类，提供获取SQLIteDatabase实例的方法，它会在第一次使用数据库时调用获取实例方法时创建SQLiteDatabase实例，并且处理数据库版本变化，开发人员在实现ContentProvider时都要实现一个自定义的SQLiteOpenHelper类，处理数据的创建、升级和降级。</li>
<li>  SQLiteDatabase：代表一个打开的SQLite数据库，提供了执行数据库操作的接口方法。如果不需要在进程之间共享数据，应用程序也可以自行创建这个类的实例来读写SQLite数据库。</li>
<li>  SQLiteSession：SQLiteSession负责管理数据库连接和事务的生命周期，通过SQLiteConnectionPool获取数据库连接来执行具体的数据库操作。</li>
<li>  SQLiteConnectionPool：数据库连接池，管理所有打开的数据库连接（Connection）。所有数据库连接都是通过它来打开，打开后会加入连接池，在读写数据库时需要从连接池中获取一个数据库连接来使用。</li>
<li>  SQLiteConnection：代表了数据库连接，每个Connection封装了一个native层的sqlite3实例，通过JNI调用SQLite动态库的接口方法操作数据库，Connection要么被Session持有，要么被连接池持有。</li>
<li>  CursorFactory：可选的Cursor工厂，可以提供自定义工厂来创建Cursor。</li>
<li>  DatabaseErrorHandler：可选的数据库异常处理器（目前仅处理数据库Corruption），如果不提供，将会使用默认的异常处理器。</li>
<li>  SQLiteDatabaseConfiguration：数据库配置，应用程序可以创建多个到SQLite数据库的连接，这个类用来保证每个连接的配置都是相同的。</li>
<li>  SQLiteQuery和SQLiteStatement：从抽象类SQLiteProgram派生，封装了SQL语句的执行过程，在执行时自动组装待执行的SQL语句，并调用SQLiteSession来执行数据库操作。这两个类的实现应用了设计模式中的命令模式。</li>
</ul>
<h1 id="使用SQLiteOpenHelper的原因"><a href="#使用SQLiteOpenHelper的原因" class="headerlink" title="使用SQLiteOpenHelper的原因"></a>使用SQLiteOpenHelper的原因</h1><p>之所以需要使用SQLiteOpenHelper，而不是调用Context的方法来直接得到SQLiteDatabase，主要是因为它有两个好处：</p>
<ol>
<li> 自动管理创建：当需要对数据库进行操作的时候，不用关心SQLiteOpenHelper所关联的SQLiteDatabase是否创建，SQLiteOpenHelper会帮我们去判断，如果没有创建，那么就先创建该数据库后，再返回给使用者。</li>
<li> 自动管理版本：当需要对数据库进行操作之前，如果发现当前声明的数据库的版本和手机内的数据库版本不同的时候，那么会分别调用onUpgrade和onDowngrade，这样使用者就可以在里面来处理新旧版本的兼容问题。</li>
</ol>
<h1 id="SQLiteOpenHelper跟数据库连接池的关系是怎样的？"><a href="#SQLiteOpenHelper跟数据库连接池的关系是怎样的？" class="headerlink" title="# SQLiteOpenHelper跟数据库连接池的关系是怎样的？"></a># SQLiteOpenHelper跟数据库连接池的关系是怎样的？</h1><p>一个SQLiteOpenHelper对象存有一个SQLiteDatabase对象</p>
<p>一个SQLiteDatabase对象存有一个SQLiteConnectionPool对象</p>
<p>一个SQLiteConnectionPool对象</p>
<ol>
<li> 在journal-mode下最多存有1个SQLiteConnection</li>
<li> 在wal-mode下最多存有2个SQLiteConnection</li>
</ol>
<h1 id="SQL-语句的执行过程"><a href="#SQL-语句的执行过程" class="headerlink" title="SQL 语句的执行过程"></a>SQL 语句的执行过程</h1><p>创建SQLiteStatement对象，把SQL语句传给SQLiteStatement构造函数，调用SQLiteStatement的executeInsert()</p>
<p>SQLiteStatement.executeInsert()内部的增删改查方法都会先getSession()获取SQLiteSession，再调用SQLiteSession的execute方法</p>
<p>继续追查可以发现SQLiteSession是在SQLiteDatabase里以ThreadLocal形式存储，也就是每个线程只能有一个SQLiteSession</p>
<p>SQLiteSession的execute方法里会从数据库连接获取一个连接，每个SQLiteSession对象有一个SQLiteConnection对象</p>
<h1 id="SQLiteSession存在的价值"><a href="#SQLiteSession存在的价值" class="headerlink" title="SQLiteSession存在的价值"></a>SQLiteSession存在的价值</h1><p>给数据库连接代理了一层，管理事务和连接的生命周期。</p>
<p>在事务执行过程中一直持有数据库连接。</p>
<p>由于数据库连接数量是有限的，所以连接用完后要及时释放连接。</p>
<p>事务开启后，从连接池获取连接。</p>
<p>事务结束后，把连接归还到连接池。</p>
<h1 id="数据库连接是什么意思？"><a href="#数据库连接是什么意思？" class="headerlink" title="数据库连接是什么意思？"></a>数据库连接是什么意思？</h1><p>一个连接对应一个事务操作</p>
<h1 id="如果一个数据库连接始终不关闭会有什么影响？"><a href="#如果一个数据库连接始终不关闭会有什么影响？" class="headerlink" title="如果一个数据库连接始终不关闭会有什么影响？"></a>如果一个数据库连接始终不关闭会有什么影响？</h1><p>SQLite连接数有最大限制，不关闭，会导致别的进程无法连接数据库。</p>
<h1 id="SQLiteConnectionPool连接池大小是怎么定的"><a href="#SQLiteConnectionPool连接池大小是怎么定的" class="headerlink" title="SQLiteConnectionPool连接池大小是怎么定的?"></a>SQLiteConnectionPool连接池大小是怎么定的?</h1><p>目前Android系统的实现中，如果以非WAL模式打开数据库，连接池中只会保持一个数据库连接，如果以WAL模式打开数据库，连接池中的最大连接数量则根据系统配置决定，默认配置是两个。</p>
<h1 id="数据库连接池只提供最多1个连接会有什么影响？"><a href="#数据库连接池只提供最多1个连接会有什么影响？" class="headerlink" title="数据库连接池只提供最多1个连接会有什么影响？"></a>数据库连接池只提供最多1个连接会有什么影响？</h1><p>如果应用程序中有大量的并发数据库读和写操作的话，每个操作的时长都可能受到影响，所以数据库操作应放在工作线程中执行，以免影响UI响应。</p>
<p>因为每个事务都是在SQLiteSession中执行的，执行事务前会从连接池获取连接，调用的是SQLiteConnectionPool.acquireConnection()，方法内如果获取不到Connection就会阻塞线程等待，用链表存储阻塞的线程，直到连接被释放，也就是别的事务执行完成。</p>
<p>我们平时在多线程中的数据库操作都是串行的。</p>
<h1 id="Android里开启事务，事务模式用的是哪个？"><a href="#Android里开启事务，事务模式用的是哪个？" class="headerlink" title="Android里开启事务，事务模式用的是哪个？"></a>Android里开启事务，事务模式用的是哪个？</h1><ul>
<li>SQLiteDatabase.beginTransaction()开启的是EXCLUSIVE。</li>
<li>SQLiteDatabase.beginTransactionNonExclusive()开启的是IMMEDIATE。</li>
</ul>
<p>注意这两个事务模式只针对回滚日志模式下的事务。</p>
<p><a target="_blank" rel="noopener" href="https://sqlite.org/lang_transaction.html#:%7E:text=EXCLUSIVE%20is%20similar%20to%20IMMEDIATE,while%20the%20transaction%20is%20underway.">SQLite官网</a>说在WAL日志模式下，EXCLUSIVE和IMMEDIATE是一样的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/" class="post-title-link" itemprop="url">SQLite事务、回滚日志、WAL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-18 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-18T20:56:00+08:00">2017-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite事务、回滚日志、WAL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h1><p>事务定义了一组数据库操作的边界，这组操作要么全部执行，要么全部不执行，这也是事务的原子性特征</p>
<h1 id="为什么要发明事务？事务存在的价值是什么？"><a href="#为什么要发明事务？事务存在的价值是什么？" class="headerlink" title="为什么要发明事务？事务存在的价值是什么？"></a>为什么要发明事务？事务存在的价值是什么？</h1><p>在操作数据库的情况下，需要考虑的特别的场景处理特别多，例如并发操作、系统崩溃等，发明事务这个模型，就可以用来简化讨论，把复杂的场景归类为少数的几个特定类型的场景，降低处理成本。</p>
<p>数据库操作例如增删改查、建立索引、建立约束等。</p>
<h1 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h1><p>ACID</p>
<h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h2><p>事务内的操作要么全部执行，要么全部不执行，不可再拆分</p>
<h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><p>保证数据库从一个正确的状态转变到另一个正确的状态，正确的状态指的是当前数据库中的数据都满足预定的约束条件。</p>
<p>AID是保证一致性的必要条件，但不是充分条件，因为数据库作为通用的技术，不可能知道具体业务场景的正确逻辑，所以正确的逻辑需要由用户决定应该使用怎样的约束</p>
<h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h2><p>事务的执行不受其他事务的干扰，事务之间的操作只能串行的执行，保证任何事务都不可能读取到其他任何事务内部执行的中间状态，否则会产生数据混乱</p>
<h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h2><p>事务一旦提交，它对数据库中的数据改变就是永久性的，接下来的其他操作或故障都不会影响本次事务提交的结果</p>
<h2 id="事务的原子性是如何实现的？"><a href="#事务的原子性是如何实现的？" class="headerlink" title="事务的原子性是如何实现的？"></a>事务的原子性是如何实现的？</h2><p>SQLite事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。</p>
<p>回滚日志文件，用于实现数据库的原子提交和回滚。 此文件和数据库文件总是在同一个目录，并且有相同的文件名，但是在文件名中添加了一个-journal 字符串。此文件一般在transaction开始时创建，transaction结束时删除。</p>
<p>如果系统crash，Rollback journals文件将被保留，下次打开数据库文件时，系统会检查有没有Rollback journals文件存在，如果有就用它来恢复数据库。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092550.png"></p>
<h1 id="创建回滚日志详细过程是怎样的？"><a href="#创建回滚日志详细过程是怎样的？" class="headerlink" title="创建回滚日志详细过程是怎样的？"></a>创建回滚日志详细过程是怎样的？</h1><ol>
<li> 写数据库前获取保留锁</li>
<li> 创建回滚日志文件，将要修改的页的原始数据写到缓存中</li>
<li> 在用户空间修改页数据</li>
<li> 回滚日志的缓存刷盘到回滚日志文件中</li>
<li> 获取未决锁，等待共享锁都释放后，提升为排它锁</li>
<li> 将用户空间修改过的数据写入数据库文件，会先写到操作系统的缓存中，再刷盘到磁盘上</li>
<li> 删除rollback journal文件</li>
<li> 释放排它锁</li>
</ol>
<h2 id="创建rollback-journal-file"><a href="#创建rollback-journal-file" class="headerlink" title="创建rollback journal file"></a>创建rollback journal file</h2><p>将要修改的pages的原始数据写入rollback journal file，以page为单位写入。</p>
<p>rollback journal file中绿色的部分是header,header中会包括数据库文件的原始大小(即包括多少个page)。每一个page保存到rollback journal中时前边四字节会保存该page的page number。</p>
<ul>
<li>  rollback journal创建之后并没有实际落盘,只是保存在操作系统的缓存中</li>
<li>  rollback journal以page为单位,但每个page前四字节会有一个page number的记录,后四字节有一个checksum</li>
</ul>
<h2 id="在用户空间修改数据库文件"><a href="#在用户空间修改数据库文件" class="headerlink" title="在用户空间修改数据库文件"></a>在用户空间修改数据库文件</h2><p>修改用户进程空间内的数据库文件,注意不同的用户进程有自己的私有内存空间,因此此时的修改并不影响其他进程的读取操作。</p>
<h2 id="将rollback-journal落盘"><a href="#将rollback-journal落盘" class="headerlink" title="将rollback journal落盘"></a>将rollback journal落盘</h2><p>该步骤是保持原子性很关键的一步,保证即使掉电或者操作系统crash,Sqlite也能恢复到原来的状态。</p>
<p>(进行到该步也能看出reserved lock的作用,这种锁是一个中间状态,既能为即将写入做准备,又不影响其他进程的读取操作,提高并行度)。</p>
<p>该步需要刷两次盘,第一次将rollback journal的内容刷到磁盘,第二次在header中记录第一步中刷到磁盘的page个数,然后将header刷盘。</p>
<h2 id="获取排他锁"><a href="#获取排他锁" class="headerlink" title="获取排他锁"></a>获取排他锁</h2><p>在实际写入数据库文件之前,需要获取一个排他锁.获取过程分两步<br>    • 获取一个pending lock<br>    • 将pending lock升级为排他锁<br>获取到pending lock之后,在数据库文件上已经获取到共享锁的进程可以继续读取,但不允许其他进程继续获取共享锁.该锁存在的意义在于防止write starvation(即有大量的读取连接时,一直有新的共享锁产生,导致获取不到排他锁).当所有已经存在的共享锁都释放后,此时该pending lock即可以升级为排他锁。</p>
<h2 id="写入数据库文件"><a href="#写入数据库文件" class="headerlink" title="写入数据库文件"></a>写入数据库文件</h2><p>获取到排他锁后,说明已经没有其他进程在读取该数据库文件.此时可以安全的写入数据库文件.注意也只是写入操作系统的缓存中,并没有落盘。</p>
<h2 id="删除rollback-journal"><a href="#删除rollback-journal" class="headerlink" title="删除rollback journal"></a>删除rollback journal</h2><p>因为数据库文件已经安全落盘,此时可以删除掉rollback journal.若删除之前系统crash或者掉电,则重启后会恢复到事务开始前的状态,如果删除之后系统crash或者掉电,因为数据库文件已经落盘,相当于事务已经执行完成.(那么会不会在删除一半时系统crash或者掉电呢?注意上文中关于硬件的一些假设,删除操作必须是原子性的,即不会发生这种情况)</p>
<p>因为删除一个文件也是一个耗时的操作,因此Sqlite提供了两种方式减少删除过程的耗时.</p>
<ul>
<li>  将一个文件truncate为0</li>
<li>  将journal file header清0.清0操作并不是原子性的,但只要header中有一个byte被清0,该文件就会被识别为无效的格式</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/lockingv3.html#rollback">The Rollback Journal</a></li>
</ul>
<h1 id="热日志是什么意思？"><a href="#热日志是什么意思？" class="headerlink" title="热日志是什么意思？"></a>热日志是什么意思？</h1><p>每次打开数据库文件，或者从数据库读取页时，都要简单的做一致性检查。</p>
<p>如果发现存在回滚日志文件，但是数据库中没有保留锁，那么创建日志文件的肯定崩溃了或者系统死机了，因为正常情况下，获得保留锁后才会创建回滚日志。</p>
<p>这种情况下日志被称为“热日志”，数据库可能处于不一致的状态（不满足约束条件），要让一切正常需要回滚日志，将数据库还原到初始的被中断的事务之前的状态。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092653.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>
<h1 id="SQLite中事务为什么还要分不同的类型？分别有什么作用？"><a href="#SQLite中事务为什么还要分不同的类型？分别有什么作用？" class="headerlink" title="SQLite中事务为什么还要分不同的类型？分别有什么作用？"></a>SQLite中事务为什么还要分不同的类型？分别有什么作用？</h1><p>是为了解决死锁</p>
<p>SQLite的事务分为</p>
<ol>
<li> deferred</li>
<li> immediate</li>
<li> exclusive</li>
</ol>
<p>begin [ deferred | immediate | exclusive ] transaction</p>
<p>deferred</p>
<ol>
<li> 未指定事务模式时默认的选择</li>
<li> 开始事务时处于未锁定状态</li>
<li> 实际访问数据库时才试图加锁</li>
<li> 第一个读数据库操作试图获取共享锁</li>
<li> 第一个写数据库操作试图获取预留锁</li>
</ol>
<p>immediate</p>
<ol>
<li> 事务开始时试图获取预留锁</li>
<li> 获取预留锁成功后，其他连接中已执行的事务无法再获取到预留锁</li>
<li> 新的连接开始immediate和exclusive的事务也会失败，并返回SQLITE_BUSY错误</li>
<li> 最后提交事务时，预留锁会提升到未决锁</li>
<li> 等待其他连接中的事务释放共享锁</li>
<li> 阻止新的连接获取共享锁</li>
<li> 如果其他事务一直没释放共享锁，会返回SQLITE_BUSY错误</li>
</ol>
<p>exclusive</p>
<ol>
<li> 开始事务时尝试获取排它锁</li>
<li> 获取成功后阻止所有的读写操作</li>
<li> 在事务内可以对数据库进行任意的读写</li>
</ol>
<p>参考《SQLite权威指南（第2版）》118页  第4章 SQLite中的高级SQL - 事务的类型</p>
<h1 id="SQLite-WAL是什么？"><a href="#SQLite-WAL是什么？" class="headerlink" title="SQLite WAL是什么？"></a>SQLite WAL是什么？</h1><p>SQLite在3.7.0开始引入了WAL技术</p>
<p>Write-Ahead Log</p>
<p>预先写日志</p>
<p>默认的 rollback journal 模式工作原理大致为：写操作进行前进行数据库文件拷贝，然后对数据库进行写操作。如果发生 Crash 或者 rallback 则将日志中的原始内容回滚到数据库中进行恢复操作，否则在 Commit 完成时删除日志文件。</p>
<p>WAL模式采用了相反的的做法，</p>
<p>在准备写数据库文件前，会先复制数据库文件的中的原始数据到日志文件，写操作也只更新日志文件，原有数据库文件不变动；</p>
<p>如果事务失败，WAL中的数据被忽略；</p>
<p>如果事务成功，在随后的某个时间点，将WAL中的数据写回到数据库文件，这个时间点称为checkpoint。</p>
<p>WAL使用检查点将修改写回数据库，默认情况下，当WAL文件发现有1000页修改时，将自动调用检查点。这个页数大小可以自行配置。</p>
<p>读数据时，SQLite在WAL中搜索，找到最后一个写入点，并记录，读时忽略这个写入点后面的信息，如果读取在WAL中读取不到数据，则去数据库文件中读取；写数据时继续往记录点后追加写入数据，这样保证了读和写可以同时进行；由于同一时刻只能有一个连接写数据库，写与写之间是互斥的，所以不会产生写入点后面写数据时指针冲突。</p>
<p>由于每个读操作都会搜索整个WAL文件，所以在共享内存加建立了一个wal-index索引，加速查找，避免扫描整个WAL文件。</p>
<h1 id="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"><a href="#WAL提升了哪方面的性能？优点是什么？解决了什么问题？" class="headerlink" title="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"></a>WAL提升了哪方面的性能？优点是什么？解决了什么问题？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093052.png"></p>
<p>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> WAL is significantly faster in most scenarios.</li>
<li> WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</li>
<li> Disk I/O operations tends to be more sequential using WAL.</li>
<li> WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="WAL的缺点是什么？"><a href="#WAL的缺点是什么？" class="headerlink" title="WAL的缺点是什么？"></a>WAL的缺点是什么？</h1><ol>
<li> 所有的数据库操作必须都在同一台机器上进行，并且该机器的操作系统需要支持 VFS 特性。</li>
<li> 当连接处于 WAL 模式中时我们无法修改页大小</li>
<li> 为满足 Wal 和相关共享内存的需要，使用 WAL 引入了两个额外的半持久性文件 -wal 和 -shm 该文件需要占用一定的存储空间。</li>
<li> 数据库读性能会比 rollback journal 模式略差 （大概慢 1% ～ 2% ），另外写操作也会间歇性的性能下降。</li>
<li> 读操作的性能会比 rollback journal 模式出现部分下降，因为它需要额外对 -wal 文件进行一次检索，而且 Checkpoint 本身就比较耗时且会对读操作进行阻塞。</li>
<li> 频繁 Checkpoint 变得频繁又会影响写操作的性能指标，而且频繁的同步操作也会增加数据库损坏的概率</li>
</ol>
<hr>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093220.png"><br>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</li>
<li> Transactions that involve changes against multiple <a target="_blank" rel="noopener" href="https://sqlite.org/lang_attach.html">ATTACHed</a> databases are atomic for each individual database, but are not atomic across all databases as a set.</li>
<li> WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</li>
<li> There is an additional quasi-persistent “-wal” file and “-shm” shared memory file associated with each database, which can make SQLite less appealing for use as an <a target="_blank" rel="noopener" href="https://sqlite.org/appfileformat.html">application file-format</a>.</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="Android中如何开启WAL？"><a href="#Android中如何开启WAL？" class="headerlink" title="Android中如何开启WAL？"></a>Android中如何开启WAL？</h1><p>SQLiteDatabase.enableWriteAheadLogging()</p>
<p>根据注释描述，Android默认没有开启WAL。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">SQLite锁机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-17 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-17T20:56:00+08:00">2017-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite锁机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQLite锁的粒度到哪里？"><a href="#SQLite锁的粒度到哪里？" class="headerlink" title="SQLite锁的粒度到哪里？"></a>SQLite锁的粒度到哪里？</h1><p>SQLite锁的是整个数据库文件，不支持页锁、表锁和行锁，粒度较粗。</p>
<p>当一个连接要写数据库文件时，所有其他的连接都会阻塞，直到写数据的连接事务结束。</p>
<p>SQLite 3.7.0 新增 Write-Ahead Log 机制改变了事务行为，读写可以并发。</p>
<h1 id="为什么SQLite不支持表锁和行锁呢？"><a href="#为什么SQLite不支持表锁和行锁呢？" class="headerlink" title="为什么SQLite不支持表锁和行锁呢？"></a>为什么SQLite不支持表锁和行锁呢？</h1><p>支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。</p>
<p>同时复杂性增大会增加运行设备电量的损害，对于手机这类这种电量敏感的设备比较重要。</p>
<h1 id="SQLite锁机制是怎样的？"><a href="#SQLite锁机制是怎样的？" class="headerlink" title="SQLite锁机制是怎样的？"></a>SQLite锁机制是怎样的？</h1><p>有多个数据库连接同时访问同一个数据库，就产生了资源竞争，需要锁机制保证资源竞争的正确性</p>
<p>数据库操作无非就是读和写，按道理普通的读写锁就可以实现，但高并发下读写锁仍然有优化的空间，为了提高整体的吞吐量，SQLite使用了锁逐步提升的机制</p>
<p>SQLite共有5种锁状态：</p>
<ol>
<li> 无锁（unlocked）</li>
<li> 共享（shared）</li>
<li> 预留（reserved）</li>
<li> 未决（pending）</li>
<li> 排它（exclusive）</li>
</ol>
<p>每个数据库连接同一时刻只能处于其中一个状态</p>
<p>无锁：</p>
<ol>
<li> 即使事务已经开始，在没有读写数据库前，都是无锁状态</li>
</ol>
<p>共享：</p>
<ol>
<li> 读数据库必须获得共享锁</li>
<li> 多个数据库连接可以同时获得共享锁，即允许多个连接同时读数据库</li>
<li> 写数据库前必须要释放所有的共享锁</li>
</ol>
<p>预留：</p>
<ol>
<li> 写数据需要先获取到预留锁</li>
<li> 持有预留锁后就可以立即把数据写入缓存中，而不用竞争数据库文件，把可以不占用的数据库文件可以完成的事情提前完成，这样最大程度的减少独占数据库文件的时间</li>
<li> 预留锁可以与共享锁共存</li>
<li> 预留锁不影响其他已经持有共享锁的连接继续读数据库</li>
<li> 预留锁不阻止其他连接获得新的共享锁，因为并不确定是否要立即写入数据库文件，可能之后还要修改数据库内容，提交事务的时候才知道后面不会再修改数据库了</li>
<li> 一个数据库同时只能有一个预留锁存在</li>
</ol>
<p>未决：</p>
<ol>
<li> 当连接提交事务时，就要把缓存里的数据往数据库文件中写入，以保证事务的持久性</li>
<li> 对数据库文件写数据前，需要保证没有连接再持有共享锁</li>
<li> 但此时可能还有其他连接持有共享锁，需要等待这些连接释放共享锁后，才能写数据</li>
<li> 同时要阻止新的连接获取共享锁，否则写数据一直得不到执行</li>
<li> 所以从预留锁要转变为未决锁，来阻止新的连接获取共享锁</li>
</ol>
<p>排它：</p>
<ol>
<li> 所有共享锁释放后，未决锁提升为排他锁</li>
<li> 排它锁和未决锁一样，会阻止新的连接获取共享锁，阻止读数据</li>
<li> 获得排它锁后，就可以把缓存中的数据写入数据库文件</li>
</ol>
<p>参考资料：</p>
<p>《SQLite权威指南（第2版）》116页  第4章 SQLite中的高级SQL - 数据库锁</p>
<h1 id="SQLite锁为什么搞这么多状态？"><a href="#SQLite锁为什么搞这么多状态？" class="headerlink" title="SQLite锁为什么搞这么多状态？"></a>SQLite锁为什么搞这么多状态？</h1><ul>
<li>由于写数据时是排他的，其他连接无法读数据库，所以要尽可能的减少写数据时的耗时，才能提高系统整体的吞吐量。</li>
<li>所以写数据时先获取预留锁，把可以在不占用数据库文件的事情提前做好。</li>
<li>那些需要占用数据库文件才能做的事情留到获取到排他锁时再做。<ul>
<li>获取排它锁前需要保证没有连接再获取共享锁。</li>
<li>所以先从预留锁提升到未决锁，用来阻止新的共享锁的获取。</li>
<li>等待已经获取的共享锁的连接执行完后释放了所有的共享锁，最后获取到排它锁写数据库文件。</li>
</ul>
</li>
</ul>
<h1 id="锁的状态转移过程是怎样的？"><a href="#锁的状态转移过程是怎样的？" class="headerlink" title="锁的状态转移过程是怎样的？"></a>锁的状态转移过程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091837.png"></p>
<h1 id="为什么事务的开始都要先获取未决锁，再获取共享锁？"><a href="#为什么事务的开始都要先获取未决锁，再获取共享锁？" class="headerlink" title="为什么事务的开始都要先获取未决锁，再获取共享锁？"></a>为什么事务的开始都要先获取未决锁，再获取共享锁？</h1><p>因为如果已经获得了未决锁，说明要占用数据库文件进行写操作，就不允许读了，而读数据库需要获得共享锁，这里就阻止别的连接获取共享锁。</p>
<h1 id="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"><a href="#有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？" class="headerlink" title="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"></a>有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？</h1><p>获得预留锁时，读写可以并发执行，但是真正写数据库需要阻止共享锁获取。</p>
<p>这样做可以提升系统整体的吞吐量。</p>
<h1 id="SQLite锁机制需要注意什么？"><a href="#SQLite锁机制需要注意什么？" class="headerlink" title="SQLite锁机制需要注意什么？"></a>SQLite锁机制需要注意什么？</h1><p>注意死锁的发生</p>
<h1 id="SQLite什么情况下会发生死锁？"><a href="#SQLite什么情况下会发生死锁？" class="headerlink" title="SQLite什么情况下会发生死锁？"></a>SQLite什么情况下会发生死锁？</h1><p>SQLite发生死锁时会抛出database is locked的异常信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091949.png"></p>
<p>参考《SQL权威指南（第2版）》117页 SQLite中的高级SQL - 死锁</p>
<h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>用正确的事务类型来开启事务</p>
<p>存在并发写数据，就开启immediate或exclusive事务，提供了同步机制</p>
<p>SQLite有三种不同的事务类型：</p>
<ol>
<li> DEFERRED（推迟）</li>
<li> MMEDIATE（立即）</li>
<li> EXCLUSIVE（排它）</li>
</ol>
<p>事务类型在BEGIN命令中指定。</p>
<p>一个deferred事务不获取任何锁，直到它需要锁的时候。而且BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态；默认情况下是这样的。如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取SHARED LOCK；同样，当进行第一次写操作时，它会获取RESERVED LOCK。</p>
<p>由BEGIN开始的Immediate事务会试着获取RESERVED LOCK。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作，但是RESERVED LOCK会阻止其它的连接BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，SQLite会返回SQLITE_BUSY错误。这时你就可以对数据库进行修改操作，但是你不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。</p>
<p>Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 上面那个例子的问题在于两个连接最终都想写数据库，但是他们都没有放弃各自原来的锁，最终，shared 锁导致了问题的出现。如果两个连接都以BEGIN IMMEDIATE开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入BEGIN IMMEDIATE，其它的连接就得等待。BEGIN IMMEDIATE和BEGIN EXCLUSIVE通常被写事务使用。就像同步机制一样，它防止了死锁的产生。 基本的准则是：如果你在使用的数据库没有其它的连接，用BEGIN就足够了。但是，如果你使用的数据库在其它的连接也要对数据库进行写操作，就得使用BEGIN IMMEDIATE或BEGIN EXCLUSIVE开始你的事务。</p>
<h1 id="Android中对SQLite开启的哪一种事务类型？"><a href="#Android中对SQLite开启的哪一种事务类型？" class="headerlink" title="Android中对SQLite开启的哪一种事务类型？"></a>Android中对SQLite开启的哪一种事务类型？</h1><p>SQLiteDatabase开启事务有两个方法：</p>
<ol>
<li> beginTransaction()开启exclusive事务类型</li>
<li> beginTransactionNonExclusive()开启immediate事务类型</li>
</ol>
<h1 id="锁的状态存储在哪里？"><a href="#锁的状态存储在哪里？" class="headerlink" title="锁的状态存储在哪里？"></a>锁的状态存储在哪里？</h1><p>数据库文件是独立于进程的，多个进程可以访问同一个文件，所以数据库锁是存在数据库文件中的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092032.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092040.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">SQLite并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-16 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-16T20:31:00+08:00">2017-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite并发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQLite支持多线程吗？"><a href="#SQLite支持多线程吗？" class="headerlink" title="SQLite支持多线程吗？"></a>SQLite支持多线程吗？</h1><p>SQLite支持多线程，但是是有条件的支持，也就是：</p>
<ul>
<li>同一个连接不能在多线程中使用，不同连接才可以在多线程中使用，这个是最宏观的SQLite多线程准则。</li>
<li>SQLite的文件锁是粗颗粒的，也就是以数据库文件为维度加锁，涉及到5种锁状态。</li>
</ul>
<p>为了确保数据库安全，SQLite 内部抽象了两种类型的互斥锁（锁的具体实现和宿主平台有关）来应对线程并发问题：</p>
<ul>
<li>fullMutex<br>可以理解为 connection mutex，和连接句柄（上问描述的 sqlite3 结构体）绑定。<br>保证任何时候，最多只有一个线程在执行基于连接的事务。</li>
<li>coreMutex<br>当前进程中，与文件绑定的锁。<br>用于保护数据库相关临界资源，确保在任何时候，最多只有一个线程在访问。</li>
</ul>
<h2 id="SQLite三种线程模型"><a href="#SQLite三种线程模型" class="headerlink" title="SQLite三种线程模型"></a>SQLite三种线程模型</h2><ul>
<li>single-thread<ul>
<li>  coreMutex 和 fullMutex 都被禁用。</li>
<li>  用户层需要确保在任何时候只有一个线程访问 API，否则抛出异常。</li>
</ul>
</li>
<li>multi-thread<ul>
<li>  coreMutex 保留，fullMutex 禁用。</li>
<li>  可以多个线程基于不同的连接并发访问数据库，但单个连接在任何时候只能被一个线程访问。</li>
<li>单个 connection，如果并发访问，会抛出异常。<ul>
<li>  报错信息：illegal multi-threaded access to database connection。</li>
</ul>
</li>
</ul>
</li>
<li>serialized<ul>
<li>  coreMutex 和 fullMutex 都保留。</li>
</ul>
</li>
</ul>
<h1 id="同一个数据库连接多线程访问会有什么问题？"><a href="#同一个数据库连接多线程访问会有什么问题？" class="headerlink" title="同一个数据库连接多线程访问会有什么问题？"></a>同一个数据库连接多线程访问会有什么问题？</h1><p>一个数据库连接对应一个事务操作，多线程访问一个连接会造成事务不原子化，事务执行结果会混乱。</p>
<h1 id="不同的连接同时写数据库会发生什么？"><a href="#不同的连接同时写数据库会发生什么？" class="headerlink" title="不同的连接同时写数据库会发生什么？"></a>不同的连接同时写数据库会发生什么？</h1><p>就走入了SQLite本身的锁机制。</p>
<p>写数据会去获取保留锁、独占锁。</p>
<p>如果还有连接要写入，就会返回SQLITE_BUSY。</p>
<h1 id="Android中的SQLite的Thread-Mode是什么？"><a href="#Android中的SQLite的Thread-Mode是什么？" class="headerlink" title="Android中的SQLite的Thread Mode是什么？"></a>Android中的SQLite的Thread Mode是什么？</h1><p><a target="_blank" rel="noopener" href="http://www.sqlite.org/threadsafe.html">SQLite官网</a>说默认线程模式是serialized</p>
<p>Android的SQLiteDatabase类的<a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">setLockingEnabled(boolean lockingEnabled)文档</a>说，默认线程模式是Multi-thread。</p>
<p>API 16 setLockingEnabled() 方法又废弃了。</p>
<p>不管怎么说肯定不是single-thread，不是multi-thread就是serialized。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11167834/what-is-the-default-threading-mode-of-sqlite-in-android">What is the Default Threading mode of SQLite in Android?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">数据库索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-15 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-15T20:31:00+08:00">2017-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/数据库索引/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库建立索引是干什么的？"><a href="#数据库建立索引是干什么的？" class="headerlink" title="数据库建立索引是干什么的？"></a>数据库建立索引是干什么的？</h1><p>按某列的条件做查询后（where子句中访问的列），需要线性扫描全表太慢了。</p>
<p>用B+树实现索引可以在对数时间内完成查询。</p>
<h1 id="索引为什么不用平衡二叉查找树，要用B树或B-树做索引？"><a href="#索引为什么不用平衡二叉查找树，要用B树或B-树做索引？" class="headerlink" title="索引为什么不用平衡二叉查找树，要用B树或B+树做索引？"></a>索引为什么不用平衡二叉查找树，要用B树或B+树做索引？</h1><p>B树又称多路平衡二叉查找树，一个结点存储多个值，可以降低树的高度，即降低了访问结点的次数，一次访问可以认为是一次IO，降低了IO次数就会提高整体的访问速度。</p>
<h1 id="为什么不用哈希表做索引？查询时间复杂度不是O-1"><a href="#为什么不用哈希表做索引？查询时间复杂度不是O-1" class="headerlink" title="为什么不用哈希表做索引？查询时间复杂度不是O(1)?"></a>为什么不用哈希表做索引？查询时间复杂度不是O(1)?</h1><ol>
<li> 哈希索引对于范围查询和排序却无法很好地支持，最终导致全表扫描</li>
<li> 哈希索引不支持多列联合索引的最左匹配规则</li>
<li> 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li>
</ol>
<h1 id="为什么用B-树做索引而不用B树？"><a href="#为什么用B-树做索引而不用B树？" class="headerlink" title="为什么用B+树做索引而不用B树？"></a>为什么用B+树做索引而不用B树？</h1><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</p>
<p> B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。</p>
<p>而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间。</p>
<h1 id="使用B树做索引的好处？"><a href="#使用B树做索引的好处？" class="headerlink" title="使用B树做索引的好处？"></a>使用B树做索引的好处？</h1><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h1 id="索引有什么缺点？"><a href="#索引有什么缺点？" class="headerlink" title="索引有什么缺点？"></a>索引有什么缺点？</h1><ol>
<li> 占用空间，因为会把列的信息都复制一遍</li>
<li> 插入、修改、删除时需要额外花时间更新索引</li>
</ol>
<h1 id="索引适用场景？"><a href="#索引适用场景？" class="headerlink" title="索引适用场景？"></a>索引适用场景？</h1><p>适用查询非常频繁而更新不频繁的列。</p>
<h2 id="where子句中对列的访问"><a href="#where子句中对列的访问" class="headerlink" title="where子句中对列的访问"></a>where子句中对列的访问</h2><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p>
<h1 id="为什么外键要加索引？"><a href="#为什么外键要加索引？" class="headerlink" title="为什么外键要加索引？"></a>为什么外键要加索引？</h1><p>避免子表上的全表扫描。（外键在子表上，外键对应主表的主键）</p>
<p>假设删除departments主表id=10的记录，如果employees子表的department_id外键没有索引，那么就会全表扫描employees子表，以确认是否存在department id=10的记录。</p>
<h1 id="联合索引是什么？"><a href="#联合索引是什么？" class="headerlink" title="联合索引是什么？"></a>联合索引是什么？</h1><p>对多个字段联合创建的索引。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232210.png"></p>
<p>只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p>
<p>通俗理解：</p>
<p>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</p>
<p>所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p>
<p>查英语字典、汉语字典也是这样。</p>
<h1 id="联合索引的底层实现是怎样的？"><a href="#联合索引的底层实现是怎样的？" class="headerlink" title="联合索引的底层实现是怎样的？"></a>联合索引的底层实现是怎样的？</h1><p>索引的底层是一颗B+树，联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。</p>
<p>构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。</p>
<p>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232238.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p>联合索引会对最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序，以此类推。</p>
<p>所以如果要利用到联合索引中靠后列的索引，前面列就必须相等，如果前面列不相等（比如用范围查询），那么后面的列没办法保证顺序，后面列的顺序都是在前面列相等的情况下才保持顺序的。</p>
<h1 id="为什么表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么表必须有主键，并且推荐使用整型的自增主键？"></a>为什么表必须有主键，并且推荐使用整型的自增主键？</h1><p>不建主键不代表没有主键，没有建主键innodb会帮你选一个字段，一个可以标识唯一的字段，选为默认字段，如果这个字段唯一的话，不重复，可一键唯一索引的话，就会作为类似于唯一索引，用这个字段来作为唯一索引来维护整个表的数据。如果没有，mysql会生成一个唯一的列，类似于rowid，只不过你看不到，他会用生成的这个唯一列，维护B+Tree的结构，查数据的时候还是用B+Tree的结构去查找。</p>
<h2 id="为什么推荐整型呢？"><a href="#为什么推荐整型呢？" class="headerlink" title="为什么推荐整型呢？"></a>为什么推荐整型呢？</h2><p>我们想象一下查找过程，是把节点load到内存然后在内存里去比较大小，也就是在查找的过程中要不断的去进行数据的比对。假设UUID，既不自增也不是整形。问一下，是整形的1&lt;2比较的效率高还是字符串的“abc”和“abe”比较的效率高呢？显然是前者，因为字符串的比较是转换成ASICI一位一位的比，如果最后一位不一样，比到最后才比较出大小，就比整形比较慢多了，存储空间来说，整形更小。索引越节约资源越好。</p>
<p>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232458.png"></p>
<p>所以建议使用int的auto_increment作为主键。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232514.png"><br>主键的值是顺序的，所以每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p>
<h2 id="为什么是自增的呢？"><a href="#为什么是自增的呢？" class="headerlink" title="为什么是自增的呢？"></a>为什么是自增的呢？</h2><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h1 id="聚簇索引是什么？"><a href="#聚簇索引是什么？" class="headerlink" title="聚簇索引是什么？"></a>聚簇索引是什么？</h1><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>数据库表数据是用B+树来存储组织的，那么这个B+树可以认为是一种索引，这就是聚簇索引。</p>
<p>索引是针对某一列而言的，一般的聚簇索引就是主键列。</p>
<p>聚簇索引确定了表数据的物理存储顺序，聚簇索引B+树的叶子结点存储的是整个行数据</p>
<p>由于聚簇索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚簇索引。</p>
<p>聚簇索引类似于电话簿，按姓氏排列数据。汉语字典也是聚簇索引的典型应用，在汉语字典里，索引项是字母+声调，字典正文也是按照先字母再声调的顺序排列。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<p>如果是普通的索引，B+树的叶子结点存储的行的主键，然后需要再去聚簇索引下去查询一遍，找到完整的行数据，有一个回表查询的过程，所以在聚簇索引上查询会少了回表查询的过程，查询速度快。</p>
<p>MySQL官方对聚簇索引的解释：</p>
<p><strong>The InnoDB term for a primary key index</strong>. InnoDB table storage is organized based on the values of the primary key columns, to speed up queries and sorts involving the primary key columns. For best performance, choose the primary key columns carefully based on the most performance-critical queries. Because modifying the columns of the clustered index is an expensive operation, choose primary columns that are rarely or never updated.</p>
<p>注意标黑的那段话，聚簇索引就是主键的一种术语。</p>
<h1 id="聚簇索引有什么用？"><a href="#聚簇索引有什么用？" class="headerlink" title="聚簇索引有什么用？"></a>聚簇索引有什么用？</h1><p>聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">聚集索引</a>可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚簇（物理排序），避免每次查询该列时都进行排序，从而节省成本。</p>
<p>在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查(between、&lt;、&lt;=、&gt;、&gt;=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大大提高查询速度。</p>
<h1 id="为什么非聚簇索引结构叶子节点存储的是主键值？"><a href="#为什么非聚簇索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非聚簇索引结构叶子节点存储的是主键值？"></a>为什么非聚簇索引结构叶子节点存储的是主键值？</h1><p>为了一致性和节省存储空间。已经维护了一套主键索引+数据的B+Tree结构，如果再有其他的非主键索引的话，索引的叶子节点存储的是主键，这是为了节省空间，因为继续存数据的话，那就会导致一份数据存了多份，空间占用就会翻倍。另一方面也是一致性的考虑，都通过主键索引来找到最终的数据，避免维护多份数据导致不一致的情况。</p>
<h1 id="哪些列适合作为聚簇索引？"><a href="#哪些列适合作为聚簇索引？" class="headerlink" title="哪些列适合作为聚簇索引？"></a>哪些列适合作为聚簇索引？</h1><p>1、主键列,该列在where子句中使用并且插入是随机的。</p>
<p>2、按范围存取的列，如pri_order &gt; 100 and pri_order &lt; 200。</p>
<p>3、在group by或order by中使用的列。</p>
<p>4、不经常修改的列。</p>
<p>5、在连接操作中使用的列。</p>
<h1 id="聚簇索引的优点和缺点？"><a href="#聚簇索引的优点和缺点？" class="headerlink" title="聚簇索引的优点和缺点？"></a>聚簇索引的优点和缺点？</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li> 适合范围查询</li>
<li> 适配排序</li>
<li> 当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引只能定位到对应主键，然后要再回表查询聚簇索引，才能找到完整的行数据。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p>
<p>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
<p>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
<p>4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
<h1 id="二级索引是什么？"><a href="#二级索引是什么？" class="headerlink" title="二级索引是什么？"></a>二级索引是什么？</h1><p>表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p>
<p>除了聚簇索引以外的所有索引都称为二级索引，二级索引的叶子节点内容是主键的值。</p>
<p>二级索引没有存储全部的数据，假如二级索引满足查询需求，则直接返回，即为覆盖索引，反之则需要回表去主键索引(聚簇索引)查询。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233004.png"></p>
<h1 id="何时使用聚簇索引与非聚簇索引？"><a href="#何时使用聚簇索引与非聚簇索引？" class="headerlink" title="何时使用聚簇索引与非聚簇索引？"></a>何时使用聚簇索引与非聚簇索引？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233032.png"></p>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><p>（1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列，即较频繁作为查询条件的字段才去创建索引</p>
<p>（2）取值离散小、查询中很少涉及、重复值比较多的列，索引效果较差，没有必要在此列建立索引</p>
<p>（3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p>
<p>（4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<p>（5）更新频繁字段不适合创建索引。</p>
<h1 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h1><ol>
<li> 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li> 存储引擎不能使用索引范围条件右边的列</li>
<li> 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</li>
<li> mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li> is null,is not null也无法使用索引</li>
<li> like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/" class="post-title-link" itemprop="url">关系型数据库-范式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-12 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-12T20:31:00+08:00">2017-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 16:50:47" itemprop="dateModified" datetime="2021-08-28T16:50:47+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/关系型数据库-范式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="范式解决的是什么问题？"><a href="#范式解决的是什么问题？" class="headerlink" title="范式解决的是什么问题？"></a>范式解决的是什么问题？</h1><p>消除数据冗余，提高增删改查的性能。</p>
<h1 id="范式的优缺点？"><a href="#范式的优缺点？" class="headerlink" title="范式的优缺点？"></a>范式的优缺点？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231020.png"></p>
<p>参考：《高性能MySQL》 4.3.1 范式的优点和缺点。</p>
<h1 id="反范式的优缺点？"><a href="#反范式的优缺点？" class="headerlink" title="反范式的优缺点？"></a>反范式的优缺点？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231049.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231057.png"></p>
<p>参考：《高性能MySQL》 4.3.2 反范式的优点和缺点</p>
<h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>确保每列保持原子性。</p>
<p>每列不可再分割，符合原子性特征，不分割的话你增删改查特定的数据发现不是单独的一列就不方便。</p>
<p>违反第一范式：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231130.png"></p>
<p>符合第一范式：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231142.png"></p>
<h2 id="满足第一范式后还存在什么问题？"><a href="#满足第一范式后还存在什么问题？" class="headerlink" title="满足第一范式后还存在什么问题？"></a>满足第一范式后还存在什么问题？</h2><p>但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231343.png"></p>
<ol>
<li> 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大</li>
<li> 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 ——插入异常</li>
<li> 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常</li>
<li> 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常。</li>
</ol>
<h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>确保每列都和主键相关。</p>
<p>每列依赖于全部的主键而非部分主键，这样才可以唯一确定一行记录，消除一部分冗余。</p>
<h2 id="怎样判断表是否符合第二范式？"><a href="#怎样判断表是否符合第二范式？" class="headerlink" title="怎样判断表是否符合第二范式？"></a>怎样判断表是否符合第二范式？</h2><p>第一步：找出数据表中所有的码（单主键或联合主键）。</p>
<p>第二步：根据第一步所得到的码，找出所有的主属性（主键中的属性）。</p>
<p>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。</p>
<p>第四步：查看是否存在非主属性对码的部分函数依赖，根据上下文分析属性间依赖关系</p>
<h2 id="违反第二范式会怎样？"><a href="#违反第二范式会怎样？" class="headerlink" title="违反第二范式会怎样？"></a>违反第二范式会怎样？</h2><p>为了满足第二范式，会把表进行拆分，这样可以消除表中的冗余信息、插入异常、删除异常、修改异常。</p>
<p>违反第二范式的表：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231441.png"></p>
<p>属性间依赖关系：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231449.png"></p>
<p>满足第二范式后表情况：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231504.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231512.png"></p>
<p>运用第二范式后结果：</p>
<ol>
<li>李小明转系到法律系<br> 只需要修改一次李小明对应的系的值即可。——有改进</li>
<li>数据冗余是否减少了？<br> 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
<li>删除某个系中所有的学生记录<br> 该系的信息仍然全部丢失。——无改进</li>
<li>插入一个尚无学生的新系的信息。<br> 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
</ol>
<h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>确保每列都和主键直接相关而非间接相关。</p>
<p>非主键列之间不应该有依赖关系，这样可以消除冗余信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231541.png"></p>
<p>对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231553.png"></p>
<p>对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。</p>
<p>为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：</p>
<ul>
<li>选课（学号，课名，分数）</li>
<li>学生（学号，姓名，系名）</li>
<li>系（系名，系主任）</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231621.png"></p>
<p>结果：</p>
<ol>
<li>删除某个系中所有的学生记录<br> 该系的信息不会丢失。——有改进</li>
<li>插入一个尚无学生的新系的信息。<br> 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
<li> 数据冗余更加少了。——有改进</li>
</ol>
<h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><p>消除多值依赖，不能有多个主键</p>
<p>符合第三范式的表：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231650.png"></p>
<ol>
<li> 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li> 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量</p>
<p>码：（管理员，物品名），（仓库名，物品名）</p>
<p>主属性：仓库名、管理员、物品名</p>
<p>非主属性：数量</p>
<p>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
<ol>
<li> 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
<li> 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li>
<li> 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li>
</ol>
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
<p>造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）</p>
<p>库存（仓库名，物品名，数量）</p>
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
<h1 id="严格遵守范式会有什么问题？"><a href="#严格遵守范式会有什么问题？" class="headerlink" title="严格遵守范式会有什么问题？"></a>严格遵守范式会有什么问题？</h1><p>一般达到2范式就可以，为了性能和灵活性不需要严格的遵守范式，允许存在冗余，可以带来其他的便利，但是最好要知道是怎么回事。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20028672">数据库第一二三范式到底在说什么？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">151</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
