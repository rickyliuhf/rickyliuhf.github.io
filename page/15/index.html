<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/15/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CyclicBarrier/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CyclicBarrier/" class="post-title-link" itemprop="url">Java并发-CyclicBarrier</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-18 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-18T20:00:00+08:00">2017-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CyclicBarrier/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-CyclicBarrier/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul>
<li>CyclicBarrier构造函数传入一个数字N。</li>
<li>线程调用CyclicBarrier.await()会阻塞等待，直到有第N个线程调用CyclicBarrier.await()，所有线程一起执行await()方法后续逻辑。</li>
<li>再次调用await()可以继续这一波操作，循环使用。</li>
</ul>
<p>比喻：</p>
<ul>
<li>人到齐了一起走，没到齐每个人都一直等着不走。</li>
<li>走完了过后，下一波人来了继续这个流程。</li>
</ul>
<p>可循环利用的屏障。</p>
<p>举例：</p>
<p>CyclicBarrier barrier = new CyclicBarrier(5);</p>
<p>然后各个线程调用barrier.await();</p>
<p>当有5个线程await()过后，会继续执行await()后续代码</p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>调用CyclicBarrier的await()方法，通过ReentrantLock先加锁，然后用Condition的await实现等待。</p>
<p>每次调用await()会计数，当第个N个线程执行await()后，会对Condition对象signalAll()来让所有等待线程的继续执行。</p>
<p>然后重新计数，继续同样的过程。</p>
<h1 id="CountDownLatch和CyclicBarrier区别？"><a href="#CountDownLatch和CyclicBarrier区别？" class="headerlink" title="CountDownLatch和CyclicBarrier区别？"></a>CountDownLatch和CyclicBarrier区别？</h1><p>CountDownLatch主要是实现了1个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行操作，描述的是1个线程或N个线程等待其他线程的关系。</p>
<p>CyclicBarrier主要是实现了多个线程之间相互等待，直到所有的线程都满足了条件之后各自才能继续执行后续的操作，描述的多个线程内部相互等待的关系。</p>
<p>CountDownLatch是一次性的，而CyclicBarrier则可以被重置而重复使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/" class="post-title-link" itemprop="url">Java并发-ReadWriteLock、StampedLock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-17 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-17T20:00:00+08:00">2017-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-ReadWriteLock、StampedLock/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="读写锁存在的意义？解决了什么问题？"><a href="#读写锁存在的意义？解决了什么问题？" class="headerlink" title="读写锁存在的意义？解决了什么问题？"></a>读写锁存在的意义？解决了什么问题？</h1><p>synchronzied和ReentraintLock的锁是排他锁，同一时刻只允许一个线程访问同一个资源。</p>
<p>然而在读多写少的情况下，排他锁会让多个并发的读之间互斥，但多个线程同时读不会影响数据的一致性，写的时候保证获取的是排他锁保证数据一致性即可。</p>
<p>也就是读与读之间不互斥，写与读、写与写之间互斥。</p>
<p>这样的话就提高了系统整体的吞吐量。</p>
<h1 id="ReentraintReadWriteLock实现原理是什么？"><a href="#ReentraintReadWriteLock实现原理是什么？" class="headerlink" title="ReentraintReadWriteLock实现原理是什么？"></a>ReentraintReadWriteLock实现原理是什么？</h1><p>内部有ReadLock和WriteLock两个类，分别实现读锁和写锁。</p>
<p>两个Lock类里是通过Sync来实现锁的语义，Sync类继承AQS，并且分为非公平实现和公平的实现。</p>
<p>由于AQS的state是int类型的变量，在内存中占用4个字节，也就是32位。将其拆分为两部分：高16位和低16位，其中高16位用来表示读锁的个数，低16位用来表示写锁重入次数。</p>
<p>当设置读锁成功时，就将高16位加1，释放读锁时，将高16位减1；当设置写锁成功时，就将低16位加1，释放写锁时，将第16位减1。如下图所示。</p>
<p>这样读锁和写锁就可以都通过CAS去操作同一个state变量，实现读和写之间的互斥。</p>
<h1 id="读写锁适用场景？"><a href="#读写锁适用场景？" class="headerlink" title="读写锁适用场景？"></a>读写锁适用场景？</h1><p>读多写少，又需要保持线程安全，可以有效提高吞吐量。</p>
<h1 id="StampedLock解决了什么问题？"><a href="#StampedLock解决了什么问题？" class="headerlink" title="StampedLock解决了什么问题？"></a>StampedLock解决了什么问题？</h1><p>ReentraintReadWriteLock读写锁在读多写少的情况下，必须要等待所有读锁释放才能获取写锁，可能会导致写饥饿，写可能要等待很久，这是一种悲观的读锁。</p>
<p>正确的做法应该是，如果检测到有写入，已经获取读锁的线程不应该继续读了，把读锁让出来，给写入线程优先执行，写入完成了再读，这样就不会写饥饿了。</p>
<p>StampedLock做的就是，先不加锁的读数据，读完了检测一下是否有线程写过数据了，有写过数据则需要重新读最新的数据，并且要加悲观读锁读，以阻止新的写入锁获取，确保读的数据一定是最新修改的。</p>
<p>更通俗的讲就是在读锁没有释放的时候是可以获取到一个写锁，获取到写锁之后，读锁阻塞，这一点和读写锁一致，唯一的区别在于读写锁不支持在没有释放读锁的时候获取写锁。</p>
<h1 id="StampedLock如何检测是否有数据写入？"><a href="#StampedLock如何检测是否有数据写入？" class="headerlink" title="StampedLock如何检测是否有数据写入？"></a>StampedLock如何检测是否有数据写入？</h1><p>在第一次读数据之前先从StampedLock获取一个stamp，如果有数据写入，StampedLock里的stamp就会变，然后第一次读数据后，检测stamp变了说明有写入。</p>
<h1 id="StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？"><a href="#StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？" class="headerlink" title="StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？"></a>StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？</h1><p>确实面临同样的问题，但这种情况发生的概率很小，因为StampedLock使用场景就是读多写少，检测到有写操作后，可以认为大概率之后的一段时间是不会有写操作发生的。</p>
<h1 id="StampedLock如何解决ABA问题？"><a href="#StampedLock如何解决ABA问题？" class="headerlink" title="StampedLock如何解决ABA问题？"></a>StampedLock如何解决ABA问题？</h1><p>StampedLock用一个long类型的state变量保存锁的状态，其中state的低7位存储读锁的个数，第8位存储写锁的标志，第8位为0表示没有获取到写锁，第8位为1表示已获取到写锁。</p>
<p>每次获取和释放写锁，都会给state加上1000 0000，也就是在state的第8位上加1，这样在高位就产生了进位，每次获取写锁后state的值都不一样，这样就可以知道发生了ABA。</p>
<p>long总共有64位，高位一共有64-8=56位，一共可以记录2的55次方种状态。</p>
<h1 id="StampedLock为什么不设计为可重入？"><a href="#StampedLock为什么不设计为可重入？" class="headerlink" title="StampedLock为什么不设计为可重入？"></a>StampedLock为什么不设计为可重入？</h1><p>StampedLock为了解决ABA问题，state变量低7位记录读锁个数，第8位记录是否获取了写锁，第9位到第64位记录了写锁的状态，没有地方存储写锁的重入次数。</p>
<p>对比ReentraintReadWriteLock的实现原理，其实也可以在state的高位中划分一部分区域记录写锁的重入次数。</p>
<h1 id="StampedLock的锁升级是为了解决什么问题？"><a href="#StampedLock的锁升级是为了解决什么问题？" class="headerlink" title="StampedLock的锁升级是为了解决什么问题？"></a>StampedLock的锁升级是为了解决什么问题？</h1><p>有时候写数据只在数据处于特定的条件下才去更改，也就是有可能不修改数据，那如果一开始先获取写锁就会阻碍读锁的获取，吞吐量降低，所以得先获取读锁，判断符合特定条件后，确定需要写入了，再获取写锁，此时就是锁的升级，把读锁释放升级为写锁，前提是当前只有一个读锁；</p>
<p>如果有多个读锁，升级就失败，转为获取正常的写锁，获取不到就阻塞当前线程。</p>
<h1 id="StampedLock有什么缺点？"><a href="#StampedLock有什么缺点？" class="headerlink" title="StampedLock有什么缺点？"></a>StampedLock有什么缺点？</h1><ol>
<li> 不可重入</li>
<li> 不支持Condition</li>
<li> 不支持公平竞争</li>
</ol>
<p>所以也不能完全替代synchronized和ReentrantLock。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/" class="post-title-link" itemprop="url">Java并发-条件变量、wait()与notify()、await()与signal()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-16 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-16T20:00:00+08:00">2017-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-wait()、notify()、notifyAll()/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Object-wait-为什么要配合while使用？"><a href="#Object-wait-为什么要配合while使用？" class="headerlink" title="Object.wait()为什么要配合while使用？"></a>Object.wait()为什么要配合while使用？</h1><p>wait之前一般都是要判断某个条件成立才会wait，这个判断条件需要写成while：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (check pass) &#123;</span><br><span class="line">	wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果写成if，wait过后当前线程交出锁，等当前线程重新被唤起后，条件是否满足是不知道的，其他线程可能修改了条件的状态，要重新判断一下，否则可能条件未满足就继续执行了。</p>
<p>以生产者消费者模型为例。</p>
<ul>
<li>有1个生产者往缓冲区加数据，有2个消费者从缓冲区取数据。</li>
<li>消费者取数据前会检查缓冲区是否为空，不为空才能取数据，为空的话要等待。</li>
<li>假设两个消费者线程都等待了。</li>
<li>然后生产者往缓冲区添加数据后做notifyAll唤醒所有消费者，会唤醒两个等待的消费者线程，让消费者线程从监视器的等待队列移动到锁竞争队列，两者竞争锁。</li>
<li>其中一个线程竞争到锁后，消费了缓冲区数据，缓冲区没有数据了，释放锁后另外一个消费者获得到了锁，开始取从缓冲区取数据，而没有再做条件检查了。</li>
</ul>
<p>这种现象叫做虚假唤醒。</p>
<h1 id="Object的notify-和notifyAll-有什么区别？"><a href="#Object的notify-和notifyAll-有什么区别？" class="headerlink" title="Object的notify()和notifyAll()有什么区别？"></a>Object的notify()和notifyAll()有什么区别？</h1><p>每一个对象都有一个内部锁，即监视器（Monitor），虚拟机会给每个对象维护两个线程集合（可能是队列），一个叫Entry Set（入口集），另外一个叫Wait Set（等待集），对于任意对象object，object的Entry Set用于存储等待获取object内部锁的所有线程，object的Wait Set存储执行了object.wait()和object.wait(long timeout)的线程。</p>
<ul>
<li>notify()会唤醒Wait Set里的一个线程。</li>
<li>notifyAll()会唤醒Wait Set里的所有线程，线程被唤醒后去竞争获取锁，没有获取锁的线程进入Entry Set。</li>
</ul>
<h1 id="什么时候用notify-？什么时候用notifyAll"><a href="#什么时候用notify-？什么时候用notifyAll" class="headerlink" title="什么时候用notify()？什么时候用notifyAll()?"></a>什么时候用notify()？什么时候用notifyAll()?</h1><p>如果所有线程都在等待相同的条件，并且一次只有一个线程可以从条件变为true，则可以使用notify。</p>
<p>在这种情况下，notify是优于notifyAll 因为唤醒所有这些因为我们知道只有一个线程会受益而所有其他线程将再次等待，所以调用notifyAll方法只是浪费CPU。</p>
<p>虽然这看起来很合理，但仍有一个警告，即无意中的接收者吞下了关键通知。通过使用notifyAll，我们确保所有收件人都会收到通知。</p>
<h1 id="Object的wait-notifyAll-和Condition的await-signalAll-的区别？"><a href="#Object的wait-notifyAll-和Condition的await-signalAll-的区别？" class="headerlink" title="Object的wait()/notifyAll()和Condition的await()/signalAll()的区别？"></a>Object的wait()/notifyAll()和Condition的await()/signalAll()的区别？</h1><p>以生产者消费者模型为例。</p>
<ul>
<li>使用wait()、notify()/notifyAll()的缺点在于在生产者唤醒消费者、或者消费者唤醒生产者时，由于生产者和消费者使用同一个锁，所以生产者也会将生产者唤醒，消费者也会将消费者唤醒。</li>
<li>如果能让消费者只唤醒生产者，或者生产者只唤醒消费者，就没有性能浪费了。</li>
<li>所以一个ReentrantLock支持创建多个Condition，以应对这种场景。</li>
<li>synchronized的锁对象没有提供多条件唤醒。</li>
</ul>
<p>ArrayBlockingQueue是典型的生产者消费者的例子，源码是很好的参考。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/" class="post-title-link" itemprop="url">Java并发-synchronized、ReentrantLock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-15T20:00:00+08:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-synchronized、锁升级、wait和notify/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h1><p>让一段代码在多线程之间互斥访问，保证原子性、有序性、可见性，并且是可重入的。</p>
<h1 id="synchronized使用方式"><a href="#synchronized使用方式" class="headerlink" title="synchronized使用方式"></a>synchronized使用方式</h1><ul>
<li>synchronized修饰代码块时需要传入一个对象作为锁，这个对象可以是任意的，进入同步代码块前要获取这个锁，没有获得锁的线程就要阻塞等待，同步代码块执行完释放锁。</li>
<li>修饰成员方法时，锁是对象实例。</li>
<li>修饰静态方法时，锁是类的class实例。</li>
</ul>
<h1 id="synchronized原理综述"><a href="#synchronized原理综述" class="headerlink" title="synchronized原理综述"></a>synchronized原理综述</h1><p>每个Java对象都关联一个监视器锁对象，同步代码块在字节码层面是通过在代码块的指令前后加上monitorenter和monitorexit指令来标识的。</p>
<p>当线程执行到monitorenter指令时，当前线程试图获取监视器对象所有权，如果未加锁或者已被当前线程持有，就把锁计数加1；执行到monitorexit指令的时候，锁计数减1。锁计数为0时，锁就被释放了。</p>
<p>如果当前线程获取监视器对象失败，线程会阻塞等待，线程会作为一个结点存入监视器对象的锁池队列中，等待唤醒。</p>
<p>监视器对象还有一个等待池队列，在同步代码块中调用锁对象的wait方法的时候，线程会阻塞，并被封装为一个结点，进入监视器对象的等待池队列，调用锁对象的notify和notifyAll的时候，会把等待池队列中的线程放入锁池队列中，只有锁池中的线程才能参与竞争锁。</p>
<p>wait和notify用来线程之间同步过程的，比如实现生产者消费者模型。</p>
<p>监视器锁底层是通过操作系统的互斥锁实现的，操作系统做线程切换需要从用户态转换到内核态，所以比较消耗性能。这种依赖于操作系统互斥锁而实现的锁叫做重量级锁。</p>
<p>如果线程竞争并不激烈，切换线程的开销是不划算的，特别是多个线程在不同的时段获取同一把锁，可以用自旋锁，就是CAS+循环，CAS由硬件之间实现，开销比切换线程开销要小，这就是轻量级锁，在JDK6引入。</p>
<p>锁信息具体存储在对象头的MarkWord里，一个对象在虚拟机的内存布局分为三部分，对象头、实例数据、对齐填充，其中对象头又分为MarkWord、类型指针、数组长度，MarkWord存储了锁相关的信息、hashCode、垃圾回收的分代年龄等。</p>
<p>轻量级锁的CAS操作具体修改的是锁对象头的mark word，修改为指向当前线程栈帧中的锁记录的指针。虚拟机会为每个线程在当前线程栈帧中创建一块锁记录空间，存储锁对象的对象头中的mark word的拷贝。</p>
<p>如果CAS修改成功，当前线程就获得了轻量级锁。</p>
<p>如果更新失败，说明有线程竞争，开始自旋，自旋超过一定次数，升级为重量级锁。避免竞争激烈的情况下自旋空耗CPU。</p>
<p>如果压根都没有线程竞争，只有单线程访问同步代码块，其实每次进行CAS操作获取轻量级锁也是没有必要的开销，所以JDK6又引入了偏向锁，只在第一次申请锁的时候，对Java对象头的MARK WORD做CAS操作，记录下当前申请锁的线程ID，退出同步代码块后，也不释放锁，锁对象的对象头中记录的还是当前的线程ID，同一个线程再次进入这个锁的同步代码块的时候，检查锁的对象头中记录的线程ID是否还是自己，是的话就直接进入，不用再CAS了。当有多个线程要申请锁的时候，就会升级到轻量级锁。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<h1 id="ReentrantLock与synchronized的区别？"><a href="#ReentrantLock与synchronized的区别？" class="headerlink" title="ReentrantLock与synchronized的区别？"></a>ReentrantLock与synchronized的区别？</h1><p>ReentrantLock与synchronized有相同的功能和语义，添加了更多灵活的功能。<br>synchronized能干的ReentrantLock都能干，ReentrantLock能干synchronized不一定能干。</p>
<p>最主要区别有三点：支持等待可中断、可实现公平锁、锁可以绑定多个条件。</p>
<p>详细区别：<br>|   |ReentrantLock|synchronized<br>|—|—|—|<br>|底层实现|继承AQS|监视器模式<br>|灵活性|支持响应中断、超时、尝试获取锁|不灵活<br>|释放锁形式|必须显式调用unlock()释放锁，可跨方法调用|自动释放监视器，不可跨方法释放<br>|锁类型|公平锁和非公平锁|非公平锁<br>|条件队列|可关联多个条件队列|只有一个条件队列<br>|错误排查|没有释放锁，很追溯发生错误的位置，因为没有记录应该释放锁的时间和位置难度|synchronized加锁解锁过程有完整的日志</p>
<h1 id="该用ReentrantLock还是synchronized？"><a href="#该用ReentrantLock还是synchronized？" class="headerlink" title="该用ReentrantLock还是synchronized？"></a>该用ReentrantLock还是synchronized？</h1><p>除非需要ReentrantLock的特定的功能，否则还是应该优先使用synchronized，因为简单易用，不会忘记释放锁。</p>
<h1 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h1><p>底层通过继承AbstractQueuedSynchronizer实现。</p>
<p>大致过程：</p>
<ul>
<li>先通过cas修改int类型的state变量，修改成功则获取互斥锁成功。</li>
<li>cas修改失败则把当前线程生成一个节点，放入一个等待队列中，线程被挂起。<ul>
<li>等待队列操作也都是通过cas加自旋的方式来完成，避免同步开销。</li>
</ul>
</li>
<li>释放锁后，会唤醒队列去自旋CAS去修改state来获取互斥锁。</li>
</ul>
<p>state变量记录锁的重入次数。</p>
<h1 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h1><ul>
<li>jdk1.6之前synchronized直接就上重量级锁。</li>
<li>jdk1.6开始synchronized会先由无锁转为偏向锁，再转为轻量级锁，再转为重量级锁，锁只能升级不能降级。</li>
</ul>
<p>偏向锁、轻量级锁是针对synchronized优化。</p>
<h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h1><p>JVM中，对象在内存中除了存储对象本身的数据，还会额外存储关于对象的一些附加信息。</p>
<ul>
<li>普通对象的对象头中存储mark word和类型指针（指向对象所属类的指针）。</li>
<li>数组对象还会存储数组长度。</li>
</ul>
<p>mark word存储对象的hashcode、GC分代年龄、锁状态等信息。</p>
<p>mark word长度在32位系统上为32位，64位系统上长度为64位。</p>
<p>为了在有限的空间存储较多的信息，其数据格式不固定，数据位共享复用。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210826195541.png"></p>
<p>当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；</p>
<p>当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；</p>
<p>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>研究发现，大多数情况下不仅不存在锁竞争，而且总是由同一个线程多次重入，为了让同一个线程多次重入获取锁的代价更低，就引入了偏向锁的概念。</p>
<p>偏向锁获取过程：</p>
<ol>
<li> 当前线程访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认是否为可偏向状态。</li>
<li> 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>
<li> 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li>
<li> 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致当前获得偏向锁的线程被暂停）</li>
<li> 执行同步代码。</li>
</ol>
<p>偏向锁的释放：</p>
<p>偏向锁只有当遇到其他线程也尝试获取偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。（也就是对于获取偏向锁的线程 只有lock的动作，没有unlock的动作，这是因偏向的需要，即使可能这个线程已经死亡。）偏向锁的撤销步骤如下：</p>
<ol>
<li> 等到全局安全点（在这个时间点上没有正在执行的字节码）。</li>
<li> 暂停持有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果线程不处于活动状态，则将对象头设置为无锁状态。争抢锁的线程会再走生成偏向锁的过程，然后成为偏向锁的拥有者。</li>
<li> 如果持有偏向锁的线程还处于活动状态，则将锁升级为轻量级锁。</li>
</ol>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>轻量级锁实现是自旋锁，没有抢到锁的线程将自旋，即不停的循环判断是否能获取到锁，不会让线程阻塞。获取锁的操作就是通过CAS修改对象头的锁标记位。</p>
<p>长时间的循环是很占用CPU的，一个线程持有锁，其他线程只能原地空耗CPU，不执行任何有效的任务，这种现象称为busy-waiting。</p>
<p>利用短时间的busy-waiting换取线程的阻塞和唤醒在用户态和内核态切换的开销。</p>
<p>busy-waiting是有限度的（JVM可以设置参数调节循环次数上限），如果锁竞争激烈，自旋超过一定次数，就升级为重量级锁。</p>
<p>具体的CAS过程：</p>
<ul>
<li>  当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>
<li>  若CAS操作成功，则轻量级锁的上锁过程成功；</li>
<li>  若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>
</ul>
<p>轻量级锁比重量级锁性能更高的前提是：</p>
<ul>
<li>在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>
</ul>
<p>轻量级锁是为了在线程交替执行同步块时提高性能。</p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>阻塞所有竞争锁但未获得锁的线程。</p>
<p>实现依赖于操作系统的同步函数，在linux上使用mutex互斥锁，涉及到用户态和内核态的切换、进程线程上下文的切换，成本较高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/" class="post-title-link" itemprop="url">Java并发-CAS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-13 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-13T20:00:00+08:00">2017-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-CAS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源</p>
<p>所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁更新方式认为：在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。</p>
<p>但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。</p>
<p>CAS机制就是乐观锁的典型实现。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p>
<ul>
<li>  主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li>
<li>  工作内存中共享变量的副本值，也叫预期值：A</li>
<li>  需要将共享变量更新到的最新值：B</li>
</ul>
<h1 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h1><ol>
<li> 可以保证变量操作的原子性；</li>
<li> 并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li>
<li> 在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li>
</ol>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p>
<h2 id="可能会消耗较高的CPU"><a href="#可能会消耗较高的CPU" class="headerlink" title="可能会消耗较高的CPU"></a>可能会消耗较高的CPU</h2><p>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
<h2 id="不能保证代码块的原子性"><a href="#不能保证代码块的原子性" class="headerlink" title="不能保证代码块的原子性"></a>不能保证代码块的原子性</h2><p>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android View 绘制机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-25 20:32:00" itemprop="dateCreated datePublished" datetime="2017-05-25T20:32:00+08:00">2017-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android View 绘制机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="View绘制整个流程"><a href="#View绘制整个流程" class="headerlink" title="View绘制整个流程"></a>View绘制整个流程</h1><p>Activity走到onResume时，会调用ActivityThread的handleResumeActivity。</p>
<p>在这里会创建DecorView，通过WindowManager添加到PhoneWindow中。</p>
<p>这里也会创建ViewRootImpl，把DecorView的parent指定为ViewRootImpl。</p>
<p>再调用DecorView的requestLayout，requestLayout会层层的调用parent的requestLayout，最后走到ViewRootImpl的requestLayout。</p>
<p>然后走到ViewRootImpl.scheduleTraversals()，注册垂直同步监听。</p>
<p>当垂直同步信号来临时，去调用ViewRootImpl.doTraversal() .</p>
<p>再调用ViewRootImpl.performTraversals()，然后依次调用performMeasure()、performLayout()、performDraw()。</p>
<hr>
<p>View.invalidate()也会层层调用parent的invalidateChildInParent，最后调用到ViewRootImpl的invalidateChildInParent，然后调用ViewRootImpl.scheduleTraversals()。</p>
<p>等待垂直同步信号来临时，调用ViewRootImpl.doTraversal()，由于没有给View设置FORCE_LAYOUT的flag，所以不会走measure和layout，只会performDraw()，并且只绘制dirty区域。</p>
<h1 id="首次-View-的绘制流程是在什么时候触发的？"><a href="#首次-View-的绘制流程是在什么时候触发的？" class="headerlink" title="首次 View 的绘制流程是在什么时候触发的？"></a>首次 View 的绘制流程是在什么时候触发的？</h1><p>ActivityThread.handleResumeActivity 里触发的。</p>
<p>ActivityThread.handleResumeActivity 里会调用 wm.addView 来添加 DecorView，wm 是 WindowManagerImpl</p>
<p>最终通过 WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView -&gt; ViewRootImpl.setView -&gt; ViewRootImpl.requestLayout 就触发了第一次 View 的绘制。</p>
<h1 id="ViewRootImpl-创建的时机？"><a href="#ViewRootImpl-创建的时机？" class="headerlink" title="ViewRootImpl 创建的时机？"></a>ViewRootImpl 创建的时机？</h1><p>ActivityThread.handleResumeActivity -&gt; WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView  中创建ViewRootImpl</p>
<h1 id="DecorView的创建时机？"><a href="#DecorView的创建时机？" class="headerlink" title="DecorView的创建时机？"></a>DecorView的创建时机？</h1><p>ActivityThread.handleResumeActivity()中ActivityClientRecord.window.getDecorView();</p>
<p>PhoneWindow.getDecorView()调用installDecor() -&gt; generateDecor()去new DecorView()</p>
<h1 id="ViewRootImpl-和-DecorView-的关系是什么？"><a href="#ViewRootImpl-和-DecorView-的关系是什么？" class="headerlink" title="ViewRootImpl 和 DecorView 的关系是什么？"></a>ViewRootImpl 和 DecorView 的关系是什么？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172333.png"></p>
<p>在 ViewRootImpl.setView 里，通过 DecorView.assignParent 把 ViewRootImpl 设置为 DecorView 的 parent。</p>
<p>所以 ViewRootImpl 和 DecorView 的关系就是 ViewRootImpl 是 DecorView 的 parent。</p>
<p>因为 DecorView 是我们布局的顶层，现在我们就知道层层调用 requestLayout 等方法是怎么调用到 ViewRootImpl 里的了。</p>
<h1 id="Activity、PhoneWindow、DecorView、ViewRootImpl-的关系？"><a href="#Activity、PhoneWindow、DecorView、ViewRootImpl-的关系？" class="headerlink" title="Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？"></a>Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？</h1><ul>
<li>PhoneWindow 其实是 Window 的唯一子类，是 Activity 和 View 交互系统的中间层。</li>
<li>DecorView 是整个 View 层级的最顶层。</li>
<li>ViewRootImpl 是 DecorView 的 parent，但是他并不是一个真正的 View，只是继承了 ViewParent 接口，用来掌管 View 的各种事件，包括 requestLayout、invalidate、dispatchInputEvent 等等。</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172438.png"></p>
<h1 id="如何触发重新绘制？"><a href="#如何触发重新绘制？" class="headerlink" title="如何触发重新绘制？"></a>如何触发重新绘制？</h1><p>View的 requestLayout 和 invalidate</p>
<h1 id="View-requestLayout-流程？"><a href="#View-requestLayout-流程？" class="headerlink" title="View.requestLayout()流程？"></a>View.requestLayout()流程？</h1><p>层层调用 parent 的 requestLayout  ，一直到ViewRootImpl.requestLayout()</p>
<p>ViewRootImpl.requestLayout() 调用 scheduleTraversals() -&gt; doTraversal() -&gt; performTraversals() 开启绘制流程。</p>
<p>在 performTraversals 里，就是熟悉的 performMeasure -&gt; performLayout -&gt; performDraw 三个流程了。</p>
<p>在performDraw View 的绘制过程中，我们可以看到，只有 flag 被设置为 PFLAG_DIRTY_OPAQUE 才会进行绘制（这里划重点）。这也就是大家经常说的 requestLayout 不会引发 draw。</p>
<h1 id="View-invalidate-流程？"><a href="#View-invalidate-流程？" class="headerlink" title="View.invalidate()流程？"></a>View.invalidate()流程？</h1><p>invalidate -&gt; invalidateInternal  -&gt; parent.invalidateChild</p>
<p>invalidateChild的while 循环里，会层层计算 parent 的 dirty 区域，最终会调用到 ViewRootImpl.invalidateChildInParent -&gt; ViewRootImpl.invalidateRectOnScreen -&gt; ViewRootImpl.scheduleTraversals -&gt; ViewRootImpl.performDraw -&gt; ViewRootImpl.draw -&gt; DecorView的draw()</p>
<p>View.draw 方法，根据 PFLAG_DIRTY_OPAQUE flag 去决定是否重新绘制。</p>
<h1 id="requestLayout-和-invalidate-的区别？"><a href="#requestLayout-和-invalidate-的区别？" class="headerlink" title="requestLayout 和 invalidate 的区别？"></a>requestLayout 和 invalidate 的区别？</h1><p>requestLayout 和 invalidate 都会触发整个绘制流程。但是在 measure 和 layout 过程中，只会对 flag 设置为 FORCE_LAYOUT 的情况进行重新测量和布局，而 draw 只会重绘 flag 为 dirty 的区域。</p>
<p>requestLayout 是用来设置 FORCE_LAYOUT 标志，invalidate 用来设置 dirty 标志。所以 requestLayout 只会触发 measure 和 layout，invalidate 只会触发 draw。</p>
<h1 id="requestLayout-一定会触发onMeasure和onLayout吗？"><a href="#requestLayout-一定会触发onMeasure和onLayout吗？" class="headerlink" title="requestLayout 一定会触发onMeasure和onLayout吗？"></a>requestLayout 一定会触发onMeasure和onLayout吗？</h1><p>不一定。</p>
<p>ViewRootImpl.performMeasure，最终调用的是 View.measure。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172624.png"><br>measureSpec 和 oldMeasureSpec 不相符的时候才会onMeasure。</p>
<p>ViewRootImpl.performLayout()：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172646.png"><br>位置有变化才去onLayout。</p>
<h1 id="PFLAG-DIRTY-OPAQUE是什么意思？"><a href="#PFLAG-DIRTY-OPAQUE是什么意思？" class="headerlink" title="PFLAG_DIRTY_OPAQUE是什么意思？"></a>PFLAG_DIRTY_OPAQUE是什么意思？</h1><p>不透明，实心。</p>
<p>实心控件：控件的onDraw方法能够保证此控件的所有区域都会被其所绘制的内容完全覆盖。换句话说，通过此控件所属的区域无法看到此控件之下的内容，也就是既没有半透明也没有空缺的部分。</p>
<h1 id="什么时候View的flag-被设置为-PFLAG-DIRTY-OPAQUE？"><a href="#什么时候View的flag-被设置为-PFLAG-DIRTY-OPAQUE？" class="headerlink" title="什么时候View的flag 被设置为 PFLAG_DIRTY_OPAQUE？"></a>什么时候View的flag 被设置为 PFLAG_DIRTY_OPAQUE？</h1><p>invalidate 会调用 parent.invalidateChild，在这里被赋值的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172722.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">RecyclerView缓存机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-05 21:33:00" itemprop="dateCreated datePublished" datetime="2017-05-05T21:33:00+08:00">2017-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/RecyclerView缓存机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RecyclerView的缓存分为四级"><a href="#RecyclerView的缓存分为四级" class="headerlink" title="RecyclerView的缓存分为四级"></a>RecyclerView的缓存分为四级</h1><ul>
<li>  Scrap</li>
<li>  Cache</li>
<li>  ViewCacheExtension</li>
<li>  RecycledViewPool</li>
</ul>
<h2 id="Scrap"><a href="#Scrap" class="headerlink" title="Scrap"></a>Scrap</h2><p>对应ListView 的Active View，就是屏幕内的缓存数据，就是相当于换了个名字，可以直接拿来复用。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>刚刚移出屏幕的缓存数据，默认大小是2个，当其容量被充满同时又有新的数据添加的时候，会根据FIFO原则，把优先进入的缓存数据移出并放到下一级缓存中，然后再把新的数据添加进来。</p>
<p>Cache里面的数据是干净的，也就是携带了原来的ViewHolder的所有数据信息，数据可以直接来拿来复用。</p>
<p>需要注意的是，cache是根据position来寻找数据的，这个postion是根据第一个或者最后一个可见的item的position以及用户操作行为（上拉还是下拉）。</p>
<p>举个栗子：当前屏幕内第一个可见的item的position是1，用户进行了一个下拉操作，那么当前预测的position就相当于（1-1=0），也就是position=0的那个item要被拉回到屏幕，此时RecyclerView就从Cache里面找position=0的数据，如果找到了就直接拿来复用。</p>
<h2 id="ViewCacheExtension"><a href="#ViewCacheExtension" class="headerlink" title="ViewCacheExtension"></a>ViewCacheExtension</h2><p>用户自定义的缓存策略。</p>
<p>用户没有定义的时候，将跳过。</p>
<h2 id="RecycledViewPool"><a href="#RecycledViewPool" class="headerlink" title="RecycledViewPool"></a>RecycledViewPool</h2><p>Cache默认的缓存数量是2个，当Cache缓存满了以后会根据FIFO（先进先出）的规则把Cache先缓存进去的ViewHolder移出并缓存到RecycledViewPool中，RecycledViewPool默认的缓存数量是5个。</p>
<p>RecycledViewPool与Cache相比不同的是，从Cache里面移出的ViewHolder再存入RecycledViewPool之前ViewHolder的数据会被全部重置，相当于一个新的ViewHolder，而且Cache是根据position来获取ViewHolder，而RecycledViewPool是根据itemType获取的，如果没有重写getItemType（）方法，itemType就是默认的。</p>
<p>因为RecycledViewPool缓存的ViewHolder是全新的，所以取出来的时候需要走onBindViewHolder（）方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/" class="post-title-link" itemprop="url">Android中数据库相关的类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-19 20:22:00" itemprop="dateCreated datePublished" datetime="2017-03-19T20:22:00+08:00">2017-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/Android中数据库相关的类/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android中数据库相关类"><a href="#Android中数据库相关类" class="headerlink" title="Android中数据库相关类"></a>Android中数据库相关类</h1><ul>
<li>  SQLiteOpenHelper：管理SQLite的帮助类，提供获取SQLIteDatabase实例的方法，它会在第一次使用数据库时调用获取实例方法时创建SQLiteDatabase实例，并且处理数据库版本变化，开发人员在实现ContentProvider时都要实现一个自定义的SQLiteOpenHelper类，处理数据的创建、升级和降级。</li>
<li>  SQLiteDatabase：代表一个打开的SQLite数据库，提供了执行数据库操作的接口方法。如果不需要在进程之间共享数据，应用程序也可以自行创建这个类的实例来读写SQLite数据库。</li>
<li>  SQLiteSession：SQLiteSession负责管理数据库连接和事务的生命周期，通过SQLiteConnectionPool获取数据库连接来执行具体的数据库操作。</li>
<li>  SQLiteConnectionPool：数据库连接池，管理所有打开的数据库连接（Connection）。所有数据库连接都是通过它来打开，打开后会加入连接池，在读写数据库时需要从连接池中获取一个数据库连接来使用。</li>
<li>  SQLiteConnection：代表了数据库连接，每个Connection封装了一个native层的sqlite3实例，通过JNI调用SQLite动态库的接口方法操作数据库，Connection要么被Session持有，要么被连接池持有。</li>
<li>  CursorFactory：可选的Cursor工厂，可以提供自定义工厂来创建Cursor。</li>
<li>  DatabaseErrorHandler：可选的数据库异常处理器（目前仅处理数据库Corruption），如果不提供，将会使用默认的异常处理器。</li>
<li>  SQLiteDatabaseConfiguration：数据库配置，应用程序可以创建多个到SQLite数据库的连接，这个类用来保证每个连接的配置都是相同的。</li>
<li>  SQLiteQuery和SQLiteStatement：从抽象类SQLiteProgram派生，封装了SQL语句的执行过程，在执行时自动组装待执行的SQL语句，并调用SQLiteSession来执行数据库操作。这两个类的实现应用了设计模式中的命令模式。</li>
</ul>
<h1 id="使用SQLiteOpenHelper的原因"><a href="#使用SQLiteOpenHelper的原因" class="headerlink" title="使用SQLiteOpenHelper的原因"></a>使用SQLiteOpenHelper的原因</h1><p>之所以需要使用SQLiteOpenHelper，而不是调用Context的方法来直接得到SQLiteDatabase，主要是因为它有两个好处：</p>
<ol>
<li> 自动管理创建：当需要对数据库进行操作的时候，不用关心SQLiteOpenHelper所关联的SQLiteDatabase是否创建，SQLiteOpenHelper会帮我们去判断，如果没有创建，那么就先创建该数据库后，再返回给使用者。</li>
<li> 自动管理版本：当需要对数据库进行操作之前，如果发现当前声明的数据库的版本和手机内的数据库版本不同的时候，那么会分别调用onUpgrade和onDowngrade，这样使用者就可以在里面来处理新旧版本的兼容问题。</li>
</ol>
<h1 id="SQLiteOpenHelper跟数据库连接池的关系是怎样的？"><a href="#SQLiteOpenHelper跟数据库连接池的关系是怎样的？" class="headerlink" title="# SQLiteOpenHelper跟数据库连接池的关系是怎样的？"></a># SQLiteOpenHelper跟数据库连接池的关系是怎样的？</h1><p>一个SQLiteOpenHelper对象存有一个SQLiteDatabase对象</p>
<p>一个SQLiteDatabase对象存有一个SQLiteConnectionPool对象</p>
<p>一个SQLiteConnectionPool对象</p>
<ol>
<li> 在journal-mode下最多存有1个SQLiteConnection</li>
<li> 在wal-mode下最多存有2个SQLiteConnection</li>
</ol>
<h1 id="SQL-语句的执行过程"><a href="#SQL-语句的执行过程" class="headerlink" title="SQL 语句的执行过程"></a>SQL 语句的执行过程</h1><p>创建SQLiteStatement对象，把SQL语句传给SQLiteStatement构造函数，调用SQLiteStatement的executeInsert()</p>
<p>SQLiteStatement.executeInsert()内部的增删改查方法都会先getSession()获取SQLiteSession，再调用SQLiteSession的execute方法</p>
<p>继续追查可以发现SQLiteSession是在SQLiteDatabase里以ThreadLocal形式存储，也就是每个线程只能有一个SQLiteSession</p>
<p>SQLiteSession的execute方法里会从数据库连接获取一个连接，每个SQLiteSession对象有一个SQLiteConnection对象</p>
<h1 id="SQLiteSession存在的价值"><a href="#SQLiteSession存在的价值" class="headerlink" title="SQLiteSession存在的价值"></a>SQLiteSession存在的价值</h1><p>给数据库连接代理了一层，管理事务和连接的生命周期。</p>
<p>在事务执行过程中一直持有数据库连接。</p>
<p>由于数据库连接数量是有限的，所以连接用完后要及时释放连接。</p>
<p>事务开启后，从连接池获取连接。</p>
<p>事务结束后，把连接归还到连接池。</p>
<h1 id="数据库连接是什么意思？"><a href="#数据库连接是什么意思？" class="headerlink" title="数据库连接是什么意思？"></a>数据库连接是什么意思？</h1><p>一个连接对应一个事务操作</p>
<h1 id="如果一个数据库连接始终不关闭会有什么影响？"><a href="#如果一个数据库连接始终不关闭会有什么影响？" class="headerlink" title="如果一个数据库连接始终不关闭会有什么影响？"></a>如果一个数据库连接始终不关闭会有什么影响？</h1><p>SQLite连接数有最大限制，不关闭，会导致别的进程无法连接数据库。</p>
<h1 id="SQLiteConnectionPool连接池大小是怎么定的"><a href="#SQLiteConnectionPool连接池大小是怎么定的" class="headerlink" title="SQLiteConnectionPool连接池大小是怎么定的?"></a>SQLiteConnectionPool连接池大小是怎么定的?</h1><p>目前Android系统的实现中，如果以非WAL模式打开数据库，连接池中只会保持一个数据库连接，如果以WAL模式打开数据库，连接池中的最大连接数量则根据系统配置决定，默认配置是两个。</p>
<h1 id="数据库连接池只提供最多1个连接会有什么影响？"><a href="#数据库连接池只提供最多1个连接会有什么影响？" class="headerlink" title="数据库连接池只提供最多1个连接会有什么影响？"></a>数据库连接池只提供最多1个连接会有什么影响？</h1><p>如果应用程序中有大量的并发数据库读和写操作的话，每个操作的时长都可能受到影响，所以数据库操作应放在工作线程中执行，以免影响UI响应。</p>
<p>因为每个事务都是在SQLiteSession中执行的，执行事务前会从连接池获取连接，调用的是SQLiteConnectionPool.acquireConnection()，方法内如果获取不到Connection就会阻塞线程等待，用链表存储阻塞的线程，直到连接被释放，也就是别的事务执行完成。</p>
<p>我们平时在多线程中的数据库操作都是串行的。</p>
<h1 id="Android里开启事务，事务模式用的是哪个？"><a href="#Android里开启事务，事务模式用的是哪个？" class="headerlink" title="Android里开启事务，事务模式用的是哪个？"></a>Android里开启事务，事务模式用的是哪个？</h1><ul>
<li>SQLiteDatabase.beginTransaction()开启的是EXCLUSIVE。</li>
<li>SQLiteDatabase.beginTransactionNonExclusive()开启的是IMMEDIATE。</li>
</ul>
<p>注意这两个事务模式只针对回滚日志模式下的事务。</p>
<p><a target="_blank" rel="noopener" href="https://sqlite.org/lang_transaction.html#:%7E:text=EXCLUSIVE%20is%20similar%20to%20IMMEDIATE,while%20the%20transaction%20is%20underway.">SQLite官网</a>说在WAL日志模式下，EXCLUSIVE和IMMEDIATE是一样的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/" class="post-title-link" itemprop="url">SQLite事务、回滚日志、WAL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-18 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-18T20:56:00+08:00">2017-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite事务、回滚日志、WAL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h1><p>事务定义了一组数据库操作的边界，这组操作要么全部执行，要么全部不执行，这也是事务的原子性特征</p>
<h1 id="为什么要发明事务？事务存在的价值是什么？"><a href="#为什么要发明事务？事务存在的价值是什么？" class="headerlink" title="为什么要发明事务？事务存在的价值是什么？"></a>为什么要发明事务？事务存在的价值是什么？</h1><p>在操作数据库的情况下，需要考虑的特别的场景处理特别多，例如并发操作、系统崩溃等，发明事务这个模型，就可以用来简化讨论，把复杂的场景归类为少数的几个特定类型的场景，降低处理成本。</p>
<p>数据库操作例如增删改查、建立索引、建立约束等。</p>
<h1 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h1><p>ACID</p>
<h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h2><p>事务内的操作要么全部执行，要么全部不执行，不可再拆分</p>
<h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><p>保证数据库从一个正确的状态转变到另一个正确的状态，正确的状态指的是当前数据库中的数据都满足预定的约束条件。</p>
<p>AID是保证一致性的必要条件，但不是充分条件，因为数据库作为通用的技术，不可能知道具体业务场景的正确逻辑，所以正确的逻辑需要由用户决定应该使用怎样的约束</p>
<h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h2><p>事务的执行不受其他事务的干扰，事务之间的操作只能串行的执行，保证任何事务都不可能读取到其他任何事务内部执行的中间状态，否则会产生数据混乱</p>
<h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h2><p>事务一旦提交，它对数据库中的数据改变就是永久性的，接下来的其他操作或故障都不会影响本次事务提交的结果</p>
<h2 id="事务的原子性是如何实现的？"><a href="#事务的原子性是如何实现的？" class="headerlink" title="事务的原子性是如何实现的？"></a>事务的原子性是如何实现的？</h2><p>SQLite事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。</p>
<p>回滚日志文件，用于实现数据库的原子提交和回滚。 此文件和数据库文件总是在同一个目录，并且有相同的文件名，但是在文件名中添加了一个-journal 字符串。此文件一般在transaction开始时创建，transaction结束时删除。</p>
<p>如果系统crash，Rollback journals文件将被保留，下次打开数据库文件时，系统会检查有没有Rollback journals文件存在，如果有就用它来恢复数据库。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092550.png"></p>
<h1 id="创建回滚日志详细过程是怎样的？"><a href="#创建回滚日志详细过程是怎样的？" class="headerlink" title="创建回滚日志详细过程是怎样的？"></a>创建回滚日志详细过程是怎样的？</h1><ol>
<li> 写数据库前获取保留锁</li>
<li> 创建回滚日志文件，将要修改的页的原始数据写到缓存中</li>
<li> 在用户空间修改页数据</li>
<li> 回滚日志的缓存刷盘到回滚日志文件中</li>
<li> 获取未决锁，等待共享锁都释放后，提升为排它锁</li>
<li> 将用户空间修改过的数据写入数据库文件，会先写到操作系统的缓存中，再刷盘到磁盘上</li>
<li> 删除rollback journal文件</li>
<li> 释放排它锁</li>
</ol>
<h2 id="创建rollback-journal-file"><a href="#创建rollback-journal-file" class="headerlink" title="创建rollback journal file"></a>创建rollback journal file</h2><p>将要修改的pages的原始数据写入rollback journal file，以page为单位写入。</p>
<p>rollback journal file中绿色的部分是header,header中会包括数据库文件的原始大小(即包括多少个page)。每一个page保存到rollback journal中时前边四字节会保存该page的page number。</p>
<ul>
<li>  rollback journal创建之后并没有实际落盘,只是保存在操作系统的缓存中</li>
<li>  rollback journal以page为单位,但每个page前四字节会有一个page number的记录,后四字节有一个checksum</li>
</ul>
<h2 id="在用户空间修改数据库文件"><a href="#在用户空间修改数据库文件" class="headerlink" title="在用户空间修改数据库文件"></a>在用户空间修改数据库文件</h2><p>修改用户进程空间内的数据库文件,注意不同的用户进程有自己的私有内存空间,因此此时的修改并不影响其他进程的读取操作。</p>
<h2 id="将rollback-journal落盘"><a href="#将rollback-journal落盘" class="headerlink" title="将rollback journal落盘"></a>将rollback journal落盘</h2><p>该步骤是保持原子性很关键的一步,保证即使掉电或者操作系统crash,Sqlite也能恢复到原来的状态。</p>
<p>(进行到该步也能看出reserved lock的作用,这种锁是一个中间状态,既能为即将写入做准备,又不影响其他进程的读取操作,提高并行度)。</p>
<p>该步需要刷两次盘,第一次将rollback journal的内容刷到磁盘,第二次在header中记录第一步中刷到磁盘的page个数,然后将header刷盘。</p>
<h2 id="获取排他锁"><a href="#获取排他锁" class="headerlink" title="获取排他锁"></a>获取排他锁</h2><p>在实际写入数据库文件之前,需要获取一个排他锁.获取过程分两步<br>    • 获取一个pending lock<br>    • 将pending lock升级为排他锁<br>获取到pending lock之后,在数据库文件上已经获取到共享锁的进程可以继续读取,但不允许其他进程继续获取共享锁.该锁存在的意义在于防止write starvation(即有大量的读取连接时,一直有新的共享锁产生,导致获取不到排他锁).当所有已经存在的共享锁都释放后,此时该pending lock即可以升级为排他锁。</p>
<h2 id="写入数据库文件"><a href="#写入数据库文件" class="headerlink" title="写入数据库文件"></a>写入数据库文件</h2><p>获取到排他锁后,说明已经没有其他进程在读取该数据库文件.此时可以安全的写入数据库文件.注意也只是写入操作系统的缓存中,并没有落盘。</p>
<h2 id="删除rollback-journal"><a href="#删除rollback-journal" class="headerlink" title="删除rollback journal"></a>删除rollback journal</h2><p>因为数据库文件已经安全落盘,此时可以删除掉rollback journal.若删除之前系统crash或者掉电,则重启后会恢复到事务开始前的状态,如果删除之后系统crash或者掉电,因为数据库文件已经落盘,相当于事务已经执行完成.(那么会不会在删除一半时系统crash或者掉电呢?注意上文中关于硬件的一些假设,删除操作必须是原子性的,即不会发生这种情况)</p>
<p>因为删除一个文件也是一个耗时的操作,因此Sqlite提供了两种方式减少删除过程的耗时.</p>
<ul>
<li>  将一个文件truncate为0</li>
<li>  将journal file header清0.清0操作并不是原子性的,但只要header中有一个byte被清0,该文件就会被识别为无效的格式</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/lockingv3.html#rollback">The Rollback Journal</a></li>
</ul>
<h1 id="热日志是什么意思？"><a href="#热日志是什么意思？" class="headerlink" title="热日志是什么意思？"></a>热日志是什么意思？</h1><p>每次打开数据库文件，或者从数据库读取页时，都要简单的做一致性检查。</p>
<p>如果发现存在回滚日志文件，但是数据库中没有保留锁，那么创建日志文件的肯定崩溃了或者系统死机了，因为正常情况下，获得保留锁后才会创建回滚日志。</p>
<p>这种情况下日志被称为“热日志”，数据库可能处于不一致的状态（不满足约束条件），要让一切正常需要回滚日志，将数据库还原到初始的被中断的事务之前的状态。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092653.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>
<h1 id="SQLite中事务为什么还要分不同的类型？分别有什么作用？"><a href="#SQLite中事务为什么还要分不同的类型？分别有什么作用？" class="headerlink" title="SQLite中事务为什么还要分不同的类型？分别有什么作用？"></a>SQLite中事务为什么还要分不同的类型？分别有什么作用？</h1><p>是为了解决死锁</p>
<p>SQLite的事务分为</p>
<ol>
<li> deferred</li>
<li> immediate</li>
<li> exclusive</li>
</ol>
<p>begin [ deferred | immediate | exclusive ] transaction</p>
<p>deferred</p>
<ol>
<li> 未指定事务模式时默认的选择</li>
<li> 开始事务时处于未锁定状态</li>
<li> 实际访问数据库时才试图加锁</li>
<li> 第一个读数据库操作试图获取共享锁</li>
<li> 第一个写数据库操作试图获取预留锁</li>
</ol>
<p>immediate</p>
<ol>
<li> 事务开始时试图获取预留锁</li>
<li> 获取预留锁成功后，其他连接中已执行的事务无法再获取到预留锁</li>
<li> 新的连接开始immediate和exclusive的事务也会失败，并返回SQLITE_BUSY错误</li>
<li> 最后提交事务时，预留锁会提升到未决锁</li>
<li> 等待其他连接中的事务释放共享锁</li>
<li> 阻止新的连接获取共享锁</li>
<li> 如果其他事务一直没释放共享锁，会返回SQLITE_BUSY错误</li>
</ol>
<p>exclusive</p>
<ol>
<li> 开始事务时尝试获取排它锁</li>
<li> 获取成功后阻止所有的读写操作</li>
<li> 在事务内可以对数据库进行任意的读写</li>
</ol>
<p>参考《SQLite权威指南（第2版）》118页  第4章 SQLite中的高级SQL - 事务的类型</p>
<h1 id="SQLite-WAL是什么？"><a href="#SQLite-WAL是什么？" class="headerlink" title="SQLite WAL是什么？"></a>SQLite WAL是什么？</h1><p>SQLite在3.7.0开始引入了WAL技术</p>
<p>Write-Ahead Log</p>
<p>预先写日志</p>
<p>默认的 rollback journal 模式工作原理大致为：写操作进行前进行数据库文件拷贝，然后对数据库进行写操作。如果发生 Crash 或者 rallback 则将日志中的原始内容回滚到数据库中进行恢复操作，否则在 Commit 完成时删除日志文件。</p>
<p>WAL模式采用了相反的的做法，</p>
<p>在准备写数据库文件前，会先复制数据库文件的中的原始数据到日志文件，写操作也只更新日志文件，原有数据库文件不变动；</p>
<p>如果事务失败，WAL中的数据被忽略；</p>
<p>如果事务成功，在随后的某个时间点，将WAL中的数据写回到数据库文件，这个时间点称为checkpoint。</p>
<p>WAL使用检查点将修改写回数据库，默认情况下，当WAL文件发现有1000页修改时，将自动调用检查点。这个页数大小可以自行配置。</p>
<p>读数据时，SQLite在WAL中搜索，找到最后一个写入点，并记录，读时忽略这个写入点后面的信息，如果读取在WAL中读取不到数据，则去数据库文件中读取；写数据时继续往记录点后追加写入数据，这样保证了读和写可以同时进行；由于同一时刻只能有一个连接写数据库，写与写之间是互斥的，所以不会产生写入点后面写数据时指针冲突。</p>
<p>由于每个读操作都会搜索整个WAL文件，所以在共享内存加建立了一个wal-index索引，加速查找，避免扫描整个WAL文件。</p>
<h1 id="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"><a href="#WAL提升了哪方面的性能？优点是什么？解决了什么问题？" class="headerlink" title="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"></a>WAL提升了哪方面的性能？优点是什么？解决了什么问题？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093052.png"></p>
<p>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> WAL is significantly faster in most scenarios.</li>
<li> WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</li>
<li> Disk I/O operations tends to be more sequential using WAL.</li>
<li> WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="WAL的缺点是什么？"><a href="#WAL的缺点是什么？" class="headerlink" title="WAL的缺点是什么？"></a>WAL的缺点是什么？</h1><ol>
<li> 所有的数据库操作必须都在同一台机器上进行，并且该机器的操作系统需要支持 VFS 特性。</li>
<li> 当连接处于 WAL 模式中时我们无法修改页大小</li>
<li> 为满足 Wal 和相关共享内存的需要，使用 WAL 引入了两个额外的半持久性文件 -wal 和 -shm 该文件需要占用一定的存储空间。</li>
<li> 数据库读性能会比 rollback journal 模式略差 （大概慢 1% ～ 2% ），另外写操作也会间歇性的性能下降。</li>
<li> 读操作的性能会比 rollback journal 模式出现部分下降，因为它需要额外对 -wal 文件进行一次检索，而且 Checkpoint 本身就比较耗时且会对读操作进行阻塞。</li>
<li> 频繁 Checkpoint 变得频繁又会影响写操作的性能指标，而且频繁的同步操作也会增加数据库损坏的概率</li>
</ol>
<hr>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093220.png"><br>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</li>
<li> Transactions that involve changes against multiple <a target="_blank" rel="noopener" href="https://sqlite.org/lang_attach.html">ATTACHed</a> databases are atomic for each individual database, but are not atomic across all databases as a set.</li>
<li> WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</li>
<li> There is an additional quasi-persistent “-wal” file and “-shm” shared memory file associated with each database, which can make SQLite less appealing for use as an <a target="_blank" rel="noopener" href="https://sqlite.org/appfileformat.html">application file-format</a>.</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="Android中如何开启WAL？"><a href="#Android中如何开启WAL？" class="headerlink" title="Android中如何开启WAL？"></a>Android中如何开启WAL？</h1><p>SQLiteDatabase.enableWriteAheadLogging()</p>
<p>根据注释描述，Android默认没有开启WAL。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">SQLite锁机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-17 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-17T20:56:00+08:00">2017-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 17:29:13" itemprop="dateModified" datetime="2021-08-28T17:29:13+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite锁机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQLite锁的粒度到哪里？"><a href="#SQLite锁的粒度到哪里？" class="headerlink" title="SQLite锁的粒度到哪里？"></a>SQLite锁的粒度到哪里？</h1><p>SQLite锁的是整个数据库文件，不支持页锁、表锁和行锁，粒度较粗。</p>
<p>当一个连接要写数据库文件时，所有其他的连接都会阻塞，直到写数据的连接事务结束。</p>
<p>SQLite 3.7.0 新增 Write-Ahead Log 机制改变了事务行为，读写可以并发。</p>
<h1 id="为什么SQLite不支持表锁和行锁呢？"><a href="#为什么SQLite不支持表锁和行锁呢？" class="headerlink" title="为什么SQLite不支持表锁和行锁呢？"></a>为什么SQLite不支持表锁和行锁呢？</h1><p>支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。</p>
<p>同时复杂性增大会增加运行设备电量的损害，对于手机这类这种电量敏感的设备比较重要。</p>
<h1 id="SQLite锁机制是怎样的？"><a href="#SQLite锁机制是怎样的？" class="headerlink" title="SQLite锁机制是怎样的？"></a>SQLite锁机制是怎样的？</h1><p>有多个数据库连接同时访问同一个数据库，就产生了资源竞争，需要锁机制保证资源竞争的正确性</p>
<p>数据库操作无非就是读和写，按道理普通的读写锁就可以实现，但高并发下读写锁仍然有优化的空间，为了提高整体的吞吐量，SQLite使用了锁逐步提升的机制</p>
<p>SQLite共有5种锁状态：</p>
<ol>
<li> 无锁（unlocked）</li>
<li> 共享（shared）</li>
<li> 预留（reserved）</li>
<li> 未决（pending）</li>
<li> 排它（exclusive）</li>
</ol>
<p>每个数据库连接同一时刻只能处于其中一个状态</p>
<p>无锁：</p>
<ol>
<li> 即使事务已经开始，在没有读写数据库前，都是无锁状态</li>
</ol>
<p>共享：</p>
<ol>
<li> 读数据库必须获得共享锁</li>
<li> 多个数据库连接可以同时获得共享锁，即允许多个连接同时读数据库</li>
<li> 写数据库前必须要释放所有的共享锁</li>
</ol>
<p>预留：</p>
<ol>
<li> 写数据需要先获取到预留锁</li>
<li> 持有预留锁后就可以立即把数据写入缓存中，而不用竞争数据库文件，把可以不占用的数据库文件可以完成的事情提前完成，这样最大程度的减少独占数据库文件的时间</li>
<li> 预留锁可以与共享锁共存</li>
<li> 预留锁不影响其他已经持有共享锁的连接继续读数据库</li>
<li> 预留锁不阻止其他连接获得新的共享锁，因为并不确定是否要立即写入数据库文件，可能之后还要修改数据库内容，提交事务的时候才知道后面不会再修改数据库了</li>
<li> 一个数据库同时只能有一个预留锁存在</li>
</ol>
<p>未决：</p>
<ol>
<li> 当连接提交事务时，就要把缓存里的数据往数据库文件中写入，以保证事务的持久性</li>
<li> 对数据库文件写数据前，需要保证没有连接再持有共享锁</li>
<li> 但此时可能还有其他连接持有共享锁，需要等待这些连接释放共享锁后，才能写数据</li>
<li> 同时要阻止新的连接获取共享锁，否则写数据一直得不到执行</li>
<li> 所以从预留锁要转变为未决锁，来阻止新的连接获取共享锁</li>
</ol>
<p>排它：</p>
<ol>
<li> 所有共享锁释放后，未决锁提升为排他锁</li>
<li> 排它锁和未决锁一样，会阻止新的连接获取共享锁，阻止读数据</li>
<li> 获得排它锁后，就可以把缓存中的数据写入数据库文件</li>
</ol>
<p>参考资料：</p>
<p>《SQLite权威指南（第2版）》116页  第4章 SQLite中的高级SQL - 数据库锁</p>
<h1 id="SQLite锁为什么搞这么多状态？"><a href="#SQLite锁为什么搞这么多状态？" class="headerlink" title="SQLite锁为什么搞这么多状态？"></a>SQLite锁为什么搞这么多状态？</h1><ul>
<li>由于写数据时是排他的，其他连接无法读数据库，所以要尽可能的减少写数据时的耗时，才能提高系统整体的吞吐量。</li>
<li>所以写数据时先获取预留锁，把可以在不占用数据库文件的事情提前做好。</li>
<li>那些需要占用数据库文件才能做的事情留到获取到排他锁时再做。<ul>
<li>获取排它锁前需要保证没有连接再获取共享锁。</li>
<li>所以先从预留锁提升到未决锁，用来阻止新的共享锁的获取。</li>
<li>等待已经获取的共享锁的连接执行完后释放了所有的共享锁，最后获取到排它锁写数据库文件。</li>
</ul>
</li>
</ul>
<h1 id="锁的状态转移过程是怎样的？"><a href="#锁的状态转移过程是怎样的？" class="headerlink" title="锁的状态转移过程是怎样的？"></a>锁的状态转移过程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091837.png"></p>
<h1 id="为什么事务的开始都要先获取未决锁，再获取共享锁？"><a href="#为什么事务的开始都要先获取未决锁，再获取共享锁？" class="headerlink" title="为什么事务的开始都要先获取未决锁，再获取共享锁？"></a>为什么事务的开始都要先获取未决锁，再获取共享锁？</h1><p>因为如果已经获得了未决锁，说明要占用数据库文件进行写操作，就不允许读了，而读数据库需要获得共享锁，这里就阻止别的连接获取共享锁。</p>
<h1 id="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"><a href="#有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？" class="headerlink" title="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"></a>有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？</h1><p>获得预留锁时，读写可以并发执行，但是真正写数据库需要阻止共享锁获取。</p>
<p>这样做可以提升系统整体的吞吐量。</p>
<h1 id="SQLite锁机制需要注意什么？"><a href="#SQLite锁机制需要注意什么？" class="headerlink" title="SQLite锁机制需要注意什么？"></a>SQLite锁机制需要注意什么？</h1><p>注意死锁的发生</p>
<h1 id="SQLite什么情况下会发生死锁？"><a href="#SQLite什么情况下会发生死锁？" class="headerlink" title="SQLite什么情况下会发生死锁？"></a>SQLite什么情况下会发生死锁？</h1><p>SQLite发生死锁时会抛出database is locked的异常信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091949.png"></p>
<p>参考《SQL权威指南（第2版）》117页 SQLite中的高级SQL - 死锁</p>
<h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>用正确的事务类型来开启事务</p>
<p>存在并发写数据，就开启immediate或exclusive事务，提供了同步机制</p>
<p>SQLite有三种不同的事务类型：</p>
<ol>
<li> DEFERRED（推迟）</li>
<li> MMEDIATE（立即）</li>
<li> EXCLUSIVE（排它）</li>
</ol>
<p>事务类型在BEGIN命令中指定。</p>
<p>一个deferred事务不获取任何锁，直到它需要锁的时候。而且BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态；默认情况下是这样的。如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取SHARED LOCK；同样，当进行第一次写操作时，它会获取RESERVED LOCK。</p>
<p>由BEGIN开始的Immediate事务会试着获取RESERVED LOCK。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作，但是RESERVED LOCK会阻止其它的连接BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，SQLite会返回SQLITE_BUSY错误。这时你就可以对数据库进行修改操作，但是你不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。</p>
<p>Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 上面那个例子的问题在于两个连接最终都想写数据库，但是他们都没有放弃各自原来的锁，最终，shared 锁导致了问题的出现。如果两个连接都以BEGIN IMMEDIATE开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入BEGIN IMMEDIATE，其它的连接就得等待。BEGIN IMMEDIATE和BEGIN EXCLUSIVE通常被写事务使用。就像同步机制一样，它防止了死锁的产生。 基本的准则是：如果你在使用的数据库没有其它的连接，用BEGIN就足够了。但是，如果你使用的数据库在其它的连接也要对数据库进行写操作，就得使用BEGIN IMMEDIATE或BEGIN EXCLUSIVE开始你的事务。</p>
<h1 id="Android中对SQLite开启的哪一种事务类型？"><a href="#Android中对SQLite开启的哪一种事务类型？" class="headerlink" title="Android中对SQLite开启的哪一种事务类型？"></a>Android中对SQLite开启的哪一种事务类型？</h1><p>SQLiteDatabase开启事务有两个方法：</p>
<ol>
<li> beginTransaction()开启exclusive事务类型</li>
<li> beginTransactionNonExclusive()开启immediate事务类型</li>
</ol>
<h1 id="锁的状态存储在哪里？"><a href="#锁的状态存储在哪里？" class="headerlink" title="锁的状态存储在哪里？"></a>锁的状态存储在哪里？</h1><p>数据库文件是独立于进程的，多个进程可以访问同一个文件，所以数据库锁是存在数据库文件中的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092032.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092040.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">177</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
