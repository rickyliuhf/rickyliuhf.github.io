<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/12/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/" class="post-title-link" itemprop="url">Java集合类-TreeMap、ConcurrentSkipListMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-08 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-08T20:00:00+08:00">2018-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-TreeMap、ConcurrentSkipListMap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TreeMap作用"><a href="#TreeMap作用" class="headerlink" title="TreeMap作用"></a>TreeMap作用</h1><ul>
<li> 元素可以按key保持顺序。</li>
<li> 因为有序，提供了很多范围查询的方法，非常方便。</li>
</ul>
<h1 id="TreeMap的实现"><a href="#TreeMap的实现" class="headerlink" title="TreeMap的实现"></a>TreeMap的实现</h1><p>TreeMap实现了NavigableMap接口，该接口又继承SortedMap接口，两个提供了很多范围查询的方法，非常方便。</p>
<p>用红黑树实现，插入、删除、查询的平均时间复杂度都是log(n)。</p>
<h1 id="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap"><a href="#TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap" class="headerlink" title="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?"></a>TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?</h1><ol>
<li> 因为红黑树的结构调整可能涉及整个树的结点，这样并发下就要锁住很多结点，使用跳表会更局部一点，只锁住局部的几个结点，并发性能更高。</li>
<li> 红黑树加锁实现起来比较复杂，跳表是链表加锁比较容易实现</li>
</ol>
<p>可以用过Collections.synchronizedSortedMap()保证线程安全，也可以改用ConcurrentSkipListMap并发性能更好。</p>
<h1 id="TreeMap为什么用红黑树不用AVL树？"><a href="#TreeMap为什么用红黑树不用AVL树？" class="headerlink" title="TreeMap为什么用红黑树不用AVL树？"></a>TreeMap为什么用红黑树不用AVL树？</h1><p>跟HashMap中的问题一样。</p>
<p>红黑树的3结点可以吸收变化，在多次使用中可以减少调整数据结构的次数，从而提升性能。</p>
<h1 id="ConcurrentSkipListMap是什么？"><a href="#ConcurrentSkipListMap是什么？" class="headerlink" title="ConcurrentSkipListMap是什么？"></a>ConcurrentSkipListMap是什么？</h1><p>跳表：链表+多级索引（多层链表）。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825212310.png"></p>
<ul>
<li>给有序链表再增加若干层额外的指针索引，用空间换时间。</li>
<li>每一层都是一个有序链表。</li>
<li>实际效果类似于平衡二叉搜索树。</li>
<li>插入、删除、查询的平均时间复杂度都是log(n)。</li>
<li>支持按key排序所有元素，也支持快速查找。</li>
</ul>
<h1 id="跳表的数据结构存在什么问题？"><a href="#跳表的数据结构存在什么问题？" class="headerlink" title="跳表的数据结构存在什么问题？"></a>跳表的数据结构存在什么问题？</h1><p>按照理想的生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。</p>
<h1 id="跳表与红黑树区别？"><a href="#跳表与红黑树区别？" class="headerlink" title="跳表与红黑树区别？"></a>跳表与红黑树区别？</h1><ol>
<li> 红黑树为了保持平衡有可能会调整很多结点甚至整个树，而跳表只要修改相邻结点更加的局部，跳表调整次数少性能也就高，同时并发加锁时，锁住的结点更少，可以减少竞争</li>
<li> 跳表的区间查询更高效，因为找到链表头结点顺序遍历就行了，红黑树需要中序遍历相对比较复杂</li>
<li> 跳表占用空间更少，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
</ol>
<h1 id="ConcurrentSkipListMap存在什么问题？"><a href="#ConcurrentSkipListMap存在什么问题？" class="headerlink" title="ConcurrentSkipListMap存在什么问题？"></a>ConcurrentSkipListMap存在什么问题？</h1><p>size方法求得链表长度要遍历整个链表，并且没有加锁，多线程高并发下这个方法返回值并不准确，高并发下使用size的意义不大。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yd2sOhmVtZeEkJ06cTE7qA"> 死磕 java集合之ConcurrentSkipListMap源码分析——发现个bug</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1811782/when-should-i-use-concurrentskiplistmap">When should I use ConcurrentSkipListMap?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20202931/answer/16086538">为啥 redis 使用跳表(skiplist)而不是使用 red-black？ - 于康的回答 - 知乎</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java集合类-ConcurrentHashMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-07 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-07T20:00:00+08:00">2018-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-ConcurrentHashMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>高性能且线程安全的哈希表。</p>
<h1 id="线程安全是怎么实现的？"><a href="#线程安全是怎么实现的？" class="headerlink" title="线程安全是怎么实现的？"></a>线程安全是怎么实现的？</h1><p>Java7中ConcurrentHashMap将哈希表分割成为多个段（Segment），每一个段继承ReentrantLock，对每一段进行加锁。每个Segment里类似又有一个小的HashMap，等于是双重哈希表。</p>
<p>Java8中采用了自旋CAS和synchronzied保证线程安全，锁的粒度调整为对table数组中每个元素进行加锁；put元素时，定位到桶位置后，通过synchronzied给桶中链表首节点或红黑树根节点加锁。这样多线程竞争哈希表同一个桶位置的几率又降低了。</p>
<p>java8的ConcurrentHashMap的数据结构参考java8的HashMap，采用数组+链表+红黑树。</p>
<ul>
<li><p>put方法里，是一个无限循环，即自旋，修改table数组都是通过cas操作，自旋锁的机制避免了阻塞和恢复线程的上下文切换开销。</p>
</li>
<li><p>只要当前桶位置没有元素，就先自旋CAS进行更新。</p>
</li>
<li><p>存在hash冲突或修改已有的值时，需要进入桶内部的链表或红黑树进行操作时，才开始用synchronized真正加锁。</p>
</li>
</ul>
<p>get是不加锁的，所以与CopyOnWriteArrayList一样，不保证读数据的实时性，数据是弱一致性。</p>
<p>size的求法和LongAdder里的思路一样，将大小数据分段累加，避免多线程竞争，用自旋cas保证数据更新的原子性。</p>
<h1 id="不能解决什么问题？"><a href="#不能解决什么问题？" class="headerlink" title="不能解决什么问题？"></a>不能解决什么问题？</h1><p>因为数据是弱一致性的，get时并不加锁，所以对读数据实时性要求高的需求不能满足。</p>
<p>例如线程1在某一时刻执行了put(key, value)，先线程2随后立即get(key)不一定能读取到线程1刚put的，因为put可能正在进行中还没结束。</p>
<h1 id="扩容机制是怎样的？"><a href="#扩容机制是怎样的？" class="headerlink" title="扩容机制是怎样的？"></a>扩容机制是怎样的？</h1><p>本来一个线程扩容时，其他线程应该都阻塞等待这个线程扩容完成后才能对哈希表进行读写，这就成了并发的瓶颈。</p>
<p>ConcurrentHashMap具体实现是，反正你闲着也是闲着，不如一起来扩容。</p>
<p>扩容时nextTable会指向扩容后的数组，扩容方法transfer里通过自旋进行。</p>
<p>多个线程通过sizeCtl判断当前所处状态，再通过transferIndex协调各线程应该操作哪一些桶。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">ConcurrentHashMap1.8 - 扩容详解（图文并茂）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lfs2640666960/p/9621461.html">深入理解HashMap+ConcurrentHashMap的扩容策略  </a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/487d00afe6ca">ConcurrentHashMap源码分析（JDK8） 扩容实现机制</a></li>
</ul>
<h1 id="跟同样是线程安全的Hashtable有何区别？"><a href="#跟同样是线程安全的Hashtable有何区别？" class="headerlink" title="跟同样是线程安全的Hashtable有何区别？"></a>跟同样是线程安全的Hashtable有何区别？</h1><p>Hashtable的线程安全是对整个哈希表上锁（在多数方法上加上sychronized），其中一个线程访问哈希表时，其他线程只能等待，很多没有必要上锁的场景也上锁，因此在多线程竞争激烈的情况下整体访问速度会变慢。</p>
<p>ConcurrentHashMap把哈希表分割成若干个段，修改每一段时仅针对访问的段上锁，不同的线程访问不同的段时互不干扰，减少了多个线程争抢同一把锁的几率，减少了线程等待的时间，所以提高了性能。</p>
<p>分段锁是怎么实现的？</p>
<p>get方法不加锁，结点类里的value设置了volatile保证了value在多线程下的可见性，保证get到value最新的修改值。</p>
<p>总结：</p>
<ol>
<li> 循环+CAS实现自旋锁，减少线程阻塞恢复的上下文切换消耗</li>
<li> size更新采用LongAdder分段锁思想，减少竞争</li>
<li> LongAdder机制中的字节填充解决伪共享</li>
<li> 多线程协同分组扩容。</li>
</ol>
<h1 id="与Collections-synchronizedMap-的区别？"><a href="#与Collections-synchronizedMap-的区别？" class="headerlink" title="与Collections.synchronizedMap()的区别？"></a>与Collections.synchronizedMap()的区别？</h1><p>Collections.synchronizedMap()对HashMap做了一层装饰，用synchronized锁住整个哈希表，以保证各操作的线程安全，锁的粒度比较大。<br>性能比ConcurrentHashMap更差，但可以保证读的实时性。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dee05ac6fb9a0163f77beb6">深入解析 ConcurrentHashMap 实现内幕，吊打面试官？没问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heqiyoujing/p/11143525.html">ConcurrentHashMap面试题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java集合类-HashMap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-06 20:00:00" itemprop="dateCreated datePublished" datetime="2018-05-06T20:00:00+08:00">2018-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">集合类</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="集合类/Java集合类-HashMap原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>JDK 1.7：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java</a></li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java</a></li>
</ul>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ol>
<li> 非线程安全，所以存取速度快</li>
<li> 可以接受null的键和值</li>
<li> 不保证key有序</li>
<li> key的顺序会随时间变化（动态调整大小后会变化）</li>
</ol>
<h1 id="散列过程"><a href="#散列过程" class="headerlink" title="散列过程"></a>散列过程</h1><ol>
<li> 通过散列函数，用元素的key计算出元素在数组中的索引位置</li>
<li> 解决散列冲突，即相同散列值（数组索引位置）元素如何存取</li>
</ol>
<h1 id="散列函数的选取标准"><a href="#散列函数的选取标准" class="headerlink" title="散列函数的选取标准"></a>散列函数的选取标准</h1><ol>
<li> 易于计算</li>
<li> 均匀分布所有键</li>
</ol>
<h1 id="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"><a href="#拉链法查找一个元素的最少、最坏、平均次数分别是多少？" class="headerlink" title="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"></a>拉链法查找一个元素的最少、最坏、平均次数分别是多少？</h1><p>设哈希表大小为m，已存储的元素个数为n</p>
<p>如果散列函数把所有元素散列到一个位置，链表的长度就是n，最坏情况下就是查找链表中最后一个元素，查找次数是n</p>
<p>如果散列函数散列到哈希表每个位置的概率相同，此时元素分布最均匀，拉链法相当于把n个元素分为m组，那么每组（链表）长度最多为n/m，最坏情况下查找链表最后一个元素，需要n/m次</p>
<h1 id="桶（bucket）是什么意思？"><a href="#桶（bucket）是什么意思？" class="headerlink" title="桶（bucket）是什么意思？"></a>桶（bucket）是什么意思？</h1><p>HashMap内部的哈希表由数组实现，数组的每一个位置称为桶，存储一个链表的头结点，或红黑树的根节点，一个桶下所有元素key的hashCode都相同，元素存储在哪一个桶是根据元素key计算出数组索引位置而定的</p>
<h1 id="什么情况下会要求哈希表的大小要是质数？"><a href="#什么情况下会要求哈希表的大小要是质数？" class="headerlink" title="什么情况下会要求哈希表的大小要是质数？"></a>什么情况下会要求哈希表的大小要是质数？</h1><p>简述：</p>
<ul>
<li>关注哈希表的大小是因为求得元素在哈希表中存储存储位置是通过  key的hashCode % 哈希表大小  得到，如果散列函数计算结果不均匀，容易产生散列冲突，提高了查找次数。</li>
<li>质数不容易被整除，故而可以让计算出的索引分布的比较均匀。合数有公因子，计算出的索引位置容易聚集在公因数的位置，产生较多的散列冲突。</li>
</ul>
<p>key与哈希表大小互质，这样取模的结果就分散的比较均匀。</p>
<p>如果key可以整除哈希表大小，如果key容易在公因数的位置产生聚集，就会产生较多的散列冲突。</p>
<p>使用质数作为容量，可以使元素更分散，减少冲突；</p>
<p>如果用合数作为容量，会使元素聚集，增加冲突，增加查找次数。</p>
<p>一般是通过除留取余法确定元素在数组中存储索引位置，即：</p>
<p>元素在数组中的存储位置 = key的hashCode % 哈希表长度</p>
<p>假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。</p>
<p>例如2 4 6 8 10 12这6个数，如果对 6 取余  得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多，并且呈现以合数的因子为间隔增长；如果对 7取余  得到 2 4 6 1 3 5 得到6种HASH值，没有冲突。</p>
<p>用质数作为数组容量使得任何数想整除它是不可能的，因此探测序列最终会检查到所有单元，冲突较少。</p>
<p>当散列函数计算结果的均匀性较差时，最好使用质数作为哈希表大小可以在除留取余时使得计算出的索引位置分布的更均匀。</p>
<p>但是库一般都会提供散列比较均匀的散列函数，只要散列函数设计的均匀，什么数做桶的大小都行，有时为了方便支持桶的动态扩容或者避免使用除法，桶的大小使用2的幂。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？
</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">算法分析：哈希表的大小为何是素数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.moew.xyz/2019/07/29/%E4%B8%BA%E4%BD%95%E5%9C%A8%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%EF%BC%8C%E8%A6%81%E5%B0%BD%E9%87%8F%E5%8F%96%E7%B4%A0%E6%95%B0/">为何在散列表中除留余数法取模运算中，要尽量取素数
</a></li>
</ul>
<h1 id="为什么桶容量要是2的次方？"><a href="#为什么桶容量要是2的次方？" class="headerlink" title="为什么桶容量要是2的次方？"></a>为什么桶容量要是2的次方？</h1><p>散列表用数组实现时，要计算元素应当存储在数组的哪个位置（索引），应当将元素key的hashCode对散列表大小取模，取模结果就是元素要存放在数组的索引位置。</p>
<p>如果key的hashCode函数不能把key散列的均匀，就需要用质数作为哈希表大小，在除留取余的求数组索引时能够让元素分布的比较均匀。</p>
<p>如果key的hashCode能够散列的比较均匀，那么其实用什么数作为哈希表大小都可以。</p>
<p>桶容量为2的幂时取模的好处：<br>1.可以用位运算取模，计算速度更快，位运算也很方便。<br>2.可以让元素分布的均匀，减少散列冲突。<br>3.方便扩容计算，扩容也只需要乘以2，容量左移一位。</p>
<h1 id="为什么2的幂的容量可以让元素分布更均匀？"><a href="#为什么2的幂的容量可以让元素分布更均匀？" class="headerlink" title="为什么2的幂的容量可以让元素分布更均匀？"></a>为什么2的幂的容量可以让元素分布更均匀？</h1><p>位运算对2的幂取模过程：一个二进制数乘以2的n次方相当于将该数左移n位，一个二进制数除以2的n次方相当于将该数右移n位，右移出界的部分就是余数，其实也就是原数低n位，取低n位的数，只需要将原数跟低位是n个1的二进制数做与操作就可以得到，低位是n个1的二进制数可以由2的n次方再减1得到。</p>
<p>如果对不是2的幂的数进行位运算取模，假设这个数是x，x-1的二进制数一定不是全部都是1，而是含有0，此时x-1与原数做与操作后，那些有0的位置都会用不到，造成空间浪费，也增大了散列冲突。如果x-1全部是1的话，只要key的hashCode的二进制中的1在低n位分布均匀，就可以保证计算index的过程是分布均匀的，要求x-1的二进制全部是1，那么x就是2的幂。</p>
<h1 id="通过构造函数传入不是2的幂的容量值会怎样？"><a href="#通过构造函数传入不是2的幂的容量值会怎样？" class="headerlink" title="通过构造函数传入不是2的幂的容量值会怎样？"></a>通过构造函数传入不是2的幂的容量值会怎样？</h1><p>会找一个最接近传入容量的2的幂作为实际桶的容量。</p>
<h1 id="哈希表容量是2的幂会有什么问题？"><a href="#哈希表容量是2的幂会有什么问题？" class="headerlink" title="哈希表容量是2的幂会有什么问题？"></a>哈希表容量是2的幂会有什么问题？</h1><p>key的hash取余求索引时，会截断hash的高位，如果多个key的hash的低位比较固定，高位变化较大，那么最后计算的散列冲突就很多了。</p>
<p>所以需要扰动函数处理一下key的hash，把高位的变化信息传递到低位。</p>
<h1 id="扰动函数是什么，起到什么作用？"><a href="#扰动函数是什么，起到什么作用？" class="headerlink" title="扰动函数是什么，起到什么作用？"></a>扰动函数是什么，起到什么作用？</h1><p>存储一个元素时，需要决定该元素应该存储在table（桶）中哪一个位置，需要用元素的key的hashCode对桶容量做取模运算来获得要存储的数组索引位置。</p>
<p>如果桶容量较小，取模操作会仅对key.hashCode()的低位做运算，如果多个元素的key的hashCode()低位相同，只是高位不同，那么冲突就较多，所以需要将高位和低位结合起来取模，减少冲突，避免散列分布不均。</p>
<p>所以在对hashCode做取模运算之前，还需要让hashCode经过扰动函数扰动一下。</p>
<p>jdk1.8中对key的hashCode的扰动函数做了优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将key.hashCode()的低16位和高16位做异或运算。</p>
<p>仅仅异或一下做扰动，权衡了速度、性能、质量，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<h2 id="为什么是右移16位？"><a href="#为什么是右移16位？" class="headerlink" title="为什么是右移16位？"></a>为什么是右移16位？</h2><p>推测：因为java中int是32位的，高16位和低16位异或已经算是顾全到了数字的二进制的每一位。</p>
<p>实际：权衡了速度、性能、质量</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
</ul>
<h2 id="扰动函数为什么是异或运算？"><a href="#扰动函数为什么是异或运算？" class="headerlink" title="扰动函数为什么是异或运算？"></a>扰动函数为什么是异或运算？</h2><ol>
<li> 实现简单，运算快捷</li>
<li>对参与运算的两方的二进制的每一位都各自有50%的概率影响结果输出</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">Why is XOR the default way to combine hashes?</a></li>
</ul>
<h1 id="桶的最大容量为什么是2的30次方，不是2的31次方？"><a href="#桶的最大容量为什么是2的30次方，不是2的31次方？" class="headerlink" title="桶的最大容量为什么是2的30次方，不是2的31次方？"></a>桶的最大容量为什么是2的30次方，不是2的31次方？</h1><p>java中int是32位，理论上1可以最多左移31位，因为1不移动就占了1位，所以可以移动的位数是32-1=31位；而虚拟机规定int类型最高位是符号位，符号位不参与移动，可移动位数就是31-1=30位</p>
<h1 id="两个key对象的hashCode相同，如何获取value对象"><a href="#两个key对象的hashCode相同，如何获取value对象" class="headerlink" title="两个key对象的hashCode相同，如何获取value对象?"></a>两个key对象的hashCode相同，如何获取value对象?</h1><p>在遍历该桶的链表，链表中每个节点保存了键值对信息，将目标key与每个节点的key调用equals方法比较，相等的则为想要找到的节点，取其value对象。</p>
<h1 id="什么对象适合做为HashMap的key"><a href="#什么对象适合做为HashMap的key" class="headerlink" title="什么对象适合做为HashMap的key?"></a>什么对象适合做为HashMap的key?</h1><p>使用String，Integer等系统类比较好，因为他们的hashCode方法实现是比较均匀的，可以减少散列冲突。</p>
<p>其次这些类一旦创建都是不可变的，一来可以缓存hashCode，二来保证唯一性，三来线程安全。</p>
<h1 id="自定义对象实现hashCode-方法有什么注意事项？"><a href="#自定义对象实现hashCode-方法有什么注意事项？" class="headerlink" title="自定义对象实现hashCode()方法有什么注意事项？"></a>自定义对象实现hashCode()方法有什么注意事项？</h1><p><strong>原则：</strong><br>一个对象的hashCode应该认为有均等的机会得到2的32次方中的任意一个32位整数值。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205744.png" alt="《算法4》节选"></p>
<p>一个优秀的散列方法需要满足三个条件：</p>
<ul>
<li>一致性 - 等价的键必然产生相等的散列值</li>
<li>高效性 - 计算简便</li>
<li>均匀性 - 均匀地散列所有的键</li>
</ul>
<p>保证均匀性的最好办法也许是保证键的每一位都在散列值的计算中起到了相同的作用，实现散列函数最常见的错误是忽略了高位的键。</p>
<p>可以参考String的hashCode设计，kotlin的data class自动生成的hashCode以及集合类的hashCode算法都很相似。</p>
<p>需要使用不可变的属性实现hashCode()方法，因为：</p>
<ol>
<li> 可以在计算一次哈希值后缓存起来，提高哈希表的读取速度。</li>
<li> 如果key在放入哈希表时和取出哈希表时hashCode()发生变化，则会取不到之前存放的对象。</li>
<li> 不可变的属性是线程安全的。</li>
</ol>
<h1 id="装载因子是什么？"><a href="#装载因子是什么？" class="headerlink" title="装载因子是什么？"></a>装载因子是什么？</h1><p>哈希表中已存储元素个数与哈希表总大小比值，即已存储元素个数与桶个数比值。</p>
<p>装载因子越大，说明填充率高，空间利用率高，但是散列冲突可能性增大。</p>
<p>装载因子越小，说明填充率低，浪费很多空间，但是散列冲突可能性减小。</p>
<p>冲突越多，查找元素的时间越长，所以必须在时间和空间上进行权衡。</p>
<h1 id="装载因子有什么作用？"><a href="#装载因子有什么作用？" class="headerlink" title="装载因子有什么作用？"></a>装载因子有什么作用？</h1><p>装载因子 = 已存储的元素个数 / 桶大小</p>
<p>HashMap构造时可以传入一个装载因子，不传入的话会使用默认的装载因子0.75，构造时规定这个装载因子意思是装载因子的最大值。</p>
<p>随着哈希表中存储元素的个数增多，填充率越高，实际的装载因子会逐渐增大，当  实际装载因子  大于  预设装载因子  时，为了避免大量的散列冲突，要增大桶的数量，HashMap会将通大小调整为原来的两倍，因为桶大小要求是2的幂，所以就扩大2倍。</p>
<h1 id="桶容量是如何动态扩展的？"><a href="#桶容量是如何动态扩展的？" class="headerlink" title="桶容量是如何动态扩展的？"></a>桶容量是如何动态扩展的？</h1><p>当  已存储元素个数  超过  哈希表大小 * 装载因子，会扩容至原大小的两倍，并对部分元素重新散列。</p>
<p>当put元素时，发现已存储元素个数超过threshold时，会触发扩容。</p>
<p>threshold的首次赋值由构造HashMap时传入的初始容量和装载因子决定。</p>
<p>threshold = 初始容量 * 装载因子</p>
<p>每次扩容桶（table）大小会变为原来两倍，threshold也会变为原来的两倍。</p>
<h1 id="构造函数传入不是2的幂的初始容量会怎样？"><a href="#构造函数传入不是2的幂的初始容量会怎样？" class="headerlink" title="构造函数传入不是2的幂的初始容量会怎样？"></a>构造函数传入不是2的幂的初始容量会怎样？</h1><p>不管传什么初始容量，都会经由tableSizeFor()计算得到大于等于传入的初始容量的最小的2的幂作为桶的实际容量大小</p>
<p>在put()时触发resize()，threshold也会被重新赋值为桶容量乘以装载因子。</p>
<h1 id="tableSizeFor-算法过程是怎样的？"><a href="#tableSizeFor-算法过程是怎样的？" class="headerlink" title="tableSizeFor()算法过程是怎样的？"></a>tableSizeFor()算法过程是怎样的？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三种情况</p>
<ol>
<li>cap小于0，返回1</li>
<li>cap经过位运算后大于等于MAXIMUM_CAPACITY，返回MAXIMUM_CAPACITY</li>
<li>cap经过位运算后返回n+1</li>
</ol>
<p>先考虑正常的情况，对于一个给定的cap，分为两种情况，cap可能是2的幂或非2的幂。</p>
<ol>
<li>当cap不是2的幂，例如10，二进制为1010，cap - 1 = 1001，几个右移操作实际的结果就是从cap - 1的二进制的1的最高位开始到最低位全部变成1，最后返回n + 1就是2的幂了</li>
<li>当cap是2的幂，例如16，二进制为10000，cap-1 = 1111，右移操作后n还是为1111，n+1就还是16</li>
</ol>
<p>所以正常情况下tableSizeFor()得出的就是大于等于cap的数</p>
<p>如果cap一开始不减1，当cap是2的幂时，最后计算得出的就会是cap的2倍</p>
<p>cap小于0，没有实际的意义，不能表示桶容量，故而返回最小正整数1</p>
<p>cap大于等于MAXIMUM_CAPACITY时，MAXIMUM_CAPACITY是2的30次方，此时cap的二进制最高位1是在第31位，逻辑右移再加1会得到32个1，int中最高位（第32位）是符号位，最高位1表示负数了，没有意义，故而将最大值限定在2的30次方，2的30次方减1的二进制是从第1位到第30位全都是1</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）
</a></li>
</ul>
<h1 id="为什么要调整桶大小？"><a href="#为什么要调整桶大小？" class="headerlink" title="为什么要调整桶大小？"></a>为什么要调整桶大小？</h1><p>为了减少散列冲突，减少元素查找次数</p>
<h1 id="为什么桶初始容量是16？"><a href="#为什么桶初始容量是16？" class="headerlink" title="为什么桶初始容量是16？"></a>为什么桶初始容量是16？</h1><p>这个问题不好解答可以考虑边界情况，桶容量过大、过小会导致什么</p>
<p>桶容量过大会导致大量空间浪费</p>
<p>桶容量过小会导致频繁扩容，扩容一次是耗时的</p>
<p>16应当是一个权衡评估后得出的值</p>
<h1 id="默认装载因子为什么是0-75？"><a href="#默认装载因子为什么是0-75？" class="headerlink" title="默认装载因子为什么是0.75？"></a>默认装载因子为什么是0.75？</h1><p>可以先考虑装载因子过大和过小分别会有什么问题</p>
<p>装载因子过大，表明哈希表填充率高，但是散列冲突的可能性大，查找元素的次数多</p>
<p>装载因子过小，表明哈希表的空闲空间大，空间利用率低，但冲突较少，查找元素次数少</p>
<p>0.75乘以2的幂是整数，不需要再做四舍五入，计算方便</p>
<p>根据HashMap注释</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost(reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/reliveIT/article/details/82960063">HashMap defaultLoadFactor = 0.75和泊松分布没有关系
</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64f6de3ffcc1">HashMap的loadFactor为什么是0.75？
</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/31401836/2011291">StackOverflow: What is the significance of load factor in HashMap?
</a></li>
</ul>
<h1 id="resize-的大致过程"><a href="#resize-的大致过程" class="headerlink" title="resize()的大致过程"></a>resize()的大致过程</h1><p>根据resize()方法的注释所言，resize()会将桶容量扩充两倍，由于容量是2的幂，原来桶中的元素位置要么是原封不动，要么是再移动2的幂个位置。</p>
<p>求元素的在table中的索引依然是  元素key的hashCode &amp; (桶容量-1)</p>
<p>例如原来容量是16，二进制为10000，求元素索引时是 hashCode &amp; 1111</p>
<p>扩容两倍后容量是32，二进制位100000，求元素索引的计算变成了 hashCode &amp; 11111，比之前多了一个1，如果元素key的hashCode在该位也是1，等同于元素的索引位置增加了2的幂。</p>
<p>桶中是链表时，会将链表划分为两个链表，一个留在原桶，一个放入移动了2的幂的桶中。</p>
<p>为什么要这样调整？原封不动不行吗？</p>
<p>因为这样做是为了保证散列均匀，减少冲突。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现
</a></li>
</ul>
<h1 id="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"><a href="#为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"></a>为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？</h1><p>因为节点数过少时，红黑树的插入、删除的成本比链表要高很多。</p>
<p>在散列均匀的情况下，冲突较少，每个桶中链表的平均长度比较短，性能可接受。</p>
<h1 id="为什么链表的长度为8时变成红黑树？"><a href="#为什么链表的长度为8时变成红黑树？" class="headerlink" title="为什么链表的长度为8时变成红黑树？"></a>为什么链表的长度为8时变成红黑树？</h1><p>根据jdk1.8的HashMap中的注释所言，假设散列分布均匀，在负载因子为0.75的条件下，某一个桶中元素出现的频率满足λ为0.5的泊松分布。从概率来看，之所以链表长度超过 8 以后要变成红黑树，因为在散列分布均匀的情况下出现这种情况的概率小到忽略不计，一旦出现，几乎可以认为是散列函数设计有问题导致的，即散列不均匀。</p>
<p>所以红黑树是专门应对元素key糟糕的（分布不均匀）的散列函数而准备的。</p>
<p>二项分布：n次重复独立伯努利试验，一次伯努利实验只有两种对立的结果。</p>
<p>泊松分布：当二项分布的n很大，p很小时，可以近似为泊松分布。</p>
<p>算法第四版465页：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205936.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205952.png"></p>
<p>散列均匀时，每个桶的链表的平均长度为  实际元素总数  / 哈希表大小，这个就是装载因子λ</p>
<p>现在的问题就是，将N个元素随机放入M个桶，每个桶的元素平均个数为λ（N/M），求每个桶元素个数为k的概率。</p>
<p>对于某一个桶而言，一个元素放入桶中是一个二元结果，要么放入，要么不放入，散列均匀的情况下，不管有多少个桶，每个元素出现在同一个桶的概率是相同，每个桶中平均有λ个元素时，那么一个元素出现在同一个桶的概率就是λ/N，就是桶元素数量占元素总数的比值，理解很直观。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ysmull.cn/JCF/HashMap.html">谈谈 HashMap 实现中的若干数学问题
</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26263743">泊松分布 (Poisson Distributions) 的推导
</a></li>
</ul>
<h1 id="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"><a href="#为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？" class="headerlink" title="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"></a>为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？</h1><p>是为了防止频繁插入和删除元素时不停的在树和链表之间互相转换、降低性能，红黑树和链表之间的转换是有成本的。</p>
<h1 id="MIN-TREEIFY-CAPACITY是做什么的？"><a href="#MIN-TREEIFY-CAPACITY是做什么的？" class="headerlink" title="MIN_TREEIFY_CAPACITY是做什么的？"></a>MIN_TREEIFY_CAPACITY是做什么的？</h1><p>桶中元素超过TREEIFY_THRESHOLD个（8个）后，还要保证哈希表数组table的大小大于等于MIN_TREEIFY_CAPACITY才会把链表转红黑树，容量过小时使用红黑树性价比不高，用扩容来解决桶元素堆积的问题更适合。</p>
<p>这个值为什么要是4 * TREEIFY_THRESHOLD，是为了避免在resize和树化之间产生冲突，比如初始容量是16，装载因子0.75，存储元素有16*0.75=12个时就应该扩容，但是此时如果是4个元素在一个桶，8个元素在另外一个桶，是要先树化的，树化后再等resize扩容了，可能又要将红黑树链表化，这样反复来回影响性能。</p>
<h1 id="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"><a href="#平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？" class="headerlink" title="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"></a>平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？</h1><p>单次的插入和删除操作：</p>
<p>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</p>
<p>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</p>
<p>大量的插入和删除操作：</p>
<p>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</p>
<p>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</p>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16257761/difference-between-red-black-trees-and-avl-trees">Difference between red-black trees and AVL trees</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/21aspnet/article/details/88939297">为什么Java8中HashMap链表使用红黑树而不是AVL树
</a></li>
</ul>
<h1 id="put方法大致过程"><a href="#put方法大致过程" class="headerlink" title="put方法大致过程"></a>put方法大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>table数组为null则通过resize()初始化table，创建HashMap对象不会立刻初始化table数组</li>
<li>利用扰动后的hashCode除留取余求得元素在table中的索引</li>
<li>如果没有碰撞冲突，直接存入桶中</li>
<li>如果有碰撞冲突，桶中维护一个链表存储哈希值相同的元素，java7是头插法，java8是尾插法</li>
<li>链表长度超过TREEIFY_THRESHOLD，链表转为红黑树</li>
<li>如果元素已存在，替换value。元素存在先通过key的hashCode查看桶中是否有元素，没有则不存在，有元素需要依次遍历桶中元素，通过key的equals方法比较是否相等，有相等的则存在。</li>
<li> 哈希表实际存储元素数量超过了阈值threshold（哈希表大小 * 装载因子），调用resize()扩容。</li>
</ol>
<h1 id="get方法的大致过程"><a href="#get方法的大致过程" class="headerlink" title="get方法的大致过程"></a>get方法的大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>根据哈希值求得table索引</li>
<li>若桶中第一个元素命中，直接返回</li>
<li> 有冲突则依次遍历链表或红黑树，通过key的equals比较来寻找目标节点，找到了返回其value，没有找到返回null</li>
</ol>
<h1 id="HashMap为什么线程不安全？高并发下会产生什么问题？"><a href="#HashMap为什么线程不安全？高并发下会产生什么问题？" class="headerlink" title="HashMap为什么线程不安全？高并发下会产生什么问题？"></a>HashMap为什么线程不安全？高并发下会产生什么问题？</h1><p>一句话：jdk7的HashMap在扩容时会改变链表中元素原本的顺序，高并发情况下容易导致链表产生环，进而导致死循环，CPU占用率飙升到100%。</p>
<p>jdk7中扩容采用头插法是考虑到缓存的时间局部性原则，最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数。</p>
<p>jdk8中扩容改为尾插法，高并发情况下不会产生死循环了，但是resize依然不是原子性的，可能会产生数据丢失。</p>
<p>其他方法例如链表和红黑树互转的过程，都不是原子性的，都可能会产生数据丢失的问题。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2f75c8cce01">为什么HashMap线程不安全
</a></li>
</ul>
<h1 id="Java-8-对HashMap做出了哪些改进？"><a href="#Java-8-对HashMap做出了哪些改进？" class="headerlink" title="Java  8  对HashMap做出了哪些改进？"></a>Java  8  对HashMap做出了哪些改进？</h1><ol>
<li>桶中链表长度超过8将链表转为红黑树，以应对不均匀的散列函数导致的查询次数增多</li>
<li> 链表插入元素由头插法改为尾插法，以解决并发下插入元素时链表产生环进而导致的死循环</li>
</ol>
<h1 id="modCount是做什么的？"><a href="#modCount是做什么的？" class="headerlink" title="modCount是做什么的？"></a>modCount是做什么的？</h1><p>对哈希表做出了修改（添加和删除元素），modCount就会增加，表示修改的次数，使用迭代器迭代哈希表时一旦发现modCount变化了，就会立刻抛出ConcurrentModificationException，以避免迭代时的不确定性，这称为fail-fast机制。注意修改一个已存在的元素的value不改变modCount。</p>
<h1 id="HashMap的缺点是什么？想要用哈希表还有哪些选择？"><a href="#HashMap的缺点是什么？想要用哈希表还有哪些选择？" class="headerlink" title="HashMap的缺点是什么？想要用哈希表还有哪些选择？"></a>HashMap的缺点是什么？想要用哈希表还有哪些选择？</h1><p>缺点就是结构复杂，占用内存可能较多，对哈希表有简单需求的地方不需要这么复杂而完善的类</p>
<p>例如ThreadLocalMap就自己实现了一套简单的哈希表，采用开放定址法</p>
<p>还有Android上SparseArray、ArrayMap实现的内存消耗更低的哈希表</p>
<h1 id="HashMap与Hashtable的区别？"><a href="#HashMap与Hashtable的区别？" class="headerlink" title="HashMap与Hashtable的区别？"></a>HashMap与Hashtable的区别？</h1><ol>
<li> Hashtable的get、put、clear、contains、size等大部分方法上都加上了synchronized关键字，给整个对象上锁，HashMap非线程安全</li>
<li> Hashtable中没有红黑树仅有链表</li>
<li> Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li> Hashtable不允许null的key和value，而HashMap都允许</li>
<li> Hashtable求key的hashCode没有扰动</li>
<li> HashMap和Hashtable使用Iterator遍历元素过程中对哈希表添加或删除元素是会抛出异常的（fast-fail），但Hashtable用Enumeration迭代时不会fast-fail，因为通过Enumeration的nextElement()获取下一个元素时没有对modCount做判断，而Iterator的next方法对modCount做了判断。</li>
<li> Hashtable是jdk1添加的，HashMap是jdk2添加的</li>
</ol>
<p>Dictionary已被废弃，所以Hashtable已经被废弃，而且同步性能较差，大多数操作都会锁住整个对象。用jdk1.5引入的采用分段锁的ConcurrentHashMap同步性能更好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/http2%E3%80%81quic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/http2%E3%80%81quic/" class="post-title-link" itemprop="url">http2、quic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-05 20:31:00" itemprop="dateCreated datePublished" datetime="2018-04-05T20:31:00+08:00">2018-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/http2%E3%80%81quic/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/http2、quic/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="tcp队头阻塞是什么？"><a href="#tcp队头阻塞是什么？" class="headerlink" title="tcp队头阻塞是什么？"></a>tcp队头阻塞是什么？</h1><p>tcp是按字节有序传输的，如果发送方发送了一连串的报文，中间有个报文没有收到ACK确认，会一直等待超时然后重传报文，发送方的滑动窗口一直不能移动，导致不能发送更多的报文。</p>
<p>这样http请求之间就不是独立的，会互相影响。</p>
<h1 id="http队头阻塞是什么？"><a href="#http队头阻塞是什么？" class="headerlink" title="http队头阻塞是什么？"></a>http队头阻塞是什么？</h1><p>多个http请求只能顺序请求，因为http请求和响应没有编号，同时执行多个请求，不按顺序返回响应，客户端无法分辨是哪个响应对应哪个请求，这样如果前面的请求处理较慢，后面的请求都会被阻塞。</p>
<h1 id="http2解决了什么？"><a href="#http2解决了什么？" class="headerlink" title="http2解决了什么？"></a>http2解决了什么？</h1><ol>
<li> http报文分片</li>
<li> http header压缩</li>
<li> 支持服务端推送</li>
<li> 基于TLS实现安全传输（与https相同）</li>
</ol>
<h2 id="报文分片"><a href="#报文分片" class="headerlink" title="报文分片"></a>报文分片</h2><p>http报文是纯文本的，http2报文是二进制字节流，对报文进行了分片并编号，相当于把tcp的报文分段编号实现搬到应用层。</p>
<p>同一个tcp连接可以同时传输多个http报文分片，实现多路复用，解决http请求对头阻塞问题。</p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>客户端请求一个html，服务端可以把相关的css、png等资源一同返回给客户端，减少客户端请求次数。</p>
<h1 id="QUIC解决了什么？"><a href="#QUIC解决了什么？" class="headerlink" title="QUIC解决了什么？"></a>QUIC解决了什么？</h1><p>Quick UDP Internet Connection</p>
<p>基于udp实现，在应用层实现传输可靠性，非常的自由灵活。</p>
<p>主要改进：</p>
<ol>
<li> 快速握手</li>
<li> 避免对头阻塞的多路复用</li>
<li> 连接迁移</li>
</ol>
<h2 id="快速握手"><a href="#快速握手" class="headerlink" title="快速握手"></a>快速握手</h2><p>在HTTPS协议中，由于TCP和TLS都各需要自3次握手，导致连接建立过程较为复杂和耗时，降低了HTTPS的效率。</p>
<p>QUIC选择UDP来作为其底层协议，就可以将连接建立和密钥协商的过程合二为一，简化操作流程，提高连接效率。</p>
<p>在连接建立成功后， 客户端会缓存起来原始的连接信息等。 在接下来与相同的服务器建立连接的过程中， 客户端能够在不增加额外RTT的情况下建立一个加密的连接，数据要发送的数据可以在握手的包中捎带着发送过去，而不用等待服务器的回复，从而实现0RTT。</p>
<p>所以，所谓QUIC的0RTT是指在建立连接之后，后续发送数据都不需要增加额外的RTT时间，最开始的握手还是需要1RTT的时间消耗的。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h3 id="为什么quic能解决队头阻塞？"><a href="#为什么quic能解决队头阻塞？" class="headerlink" title="为什么quic能解决队头阻塞？"></a>为什么quic能解决队头阻塞？</h3><ul>
<li>http队头阻塞用http分片解决。</li>
<li>tcp队头阻塞用udp协议代替，在应用层重新实现可靠传输机制，http请求之间是独立互不影响的。</li>
</ul>
<h3 id="为什么不修改tcp协议解决队头阻塞？"><a href="#为什么不修改tcp协议解决队头阻塞？" class="headerlink" title="为什么不修改tcp协议解决队头阻塞？"></a>为什么不修改tcp协议解决队头阻塞？</h3><ol>
<li> tcp在操作系统层面实现，普及比较麻烦。</li>
<li> 各种网络中间设备（如网关、防火墙、代理服务器）为了效率最优化，保持了约定俗成的潜规则，如某些防火墙只允许特定端口，中间代理会删除报头中不认识的选项字段</li>
</ol>
<h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>一个TCP连接由四元组确定：源ip、源端口号、目标ip、目标端口号。</p>
<p>任何一个元素变化了，tcp就要重新建立连接，例如移动手机在移动网络和WiFi切换，重新建立连接会带来数据传输时延。</p>
<p>而QUIC的连接不依赖于四元组，以一个随机ID作为标识，这样IP或端口发生变化，只要连接ID不变，还是认为是一个连接，应用层感知不到底层tcp连接的变化，这样把影响就降到最低。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20Task/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20Task/" class="post-title-link" itemprop="url">Android Task</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-03 20:31:00" itemprop="dateCreated datePublished" datetime="2018-04-03T20:31:00+08:00">2018-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20Task/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android Task/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在日常开发过程中，只要涉及到activity，那么对task相关的东西总会或多或少的接触到，不过对task相关的一些配置的作用理解的还不是很透彻，官方文档在细节上说的也不够清楚，要透彻理解还是得自己写demo实践检验，所以便有了这篇总结。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Android/Android%20Task/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/" class="post-title-link" itemprop="url">https、TLS握手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-03 20:31:00" itemprop="dateCreated datePublished" datetime="2018-04-03T20:31:00+08:00">2018-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/https、TLS握手/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http传输数据存在哪些问题？"><a href="#http传输数据存在哪些问题？" class="headerlink" title="http传输数据存在哪些问题？"></a>http传输数据存在哪些问题？</h1><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。<br>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>Charles抓包就是中间人拦截监听。</p>
<h1 id="https新引入了什么？解决了什么问题？"><a href="#https新引入了什么？解决了什么问题？" class="headerlink" title="https新引入了什么？解决了什么问题？"></a>https新引入了什么？解决了什么问题？</h1><ol>
<li> 数据加密传输，防止窃听</li>
<li> 校验数据，防止篡改</li>
<li> 使用数字证书验证身份，防止身份被冒充</li>
</ol>
<h1 id="https缺点是什么？"><a href="#https缺点是什么？" class="headerlink" title="https缺点是什么？"></a>https缺点是什么？</h1><ol>
<li> TLS握手增加了建立连接的时间</li>
<li> 每次加密解密数据需要占用额外的时间和CPU资源</li>
</ol>
<h1 id="https如何保证数据的完整性？"><a href="#https如何保证数据的完整性？" class="headerlink" title="https如何保证数据的完整性？"></a>https如何保证数据的完整性？</h1><p>http验证数据完整性存在的问题：</p>
<p>http通信是不加密的，即使对报文做了哈希摘要，并放在报文中传输，http通信内容被拦截篡改后，一并把哈希摘要也改掉，客户端是没办法识别报文是否被篡改。</p>
<p>https改进：</p>
<p>对报文的哈希摘要进行加密，另一方接受到报文并重新计算报文的哈希摘要，再对比解密后的摘要，检查是否一致。</p>
<p>对摘要的加密用对称加密，对称加密的秘钥用非对称加密方式加解密。</p>
<h1 id="https加密过程是怎样的？"><a href="#https加密过程是怎样的？" class="headerlink" title="https加密过程是怎样的？"></a>https加密过程是怎样的？</h1><p>采用对称加密方式加密报文，对称加密的秘钥用非对称加密方式加密后传递给通信双方。</p>
<p>因为：</p>
<ol>
<li> 对称加密速度快，但是通信双方都需要同一个密钥，密钥在传输过程中被窃取泄露后就不安全了</li>
<li> 非对称加密速度慢，但私钥不公开，只传递公钥出去，可以保证安全性</li>
</ol>
<h1 id="https通信过程是怎样的？"><a href="#https通信过程是怎样的？" class="headerlink" title="https通信过程是怎样的？"></a>https通信过程是怎样的？</h1><ol>
<li> 客户端发起SSL/TLS连接</li>
<li> 客户端获取服务端数字证书，验证服务端身份</li>
<li> 两端生成随机数，由服务端根据随机数，用私钥加密得到对称加密密钥</li>
<li> http的请求和响应报文都用对称加密密钥加密后再传输</li>
</ol>
<h1 id="SSL-TLS握手过程是怎样的？"><a href="#SSL-TLS握手过程是怎样的？" class="headerlink" title="SSL/TLS握手过程是怎样的？"></a>SSL/TLS握手过程是怎样的？</h1><p>有四次握手</p>
<ol>
<li> 客户端请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA公钥加密，此时是明文传输。</li>
<li> 服务端回复一种客户端支持的加密方法、一个随机数–Server random、授信的服务器证书和非对称加密的公钥。</li>
<li> 客户端收到服务端的回复后利用服务端的公钥，加上新的随机数–Premaster secret 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li>
<li> 服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li>
</ol>
<p>此后的HTTP链接数据传输即通过对称加密方式进行加密传输。</p>
<h2 id="为什么需要3个随机数作为对称加密的密钥？"><a href="#为什么需要3个随机数作为对称加密的密钥？" class="headerlink" title="为什么需要3个随机数作为对称加密的密钥？"></a>为什么需要3个随机数作为对称加密的密钥？</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在，在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。</p>
<h1 id="还有什么密钥交换算法？"><a href="#还有什么密钥交换算法？" class="headerlink" title="还有什么密钥交换算法？"></a>还有什么密钥交换算法？</h1><p>ECDHE ：“短暂 - 椭圆曲线 - 迪菲 - 赫尔曼”算法（ephemeral Elliptic Curve Diffie–Hellman）。</p>
<p>RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。</p>
<p>客户端和服务端双方在一个可以被窥探的信道下给双方建立起一个相同的密钥。</p>
<p>发送公有的参数，保留私有的参数，双方经过计算可以得到一个一致的结果，一致的结果可以用作会话密钥，这个运算的逆运算复杂度很高，所以不会泄露。</p>
<p><strong>为什么参数被窥探后还能够达到保密的效果?</strong></p>
<p>Deffie-Hellman算法的有效性依赖于计算离散对数的难度。</p>
<h1 id="https总共有多少次握手了？"><a href="#https总共有多少次握手了？" class="headerlink" title="https总共有多少次握手了？"></a>https总共有多少次握手了？</h1><p>SSL是在TCP之上，在HTTP之下。</p>
<p>TCP先三次握手建立连接，然后SSL四次握手，最后进行HTTP通信。</p>
<h1 id="https的身份认证是如何实现的？"><a href="#https的身份认证是如何实现的？" class="headerlink" title="https的身份认证是如何实现的？"></a>https的身份认证是如何实现的？</h1><p>通过数字证书验证通信方身份。</p>
<h2 id="如何验证证书是否可信？"><a href="#如何验证证书是否可信？" class="headerlink" title="如何验证证书是否可信？"></a>如何验证证书是否可信？</h2><p>服务端证书都是向CA这类的权威机构申请的，CA颁发证书时会用根证书的私钥去给申请的证书的哈希摘要做加密作为申请的证书的签名。</p>
<p>客户端收到服务端的证书后，查询证书的颁发者，一直寻找到根证书，然后用根证书里的公钥去解密其颁发的证书的签名，对比证书文件的哈希摘要是否一致，这样就验证了身份没有被篡改。</p>
<h2 id="数字证书验证身份的过程是怎样的？"><a href="#数字证书验证身份的过程是怎样的？" class="headerlink" title="数字证书验证身份的过程是怎样的？"></a>数字证书验证身份的过程是怎样的？</h2><p>服务端向CA（数字证书认证机构）提交自己的公钥申请数字证书，CA颁发证书，并把服务端的公钥内嵌在颁发的证书中，再对整个证书计算哈希摘要，用一个私钥加密这个哈希摘要，确保了申请到的证书在传输过程中可以校验证书是否被篡改，校验是通过CA提供的根证书里的公钥解密服务端证书中的哈希摘要，再计算服务端证书文件的哈希摘要，对比两者是否一致，根证书一般已事先内嵌客户端。</p>
<p>证书可以有信任链。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827203913.png"></p>
<h1 id="https单向认证是什么？"><a href="#https单向认证是什么？" class="headerlink" title="https单向认证是什么？"></a>https单向认证是什么？</h1><ol>
<li> 客户端发起请求，传送支持的TLS版本、摘要算法、随机数等信息</li>
<li> 服务端返回确认的TLS版本、摘要算法，并再发送生成的随机数、服务端的证书</li>
<li> 客户端验证证书是否可信，不可信则弹窗警告，可信则用随机数生成一个用于对称加密的密钥，用于接下来加密报文，用服务端证书的公钥加密发送给服务端</li>
<li> 服务端接收到会话密钥，用私钥解密，得到会话密钥，返回ACK确认消息</li>
</ol>
<h1 id="https双向认证是什么？"><a href="#https双向认证是什么？" class="headerlink" title="https双向认证是什么？"></a>https双向认证是什么？</h1><p>单向认证是客户端验证服务端的证书来检验服务端身份是否合法。</p>
<p>双向认证是服务端也要求验证客户端的证书来检验客户端的身份是否合法。服务端会在发送证书给客户端时，要求客户端也发送证书给服务端。</p>
<p>双向认证使用场景：</p>
<p>使用网上银行可能需要在电脑上插U盾之类的东西，就是生成客户端证书的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">UDP与TCP区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-16 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-16T19:31:00+08:00">2018-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/UDP与TCP区别/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UDP报文头"><a href="#UDP报文头" class="headerlink" title="UDP报文头"></a>UDP报文头</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827230610.png"></p>
<p>UDP 协议头中只包含 4 个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占 16 比特，即 2 字节，这 4 个字段的作用如下：</p>
<ul>
<li>源端口是一个可选字段，它表示发送方进程的端口号，接收方可以使用该字段（不一定准确）向发送方发送信息；</li>
<li>目的端口是数据报接收方的端口号，它只在目标的 IP 地址下才有意义；</li>
<li>长度是协议头和数据报中数据长度的总和，表示整个数据报的大小；</li>
<li>  校验码使用 IP 首部、UDP 首部和数据报中的数据进行计算，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题。</li>
</ul>
<h1 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h1><p>简单高效：</p>
<ol>
<li> 面向无连接</li>
<li> 报文头简单，只有8字节</li>
<li> 对应用层数据不分段</li>
</ol>
<p>关于分段：</p>
<p>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。若报文太长，则到达IP层需要分片，降低效率。若太短，则传输效率会下降（举个例子，1字节的数据，加上20字节的UDP首部，再加上20字节的IP层首部，结果发了41字节的包只完成了1字节有用数据的交付）。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<h1 id="UDP和TCP区别？"><a href="#UDP和TCP区别？" class="headerlink" title="UDP和TCP区别？"></a>UDP和TCP区别？</h1><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/" class="post-title-link" itemprop="url">最大报文长度（MSS）与最大传输单元（MTU）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-15T19:31:00+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/最大报文长度（MSS）与最大传输单元（MTU）/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大报文长度（Maximum-Segment-Size）是什么？"><a href="#最大报文长度（Maximum-Segment-Size）是什么？" class="headerlink" title="最大报文长度（Maximum Segment Size）是什么？"></a>最大报文长度（Maximum Segment Size）是什么？</h1><p>TCP报文数据部分的最大长度，不包含TCP头。</p>
<p>这个MSS指的是TCP报文段中数据部分的最大长度，并不是整个TCP报文段长度。整个TCP报文段长度 = TCP首部长度 + TCP数据部分长度。</p>
<p>如果上层交付下来的数据太大，就对其进行数据分块。这个分块过程是在传输层完成的，在接收端的传输层对分块的TCP报文段的数据部分进行重组。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）存储在什么地方？"><a href="#最大报文长度（Maximum-Segment-Size）存储在什么地方？" class="headerlink" title="最大报文长度（Maximum Segment Size）存储在什么地方？"></a>最大报文长度（Maximum Segment Size）存储在什么地方？</h1><p>TCP首部中的Options字段</p>
<h1 id="为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？"><a href="#为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？" class="headerlink" title="为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？"></a>为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？</h1><p>当TCP数据长度超过MSS的时候，TCP会做分段。</p>
<p>这样是为了防止IP层对TCP报文分片。</p>
<h1 id="IP层对TCP报文进行分片会产生什么问题？"><a href="#IP层对TCP报文进行分片会产生什么问题？" class="headerlink" title="IP层对TCP报文进行分片会产生什么问题？"></a>IP层对TCP报文进行分片会产生什么问题？</h1><p>IP分片后，接收端需要等到所有IP包到达后，才能确定整个TCP报文收到了，然后发送ACK报文，这样比较低效，也增加了控制的复杂性。</p>
<p>IP分片后，如果有几个分片丢失了，只能重传所有分片，这样是很浪费流量的。</p>
<p>首先因为IP层没有超时重传机制，IP层是面向无连接的，所以IP层没有办法只重传丢失的分片。</p>
<p>其次IP分片后，只有第一片有TCP的报文头，后面的IP分片没有TCP报文头，所以TCP也没办法识别到底是哪一段丢失了，也就没办法做超时重传，也没办法确定顺序，如果TCP对报文分段，每段都有TCP报文头，报文丢失就知道丢失的是哪一个。</p>
<h1 id="为什么IP数据长度过长要分片？"><a href="#为什么IP数据长度过长要分片？" class="headerlink" title="为什么IP数据长度过长要分片？"></a>为什么IP数据长度过长要分片？</h1><p>IP分组达到数据链路层，整个IP分组被作为数据链路层以太网帧的数据部分。</p>
<p>以太网帧对数据部分有最大长度的限制，所以IP数据数据过长要分片。</p>
<p>数据链路层的以太网帧的数据部分的最大长度（最大IP包长）称为最大传输单元（Maximum Transmit Unit）</p>
<p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p>
<h1 id="TCP拆分数据的意义？"><a href="#TCP拆分数据的意义？" class="headerlink" title="TCP拆分数据的意义？"></a>TCP拆分数据的意义？</h1><p>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</p>
<h1 id="最大传输单元（Maximum-Transmit-Unit）是什么？"><a href="#最大传输单元（Maximum-Transmit-Unit）是什么？" class="headerlink" title="最大传输单元（Maximum Transmit Unit）是什么？"></a>最大传输单元（Maximum Transmit Unit）是什么？</h1><p>数据链路层的以太网帧的数据部分的最大长度（IP包长）</p>
<h1 id="为什么以太网MTU默认值被设定为1500？"><a href="#为什么以太网MTU默认值被设定为1500？" class="headerlink" title="为什么以太网MTU默认值被设定为1500？"></a>为什么以太网MTU默认值被设定为1500？</h1><p>MTU为什么不能太大呢？</p>
<p>以太网早期的拓扑结构是总线型结构，总线型传输有个特点就是，同一时刻只能有一个主机占用总线传输，如果一个以太网帧过长，这个主机就会一直占用总线，其他主机只能干等着，对于其他主机来说数据延迟就变大了。</p>
<p>而且传输的数据包越大，数据位出错的可能性越大，出错了就要重传，重传又要占用很长时间的带宽，降低了整体吞吐量。</p>
<p>所以MTU不能太大。</p>
<p>如果MTU太小，各种协议头也要占用数据包大小的，这样每个报文的实际有效传输效率也会很低。</p>
<p>所以MTU要搞一个适中值。</p>
<p>1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致丢包无法发送。</p>
<h1 id="为什么MTU最小为64字节？"><a href="#为什么MTU最小为64字节？" class="headerlink" title="为什么MTU最小为64字节？"></a>为什么MTU最小为64字节？</h1><p>以CSMA/CD作为MAC<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure">算法</a>的一类LAN称为以太网。CSMA/CD冲突避免的方法：先听后发、边听边发、随机延迟后重发。一旦发生冲突，必须让每台主机都能检测到。关于最小发送间隙和最小帧长的规定也是为了避免冲突。</p>
<p>考虑如下的情况，主机发送的帧很小，而两台冲突主机相距很远。在主机A发送的帧传输到B的前一刻，B开始发送帧。这样，当A的帧到达B时，B检测到冲突，于是发送冲突信号。假如在B的冲突信号传输到A之前，A的帧已经发送完毕，那么A将检测不到冲突而误认为已发送成功。由于信号传播是有时延的，因此检测冲突也需要一定的时间。这也是为什么必须有个最小帧长的限制。</p>
<p>按照标准，10Mbps以太网采用中继器时，连接的最大长度是2500米，最多经过4个中继器，因此规定对10Mbps以太网一帧的最小发送时间为51.2微秒。这段时间所能传输的数据为512位，因此也称该时间为512位时。这个时间定义为以太网时隙，或冲突时槽。512位＝64字节，这就是以太网帧最小64字节的原因。</p>
<p>512位时是主机捕获信道的时间。如果某主机发送一个帧的64字节仍无冲突，以后也就不会再发生冲突了，称此主机捕获了信道。</p>
<p>由于信道是所有主机共享的，如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的最大帧长为1500。</p>
<p>100Mbps以太网的时隙仍为512位时，以太网规定一帧的最小发送时间必须为5.12μs。</p>
<p>1000Mbps以太网的时隙增至512字节，即4096位时，4.096μs。</p>
<p>以太网数据帧（802.3）最大与最小长度。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）是怎么确定的？"><a href="#最大报文长度（Maximum-Segment-Size）是怎么确定的？" class="headerlink" title="最大报文长度（Maximum Segment Size）是怎么确定的？"></a>最大报文长度（Maximum Segment Size）是怎么确定的？</h1><p>MSS由设备的MTU确定，不能超过MTU，否则TCP报文会被IP层分片  </p>
<h1 id="TCP报文的长度在TCP三次握手中那一次确定的？"><a href="#TCP报文的长度在TCP三次握手中那一次确定的？" class="headerlink" title="TCP报文的长度在TCP三次握手中那一次确定的？"></a>TCP报文的长度在TCP三次握手中那一次确定的？</h1><p>MSS值只会出现在SYN报文中（不要问我为什么，我也不知道为什么只出现SYN报文中），即SYN=1时，才会有MSS字段值。</p>
<p>当客户端想要以TCP方式从服务器端下载数据时，</p>
<p>（1）首先客户端会发送一个SYN请求报文，这个SYN报文的“选项”字段中会有MSS值（MSS = MTU - IP首部长度 - TCP首部长度）。该MSS值是为了告知对方最大的发送数据大小。</p>
<p>（2）当服务器端收到SYN报文后，会向请求端返回SYN+ACK（同步确认报文）报文，其中的“选项”字段也会有MSS值。</p>
<p>（3）通信双方选择SYN和SYN+ACK报文中最小的MSS最为此次TCP连接的MSS，从而达到通信双发协商MSS的效果。</p>
<p>在第二次握手后就可以确定TCP中最大传输报文（MSS）大小。</p>
<h1 id="MTU是怎么确定的？"><a href="#MTU是怎么确定的？" class="headerlink" title="MTU是怎么确定的？"></a>MTU是怎么确定的？</h1><p>每一个物理设备都有自己的 MTU，最终的MTU由整个链路上 MTU 最小的物理设备决定。</p>
<p>路径MTU发现（PMTUD： Path MTU Discovery ）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP拥塞控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-13 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-13T19:31:00+08:00">2018-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP拥塞控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么情况下才算发生了网络拥塞？"><a href="#什么情况下才算发生了网络拥塞？" class="headerlink" title="什么情况下才算发生了网络拥塞？"></a>什么情况下才算发生了网络拥塞？</h1><p>发送方有TCP报文超时了没有收到ACK确认报文</p>
<h1 id="拥塞控制的过程是怎样的？"><a href="#拥塞控制的过程是怎样的？" class="headerlink" title="拥塞控制的过程是怎样的？"></a>拥塞控制的过程是怎样的？</h1><p>慢启动、拥塞避免、快重传、快恢复</p>
<p>拥塞窗口，拥塞窗口大小cwnd（congestion window）表示可以发送的报文字节数，单位是一个MSS（最大报文长度）</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>拥塞窗口初始大小为1，每收到一个ACK，拥塞窗口大小+1，实际效果就是每过一个RTT，拥塞窗口大小为原来的2倍，以指数增长率增长，先慢后快，达到慢开始门限ssthresh则停止慢开始，执行拥塞避免算法。</p>
<p>翻倍后如果大小超过阈值则窗口大小设为阈值。</p>
<p>例如：</p>
<p>初始窗口大小为1</p>
<p>发送第一个报文M0，收到ACK1后窗口大小+1，变为2</p>
<p>发送M1、M2，收到ACK2、ACK3后，窗口大小+2，变为4</p>
<p>再发送4个报文，收到4个ACK后，窗口大小+4，变为8</p>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>每过一个RTT（受到一个ACK），拥塞窗口大小+1</p>
<p>线性增长，避免增长过快</p>
<h2 id="发生拥塞"><a href="#发生拥塞" class="headerlink" title="发生拥塞"></a>发生拥塞</h2><p>发送方有报文超时，未收到ACK确认报文</p>
<p>无论是在慢开始阶段还是拥塞避免阶段，做出以下调整：</p>
<ol>
<li>把慢开始门限ssthresh设置为出现拥塞时发送方拥塞窗口大小的一半（不小于2）</li>
<li>拥塞窗口大小设为1，执行慢开始</li>
</ol>
<p>目的：</p>
<p>迅速减少发送方发送到网络的报文数，在发生拥塞时路由器有足够的时间把队列中挤压的报文发完</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825255523.jpeg"></p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，则不等待定时器结束就直接重传该序号的报文</p>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，慢开始门限设置为拥塞窗口大小的一半，拥塞窗口不设置为1，也设置为原窗口大小的一半，并执行拥塞避免算法，线性增大拥塞窗口。</p>
<p>因为跳过了拥塞窗口从1开始的慢开始过程，所以称为快恢复。</p>
<p>发送方窗口大小为  流量控制的滑动窗口和拥塞窗口  的较小值</p>
<h1 id="快速重传有什么问题？"><a href="#快速重传有什么问题？" class="headerlink" title="快速重传有什么问题？"></a>快速重传有什么问题？</h1><p>与基于定时器的超时重传拥有同样的问题，即：</p>
<p>不确定应该重发哪些序号的报文，如果只重发一个可能会拖慢整体传输时长，如果重发多个可能会浪费流量、增加整体传输时长，需要知道哪些序号的报文是丢失的，只重发丢失的报文。  </p>
<p>发送方收到同一个序号的多个ACK确认，发送方并不清楚这些ACK是由哪些序号的报文传输成功后ACK回来的，可能会重发接收方已经收到的报文，浪费流量。</p>
<h1 id="带选择确认的重传（SACK）解决了什么？"><a href="#带选择确认的重传（SACK）解决了什么？" class="headerlink" title="带选择确认的重传（SACK）解决了什么？"></a>带选择确认的重传（SACK）解决了什么？</h1><p>一端在发送ACK时通过在TCP报文头部增加SACK（Selective Acknowledgment）选项，告知对方已经收到的包序号区间范围，让对方只重传丢失的报文，并且可以一次性集中重传，避免了网络流量的浪费，也避免了长时间的超时等待。</p>
<p>SACK需要客户端和服务的都开启该功能</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP流量控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-12 19:31:00" itemprop="dateCreated datePublished" datetime="2018-03-12T19:31:00+08:00">2018-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:53:14" itemprop="dateModified" datetime="2021-08-28T21:53:14+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="网络/TCP流量控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么要有流量控制？"><a href="#为什么要有流量控制？" class="headerlink" title="为什么要有流量控制？"></a>为什么要有流量控制？</h1><p>双端通信的时候，发送方发送数据速度和接收方处理数据速度不一定相等；</p>
<p>如果发送过快，接收方处理不过来，接收方只能把数据存在缓冲区，缓冲区满了后再收到数据就只能丢弃；</p>
<p>所以需要控制发送方发送数据的速率，让接收方与发送方处于一种动态的平衡中才好。</p>
<p>对于发送方发送速率的控制，称为流量控制。</p>
<h1 id="滑动窗口大小是如何确定的？"><a href="#滑动窗口大小是如何确定的？" class="headerlink" title="滑动窗口大小是如何确定的？"></a>滑动窗口大小是如何确定的？</h1><p>发送数据的一方收到对方发送的ACK报文，其报文头中的窗口大小表示对方的缓冲区大小还能存放多少字节的数据，发送方拿这个窗口大小与本身的拥塞窗口大小在一起取最小值，作为自己滑动窗口的大小。</p>
<p>达到：</p>
<ol>
<li>避免对方缓冲区存不下发送过多的数据而丢弃，进而浪费网络带宽和流量</li>
<li>避免产生网络拥塞</li>
</ol>
<h1 id="滑动窗口中的内容"><a href="#滑动窗口中的内容" class="headerlink" title="滑动窗口中的内容"></a>滑动窗口中的内容</h1><p>滑动窗口内包含两类报文</p>
<ol>
<li>已发送但未收到确认</li>
<li> 允许发送但尚未发送</li>
</ol>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180835235523.jpeg"></p>
<h1 id="滑动窗口什么时候开始滑动？"><a href="#滑动窗口什么时候开始滑动？" class="headerlink" title="滑动窗口什么时候开始滑动？"></a>滑动窗口什么时候开始滑动？</h1><p>窗口左侧的报文收到了ACK报文确认，窗口就往右滑动</p>
<h1 id="如果发送端滑动窗口大小为0，不发送数据了会怎样？"><a href="#如果发送端滑动窗口大小为0，不发送数据了会怎样？" class="headerlink" title="如果发送端滑动窗口大小为0，不发送数据了会怎样？"></a>如果发送端滑动窗口大小为0，不发送数据了会怎样？</h1><p>实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅包含一个字节来获取最新的窗口大小信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">165</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">200</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
