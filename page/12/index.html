<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/12/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B4%A9%E6%BA%83%E6%94%B6%E9%9B%86SDK%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B4%A9%E6%BA%83%E6%94%B6%E9%9B%86SDK%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F/" class="post-title-link" itemprop="url">设计一个崩溃收集SDK应该考虑哪些因素？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-15 20:37:00" itemprop="dateCreated datePublished" datetime="2019-06-15T20:37:00+08:00">2019-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B4%A9%E6%BA%83%E6%94%B6%E9%9B%86SDK%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="源码分析/设计一个崩溃收集SDK应该考虑哪些因素？/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计一个崩溃收集SDK应该考虑哪些因素？"><a href="#设计一个崩溃收集SDK应该考虑哪些因素？" class="headerlink" title="设计一个崩溃收集SDK应该考虑哪些因素？"></a>设计一个崩溃收集SDK应该考虑哪些因素？</h1><h2 id="包体积"><a href="#包体积" class="headerlink" title="包体积"></a>包体积</h2><p>核心框架保持尽可能精简，不依赖任何第三方库，保证增大集成SDK的App的体积。</p>
<p>需要依赖第三方库的功能，尽量设计为可插拔，让用户可选自行决策。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>作为一个全局性SDK，首先保证对App主功能没有影响。</p>
<p>其中最主要的是SDK绝对不能自己崩溃，所以不放心可以在关键逻辑都try catch。</p>
<p>其次是对CPU占用、网络带宽占用、电量消耗等App性能指标的影响要最低，保证SDK性能最高。</p>
<p>由于崩溃收集的逻辑，主要是运行在崩溃发生之后，所以对App常规使用是没有太大影响的。</p>
<h2 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h2><p>崩溃是很严重的事情，所以要尽可能早的把错误发送到服务端，最好是崩溃后立即上传数据。</p>
<h3 id="崩溃后上传数据没有网络怎么办？"><a href="#崩溃后上传数据没有网络怎么办？" class="headerlink" title="崩溃后上传数据没有网络怎么办？"></a>崩溃后上传数据没有网络怎么办？</h3><p>需要把数据持久化，下次一启动App就上传，保证尽可能的早。</p>
<h3 id="进程崩溃被杀，无法完成网络请求怎么办？"><a href="#进程崩溃被杀，无法完成网络请求怎么办？" class="headerlink" title="进程崩溃被杀，无法完成网络请求怎么办？"></a>进程崩溃被杀，无法完成网络请求怎么办？</h3><p>单独开一个进程做网络上传。</p>
<p>所以数据需要能够跨进程访问，可以把数据先持久化。</p>
<h2 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h2><p>由于上传数据时可能没有网络，就需要暂存数据。</p>
<p>由于崩溃的发生大多数情况下并不会很频繁，应当用文件存储，上传时直接上传文件，这样客户端实现很简单，后端存储和解析也都比较简单。</p>
<p>数据库对于大批量的数据插入、查询有优化，不是大批量数据优势就发挥的不明显。<br>并且如果数据库损坏，所有信息都查询不了。单个文件损坏，不会影响其他文件。</p>
<h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><p>文件中数据格式可以使用JSON或者ProtocolBuffer等紧凑的数据格式，减少数据流量。</p>
<p>key-value形式的存储，key可以用单词的缩写，减少数据占用。</p>
<p>在Android里使用ProtocolBuffer需要引入第三方库，会增大SDK体积；<br>虽然ProtocolBuffer比JSON序列化后占用空间更小，但是数据量不大，优势就不明显。并且网络上传时可以用GZIP压缩，压缩率也比较可观。<br>所以考虑使用JSON。</p>
<h2 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h2><p>作为任何一个需要上报数据的SDK，都需要考虑隐私性，主要是不能泄露用户隐私，上传用户个人识别信息。</p>
<p>那么有哪些泄露用户隐私的可能呢？</p>
<p>如果是SDK外部传入的参数，SDK本身没法控制，只能由SDK外部去控制，比如：</p>
<ul>
<li>可以自定义lint检查规则，禁止调用SDK的API时传入特定方法的返回值。</li>
<li>把隐私信息字符串构建为字典树，在传入参数的时候做匹配，然后过滤掉敏感词。</li>
</ul>
<p>但这两种方式都不能100%完全禁止泄露隐私信息，比如用户年龄、身高体重都是纯数字，字典树匹配很容易误杀，所以可能得先统一外部的API调用，这样方便做严格的集中控制，这又涉及到外部项目的代码规范了，这也是SDK倒逼项目规范的很好的需求。</p>
<p>在SDK内部可能有：</p>
<h3 id="异常message"><a href="#异常message" class="headerlink" title="异常message"></a>异常message</h3><p>异常堆栈里的异常message是用户可以自己传的，能自定义就有可能传递用户个人信息，最保险的做法是把message直接移除掉，Google Play管理后台和Google Anlaytics就是这么干的。</p>
<p>但这样很多时候不方便判断异常到底表示什么意思。</p>
<p>如果是手动抛出的异常，可以自定义一个异常类，表示特定类型的错误，这样方便识别具体错误。</p>
<h3 id="用户id"><a href="#用户id" class="headerlink" title="用户id"></a>用户id</h3><p>SDK层面如果需要区分用户，可以使用随机生成的UUID并保存到文件作为安装id来代替用户id，这是谷歌官方推荐的做法。</p>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>作为SDK</p>
<ul>
<li>核心逻辑要少改动才能保证不易出错、方便追查错误。</li>
<li>功能逻辑保持模块化、可配置，这样最灵活，可以使用JDK内置的SPI机制实现配置注入，或者通过Builder模式传入模块的Class来配置。</li>
</ul>
<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><h3 id="网络请求框架的选择"><a href="#网络请求框架的选择" class="headerlink" title="网络请求框架的选择"></a>网络请求框架的选择</h3><h5 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h5><p>从Android 4.4开始，HttpURLConnection内部实现通过调用okhttp完成。</p>
<p>Android源码：<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/okhttp/+/master">https://android.googlesource.com/platform/external/okhttp/+/master</a>.</p>
<h5 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h5><ul>
<li>底层基于Socket重新实现了一遍。</li>
<li>支持http2。</li>
<li>自动处理常见的网络问题。</li>
<li>API使用方便。</li>
</ul>
<h5 id="微信Mars"><a href="#微信Mars" class="headerlink" title="微信Mars"></a>微信Mars</h5><p>C实现，Android、iOS公用。<br>基于socket的解决方案，在网络调优方面具有跟强的主动性和可控性：</p>
<ul>
<li>  提供长连、短连两种网络通道；</li>
<li>  常规的网络能力，例如 DNS 防劫持、动态 IP 下发、就近接入、容灾恢复等；</li>
<li>  贴合移动互联网的网络层解决方案；</li>
<li>  贴合移动终端的平台特性：前后台、活跃态、休眠、省电、省流量等。</li>
</ul>
<h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><p>对性能不是有很严格的要求，可以选择HttpURLConnection，Okhttp的优化它都有。</p>
<h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ul>
<li>gzip压缩</li>
<li>httpdns防劫持、降低访问延迟。</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>设计思路、关键点罗列清楚，代码注释清晰，方便其他人排查问题、接手、改进。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>要保证SDK能适配各种机型的情况，所以要统计各种异常数据情况，针对性遇到的每个问题解决优化。</p>
<p>可以在灰度测试收集错误信息进行修正。</p>
<p>验证问题后，针对每一个错误编写单元测试，每次发布前自动化测试，保证过往问题不再重复出错。</p>
<p>减少错误就提高了准确性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Gson%E5%9C%A8Kotlin%E4%B8%8B%E7%9A%84%E5%B4%A9%E6%BA%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Gson%E5%9C%A8Kotlin%E4%B8%8B%E7%9A%84%E5%B4%A9%E6%BA%83/" class="post-title-link" itemprop="url">Gson在Kotlin下的崩溃</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-12 20:13:00" itemprop="dateCreated datePublished" datetime="2019-03-12T20:13:00+08:00">2019-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Gson%E5%9C%A8Kotlin%E4%B8%8B%E7%9A%84%E5%B4%A9%E6%BA%83/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Gson在Kotlin下的崩溃/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Gson解析在Kotlin下有什么问题？"><a href="#Gson解析在Kotlin下有什么问题？" class="headerlink" title="Gson解析在Kotlin下有什么问题？"></a>Gson解析在Kotlin下有什么问题？</h1><p>忽略了data class的null safty检查和默认值。</p>
<h1 id="为什么Gson会忽略data-class的null-safty检查和默认值？"><a href="#为什么Gson会忽略data-class的null-safty检查和默认值？" class="headerlink" title="为什么Gson会忽略data class的null safty检查和默认值？"></a>为什么Gson会忽略data class的null safty检查和默认值？</h1><p>在Gson的ReflectiveTypeAdapterFactory中调用了ConstructorConstructor.get()。</p>
<p>在这里Gson 实例化对象分为四种情况：</p>
<ol>
<li> 使用我们自定义的 InstanceCreator，可以在初始化时加入它；</li>
<li> 使用默认构造器，也就是无参构造函数；</li>
<li> 如果是 Collection 或 Map，则返回对应的对象；</li>
<li> 使用 UnSafe。</li>
</ol>
<p>如果没有无参构造函数就用UnSafe去构造对象。</p>
<p>UnSafe去构造对象，会绕过构造函数，只会在堆中去分配一个对象实例。</p>
<p>如果仅对data class的部分字段设置了默认值，而不是所有字段设置默认，是不会生成无参构造函数的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>想办法提供一个无参构造函数。</p>
<ol>
<li> 构造函数中的所有变量都设置默认值</li>
<li> 手动写一个无参构造函数。</li>
<li> 字段声明在类的内部，就会自动无参构造函数了。</li>
</ol>
<p>改写data class不太合适，这样的方式不够自动化，无法做出客观的保证。</p>
<p>最好的方式是对Gson做改进，因为引入新的库可能所有序列化的地方都要改。</p>
<p>有哪些库解析data class没有问题？<br>moshi和kotlinx.serialization。</p>
<p>moshi的解决方案有两种：</p>
<ul>
<li>引入kotlin反射库，包体积会增大2.5MB。</li>
<li>编译时通过注解处理器为每个data class生成JsonAdapter去解析Json数据。</li>
</ul>
<p>kotlinx.serialization解决方案：</p>
<ul>
<li>通过在data class上添加注解，编译时通过注解处理器来处理。</li>
</ul>
<p>Gson可以解决这些问题吗？<br>可以把moshi的解决方案在gson里实现一下是比较适合的，改造需要动用不少代码。如果改动太大就是直接用moshi了。</p>
<p>Moshi 和 Kotlin.serialization 的对比：</p>
<p>两者对 Kotlin 的支持差异不大。</p>
<ol>
<li> KS 的优势是支持 Kotlin 的 Multiplatform，对于需要多平台移植的 Kotlin 代码，使用 KS 更合适，但不兼容Java。</li>
<li> Moshi 的优势是兼容 Java 。</li>
</ol>
<p>所以如果是 Kotlin 与 Java 混编，考虑使用 Moshi。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903704278073357">新一代Json解析库Moshi使用及原理解析（性能對比，源码解析）</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%20%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%20%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">Kotlin 泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 20:23:00" itemprop="dateCreated datePublished" datetime="2018-12-06T20:23:00+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%20%E6%B3%9B%E5%9E%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin 泛型/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reified解决的是什么问题"><a href="#reified解决的是什么问题" class="headerlink" title="reified解决的是什么问题?"></a>reified解决的是什么问题?</h1><p>泛型会在编译后类型擦除，在运行时无法获得泛型类型T的类型信息。</p>
<p>想要在运行时获取泛型类型信息，需要使用reified和inline配合。</p>
<p>Kotlin编译器会将reified方法内联(inline)到调用的地方(call-site)。</p>
<p>方法被内联到调用的地方后，泛型T会被替换成具体的类型。</p>
<p>所以 reified 使得泛型的方法假装在运行时能够获取泛型的类信息。</p>
<p>这样不用为了获取泛型的类型再单独给方法传一个Class参数。</p>
<h1 id="协变是什么意思？"><a href="#协变是什么意思？" class="headerlink" title="协变是什么意思？"></a>协变是什么意思？</h1><p>带 extends 限定（上界）的通配符类型使得类型是协变的（covariant）。</p>
<h1 id="逆变是什么意思？"><a href="#逆变是什么意思？" class="headerlink" title="逆变是什么意思？"></a>逆变是什么意思？</h1><p>super限定的下界通配符使得类型是逆变的（contravariance）。</p>
<p>在 Java 中有 <code>List&lt;? super String&gt;</code> 是 <code>List&lt;Object&gt;</code>、<code>List&lt;String&gt;</code> 的一个超类。</p>
<h1 id="in和out关键字是做什么的？"><a href="#in和out关键字是做什么的？" class="headerlink" title="in和out关键字是做什么的？"></a>in和out关键字是做什么的？</h1><p>使用关键字 out 来支持协变，等同于 Java 中的上界通配符 ? extends。</p>
<p>使用关键字 in 来支持逆变，等同于 Java 中的下界通配符 ? super。</p>
<p>上界通配符用于读取，是产出东西给外面用，所以是out。</p>
<p>下界通配符用于修改，是生产东西存到容器里，所以是in。</p>
<p>消费者 in, 生产者 out。</p>
<h1 id="kotlin泛型中的where有什么作用？"><a href="#kotlin泛型中的where有什么作用？" class="headerlink" title="kotlin泛型中的where有什么作用？"></a>kotlin泛型中的where有什么作用？</h1><p>Java 中声明类或接口的时候，可以使用 extends 来设置边界，将泛型类型参数限制为某个类型的子集：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T的类型必须是 Animal 的子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="type">T extends Animal</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个和前面讲的声明变量时的泛型类型声明是不同的东西，这里并没有 ?。<br>同时这个边界是可以设置多个，用 &amp; 符号连接：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 的类型必须同时是 Animal 和 Food 的子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="type">T extends Animal &amp; Food</span>&gt;</span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin 只是把 extends 换成了 : 冒号。<br><code>class Monster&lt;T : Animal&gt;</code><br>设置多个边界可以使用 where 关键字：<br><code>class Monster&lt;T&gt; where T : Animal, T : Food</code><br>有人在看文档的时候觉得这个 where 是个新东西，其实虽然 Java 里没有 where ，但它并没有带来新功能，只是把一个老功能换了个新写法。</p>
<p>不过笔者觉得 Kotlin 里 where 这样的写法可读性更符合英文里的语法，尤其是如果 Monster 本身还有继承的时候：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="type">T</span>&gt; : <span class="type">MonsterParent</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">    <span class="keyword">where</span> T : Animal</span><br></pre></td></tr></table></figure>

<h1 id="实现一个-fill-函数，传入一个-Array-和一个对象，将对象填充到-Array-中，要求-Array-参数的泛型支持逆变（假设-Array-size-为-1）"><a href="#实现一个-fill-函数，传入一个-Array-和一个对象，将对象填充到-Array-中，要求-Array-参数的泛型支持逆变（假设-Array-size-为-1）" class="headerlink" title="实现一个 fill 函数，传入一个 Array 和一个对象，将对象填充到 Array 中，要求 Array 参数的泛型支持逆变（假设 Array size 为 1）"></a>实现一个 fill 函数，传入一个 Array 和一个对象，将对象填充到 Array 中，要求 Array 参数的泛型支持逆变（假设 Array size 为 1）</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">fill</span><span class="params">(to: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, from: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    to[<span class="number">0</span>] = from</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现一个-copy-函数，传入两个-Array-参数，将一个-Array-中的元素复制到另外个-Array-中，要求-Array-参数的泛型分别支持协变和逆变。"><a href="#实现一个-copy-函数，传入两个-Array-参数，将一个-Array-中的元素复制到另外个-Array-中，要求-Array-参数的泛型分别支持协变和逆变。" class="headerlink" title="实现一个 copy 函数，传入两个 Array 参数，将一个 Array 中的元素复制到另外个 Array 中，要求 Array 参数的泛型分别支持协变和逆变。"></a>实现一个 copy 函数，传入两个 Array 参数，将一个 Array 中的元素复制到另外个 Array 中，要求 Array 参数的泛型分别支持协变和逆变。</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    assert(from.size == to.size)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> from.indices) &#123;</span><br><span class="line">        to[i] = from[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%E5%86%85%E8%81%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%E5%86%85%E8%81%94/" class="post-title-link" itemprop="url">Kotlin 内联</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 21:15:00" itemprop="dateCreated datePublished" datetime="2018-12-05T21:15:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%E5%86%85%E8%81%94/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin内联/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="inline、noinline、crossline区别？"><a href="#inline、noinline、crossline区别？" class="headerlink" title="inline、noinline、crossline区别？"></a>inline、noinline、crossline区别？</h1><p>inline：编译时把inline函数的代码拷贝到调用处</p>
<p>noinline：修饰inline标记的函数的形参，不希望内联lambda</p>
<p>crossline：inline函数中的lambda表达式不允许返回到外部函数，只能返回到lambda表达式</p>
<h1 id="inline作用"><a href="#inline作用" class="headerlink" title="inline作用"></a>inline作用</h1><p>Java中没有函数的概念，Kotlin中的lambda表达式在Java中对应的是一个FunctionN的单个方法的接口类，创建一个lambda表达式相当于创建一个类。</p>
<p>inline可以修饰函数，inline修饰的函数的形参中有lambda表达式，编译时不会创建对应的FunctionN类，而是直接把lambda表达式代码拷贝到调用处，这样</p>
<ol>
<li> 在循环等高频使用一个函数的场景下，内联lambda表达式避免了频繁创建对象，不仅节约了内存，也避免了频繁的垃圾回收，减少系统卡顿</li>
<li> 减少了函数调用层级，函数调用栈少了一层，减少了性能损耗</li>
</ol>
<h1 id="inline会造成什么问题？"><a href="#inline会造成什么问题？" class="headerlink" title="inline会造成什么问题？"></a>inline会造成什么问题？</h1><ol>
<li> 调用处的代码变多，所以不能内联代码量过大的函数，只适用于内联代码量小的函数</li>
<li> 我们可以在inline函数形参的 lambda 表达式 中调用return直接返回外部函数，可能会导致inline函数之后的代码无法执行；需要使用return@label的语法，返回到lambda开始执行的位置</li>
<li> 内联后的lambda表达式已经不是对象了，所以无法作为参数传递、存储在字段中、作为返回值return，需要加noinline解决</li>
</ol>
<h1 id="noinline作用"><a href="#noinline作用" class="headerlink" title="noinline作用"></a>noinline作用</h1><p>修饰inline函数的形参中的lambda表达式，表示禁止该lambda表达式内联</p>
<h1 id="noinline禁止lambda表达式内联的意义是什么？"><a href="#noinline禁止lambda表达式内联的意义是什么？" class="headerlink" title="noinline禁止lambda表达式内联的意义是什么？"></a>noinline禁止lambda表达式内联的意义是什么？</h1><p>内联后的lambda表达式已经不是对象了，所以无法作为对象使用，也就是无法对其进行参数传递、存储在字段中、作为返回值return，需要加noinline解决</p>
<h1 id="crossinline作用"><a href="#crossinline作用" class="headerlink" title="crossinline作用"></a>crossinline作用</h1><p>既想让内联函数形参中的 lambda 也被 inline，但是又不想让 lambda 对调用方的控制流程产生影响（lambda中return会影响），就用crossline</p>
<p>crossinline依然是内联的</p>
<p>直接在lambda表达式中返回外部函数的情况称为非局部返回。</p>
<p>crossinline修饰的lambda禁止了非局部返回</p>
<h1 id="crossinline为什么要禁止非局部返回？不禁止会有什么问题？"><a href="#crossinline为什么要禁止非局部返回？不禁止会有什么问题？" class="headerlink" title="crossinline为什么要禁止非局部返回？不禁止会有什么问题？"></a>crossinline为什么要禁止非局部返回？不禁止会有什么问题？</h1><p>内联函数形参中的lambda表达式可能会在另外一个调用栈中执行，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(<span class="keyword">crossinline</span> body: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f = <span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = body()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下内联的lambda允许非局部返回，返回的是内联函数调用处的函数，但是不在一个调用栈中，非局部返回就无法做到这样的返回，所以必须禁止，用crossinline来禁止非局部返回，但仍然保持内联的特性，把lambda表达式的代码展开铺平。</p>
<h1 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h1><ul>
<li>内联函数，可以消除函数调用的开销。</li>
<li>内联类，则是可以消除创建对象的开销。</li>
</ul>
<p>用途：</p>
<ul>
<li>严格的类型别名</li>
<li>任何你想得到的包装类（wrapper）</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://aisia.moe/2018/07/03/inline-class/">Kotlin 1.3 前瞻之 Inline Class</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%E7%A9%BA%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%E7%A9%BA%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">Kotlin 空安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-03 20:13:00" itemprop="dateCreated datePublished" datetime="2018-12-03T20:13:00+08:00">2018-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%E7%A9%BA%E5%AE%89%E5%85%A8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin空安全/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kotlin调Java可能返回为空的函数"><a href="#Kotlin调Java可能返回为空的函数" class="headerlink" title="Kotlin调Java可能返回为空的函数"></a>Kotlin调Java可能返回为空的函数</h1><p>Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。</p>
<p>当把一个平台值赋值给一个 Kotlin 变量时，可以选择我们期望的类型（可空或非空类型）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nullable: String? = item <span class="comment">// 允许，没有问题</span></span><br><span class="line"><span class="keyword">val</span> notNull: String = item <span class="comment">// 允许，运行时可能失败</span></span><br></pre></td></tr></table></figure>
<p>如果我们选择非空类型，编译器会在赋值时触发一个断言。这防止 Kotlin 的非空变量保存空值。当我们把平台值传递给期待非空值等的 Kotlin 函数时，也会触发断言。 总的来说，编译器尽力阻止空值通过程序向远传播（尽管鉴于泛型的原因，有时这不可能完全消除）。</p>
<p>如果我们选择非空类型，编译器会在赋值时触发一个断言。这防止 Kotlin 的非空变量保存空值。当我们把平台值传递给期待非空值等的 Kotlin 函数时，也会触发断言。 总的来说，编译器尽力阻止空值通过程序向远传播。</p>
<p>只有在Java层给方法加上<code>@Nullable</code>之后才会提示返回值可空。</p>
<h1 id="空安全实际遇到的问题"><a href="#空安全实际遇到的问题" class="headerlink" title="空安全实际遇到的问题"></a>空安全实际遇到的问题</h1><p>一开始有一个Java的旧类，一直没有改动过，但是有需求要有不同的实现，所以需要把类的各个方法抽象为接口，接口类用Kotlin实现，接口的实现类还是原来的Java类，其中有个方法在Kotlin的接口中返回值是非空的String，java实现类中返回值是String，但是没有加@NotNull的注解，也就是可空的。</p>
<p>在实际调用这个方法的时候，当java实现类中返回null，就会报空指针异常。</p>
<h1 id="Nullable注解应该是哪个库哪个包的注解？"><a href="#Nullable注解应该是哪个库哪个包的注解？" class="headerlink" title="Nullable注解应该是哪个库哪个包的注解？"></a>Nullable注解应该是哪个库哪个包的注解？</h1><p>具有可空性注解的Java类型并不表示为平台类型，而是表示为实际可空或非空的 Kotlin 类型。编译器支持多种可空性注解，包括：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html">JetBrains</a> （org.jetbrains.annotations 包中的 @Nullable 和 @NotNull）</p>
</li>
<li><p>  Android（com.android.annotations 和 android.support.annotations)</p>
</li>
<li><p>  JSR-305（javax.annotation，详见下文）</p>
</li>
<li><p>  FindBugs（edu.umd.cs.findbugs.annotations）</p>
</li>
<li><p>  Eclipse（org.eclipse.jdt.annotation）</p>
</li>
<li><p>  Lombok（lombok.NonNull）。</p>
</li>
</ul>
<p>你可以在 <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt">Kotlin 编译器源代码</a>中找到完整的列表。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/java-interop.html#%E7%A9%BA%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B">Kotlin官方文档：空安全和平台类型</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Kotlin/Kotlin%E4%B8%BA%E4%BD%95%E5%BA%9F%E5%BC%83checked%E5%BC%82%E5%B8%B8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Kotlin/Kotlin%E4%B8%BA%E4%BD%95%E5%BA%9F%E5%BC%83checked%E5%BC%82%E5%B8%B8%EF%BC%9F/" class="post-title-link" itemprop="url">Kotlin为何废弃checked异常？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-02 20:13:00" itemprop="dateCreated datePublished" datetime="2018-12-02T20:13:00+08:00">2018-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Kotlin/Kotlin%E4%B8%BA%E4%BD%95%E5%BA%9F%E5%BC%83checked%E5%BC%82%E5%B8%B8%EF%BC%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kotlin/Kotlin为何废弃checked异常？/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？"><a href="#kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？" class="headerlink" title="kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？"></a>kotlin为何放弃了check和uncheck异常的分别？不强制要求代码捕获异常？</h1><p>Kotlin 在官网给出了一些解释，大概的意思是Checked Exception 在项目小的时候确实能够提升效率和代码质量，但是在大型项目中却会降低代码质量。</p>
<p>关于CE，Anders Hejlsberg认为它带来了两个问题版本问题和扩展问题。</p>
<h2 id="所谓的版本问题是什么意思呢？"><a href="#所谓的版本问题是什么意思呢？" class="headerlink" title="所谓的版本问题是什么意思呢？"></a>所谓的版本问题是什么意思呢？</h2><p>Anders Hejlsberg举了一个例子：</p>
<p>假设有一个方法foo，它声明了抛出异常A、B和C，在下一个版本设计的时候，foo增加了一个新的特性，可能会抛出异常D。对于设计者来说，很明显这是一个大的改变，几乎可以确定的是，客户程序员不会去处理这个异常。为了避免出现问题，设计者不得不声明一个新的方法foo2，抛出一个新的异常。然后，客户程序员可以将针对foo的逻辑处理切换到foo2。</p>
<h2 id="所谓的扩展问题又是什么意思呢？"><a href="#所谓的扩展问题又是什么意思呢？" class="headerlink" title="所谓的扩展问题又是什么意思呢？"></a>所谓的扩展问题又是什么意思呢？</h2><p>以下来自Anders Hejlsberg的原话翻译并整理：</p>
<p>如果你在设计一个很小的系统，声明一个方法抛出一个异常，这很棒。可是，如果你尝试构建一个大的系统，其中包含了四、五个小系统的时候，问题来了。假设每个子系统可能抛出四到五个异常，而每上升一个系统，就犹如爬阶梯，异常数量会指数倍增加，最终你可能处理的异常将达到40个甚至80个。很显然，这是一个很糟糕的设计！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上，异常其实是发生在实现阶段，而不是定义阶段，既要在明确实现阶段的异常又要有灵活的实现是相悖的。</p>
<p>所以 Kotlin 选择抛弃 Checked Exception，靠工程师来处理，这的确增加了 Kotlin 编写的难度，但也对大型项目更加友好，并且可以增加开发速度。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/exceptions.html">https://www.kotlincn.net/docs/reference/exceptions.html</a></li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/exceptions.html">https://kotlinlang.org/docs/reference/exceptions.html</a></li>
<li><a target="_blank" rel="noopener" href="http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">Java’s checked exceptions were a mistake</a> (Rod Waldhoff)</li>
<li><a target="_blank" rel="noopener" href="http://www.artima.com/intv/handcuffs.html">The Trouble with Checked Exceptions</a> (Anders Hejlsberg)</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/58639126/whats-the-idea-behind-kotlin-removing-checked-exceptions">What’s the idea behind Kotlin removing checked exceptions?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%E4%B9%8BContext%E3%80%81ContextImp%E3%80%81ContextWrapper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%E4%B9%8BContext%E3%80%81ContextImp%E3%80%81ContextWrapper/" class="post-title-link" itemprop="url">Android之Context、ContextImp、ContextWrapper</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-05 22:21:00" itemprop="dateCreated datePublished" datetime="2018-08-05T22:21:00+08:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%E4%B9%8BContext%E3%80%81ContextImp%E3%80%81ContextWrapper/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android之Context、ContextImp、ContextWrapper/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Context、ContextImpl、ContextWrapper关系？"><a href="#Context、ContextImpl、ContextWrapper关系？" class="headerlink" title="Context、ContextImpl、ContextWrapper关系？"></a>Context、ContextImpl、ContextWrapper关系？</h1><ul>
<li>Context是行为的抽象接口。</li>
<li>ContextImpl是Android平台上的具体实现。</li>
<li>ContextWrapper是装饰器可以修改Context的行为而不修改原始的Context对象。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Android/Android%E4%B9%8BContext%E3%80%81ContextImp%E3%80%81ContextWrapper/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android Activity启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-23 21:13:00" itemprop="dateCreated datePublished" datetime="2018-07-23T21:13:00+08:00">2018-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android Activity启动流程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Activity的启动流程是怎样的？"><a href="#Activity的启动流程是怎样的？" class="headerlink" title="Activity的启动流程是怎样的？"></a>Activity的启动流程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828194324.png"></p>
<h1 id="为什么Activity生命周期函数是运行在UI线程的"><a href="#为什么Activity生命周期函数是运行在UI线程的" class="headerlink" title="为什么Activity生命周期函数是运行在UI线程的?"></a>为什么Activity生命周期函数是运行在UI线程的?</h1><p>因为ActivityManagerService通过Binder通信给App进程的IApplicationThread这个Binder对象发送Activity生命周期的事件，而IApplicationThread是执行在Binder线程池中的，Activity生命周期函数需要执行在主线程，所以需要通过App进程的Handler转发一下，以执行在App进程的主线程。</p>
<h1 id="ApplicationThread的作用是什么？"><a href="#ApplicationThread的作用是什么？" class="headerlink" title="ApplicationThread的作用是什么？"></a>ApplicationThread的作用是什么？</h1><p>ApplicationThread是ActivityThread的内部类，继承ApplicationThreadNative,也是一个Binder对象。在此处它是作为IApplicationThread对象的server端等待client端的请求然后进行处理，最大的client就是AMS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    schedulePauseActivity()</span><br><span class="line">    scheduleStopActivity()</span><br><span class="line">    scheduleResumeActivity()</span><br><span class="line">    scheduleSendResult()</span><br><span class="line">    scheduleLaunchActivity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来它继承了ApplicationThreadNative的,并且它内部有非常多的scheduleXXX的方法，这些 schedulexxx的方法会进一步的通过往外发送消息给ActivityThread的mH这个消息队列来做处理。</p>
<h1 id="两个Activity相互跳转的生命周期？"><a href="#两个Activity相互跳转的生命周期？" class="headerlink" title="两个Activity相互跳转的生命周期？"></a>两个Activity相互跳转的生命周期？</h1><p>A Activity跳转到B Activity</p>
<p>A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop()</p>
<p>B Activity返回到A Activity</p>
<p>B.onPause() -&gt; A.onStart() -&gt; A.onResume() -&gt; B.onStop() -&gt; B.onDestroy()</p>
<p>一言以蔽之：</p>
<ol>
<li> 旧页面的onPause调用过后，才会调用新页面的onCreate</li>
<li> 要进入的页面的onResume调用后，才会调用之前页面的onStop</li>
</ol>
<h1 id="什么情况下Activity会重建？"><a href="#什么情况下Activity会重建？" class="headerlink" title="什么情况下Activity会重建？"></a>什么情况下Activity会重建？</h1><p>用户期望 Activity 的界面状态在整个配置变更（例如旋转或切换到多窗口模式）期间保持不变。但是，默认情况下，系统会在发生此类配置更改时销毁 Activity，从而清除存储在 Activity 实例中的任何界面状态。同样，如果用户暂时从您的应用切换到其他应用，并在稍后返回您的应用，他们也希望界面状态保持不变。但是，当用户离开应用且您的 Activity 停止时，系统可能会销毁该应用的进程。</p>
<h1 id="Activity重建的时候怎么保存和恢复参数？"><a href="#Activity重建的时候怎么保存和恢复参数？" class="headerlink" title="Activity重建的时候怎么保存和恢复参数？"></a>Activity重建的时候怎么保存和恢复参数？</h1><ol>
<li> onSaveInstance、onRestoreInstance方法，把对象序列化传递到Bundle对象中</li>
<li> 单例存储。</li>
<li> 数据持久化，重建后再读取。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20Zygote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20Zygote/" class="post-title-link" itemprop="url">Android Zygote</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-22 22:12:00" itemprop="dateCreated datePublished" datetime="2018-07-22T22:12:00+08:00">2018-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20Zygote/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android Zygote/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？"><a href="#为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？" class="headerlink" title="为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？"></a>为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？</h1><p>Zygote 作为一个孵化器，可以提前加载一些资源，这样 fork() 时基于 Copy-On-Write 机制创建的其他进程就能直接使用这些资源，而不用重新加载。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Android/Android%20Zygote/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android App启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-21 22:12:00" itemprop="dateCreated datePublished" datetime="2018-07-21T22:12:00+08:00">2018-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-14 22:11:34" itemprop="dateModified" datetime="2021-09-14T22:11:34+08:00">2021-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android App启动流程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Android系统启动流程是怎样的？"><a href="#Android系统启动流程是怎样的？" class="headerlink" title="Android系统启动流程是怎样的？"></a>Android系统启动流程是怎样的？</h1><p>当按电源键触发开机，首先会从 ROM 中预定义的地方加载引导程序 BootLoader 到 RAM 中，并执行 BootLoader 程序启动 Linux Kernel， 然后启动用户级别的第一个进程： init 进程。</p>
<p>init 进程会解析 init.rc 脚本做一些初始化工作，包括挂载文件系统、创建工作目录以及启动系统服务进程等，其中系统服务进程包括 Zygote、service manager、media 等。</p>
<p>在 Zygote 中会进一步去启动 system_server 进程，然后在 system_server 进程中会启动 AMS、WMS、PMS 等服务，等这些服务启动之后，AMS 中就会打开 Launcher 应用的 home Activity，最终就看到了手机的 “桌面”。</p>
<p>init.rc中引入了Zygote的启动脚本，Zygote的启动脚本存放在system/core/rootdir目录中，zygote的启动脚本其实也就是用app_process来启动一个java程序。</p>
<h1 id="SystemServer什么时候被启动？"><a href="#SystemServer什么时候被启动？" class="headerlink" title="SystemServer什么时候被启动？"></a>SystemServer什么时候被启动？</h1><p>android 29源码启动SystemServer流程：</p>
<p>init进程解析init.rc脚本</p>
<p>init.rc脚本中有执行app_process程序的代码。</p>
<p>service zygote /system/bin/app_process32 -Xzygote /system/bin –zygote –start-system-server –socket-name=zygote</p>
<p>app_process是启动java程序用的，没有指定要运行的类名，还是会走app_process的main方法，源码如下：</p>
<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp">https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp</a></p>
<p>main方法中识别到–zygote参数会执行com.android.internal.os.ZygoteInit的Java类的main方法。</p>
<p>识别到–start-system-server的参数，会执行forkSystemServer方法启动系统服务进程。</p>
<p>得到系统服务进程的pid后，执行ZygoteInit的handleSystemServerProcess() -&gt;ZygoteInit.zygoteInit() -&gt; RuntimeInit.applicationInit() -&gt; findStaticMain()，最后得到MethodAndArgsCaller，是一个Runnable，返回给ZygoteInit的main()中调用forkSystemServer()的地方执行run()。</p>
<p>MethodAndArgsCaller的run()里通过反射按照给定参数执行给定的方法，方法是main，是哪个类的main方法？类名是在ZygoteInit的forkSystemServer()指定的，类名是com.android.server.SystemServer。</p>
<h1 id="Launcher中点击App图标后，App启动流程是怎样的？"><a href="#Launcher中点击App图标后，App启动流程是怎样的？" class="headerlink" title="Launcher中点击App图标后，App启动流程是怎样的？"></a>Launcher中点击App图标后，App启动流程是怎样的？</h1><p>以下时序图基于Android 9.0源码。</p>
<h2 id="Launcher向AMS发起startActivity请求"><a href="#Launcher向AMS发起startActivity请求" class="headerlink" title="Launcher向AMS发起startActivity请求"></a>Launcher向AMS发起startActivity请求</h2><p>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程的ActivityManagerService发起startActivity请求。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192213.png"></p>
<h2 id="zygote进程创建App进程"><a href="#zygote进程创建App进程" class="headerlink" title="zygote进程创建App进程"></a>zygote进程创建App进程</h2><p>system_server进程的AMS接收到请求后，向zygote进程发送创建进程的请求</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192228.png"></p>
<h2 id="Zygote进程fork出新的子进程"><a href="#Zygote进程fork出新的子进程" class="headerlink" title="Zygote进程fork出新的子进程"></a>Zygote进程fork出新的子进程</h2><p>即App进程。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192241.png"></p>
<h2 id="App进程运行ActivityThread-main"><a href="#App进程运行ActivityThread-main" class="headerlink" title="App进程运行ActivityThread.main()"></a>App进程运行ActivityThread.main()</h2><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192256.png"></p>
<h2 id="App进程跨进程绑定ApplicationThread给系统进程的AMS"><a href="#App进程跨进程绑定ApplicationThread给系统进程的AMS" class="headerlink" title="App进程跨进程绑定ApplicationThread给系统进程的AMS"></a>App进程跨进程绑定ApplicationThread给系统进程的AMS</h2><p>AMS做好准备工作后，让App进程创建Application实例，并调用Application的onCreate()。</p>
<p><strong>为什么要绑定ApplicationThread给AMS？</strong></p>
<p>ActivityThread.attach()里调用IActivityManager.attachApplication()会把当前ActivityThread实例里的ApplicationThread实例对象传递给AMS，AMS把App进程的ApplicationThread存在ProcessRecord的thread属性中</p>
<p><strong>ApplicationThread是什么？</strong></p>
<p>ApplicationThread是一个IBinder对象，是给system_server进程中的AMS要发送数据给App进程时用的，这属于跨进程通信。</p>
<p>AMS保存了App进程的ApplicationThread后，经过一系列准备，最终调用App进程ActivityThread的handleBindApplication()，这里会调用mInstrumentation.callApplicationOnCreate()</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192310.png"></p>
<h2 id="AMS发送启动Activity的请求"><a href="#AMS发送启动Activity的请求" class="headerlink" title="AMS发送启动Activity的请求"></a>AMS发送启动Activity的请求</h2><p>在ActivityManagerService的attachApplication方法中调用了attachApplicationLocked进行绑定，从上面代码可以发现attachApplicationLocked中有两个重要的方法：thread.bindApplication和mStackSupervisor.attachApplicationLocked(app)。thread.bindApplication中的thread其实就是ActivityThread里ApplicationThread对象在AMS的代理对象，故此方法将最终调用ApplicationThread的bindApplication方法。而mStackSupervisor.attachApplicationLocked(app)主要是AMS启动Activity的作用。</p>
<p>在realStartActivityLocked方法中，创建了ClientTransaction对象并将App进程的ApplicationThread传递进去，接着为ClientTransaction对象添加LaunchActivityItem的callback，最终调用ClientLifecycleManager.scheduleTransaction()启动activity。</p>
<p>ClientLifecycleManager.scheduleTransaction()内部调用了App进程的ApplicationThread的scheduleTransaction(ClientTransaction)，该方法实际调用了ActivityThread的scheduleTransaction(ClientTransaction)</p>
<p>ClientTransactionHandler是ActivityThread的父类，所以下面时序图的ClientTransactionHandler代表ActivityThread，H是ActivityThread内部的Handler</p>
<p>ActivityThread的scheduleTransaction(ClientTransaction)向ActivityThread的Handler发送EXECUTE_TRANSACTION的消息，处理Activity的启动。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192520.png"></p>
<h2 id="ActivityThread的Handler处理启动Activity的请求"><a href="#ActivityThread的Handler处理启动Activity的请求" class="headerlink" title="ActivityThread的Handler处理启动Activity的请求"></a>ActivityThread的Handler处理启动Activity的请求</h2><p>ActivityThread的Handler对EXECUTE_TRANSACTION的消息处理主要是执行TransactionExecutor.execute(ClientTransaction)</p>
<p>TransactionExecutor.execute(ClientTransaction)主要是执行</p>
<p>executeCallbacks(transaction)</p>
<p>executeLifecycleState(transaction)</p>
<p>executeCallbacks()中会取出ClientTransaction的callbacks，对callbacks列表的每一项item执行execute()，callbacks每一项的类型为ClientTransactionItem</p>
<p><strong>ClientTransaction的callbacks在哪添加的？</strong></p>
<p>AMS的ActivityStackSupervisor的realStartActivityLocked()中添加的LaunchActivityItem。</p>
<p>LaunchActivityItem的execute()中会调用ActivityThread的。handleLaunchActivity()，然后调用performLaunchActivity()，在这里通过Instrumentation.newActivity()创建Activity实例，然后调用Activity的onCreate()。</p>
<p><strong>executeLifecycleState()做了什么？</strong></p>
<p>获取ClientTransaction的getLifecycleStateRequest()，做Activity生命周期的回调。</p>
<p>Activity的onStart()、onResume()是在这里触发的。</p>
<p>具体看源码。</p>
<p><strong>ClientTransaction的mLifecycleStateRequest是在哪设置的？</strong></p>
<p>AMS的ActivityStackSupervisor的realStartActivityLocked()中创建了ResumeActivityItem，通过clientTransaction.setLifecycleStateRequest(lifecycleItem)设置添加。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">264</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
