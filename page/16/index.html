<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Follow your heart">
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky.L的随笔">
<meta property="og:url" content="http://rickyqliu.github.io/page/16/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="Follow your heart">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rickyqliu.github.io/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/" class="post-title-link" itemprop="url">Java并发-CAS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-13 20:00:00" itemprop="dateCreated datePublished" datetime="2017-10-13T20:00:00+08:00">2017-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="并发/Java并发-CAS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源</p>
<p>所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁更新方式认为：在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。</p>
<p>但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。</p>
<p>CAS机制就是乐观锁的典型实现。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p>
<ul>
<li>  主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li>
<li>  工作内存中共享变量的副本值，也叫预期值：A</li>
<li>  需要将共享变量更新到的最新值：B</li>
</ul>
<h1 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h1><ol>
<li> 可以保证变量操作的原子性；</li>
<li> 并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li>
<li> 在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li>
</ol>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p>
<h2 id="可能会消耗较高的CPU"><a href="#可能会消耗较高的CPU" class="headerlink" title="可能会消耗较高的CPU"></a>可能会消耗较高的CPU</h2><p>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
<h2 id="不能保证代码块的原子性"><a href="#不能保证代码块的原子性" class="headerlink" title="不能保证代码块的原子性"></a>不能保证代码块的原子性</h2><p>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Android 动画原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-13 19:55:00" itemprop="dateCreated datePublished" datetime="2017-07-13T19:55:00+08:00">2017-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android 动画机制原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="View-Animation原理"><a href="#View-Animation原理" class="headerlink" title="View Animation原理"></a>View Animation原理</h1><ol>
<li> 首先，当调用了 View.startAnimation() 时动画并没有马上就执行，而是通过 invalidate() 层层通知到 ViewRootImpl 发起一次遍历 View 树的请求，而这次请求会等到接收到最近一帧到了的信号时才去发起遍历 View 树绘制操作。</li>
<li> 从 DecorView 开始遍历，绘制流程在遍历时会调用到 View 的 draw() 方法，当该方法被调用时，如果 View 有绑定动画，那么会去调用applyLegacyAnimation()，这个方法是专门用来处理动画相关逻辑的。</li>
<li> 在 applyLegacyAnimation() 这个方法里，如果动画还没有执行过初始化，先调用动画的初始化方法 initialized()，同时调用 onAnimationStart() 通知动画开始了，然后调用 getTransformation() 来根据当前时间计算动画进度，紧接着调用 applyTransformation() 并传入动画进度来应用动画。</li>
<li> getTransformation() 这个方法有返回值，如果动画还没结束会返回 true，动画已经结束或者被取消了返回 false。所以 applyLegacyAnimation() 会根据 getTransformation() 的返回值来决定是否通知 ViewRootImpl 再发起一次遍历请求，返回值是 true 表示动画没结束，那么就去通知 ViewRootImpl 再次发起一次遍历请求。然后当下一帧到来时，再从 DecorView 开始遍历 View 树绘制，重复上面的步骤，这样直到动画结束。</li>
<li> 有一点需要注意，动画是在每一帧的绘制流程里被执行，所以动画并不是单独执行的，也就是说，如果这一帧里有一些 View 需要重绘，那么这些工作同样是在这一帧里的这次遍历 View 树的过程中完成的。每一帧只会发起一次 perfromTraversals() 操作。</li>
</ol>
<p>View Animation 是在绘制的时候，改变 view 的视觉效果来实现动画的。所以不会对 view 的测量和布局过程有影响。</p>
<p>View 的动画是通过触发绘制过程来执行 draw 的。因为动画是连续的，所以需要不停的触发。</p>
<h1 id="View-Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？"><a href="#View-Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？" class="headerlink" title="View Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？"></a>View Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？</h1><p>因为动画是在 draw 时候形成的，也就是说只是视觉效果。其并没有改变它本身在父类中的位置；</p>
<h1 id="View-Animation中如果对-View-做放大缩小得动画，那么其宽度高度值是否会变化？"><a href="#View-Animation中如果对-View-做放大缩小得动画，那么其宽度高度值是否会变化？" class="headerlink" title="View Animation中如果对 View 做放大缩小得动画，那么其宽度高度值是否会变化？"></a>View Animation中如果对 View 做放大缩小得动画，那么其宽度高度值是否会变化？</h1><p>View Animation 是在绘制的时候，改变 view 的视觉效果来实现动画的。所以不会对 view 的测量和布局过程有影响。</p>
<h1 id="属性动画的原理"><a href="#属性动画的原理" class="headerlink" title="属性动画的原理"></a>属性动画的原理</h1><ol>
<li> ValueAnimator 属性动画调用了 start() 之后，会先去进行一些初始化工作，包括变量的初始化、通知动画开始事件；</li>
<li> 然后通过 AnimationHandler 将其自身 this 添加到 mAnimationCallbacks 队列里，AnimationHandller 是一个单例类，为所有的属性动画服务，列表里存放着所有正在进行或准备开始的属性动画；</li>
<li> 如果当前存在要运行的动画，那么 AnimationHandler 会去通过 Choreographer 向底层注册监听下一个屏幕刷新信号，当接收到信号时，它的 mFrameCallback 会开始进行工作，工作的内容包括遍历列表来分别处理每个属性动画在当前帧的行为，处理完列表中的所有动画后，如果列表还不为 0，那么它又会通过 Choreographer 再去向底层注册监听下一个屏幕刷新信号事件，如此反复，直至所有的动画都结束。</li>
<li> AnimationHandler 遍历列表处理动画是在 doAnimationFrame() 中进行，而具体每个动画的处理逻辑则是在各自，也就是 ValueAnimator 的 doAnimationFrame() 中进行，各个动画如果处理完自身的工作后发现动画已经结束了，那么会将其在列表中的引用赋值为空，AnimationHandler 最后会去将列表中所有为 null 的都移除掉，来清理资源。</li>
<li> 每个动画 ValueAnimator 在处理自身的动画行为时，首先，如果当前是动画的第一帧，那么会根据是否有”跳过片头”（setCurrentPlayTime()）来记录当前动画第一帧的时间 mStartTime 应该是什么。</li>
<li> 第一帧的动画其实也就是记录 mStartTime 的时间以及一些变量的初始化而已，动画进度仍然是 0，所以下一帧才是动画开始的关键，但由于属性动画的处理工作是在绘制界面之前的，那么有可能因为绘制耗时，而导致 mStartTime 记录的第一帧时间与第二帧之间隔得太久，造成丢了开头的多帧，所以如果是这种情况下，会进行 mStartTime 的修正。</li>
<li> 修正的具体做法则是当绘制工作完成后，此时，再根据当前时间与 mStartTime 记录的时间做比较，然后进行修正。</li>
<li> 如果是在动画过程中的某一帧才出现绘制耗时现象，那么，只能表示无能为力了，丢帧是避免不了的了，想要解决就得自己去分析下为什么绘制会耗时；而如果是在第一帧是出现绘制耗时，那么，系统还是可以帮忙补救一下，修正下 mStartTime 来达到避免丢帧。</li>
</ol>
<hr>
<ol>
<li> 当接收到屏幕刷新信号后，AnimationHandler 会去遍历列表，将所有待执行的属性动画都取出来去计算当前帧的动画行为。</li>
<li> 每个动画在处理当前帧的动画逻辑时，首先会先根据当前时间和动画第一帧时间以及动画的持续时长来初步计算出当前帧时动画所处的进度，然后会将这个进度值等价转换到 0-1 区间之内。</li>
<li> 接着，插值器会将这个经过初步计算之后的进度值根据设定的规则计算出实际的动画进度值，取值也是在 0-1 区间内。</li>
<li> 计算出当前帧动画的实际进度之后，会将这个进度值交给关键帧机制，来换算出我们需要的值，比如 ValueAnimator.ofInt(0, 100) 表示我们需要的值变化范围是从 0-100，那么插值器计算出的进度值是 0-1 之间的，接下去就需要借助关键帧机制来映射到 0-100 之间。</li>
<li> 关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。</li>
<li> 当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。</li>
<li> 如果有设置估值器，那么就按估值器的规则来进行映射。</li>
<li> 当关键帧超过两个时，需要先找到当前动画进度是落于哪两个关键帧之间，然后将这个进度值先映射到这两个关键帧之间的取值，接着就可以将这两个关键帧看成是第一帧和最后一帧，那么就可以按照只有两个关键帧的情况下的映射规则来进行计算了。</li>
<li> 而进度值映射到两个关键帧之间的取值，这就需要知道每个关键帧在整个关键帧组中的位置信息，或者说权重。而这个位置信息是在创建每个关键帧时就传进来的。onInt() 的规则是所有关键帧按等比例来分配权重，比如有三个关键帧，第一帧是 0，那么第二帧就是 0.5， 最后一帧 1。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20Handler%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20Handler%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android Handler机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-12 21:32:00" itemprop="dateCreated datePublished" datetime="2017-07-12T21:32:00+08:00">2017-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20Handler%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android Handler机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Handler消息机制是怎样的过程？"><a href="#Handler消息机制是怎样的过程？" class="headerlink" title="Handler消息机制是怎样的过程？"></a>Handler消息机制是怎样的过程？</h1><p>Looper.loop()流程：</p>
<ol>
<li> 通过MessageQueue.next() 取Message，没有消息就阻塞当前线程。</li>
<li> 拿到Message返回给Looper.loop的调用处，调用Message绑定的Handler的dispatchMessage处理消息。</li>
<li> 处理结束又回到第1步，无限循环。</li>
</ol>
<p>每个线程都有各自的Looper，每个Looper有一个MessageQueue。</p>
<p>消息是链表，按时间when排序。</p>
<h1 id="等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？"><a href="#等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？" class="headerlink" title="等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？"></a>等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？</h1><p>调用 MessageQueue.next() 方法的时候会调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。</p>
<p>当我们加入消息的时候，会调用 MessageQueue.enqueueMessage() 方法，添加完 Message 后，如果消息队列被阻塞，则会调用 Native 层的 nativeWake() 方法去唤醒。它通过向管道中写入一个消息，结束上述阻塞，触发上面提到的 nativePollOnce() 方法返回，好让加入的 Message 得到分发处理。</p>
<h1 id="Looper-loop-里面有死循环，为什么没有阻塞主线程？"><a href="#Looper-loop-里面有死循环，为什么没有阻塞主线程？" class="headerlink" title="Looper.loop()里面有死循环，为什么没有阻塞主线程？"></a>Looper.loop()里面有死循环，为什么没有阻塞主线程？</h1><p>loop()里会从消息队列取消息，取不到消息就阻塞当前线程，释放CPU给其他线程使用，有消息时会唤醒阻塞等待的线程。</p>
<h1 id="IdleHandler是干什么的？"><a href="#IdleHandler是干什么的？" class="headerlink" title="IdleHandler是干什么的？"></a>IdleHandler是干什么的？</h1><p>IdleHandler只有一个方法boolean queueIdle()。</p>
<p>此方法在MessageQueue.next()中调用，MessageQueue.next()又在Looper.loop()中调用。</p>
<p>queueIdle()调用时机：</p>
<p>当前消息队列没有可以处理的消息，进入空闲状态，在阻塞等待新的消息前（nativePollOnce方法会阻塞等待新消息），先调用IdleHandler的queueIdle()。</p>
<p>返回true表示下一轮处理完消息后还会回调。</p>
<p>返回false表示这是单次回调，这次回调后不会再回调了。</p>
<p>有新消息时系统会调用MessageQueue的enqueueMessage()，enqueueMessage()调用nativeWake()，唤醒线程。</p>
<p>可以向MessageQueue添加多个IdleHandler。</p>
<h1 id="IdleHandler有什么应用场景？"><a href="#IdleHandler有什么应用场景？" class="headerlink" title="IdleHandler有什么应用场景？"></a>IdleHandler有什么应用场景？</h1><p>可以作为View绘制完成的回调，做启动时间优化。</p>
<p>Activity的onCreate，onStart，onResume中耗时较短但非必要的代码可以放到IdleHandler中执行，减少启动时间。</p>
<p>Activity的onResume是在绘制View之前发生的。</p>
<p>因为在ActivityThread的handleResumeActivity()中，调用performResumeActivity()对应Activity的onResume()，然后调用wm.addView(decor,l)对应绘制。</p>
<h1 id="postDelayed-Runnable-r-long-delayMillis-是如何实现的？"><a href="#postDelayed-Runnable-r-long-delayMillis-是如何实现的？" class="headerlink" title="postDelayed(Runnable r, long delayMillis)是如何实现的？"></a>postDelayed(Runnable r, long delayMillis)是如何实现的？</h1><p>首先从消息池获取一个Message对象，将Runnable对象放入Message的callback属性中；</p>
<p>再通过当前时间和延迟时间计算Runnable执行的时间，调用MessageQueue的enqueueMessage()把消息插入消息链表，执行时间会存入Message对象的when属性中，消息链表是按Message的执行时间升序排序的，插入也会插入到符合顺序的位置。</p>
<h1 id="sendMessage-Message-msg-和post-Runnable-r-有什么区别？"><a href="#sendMessage-Message-msg-和post-Runnable-r-有什么区别？" class="headerlink" title="sendMessage(Message msg)和post(Runnable r)有什么区别？"></a>sendMessage(Message msg)和post(Runnable r)有什么区别？</h1><p>post()会将Runnable放入一个Message对象的callback属性中，还是会转换为Message，本质上没有区别，只不过post要写的参数更少，使用更方便。</p>
<h1 id="使用Handler有什么要注意的？"><a href="#使用Handler有什么要注意的？" class="headerlink" title="使用Handler有什么要注意的？"></a>使用Handler有什么要注意的？</h1><p>要避免内存泄露，自定义Handler要定义静态内部类，并且用弱引用引用外部对象，避免外部对象在消息池中一直被引用而不能垃圾回收进而导致内存泄露。</p>
<h1 id="quit和quitSafely的区别？"><a href="#quit和quitSafely的区别？" class="headerlink" title="quit和quitSafely的区别？"></a>quit和quitSafely的区别？</h1><p>quit() 和 quitSafely() 的本质就是让消息队列的 next() 返回 null，以此来退出Looper.loop()。</p>
<p>quit() 调用后直接终止 Looper，不在处理任何 Message，所有尝试把 Message 放进消息队列的操作都会失败，比如 Handler.sendMessage() 会返回 false，但是存在不安全性，因为有可能有 Message 还在消息队列中没来的及处理就终止 Looper 了。</p>
<p>quitSafely() 调用后会在所有消息都处理后再终止 Looper，所有尝试把 Message 放进消息队列的操作也都会失败。</p>
<h1 id="同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？"><a href="#同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？" class="headerlink" title="同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？"></a>同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？</h1><p>Handler创建时可以传递一个async的布尔值参数，带这个参数的构造函数只有系统才能调用，我们创建Handler时async传的是false，通过Handler进行sendMessage或post都是同步消息，如果async传true，则通过Handler发送的都是异步消息。</p>
<p>Handler的sendMessage、post、postDelayed最终都会调用enqueueMessage，这里会判断如果构造Handler时的async传了true，就设置Message.setAsynchronous(true)。</p>
<p>同步消息和异步消息在没有往消息队列插入同步屏障时没有区别，插入同步屏障后，执行的优先级会有变化。</p>
<p>MessageQueue里的消息都是按照时间升序排序的，执行也是按时间由小到大的Message依次执行，如果有一个高优先级的消息需要立即执行，如果把新消息时间设置为当前时间，可能有好几个消息都是这样，原来的按时间顺序执行的机制就没办法保证执行的先后顺序，这就需要另外的机制来保证，即同步屏障机制。</p>
<p>同步屏障也是一个Message对象，但是没有target（没有绑定Handler），通过MessageQueue的postSyncBarrier(long when)方法向消息队列添加。</p>
<p>在MessageQueue的next()方法中，如果从消息队列取出的是同步屏障的Message（target==null），则从消息队列后面找一个异步消息来执行，如果没找到则一直阻塞等待异步消息。</p>
<p>应用场景：</p>
<p>app层无法调用同步屏障，在系统源码里有使用，如ViewRootImpl的schedualeTraversals，向MessageQueue中添加了内存屏障，保证了measure、layout、draw能够优于普通的Message而得到立即执行。</p>
<h1 id="为什么-View-post-里可以拿到-View-的宽高信息呢？"><a href="#为什么-View-post-里可以拿到-View-的宽高信息呢？" class="headerlink" title="为什么 View.post 里可以拿到 View 的宽高信息呢？"></a>为什么 View.post 里可以拿到 View 的宽高信息呢？</h1><p>View.post 和 Handler.post 的区别就是：</p>
<ol>
<li> 如果在 performTraversals 前调用 View.post，则会将消息进行保存，之后在 dispatchAttachedToWindow 的时候通过 ViewRootImpl 中的 Handler 进行调用。</li>
<li> 如果在 performTraversals 以后调用 View.post，则直接通过 ViewRootImpl 中的 Handler 进行调用。</li>
</ol>
<p>因为 View.post 的 Runnable 执行的时候，已经执行过 performTraversals 了，也就是 View 的 measure layout draw 方法都执行过了，自然可以获取到 View 的宽高信息了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android View 绘制机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-25 20:32:00" itemprop="dateCreated datePublished" datetime="2017-05-25T20:32:00+08:00">2017-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android View 绘制机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="View绘制整个流程"><a href="#View绘制整个流程" class="headerlink" title="View绘制整个流程"></a>View绘制整个流程</h1><p>Activity走到onResume时，会调用ActivityThread的handleResumeActivity。</p>
<p>在这里会创建DecorView，通过WindowManager添加到PhoneWindow中。</p>
<p>这里也会创建ViewRootImpl，把DecorView的parent指定为ViewRootImpl。</p>
<p>再调用DecorView的requestLayout，requestLayout会层层的调用parent的requestLayout，最后走到ViewRootImpl的requestLayout。</p>
<p>然后走到ViewRootImpl.scheduleTraversals()，注册垂直同步监听。</p>
<p>当垂直同步信号来临时，去调用ViewRootImpl.doTraversal() .</p>
<p>再调用ViewRootImpl.performTraversals()，然后依次调用performMeasure()、performLayout()、performDraw()。</p>
<hr>
<p>View.invalidate()也会层层调用parent的invalidateChildInParent，最后调用到ViewRootImpl的invalidateChildInParent，然后调用ViewRootImpl.scheduleTraversals()。</p>
<p>等待垂直同步信号来临时，调用ViewRootImpl.doTraversal()，由于没有给View设置FORCE_LAYOUT的flag，所以不会走measure和layout，只会performDraw()，并且只绘制dirty区域。</p>
<h1 id="首次-View-的绘制流程是在什么时候触发的？"><a href="#首次-View-的绘制流程是在什么时候触发的？" class="headerlink" title="首次 View 的绘制流程是在什么时候触发的？"></a>首次 View 的绘制流程是在什么时候触发的？</h1><p>ActivityThread.handleResumeActivity 里触发的。</p>
<p>ActivityThread.handleResumeActivity 里会调用 wm.addView 来添加 DecorView，wm 是 WindowManagerImpl</p>
<p>最终通过 WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView -&gt; ViewRootImpl.setView -&gt; ViewRootImpl.requestLayout 就触发了第一次 View 的绘制。</p>
<h1 id="ViewRootImpl-创建的时机？"><a href="#ViewRootImpl-创建的时机？" class="headerlink" title="ViewRootImpl 创建的时机？"></a>ViewRootImpl 创建的时机？</h1><p>ActivityThread.handleResumeActivity -&gt; WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView  中创建ViewRootImpl</p>
<h1 id="DecorView的创建时机？"><a href="#DecorView的创建时机？" class="headerlink" title="DecorView的创建时机？"></a>DecorView的创建时机？</h1><p>ActivityThread.handleResumeActivity()中ActivityClientRecord.window.getDecorView();</p>
<p>PhoneWindow.getDecorView()调用installDecor() -&gt; generateDecor()去new DecorView()</p>
<h1 id="ViewRootImpl-和-DecorView-的关系是什么？"><a href="#ViewRootImpl-和-DecorView-的关系是什么？" class="headerlink" title="ViewRootImpl 和 DecorView 的关系是什么？"></a>ViewRootImpl 和 DecorView 的关系是什么？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172333.png"></p>
<p>在 ViewRootImpl.setView 里，通过 DecorView.assignParent 把 ViewRootImpl 设置为 DecorView 的 parent。</p>
<p>所以 ViewRootImpl 和 DecorView 的关系就是 ViewRootImpl 是 DecorView 的 parent。</p>
<p>因为 DecorView 是我们布局的顶层，现在我们就知道层层调用 requestLayout 等方法是怎么调用到 ViewRootImpl 里的了。</p>
<h1 id="Activity、PhoneWindow、DecorView、ViewRootImpl-的关系？"><a href="#Activity、PhoneWindow、DecorView、ViewRootImpl-的关系？" class="headerlink" title="Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？"></a>Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？</h1><ul>
<li>PhoneWindow 其实是 Window 的唯一子类，是 Activity 和 View 交互系统的中间层。</li>
<li>DecorView 是整个 View 层级的最顶层。</li>
<li>ViewRootImpl 是 DecorView 的 parent，但是他并不是一个真正的 View，只是继承了 ViewParent 接口，用来掌管 View 的各种事件，包括 requestLayout、invalidate、dispatchInputEvent 等等。</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172438.png"></p>
<h1 id="如何触发重新绘制？"><a href="#如何触发重新绘制？" class="headerlink" title="如何触发重新绘制？"></a>如何触发重新绘制？</h1><p>View的 requestLayout 和 invalidate</p>
<h1 id="View-requestLayout-流程？"><a href="#View-requestLayout-流程？" class="headerlink" title="View.requestLayout()流程？"></a>View.requestLayout()流程？</h1><p>层层调用 parent 的 requestLayout  ，一直到ViewRootImpl.requestLayout()</p>
<p>ViewRootImpl.requestLayout() 调用 scheduleTraversals() -&gt; doTraversal() -&gt; performTraversals() 开启绘制流程。</p>
<p>在 performTraversals 里，就是熟悉的 performMeasure -&gt; performLayout -&gt; performDraw 三个流程了。</p>
<p>在performDraw View 的绘制过程中，我们可以看到，只有 flag 被设置为 PFLAG_DIRTY_OPAQUE 才会进行绘制（这里划重点）。这也就是大家经常说的 requestLayout 不会引发 draw。</p>
<h1 id="View-invalidate-流程？"><a href="#View-invalidate-流程？" class="headerlink" title="View.invalidate()流程？"></a>View.invalidate()流程？</h1><p>invalidate -&gt; invalidateInternal  -&gt; parent.invalidateChild</p>
<p>invalidateChild的while 循环里，会层层计算 parent 的 dirty 区域，最终会调用到 ViewRootImpl.invalidateChildInParent -&gt; ViewRootImpl.invalidateRectOnScreen -&gt; ViewRootImpl.scheduleTraversals -&gt; ViewRootImpl.performDraw -&gt; ViewRootImpl.draw -&gt; DecorView的draw()</p>
<p>View.draw 方法，根据 PFLAG_DIRTY_OPAQUE flag 去决定是否重新绘制。</p>
<h1 id="requestLayout-和-invalidate-的区别？"><a href="#requestLayout-和-invalidate-的区别？" class="headerlink" title="requestLayout 和 invalidate 的区别？"></a>requestLayout 和 invalidate 的区别？</h1><p>requestLayout 和 invalidate 都会触发整个绘制流程。但是在 measure 和 layout 过程中，只会对 flag 设置为 FORCE_LAYOUT 的情况进行重新测量和布局，而 draw 只会重绘 flag 为 dirty 的区域。</p>
<p>requestLayout 是用来设置 FORCE_LAYOUT 标志，invalidate 用来设置 dirty 标志。所以 requestLayout 只会触发 measure 和 layout，invalidate 只会触发 draw。</p>
<h1 id="requestLayout-一定会触发onMeasure和onLayout吗？"><a href="#requestLayout-一定会触发onMeasure和onLayout吗？" class="headerlink" title="requestLayout 一定会触发onMeasure和onLayout吗？"></a>requestLayout 一定会触发onMeasure和onLayout吗？</h1><p>不一定。</p>
<p>ViewRootImpl.performMeasure，最终调用的是 View.measure。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172624.png"><br>measureSpec 和 oldMeasureSpec 不相符的时候才会onMeasure。</p>
<p>ViewRootImpl.performLayout()：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172646.png"><br>位置有变化才去onLayout。</p>
<h1 id="PFLAG-DIRTY-OPAQUE是什么意思？"><a href="#PFLAG-DIRTY-OPAQUE是什么意思？" class="headerlink" title="PFLAG_DIRTY_OPAQUE是什么意思？"></a>PFLAG_DIRTY_OPAQUE是什么意思？</h1><p>不透明，实心。</p>
<p>实心控件：控件的onDraw方法能够保证此控件的所有区域都会被其所绘制的内容完全覆盖。换句话说，通过此控件所属的区域无法看到此控件之下的内容，也就是既没有半透明也没有空缺的部分。</p>
<h1 id="什么时候View的flag-被设置为-PFLAG-DIRTY-OPAQUE？"><a href="#什么时候View的flag-被设置为-PFLAG-DIRTY-OPAQUE？" class="headerlink" title="什么时候View的flag 被设置为 PFLAG_DIRTY_OPAQUE？"></a>什么时候View的flag 被设置为 PFLAG_DIRTY_OPAQUE？</h1><p>invalidate 会调用 parent.invalidateChild，在这里被赋值的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172722.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20View%20Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/Android%20View%20Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/" class="post-title-link" itemprop="url">Android View Touch事件分发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-22 19:25:00" itemprop="dateCreated datePublished" datetime="2017-05-22T19:25:00+08:00">2017-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20View%20Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android View Touch事件分发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事件是如何从屏幕点击最终到达-Activity-的？"><a href="#事件是如何从屏幕点击最终到达-Activity-的？" class="headerlink" title="事件是如何从屏幕点击最终到达 Activity 的？"></a>事件是如何从屏幕点击最终到达 Activity 的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828171545.png"></p>
<h1 id="CANCEL-事件什么时候会触发？"><a href="#CANCEL-事件什么时候会触发？" class="headerlink" title="CANCEL 事件什么时候会触发？"></a>CANCEL 事件什么时候会触发？</h1><ol>
<li> View 收到 ACTION_DOWN 事件以后，上一个事件还没有结束（可能因为 APP 的切换、ANR 等导致系统扔掉了后续的事件），这个时候会先执行一次 ACTION_CANCEL。</li>
<li> 子 View 之前拦截了事件，但是后面父 View 重新拦截了事件，这个时候会给子 View 发送 ACTION_CANCEL 事件。</li>
</ol>
<h1 id="如何解决滑动冲突？"><a href="#如何解决滑动冲突？" class="headerlink" title="如何解决滑动冲突？"></a>如何解决滑动冲突？</h1><ul>
<li>  通过重写父类的 onInterceptTouchEvent 来拦截滑动事件。</li>
<li>  通过在子类中调用 parent.requestDisallowInterceptTouchEvent 来通知父类是否要拦截事件。</li>
</ul>
<h1 id="Touch事件分发流程"><a href="#Touch事件分发流程" class="headerlink" title="Touch事件分发流程"></a>Touch事件分发流程</h1><p>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View.dispatchTouchEvent()</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828171640.png"></p>
<p>注意点：</p>
<ul>
<li>如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE、ACTION_UP事件都不会执行。</li>
<li>如果在最上层的View的onTouchEvent在DOWN时间返回true，虽然ViewGroup的onInterceptTouchEvent（）对DOWN事件返回了false，但后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent()</li>
<li>onInterceptTouchEvent（）一旦返回一次true，就再也不会被调用了。</li>
<li>当dispatchTouchEvent（）事件分发时，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP）</li>
<li>dispatchTouchEvent()、 onTouchEvent() 消费事件、终结事件传递（返回true）</li>
<li>onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">RecyclerView缓存机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-05 21:33:00" itemprop="dateCreated datePublished" datetime="2017-05-05T21:33:00+08:00">2017-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/RecyclerView缓存机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RecyclerView的缓存分为四级"><a href="#RecyclerView的缓存分为四级" class="headerlink" title="RecyclerView的缓存分为四级"></a>RecyclerView的缓存分为四级</h1><ul>
<li>  Scrap</li>
<li>  Cache</li>
<li>  ViewCacheExtension</li>
<li>  RecycledViewPool
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/" class="post-title-link" itemprop="url">Android中数据库相关的类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-19 20:22:00" itemprop="dateCreated datePublished" datetime="2017-03-19T20:22:00+08:00">2017-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/Android中数据库相关的类/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android中数据库相关类"><a href="#Android中数据库相关类" class="headerlink" title="Android中数据库相关类"></a>Android中数据库相关类</h1><ul>
<li>  SQLiteOpenHelper：管理SQLite的帮助类，提供获取SQLIteDatabase实例的方法，它会在第一次使用数据库时调用获取实例方法时创建SQLiteDatabase实例，并且处理数据库版本变化，开发人员在实现ContentProvider时都要实现一个自定义的SQLiteOpenHelper类，处理数据的创建、升级和降级。</li>
<li>  SQLiteDatabase：代表一个打开的SQLite数据库，提供了执行数据库操作的接口方法。如果不需要在进程之间共享数据，应用程序也可以自行创建这个类的实例来读写SQLite数据库。</li>
<li>  SQLiteSession：SQLiteSession负责管理数据库连接和事务的生命周期，通过SQLiteConnectionPool获取数据库连接来执行具体的数据库操作。</li>
<li>  SQLiteConnectionPool：数据库连接池，管理所有打开的数据库连接（Connection）。所有数据库连接都是通过它来打开，打开后会加入连接池，在读写数据库时需要从连接池中获取一个数据库连接来使用。</li>
<li>  SQLiteConnection：代表了数据库连接，每个Connection封装了一个native层的sqlite3实例，通过JNI调用SQLite动态库的接口方法操作数据库，Connection要么被Session持有，要么被连接池持有。</li>
<li>  CursorFactory：可选的Cursor工厂，可以提供自定义工厂来创建Cursor。</li>
<li>  DatabaseErrorHandler：可选的数据库异常处理器（目前仅处理数据库Corruption），如果不提供，将会使用默认的异常处理器。</li>
<li>  SQLiteDatabaseConfiguration：数据库配置，应用程序可以创建多个到SQLite数据库的连接，这个类用来保证每个连接的配置都是相同的。</li>
<li>  SQLiteQuery和SQLiteStatement：从抽象类SQLiteProgram派生，封装了SQL语句的执行过程，在执行时自动组装待执行的SQL语句，并调用SQLiteSession来执行数据库操作。这两个类的实现应用了设计模式中的命令模式。</li>
</ul>
<h1 id="使用SQLiteOpenHelper的原因"><a href="#使用SQLiteOpenHelper的原因" class="headerlink" title="使用SQLiteOpenHelper的原因"></a>使用SQLiteOpenHelper的原因</h1><p>之所以需要使用SQLiteOpenHelper，而不是调用Context的方法来直接得到SQLiteDatabase，主要是因为它有两个好处：</p>
<ol>
<li> 自动管理创建：当需要对数据库进行操作的时候，不用关心SQLiteOpenHelper所关联的SQLiteDatabase是否创建，SQLiteOpenHelper会帮我们去判断，如果没有创建，那么就先创建该数据库后，再返回给使用者。</li>
<li> 自动管理版本：当需要对数据库进行操作之前，如果发现当前声明的数据库的版本和手机内的数据库版本不同的时候，那么会分别调用onUpgrade和onDowngrade，这样使用者就可以在里面来处理新旧版本的兼容问题。</li>
</ol>
<h1 id="SQLiteOpenHelper跟数据库连接池的关系是怎样的？"><a href="#SQLiteOpenHelper跟数据库连接池的关系是怎样的？" class="headerlink" title="# SQLiteOpenHelper跟数据库连接池的关系是怎样的？"></a># SQLiteOpenHelper跟数据库连接池的关系是怎样的？</h1><p>一个SQLiteOpenHelper对象存有一个SQLiteDatabase对象</p>
<p>一个SQLiteDatabase对象存有一个SQLiteConnectionPool对象</p>
<p>一个SQLiteConnectionPool对象</p>
<ol>
<li> 在journal-mode下最多存有1个SQLiteConnection</li>
<li> 在wal-mode下最多存有2个SQLiteConnection</li>
</ol>
<h1 id="SQL-语句的执行过程"><a href="#SQL-语句的执行过程" class="headerlink" title="SQL 语句的执行过程"></a>SQL 语句的执行过程</h1><p>创建SQLiteStatement对象，把SQL语句传给SQLiteStatement构造函数，调用SQLiteStatement的executeInsert()</p>
<p>SQLiteStatement.executeInsert()内部的增删改查方法都会先getSession()获取SQLiteSession，再调用SQLiteSession的execute方法</p>
<p>继续追查可以发现SQLiteSession是在SQLiteDatabase里以ThreadLocal形式存储，也就是每个线程只能有一个SQLiteSession</p>
<p>SQLiteSession的execute方法里会从数据库连接获取一个连接，每个SQLiteSession对象有一个SQLiteConnection对象</p>
<h1 id="SQLiteSession存在的价值"><a href="#SQLiteSession存在的价值" class="headerlink" title="SQLiteSession存在的价值"></a>SQLiteSession存在的价值</h1><p>给数据库连接代理了一层，管理事务和连接的生命周期。</p>
<p>在事务执行过程中一直持有数据库连接。</p>
<p>由于数据库连接数量是有限的，所以连接用完后要及时释放连接。</p>
<p>事务开启后，从连接池获取连接。</p>
<p>事务结束后，把连接归还到连接池。</p>
<h1 id="数据库连接是什么意思？"><a href="#数据库连接是什么意思？" class="headerlink" title="数据库连接是什么意思？"></a>数据库连接是什么意思？</h1><p>一个连接对应一个事务操作</p>
<h1 id="如果一个数据库连接始终不关闭会有什么影响？"><a href="#如果一个数据库连接始终不关闭会有什么影响？" class="headerlink" title="如果一个数据库连接始终不关闭会有什么影响？"></a>如果一个数据库连接始终不关闭会有什么影响？</h1><p>SQLite连接数有最大限制，不关闭，会导致别的进程无法连接数据库。</p>
<h1 id="SQLiteConnectionPool连接池大小是怎么定的"><a href="#SQLiteConnectionPool连接池大小是怎么定的" class="headerlink" title="SQLiteConnectionPool连接池大小是怎么定的?"></a>SQLiteConnectionPool连接池大小是怎么定的?</h1><p>目前Android系统的实现中，如果以非WAL模式打开数据库，连接池中只会保持一个数据库连接，如果以WAL模式打开数据库，连接池中的最大连接数量则根据系统配置决定，默认配置是两个。</p>
<h1 id="数据库连接池只提供最多1个连接会有什么影响？"><a href="#数据库连接池只提供最多1个连接会有什么影响？" class="headerlink" title="数据库连接池只提供最多1个连接会有什么影响？"></a>数据库连接池只提供最多1个连接会有什么影响？</h1><p>如果应用程序中有大量的并发数据库读和写操作的话，每个操作的时长都可能受到影响，所以数据库操作应放在工作线程中执行，以免影响UI响应。</p>
<p>因为每个事务都是在SQLiteSession中执行的，执行事务前会从连接池获取连接，调用的是SQLiteConnectionPool.acquireConnection()，方法内如果获取不到Connection就会阻塞线程等待，用链表存储阻塞的线程，直到连接被释放，也就是别的事务执行完成。</p>
<p>我们平时在多线程中的数据库操作都是串行的。</p>
<h1 id="Android里开启事务，事务模式用的是哪个？"><a href="#Android里开启事务，事务模式用的是哪个？" class="headerlink" title="Android里开启事务，事务模式用的是哪个？"></a>Android里开启事务，事务模式用的是哪个？</h1><ul>
<li>SQLiteDatabase.beginTransaction()开启的是EXCLUSIVE。</li>
<li>SQLiteDatabase.beginTransactionNonExclusive()开启的是IMMEDIATE。</li>
</ul>
<p>注意这两个事务模式只针对回滚日志模式下的事务。</p>
<p><a target="_blank" rel="noopener" href="https://sqlite.org/lang_transaction.html#:%7E:text=EXCLUSIVE%20is%20similar%20to%20IMMEDIATE,while%20the%20transaction%20is%20underway.">SQLite官网</a>说在WAL日志模式下，EXCLUSIVE和IMMEDIATE是一样的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/" class="post-title-link" itemprop="url">SQLite事务、回滚日志、WAL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-18 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-18T20:56:00+08:00">2017-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite事务、回滚日志、WAL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h1><p>事务定义了一组数据库操作的边界，这组操作要么全部执行，要么全部不执行，这也是事务的原子性特征</p>
<h1 id="为什么要发明事务？事务存在的价值是什么？"><a href="#为什么要发明事务？事务存在的价值是什么？" class="headerlink" title="为什么要发明事务？事务存在的价值是什么？"></a>为什么要发明事务？事务存在的价值是什么？</h1><p>在操作数据库的情况下，需要考虑的特别的场景处理特别多，例如并发操作、系统崩溃等，发明事务这个模型，就可以用来简化讨论，把复杂的场景归类为少数的几个特定类型的场景，降低处理成本。</p>
<p>数据库操作例如增删改查、建立索引、建立约束等。</p>
<h1 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h1><p>ACID</p>
<h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h2><p>事务内的操作要么全部执行，要么全部不执行，不可再拆分</p>
<h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><p>保证数据库从一个正确的状态转变到另一个正确的状态，正确的状态指的是当前数据库中的数据都满足预定的约束条件。</p>
<p>AID是保证一致性的必要条件，但不是充分条件，因为数据库作为通用的技术，不可能知道具体业务场景的正确逻辑，所以正确的逻辑需要由用户决定应该使用怎样的约束</p>
<h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h2><p>事务的执行不受其他事务的干扰，事务之间的操作只能串行的执行，保证任何事务都不可能读取到其他任何事务内部执行的中间状态，否则会产生数据混乱</p>
<h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h2><p>事务一旦提交，它对数据库中的数据改变就是永久性的，接下来的其他操作或故障都不会影响本次事务提交的结果</p>
<h2 id="事务的原子性是如何实现的？"><a href="#事务的原子性是如何实现的？" class="headerlink" title="事务的原子性是如何实现的？"></a>事务的原子性是如何实现的？</h2><p>SQLite事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。</p>
<p>回滚日志文件，用于实现数据库的原子提交和回滚。 此文件和数据库文件总是在同一个目录，并且有相同的文件名，但是在文件名中添加了一个-journal 字符串。此文件一般在transaction开始时创建，transaction结束时删除。</p>
<p>如果系统crash，Rollback journals文件将被保留，下次打开数据库文件时，系统会检查有没有Rollback journals文件存在，如果有就用它来恢复数据库。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092550.png"></p>
<h1 id="创建回滚日志详细过程是怎样的？"><a href="#创建回滚日志详细过程是怎样的？" class="headerlink" title="创建回滚日志详细过程是怎样的？"></a>创建回滚日志详细过程是怎样的？</h1><ol>
<li> 写数据库前获取保留锁</li>
<li> 创建回滚日志文件，将要修改的页的原始数据写到缓存中</li>
<li> 在用户空间修改页数据</li>
<li> 回滚日志的缓存刷盘到回滚日志文件中</li>
<li> 获取未决锁，等待共享锁都释放后，提升为排它锁</li>
<li> 将用户空间修改过的数据写入数据库文件，会先写到操作系统的缓存中，再刷盘到磁盘上</li>
<li> 删除rollback journal文件</li>
<li> 释放排它锁</li>
</ol>
<h2 id="创建rollback-journal-file"><a href="#创建rollback-journal-file" class="headerlink" title="创建rollback journal file"></a>创建rollback journal file</h2><p>将要修改的pages的原始数据写入rollback journal file，以page为单位写入。</p>
<p>rollback journal file中绿色的部分是header,header中会包括数据库文件的原始大小(即包括多少个page)。每一个page保存到rollback journal中时前边四字节会保存该page的page number。</p>
<ul>
<li>  rollback journal创建之后并没有实际落盘,只是保存在操作系统的缓存中</li>
<li>  rollback journal以page为单位,但每个page前四字节会有一个page number的记录,后四字节有一个checksum</li>
</ul>
<h2 id="在用户空间修改数据库文件"><a href="#在用户空间修改数据库文件" class="headerlink" title="在用户空间修改数据库文件"></a>在用户空间修改数据库文件</h2><p>修改用户进程空间内的数据库文件,注意不同的用户进程有自己的私有内存空间,因此此时的修改并不影响其他进程的读取操作。</p>
<h2 id="将rollback-journal落盘"><a href="#将rollback-journal落盘" class="headerlink" title="将rollback journal落盘"></a>将rollback journal落盘</h2><p>该步骤是保持原子性很关键的一步,保证即使掉电或者操作系统crash,Sqlite也能恢复到原来的状态。</p>
<p>(进行到该步也能看出reserved lock的作用,这种锁是一个中间状态,既能为即将写入做准备,又不影响其他进程的读取操作,提高并行度)。</p>
<p>该步需要刷两次盘,第一次将rollback journal的内容刷到磁盘,第二次在header中记录第一步中刷到磁盘的page个数,然后将header刷盘。</p>
<h2 id="获取排他锁"><a href="#获取排他锁" class="headerlink" title="获取排他锁"></a>获取排他锁</h2><p>在实际写入数据库文件之前,需要获取一个排他锁.获取过程分两步<br>    • 获取一个pending lock<br>    • 将pending lock升级为排他锁<br>获取到pending lock之后,在数据库文件上已经获取到共享锁的进程可以继续读取,但不允许其他进程继续获取共享锁.该锁存在的意义在于防止write starvation(即有大量的读取连接时,一直有新的共享锁产生,导致获取不到排他锁).当所有已经存在的共享锁都释放后,此时该pending lock即可以升级为排他锁。</p>
<h2 id="写入数据库文件"><a href="#写入数据库文件" class="headerlink" title="写入数据库文件"></a>写入数据库文件</h2><p>获取到排他锁后,说明已经没有其他进程在读取该数据库文件.此时可以安全的写入数据库文件.注意也只是写入操作系统的缓存中,并没有落盘。</p>
<h2 id="删除rollback-journal"><a href="#删除rollback-journal" class="headerlink" title="删除rollback journal"></a>删除rollback journal</h2><p>因为数据库文件已经安全落盘,此时可以删除掉rollback journal.若删除之前系统crash或者掉电,则重启后会恢复到事务开始前的状态,如果删除之后系统crash或者掉电,因为数据库文件已经落盘,相当于事务已经执行完成.(那么会不会在删除一半时系统crash或者掉电呢?注意上文中关于硬件的一些假设,删除操作必须是原子性的,即不会发生这种情况)</p>
<p>因为删除一个文件也是一个耗时的操作,因此Sqlite提供了两种方式减少删除过程的耗时.</p>
<ul>
<li>  将一个文件truncate为0</li>
<li>  将journal file header清0.清0操作并不是原子性的,但只要header中有一个byte被清0,该文件就会被识别为无效的格式</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/lockingv3.html#rollback">The Rollback Journal</a></li>
</ul>
<h1 id="热日志是什么意思？"><a href="#热日志是什么意思？" class="headerlink" title="热日志是什么意思？"></a>热日志是什么意思？</h1><p>每次打开数据库文件，或者从数据库读取页时，都要简单的做一致性检查。</p>
<p>如果发现存在回滚日志文件，但是数据库中没有保留锁，那么创建日志文件的肯定崩溃了或者系统死机了，因为正常情况下，获得保留锁后才会创建回滚日志。</p>
<p>这种情况下日志被称为“热日志”，数据库可能处于不一致的状态（不满足约束条件），要让一切正常需要回滚日志，将数据库还原到初始的被中断的事务之前的状态。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092653.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>
<h1 id="SQLite中事务为什么还要分不同的类型？分别有什么作用？"><a href="#SQLite中事务为什么还要分不同的类型？分别有什么作用？" class="headerlink" title="SQLite中事务为什么还要分不同的类型？分别有什么作用？"></a>SQLite中事务为什么还要分不同的类型？分别有什么作用？</h1><p>是为了解决死锁</p>
<p>SQLite的事务分为</p>
<ol>
<li> deferred</li>
<li> immediate</li>
<li> exclusive</li>
</ol>
<p>begin [ deferred | immediate | exclusive ] transaction</p>
<p>deferred</p>
<ol>
<li> 未指定事务模式时默认的选择</li>
<li> 开始事务时处于未锁定状态</li>
<li> 实际访问数据库时才试图加锁</li>
<li> 第一个读数据库操作试图获取共享锁</li>
<li> 第一个写数据库操作试图获取预留锁</li>
</ol>
<p>immediate</p>
<ol>
<li> 事务开始时试图获取预留锁</li>
<li> 获取预留锁成功后，其他连接中已执行的事务无法再获取到预留锁</li>
<li> 新的连接开始immediate和exclusive的事务也会失败，并返回SQLITE_BUSY错误</li>
<li> 最后提交事务时，预留锁会提升到未决锁</li>
<li> 等待其他连接中的事务释放共享锁</li>
<li> 阻止新的连接获取共享锁</li>
<li> 如果其他事务一直没释放共享锁，会返回SQLITE_BUSY错误</li>
</ol>
<p>exclusive</p>
<ol>
<li> 开始事务时尝试获取排它锁</li>
<li> 获取成功后阻止所有的读写操作</li>
<li> 在事务内可以对数据库进行任意的读写</li>
</ol>
<p>参考《SQLite权威指南（第2版）》118页  第4章 SQLite中的高级SQL - 事务的类型</p>
<h1 id="SQLite-WAL是什么？"><a href="#SQLite-WAL是什么？" class="headerlink" title="SQLite WAL是什么？"></a>SQLite WAL是什么？</h1><p>SQLite在3.7.0开始引入了WAL技术</p>
<p>Write-Ahead Log</p>
<p>预先写日志</p>
<p>默认的 rollback journal 模式工作原理大致为：写操作进行前进行数据库文件拷贝，然后对数据库进行写操作。如果发生 Crash 或者 rallback 则将日志中的原始内容回滚到数据库中进行恢复操作，否则在 Commit 完成时删除日志文件。</p>
<p>WAL模式采用了相反的的做法，</p>
<p>在准备写数据库文件前，会先复制数据库文件的中的原始数据到日志文件，写操作也只更新日志文件，原有数据库文件不变动；</p>
<p>如果事务失败，WAL中的数据被忽略；</p>
<p>如果事务成功，在随后的某个时间点，将WAL中的数据写回到数据库文件，这个时间点称为checkpoint。</p>
<p>WAL使用检查点将修改写回数据库，默认情况下，当WAL文件发现有1000页修改时，将自动调用检查点。这个页数大小可以自行配置。</p>
<p>读数据时，SQLite在WAL中搜索，找到最后一个写入点，并记录，读时忽略这个写入点后面的信息，如果读取在WAL中读取不到数据，则去数据库文件中读取；写数据时继续往记录点后追加写入数据，这样保证了读和写可以同时进行；由于同一时刻只能有一个连接写数据库，写与写之间是互斥的，所以不会产生写入点后面写数据时指针冲突。</p>
<p>由于每个读操作都会搜索整个WAL文件，所以在共享内存加建立了一个wal-index索引，加速查找，避免扫描整个WAL文件。</p>
<h1 id="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"><a href="#WAL提升了哪方面的性能？优点是什么？解决了什么问题？" class="headerlink" title="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"></a>WAL提升了哪方面的性能？优点是什么？解决了什么问题？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093052.png"></p>
<p>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> WAL is significantly faster in most scenarios.</li>
<li> WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</li>
<li> Disk I/O operations tends to be more sequential using WAL.</li>
<li> WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="WAL的缺点是什么？"><a href="#WAL的缺点是什么？" class="headerlink" title="WAL的缺点是什么？"></a>WAL的缺点是什么？</h1><ol>
<li> 所有的数据库操作必须都在同一台机器上进行，并且该机器的操作系统需要支持 VFS 特性。</li>
<li> 当连接处于 WAL 模式中时我们无法修改页大小</li>
<li> 为满足 Wal 和相关共享内存的需要，使用 WAL 引入了两个额外的半持久性文件 -wal 和 -shm 该文件需要占用一定的存储空间。</li>
<li> 数据库读性能会比 rollback journal 模式略差 （大概慢 1% ～ 2% ），另外写操作也会间歇性的性能下降。</li>
<li> 读操作的性能会比 rollback journal 模式出现部分下降，因为它需要额外对 -wal 文件进行一次检索，而且 Checkpoint 本身就比较耗时且会对读操作进行阻塞。</li>
<li> 频繁 Checkpoint 变得频繁又会影响写操作的性能指标，而且频繁的同步操作也会增加数据库损坏的概率</li>
</ol>
<hr>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093220.png"><br>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</li>
<li> Transactions that involve changes against multiple <a target="_blank" rel="noopener" href="https://sqlite.org/lang_attach.html">ATTACHed</a> databases are atomic for each individual database, but are not atomic across all databases as a set.</li>
<li> WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</li>
<li> There is an additional quasi-persistent “-wal” file and “-shm” shared memory file associated with each database, which can make SQLite less appealing for use as an <a target="_blank" rel="noopener" href="https://sqlite.org/appfileformat.html">application file-format</a>.</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="Android中如何开启WAL？"><a href="#Android中如何开启WAL？" class="headerlink" title="Android中如何开启WAL？"></a>Android中如何开启WAL？</h1><p>SQLiteDatabase.enableWriteAheadLogging()</p>
<p>根据注释描述，Android默认没有开启WAL。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">SQLite锁机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-17 20:56:00" itemprop="dateCreated datePublished" datetime="2017-03-17T20:56:00+08:00">2017-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite锁机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQLite锁的粒度到哪里？"><a href="#SQLite锁的粒度到哪里？" class="headerlink" title="SQLite锁的粒度到哪里？"></a>SQLite锁的粒度到哪里？</h1><p>SQLite锁的是整个数据库文件，不支持页锁、表锁和行锁，粒度较粗。</p>
<p>当一个连接要写数据库文件时，所有其他的连接都会阻塞，直到写数据的连接事务结束。</p>
<p>SQLite 3.7.0 新增 Write-Ahead Log 机制改变了事务行为，读写可以并发。</p>
<h1 id="为什么SQLite不支持表锁和行锁呢？"><a href="#为什么SQLite不支持表锁和行锁呢？" class="headerlink" title="为什么SQLite不支持表锁和行锁呢？"></a>为什么SQLite不支持表锁和行锁呢？</h1><p>支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。</p>
<p>同时复杂性增大会增加运行设备电量的损害，对于手机这类这种电量敏感的设备比较重要。</p>
<h1 id="SQLite锁机制是怎样的？"><a href="#SQLite锁机制是怎样的？" class="headerlink" title="SQLite锁机制是怎样的？"></a>SQLite锁机制是怎样的？</h1><p>有多个数据库连接同时访问同一个数据库，就产生了资源竞争，需要锁机制保证资源竞争的正确性</p>
<p>数据库操作无非就是读和写，按道理普通的读写锁就可以实现，但高并发下读写锁仍然有优化的空间，为了提高整体的吞吐量，SQLite使用了锁逐步提升的机制</p>
<p>SQLite共有5种锁状态：</p>
<ol>
<li> 无锁（unlocked）</li>
<li> 共享（shared）</li>
<li> 预留（reserved）</li>
<li> 未决（pending）</li>
<li> 排它（exclusive）</li>
</ol>
<p>每个数据库连接同一时刻只能处于其中一个状态</p>
<p>无锁：</p>
<ol>
<li> 即使事务已经开始，在没有读写数据库前，都是无锁状态</li>
</ol>
<p>共享：</p>
<ol>
<li> 读数据库必须获得共享锁</li>
<li> 多个数据库连接可以同时获得共享锁，即允许多个连接同时读数据库</li>
<li> 写数据库前必须要释放所有的共享锁</li>
</ol>
<p>预留：</p>
<ol>
<li> 写数据需要先获取到预留锁</li>
<li> 持有预留锁后就可以立即把数据写入缓存中，而不用竞争数据库文件，把可以不占用的数据库文件可以完成的事情提前完成，这样最大程度的减少独占数据库文件的时间</li>
<li> 预留锁可以与共享锁共存</li>
<li> 预留锁不影响其他已经持有共享锁的连接继续读数据库</li>
<li> 预留锁不阻止其他连接获得新的共享锁，因为并不确定是否要立即写入数据库文件，可能之后还要修改数据库内容，提交事务的时候才知道后面不会再修改数据库了</li>
<li> 一个数据库同时只能有一个预留锁存在</li>
</ol>
<p>未决：</p>
<ol>
<li> 当连接提交事务时，就要把缓存里的数据往数据库文件中写入，以保证事务的持久性</li>
<li> 对数据库文件写数据前，需要保证没有连接再持有共享锁</li>
<li> 但此时可能还有其他连接持有共享锁，需要等待这些连接释放共享锁后，才能写数据</li>
<li> 同时要阻止新的连接获取共享锁，否则写数据一直得不到执行</li>
<li> 所以从预留锁要转变为未决锁，来阻止新的连接获取共享锁</li>
</ol>
<p>排它：</p>
<ol>
<li> 所有共享锁释放后，未决锁提升为排他锁</li>
<li> 排它锁和未决锁一样，会阻止新的连接获取共享锁，阻止读数据</li>
<li> 获得排它锁后，就可以把缓存中的数据写入数据库文件</li>
</ol>
<p>参考资料：</p>
<p>《SQLite权威指南（第2版）》116页  第4章 SQLite中的高级SQL - 数据库锁</p>
<h1 id="SQLite锁为什么搞这么多状态？"><a href="#SQLite锁为什么搞这么多状态？" class="headerlink" title="SQLite锁为什么搞这么多状态？"></a>SQLite锁为什么搞这么多状态？</h1><ul>
<li>由于写数据时是排他的，其他连接无法读数据库，所以要尽可能的减少写数据时的耗时，才能提高系统整体的吞吐量。</li>
<li>所以写数据时先获取预留锁，把可以在不占用数据库文件的事情提前做好。</li>
<li>那些需要占用数据库文件才能做的事情留到获取到排他锁时再做。<ul>
<li>获取排它锁前需要保证没有连接再获取共享锁。</li>
<li>所以先从预留锁提升到未决锁，用来阻止新的共享锁的获取。</li>
<li>等待已经获取的共享锁的连接执行完后释放了所有的共享锁，最后获取到排它锁写数据库文件。</li>
</ul>
</li>
</ul>
<h1 id="锁的状态转移过程是怎样的？"><a href="#锁的状态转移过程是怎样的？" class="headerlink" title="锁的状态转移过程是怎样的？"></a>锁的状态转移过程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091837.png"></p>
<h1 id="为什么事务的开始都要先获取未决锁，再获取共享锁？"><a href="#为什么事务的开始都要先获取未决锁，再获取共享锁？" class="headerlink" title="为什么事务的开始都要先获取未决锁，再获取共享锁？"></a>为什么事务的开始都要先获取未决锁，再获取共享锁？</h1><p>因为如果已经获得了未决锁，说明要占用数据库文件进行写操作，就不允许读了，而读数据库需要获得共享锁，这里就阻止别的连接获取共享锁。</p>
<h1 id="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"><a href="#有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？" class="headerlink" title="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"></a>有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？</h1><p>获得预留锁时，读写可以并发执行，但是真正写数据库需要阻止共享锁获取。</p>
<p>这样做可以提升系统整体的吞吐量。</p>
<h1 id="SQLite锁机制需要注意什么？"><a href="#SQLite锁机制需要注意什么？" class="headerlink" title="SQLite锁机制需要注意什么？"></a>SQLite锁机制需要注意什么？</h1><p>注意死锁的发生</p>
<h1 id="SQLite什么情况下会发生死锁？"><a href="#SQLite什么情况下会发生死锁？" class="headerlink" title="SQLite什么情况下会发生死锁？"></a>SQLite什么情况下会发生死锁？</h1><p>SQLite发生死锁时会抛出database is locked的异常信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091949.png"></p>
<p>参考《SQL权威指南（第2版）》117页 SQLite中的高级SQL - 死锁</p>
<h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>用正确的事务类型来开启事务</p>
<p>存在并发写数据，就开启immediate或exclusive事务，提供了同步机制</p>
<p>SQLite有三种不同的事务类型：</p>
<ol>
<li> DEFERRED（推迟）</li>
<li> MMEDIATE（立即）</li>
<li> EXCLUSIVE（排它）</li>
</ol>
<p>事务类型在BEGIN命令中指定。</p>
<p>一个deferred事务不获取任何锁，直到它需要锁的时候。而且BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态；默认情况下是这样的。如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取SHARED LOCK；同样，当进行第一次写操作时，它会获取RESERVED LOCK。</p>
<p>由BEGIN开始的Immediate事务会试着获取RESERVED LOCK。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作，但是RESERVED LOCK会阻止其它的连接BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，SQLite会返回SQLITE_BUSY错误。这时你就可以对数据库进行修改操作，但是你不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。</p>
<p>Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 上面那个例子的问题在于两个连接最终都想写数据库，但是他们都没有放弃各自原来的锁，最终，shared 锁导致了问题的出现。如果两个连接都以BEGIN IMMEDIATE开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入BEGIN IMMEDIATE，其它的连接就得等待。BEGIN IMMEDIATE和BEGIN EXCLUSIVE通常被写事务使用。就像同步机制一样，它防止了死锁的产生。 基本的准则是：如果你在使用的数据库没有其它的连接，用BEGIN就足够了。但是，如果你使用的数据库在其它的连接也要对数据库进行写操作，就得使用BEGIN IMMEDIATE或BEGIN EXCLUSIVE开始你的事务。</p>
<h1 id="Android中对SQLite开启的哪一种事务类型？"><a href="#Android中对SQLite开启的哪一种事务类型？" class="headerlink" title="Android中对SQLite开启的哪一种事务类型？"></a>Android中对SQLite开启的哪一种事务类型？</h1><p>SQLiteDatabase开启事务有两个方法：</p>
<ol>
<li> beginTransaction()开启exclusive事务类型</li>
<li> beginTransactionNonExclusive()开启immediate事务类型</li>
</ol>
<h1 id="锁的状态存储在哪里？"><a href="#锁的状态存储在哪里？" class="headerlink" title="锁的状态存储在哪里？"></a>锁的状态存储在哪里？</h1><p>数据库文件是独立于进程的，多个进程可以访问同一个文件，所以数据库锁是存在数据库文件中的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092032.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092040.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">SQLite并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-16 20:31:00" itemprop="dateCreated datePublished" datetime="2017-03-16T20:31:00+08:00">2017-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 21:59:01" itemprop="dateModified" datetime="2021-08-28T21:59:01+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="数据库/SQLite并发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQLite支持多线程吗？"><a href="#SQLite支持多线程吗？" class="headerlink" title="SQLite支持多线程吗？"></a>SQLite支持多线程吗？</h1><p>SQLite支持多线程，但是是有条件的支持，也就是：</p>
<ul>
<li>同一个连接不能在多线程中使用，不同连接才可以在多线程中使用，这个是最宏观的SQLite多线程准则。</li>
<li>SQLite的文件锁是粗颗粒的，也就是以数据库文件为维度加锁，涉及到5种锁状态。</li>
</ul>
<p>为了确保数据库安全，SQLite 内部抽象了两种类型的互斥锁（锁的具体实现和宿主平台有关）来应对线程并发问题：</p>
<ul>
<li>fullMutex<br>可以理解为 connection mutex，和连接句柄（上问描述的 sqlite3 结构体）绑定。<br>保证任何时候，最多只有一个线程在执行基于连接的事务。</li>
<li>coreMutex<br>当前进程中，与文件绑定的锁。<br>用于保护数据库相关临界资源，确保在任何时候，最多只有一个线程在访问。</li>
</ul>
<h2 id="SQLite三种线程模型"><a href="#SQLite三种线程模型" class="headerlink" title="SQLite三种线程模型"></a>SQLite三种线程模型</h2><ul>
<li>single-thread<ul>
<li>  coreMutex 和 fullMutex 都被禁用。</li>
<li>  用户层需要确保在任何时候只有一个线程访问 API，否则抛出异常。</li>
</ul>
</li>
<li>multi-thread<ul>
<li>  coreMutex 保留，fullMutex 禁用。</li>
<li>  可以多个线程基于不同的连接并发访问数据库，但单个连接在任何时候只能被一个线程访问。</li>
<li>单个 connection，如果并发访问，会抛出异常。<ul>
<li>  报错信息：illegal multi-threaded access to database connection。</li>
</ul>
</li>
</ul>
</li>
<li>serialized<ul>
<li>  coreMutex 和 fullMutex 都保留。</li>
</ul>
</li>
</ul>
<h1 id="同一个数据库连接多线程访问会有什么问题？"><a href="#同一个数据库连接多线程访问会有什么问题？" class="headerlink" title="同一个数据库连接多线程访问会有什么问题？"></a>同一个数据库连接多线程访问会有什么问题？</h1><p>一个数据库连接对应一个事务操作，多线程访问一个连接会造成事务不原子化，事务执行结果会混乱。</p>
<h1 id="不同的连接同时写数据库会发生什么？"><a href="#不同的连接同时写数据库会发生什么？" class="headerlink" title="不同的连接同时写数据库会发生什么？"></a>不同的连接同时写数据库会发生什么？</h1><p>就走入了SQLite本身的锁机制。</p>
<p>写数据会去获取保留锁、独占锁。</p>
<p>如果还有连接要写入，就会返回SQLITE_BUSY。</p>
<h1 id="Android中的SQLite的Thread-Mode是什么？"><a href="#Android中的SQLite的Thread-Mode是什么？" class="headerlink" title="Android中的SQLite的Thread Mode是什么？"></a>Android中的SQLite的Thread Mode是什么？</h1><p><a target="_blank" rel="noopener" href="http://www.sqlite.org/threadsafe.html">SQLite官网</a>说默认线程模式是serialized</p>
<p>Android的SQLiteDatabase类的<a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">setLockingEnabled(boolean lockingEnabled)文档</a>说，默认线程模式是Multi-thread。</p>
<p>API 16 setLockingEnabled() 方法又废弃了。</p>
<p>不管怎么说肯定不是single-thread，不是multi-thread就是serialized。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11167834/what-is-the-default-threading-mode-of-sqlite-in-android">What is the Default Threading mode of SQLite in Android?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">202</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
