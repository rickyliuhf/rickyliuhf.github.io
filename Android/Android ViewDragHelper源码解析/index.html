<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rickyqliu.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。 要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Android ViewDragHelper源码解析">
<meta property="og:url" content="http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Ricky.L的随笔">
<meta property="og:description" content="前言在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。 要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/picportal/pic/raw/master/img/20210827220255.png">
<meta property="og:image" content="https://gitee.com/picportal/pic/raw/master/img/20210827220313.png">
<meta property="article:published_time" content="2015-05-21T09:58:17.000Z">
<meta property="article:modified_time" content="2021-09-02T03:22:31.097Z">
<meta property="article:author" content="Ricky.L">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="ViewDragHelper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/picportal/pic/raw/master/img/20210827220255.png">

<link rel="canonical" href="http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android ViewDragHelper源码解析 | Ricky.L的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ricky.L的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Ricky.L">
      <meta itemprop="description" content="Follow your heart">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky.L的随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android ViewDragHelper源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-05-21 17:58:17" itemprop="dateCreated datePublished" datetime="2015-05-21T17:58:17+08:00">2015-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 11:22:31" itemprop="dateModified" datetime="2021-09-02T11:22:31+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Android/Android ViewDragHelper源码解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p>在自定义ViewGroup的构造方法里调用<code>ViewDragHelper</code>的静态工厂方法<code>create</code>()创建<code>ViewDragHelper</code>实例</p>
</li>
<li><p>实现<code>ViewDragHelper.Callback</code><br>最重要的几个方法是</p>
<ul>
<li><code>tryCaptureView()</code>里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>clampViewPositionVertical()</code>决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>
<li><code>clampViewPositionHorizontal()</code>与<code>clampViewPositionVertical()</code>同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>
<li><code>getViewVerticalDragRange()</code>要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>
<li><code>getViewHorizontalDragRange()</code>与<code>getViewVerticalDragRange()</code>同理，只不过是发生在水平方向上。</li>
</ul>
</li>
<li><p>在<code>onInterceptTouchEvent()</code>方法里调用并返回<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>方法</p>
</li>
<li><p>在<code>onTouchEvent()</code>方法里调用<code>ViewDragHelper()</code>的<code>processTouchEvent()</code>方法。<code>ACTION_DOWN</code>事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在<code>onTouchEvent()</code>返回<code>true</code>，否则将收不到后续事件，不会产生拖动。</p>
</li>
<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的<code>computeScroll()</code>方法，方法实现如下：</p>
<pre><code> @Override
 public void computeScroll() &#123;
     if (mDragHelper.continueSettling(true)) &#123;
         postInvalidate();
     &#125;
 &#125;
</code></pre>
<p>并在<code>ViewDragHelper.Callback</code>的<code>onViewReleased()</code>方法里调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>，或在任意地方调用<code>smoothSlideViewTo()</code>方法。</p>
</li>
<li><p>如果要实现边缘拖动的效果，需要调用<code>ViewDragHelper</code>的<code>setEdgeTrackingEnabled()</code>方法，注册想要监听的边缘。然后实现<code>ViewDragHelper.Callback</code>里的<code>onEdgeDragStarted()</code>方法，在此手动调用<code>captureChildView()</code>传递要拖动的子View。</p>
</li>
</ol>
<p>具体的使用Demo请见最后面公布的几个案例。</p>
<h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><p>ViewDragHelper的完整源码可在<a target="_blank" rel="noopener" href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java">GitHub</a>或<a target="_blank" rel="noopener" href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol>
<li>了解View的坐标系统，<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a></li>
<li>了解MotionEvent中关于多点触控的机制，<a target="_blank" rel="noopener" href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a></li>
<li>了解Scroller类原理，<a target="_blank" rel="noopener" href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li>了解Touch事件的分发机制，<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>
</ol>
<h3 id="ViewDragHelper实例的创建"><a href="#ViewDragHelper实例的创建" class="headerlink" title="ViewDragHelper实例的创建"></a>ViewDragHelper实例的创建</h3><p><code>ViewDragHelper</code>重载了两个<code>create()</code>静态方法，先看两个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code>的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。<code>create()</code>直接调用了<code>ViewDragHelper</code>构造方法，我们再来看看这个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apps should use ViewDragHelper.create() to get a new instance.</span></span><br><span class="line"><span class="comment"> * This will allow VDH to use internal compatibility implementations for different</span></span><br><span class="line"><span class="comment"> * platform versions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parent view may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Callback may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mParentView = forParent;</span><br><span class="line">	mCallback = cb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">	mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">	mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">	mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">	mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">	mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过<code>create()</code>工厂方法来创建<code>ViewDragHelper</code>实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li><code>mParentView</code>和<code>mCallback</code>分别保存传递过来的对应参数</li>
<li><code>ViewConfiguration</code>类里定义了<code>View</code>相关的一系列时间、大小、距离等常量</li>
<li><code>mEdgeSize</code>表示边缘触摸的范围。例如<code>mEdgeSize</code>为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于<code>mParentView.getLeft() + mEdgeSize</code>时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见<code>ViewDragHelper</code>的<code>getEdgesTouched()</code>方法。</li>
<li><code>mTouchSlop</code>是一个很小的距离值，只有在前后两次触摸点的距离超过<code>mTouchSlop</code>的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>
<li><code>mMaxVelocity</code>、<code>mMinVelocity</code>是fling时的最大、最小速率，单位是像素每秒。</li>
<li><code>mScroller</code>是<code>View</code>滚动的辅助类，该类的详细解析参见下面几篇文章<ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html">Android中Scroller类的分析</a></li>
</ul>
</li>
</ul>
<p>再看三个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span></span><br><span class="line"><span class="comment"> *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">	helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">	<span class="keyword">return</span> helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数<code>sensitivity</code>是用来调节<code>mTouchSlop</code>的值。<code>sensitivity</code>越大，<code>mTouchSlop</code>越小，对滑动的检测就越敏感。例如<code>sensitivity</code>为1时，前后触摸点距离超过20dp才进行滑动处理，现在<code>sensitivity</code>为2的话，前后触摸点距离超过10dp就进行处理了。</p>
<h3 id="对Touch事件的处理"><a href="#对Touch事件的处理" class="headerlink" title="对Touch事件的处理"></a>对Touch事件的处理</h3><p>当<code>mParentView</code>（自定义ViewGroup）被触摸时，首先会调用<code>mParentView</code>的<code>onInterceptTouchEvent(MotionEvent ev)</code>，接着就调用<code>shouldInterceptTouchEvent(MotionEvent ev)</code> ，所以先来看看这个方法的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if this event as provided to the parent view&#x27;s onInterceptTouchEvent should</span></span><br><span class="line"><span class="comment"> * cause the parent to intercept the touch event stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看9~21行，首先是关于多点触控（<code>MotionEvent</code>的<code>actionIndex</code>、<code>ACTION_POINTER_DOWN </code>等概念），不明白的请参阅<a target="_blank" rel="noopener" href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a>。</p>
<p><code>mVelocityTracker</code>记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生<code>ACTION_DOWN</code>事件都会调用<code>cancel()</code>，而在<code>cancel()</code>方法里<code>mVelocityTracker</code>又被清空了，所以<code>mVelocityTracker </code>记录下的是本次<code>ACTION_DOWN</code>事件直至<code>ACTION_UP</code>事件发生后（下次<code>ACTION_DOWN</code>事件发生前）的所有触摸点的信息。</p>
<p>再来看24~42行<code>case MotionEvent.ACTION_DOWN</code>部分，先是调用<code>saveInitialMotion(x, y, pointerId)</code>保存手势的初始信息，即<code>ACTION_DOWN</code>发生时的触摸点坐标（x、y）、触摸手指编号（<code>pointerId</code>），如果触摸到了<code>mParentView</code>的边缘还会记录触摸的是哪个边缘。接着调用<code>findTopChildUnder((int) x, (int) y);</code>来获取当前触摸点下最顶层的子View，看<code>findTopChildUnder </code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the topmost child under the given point within the parent view&#x27;s coordinate system.</span></span><br><span class="line"><span class="comment"> * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x X position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y Y position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">				y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">			<span class="keyword">return</span> child;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现<code>Callback</code>里的<code>getOrderedChildIndex(int index)</code>方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（<code>getOrderedChildIndex()</code>默认直接返回<code>index</code>），会选择到topView，要想让bottomView被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">	<span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">	<span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">		<span class="keyword">return</span> indexBottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32~35行，这里还看到了一个<code>mDragState</code>成员变量，它共有三种取值：</p>
<ol>
<li><code>STATE_IDLE</code>：所有的View处于静止空闲状态</li>
<li><code>STATE_DRAGGING</code>：某个View正在被用户拖动（用户正在与设备交互）</li>
<li><code>STATE_SETTLING</code>：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br><code>mCapturedView</code>默认为<code>null</code>，所以一开始不会执行这里的代码，<code>mDragState</code>处于<code>STATE_SETTLING</code>状态时才会执行<code>tryCaptureViewForDrag()</code>，执行的情况到后面再分析，这里先跳过。</li>
</ol>
<p>37~40行调用了<code>Callback.onEdgeTouched</code>向外部通知<code>mParentView</code>的某些边缘被触摸到了，<code>mInitialEdgesTouched</code>是在刚才调用过的<code>saveInitialMotion</code>方法里进行赋值的。</p>
<p><code>ACTION_DOWN </code>部分处理完了，跳过<code>switch</code>语句块，剩下的代码就只有<code>return mDragState == STATE_DRAGGING;</code>。在<code>ACTION_DOWN</code>部分没有对<code>mDragState</code>进行赋值，其默认值为<code>STATE_IDLE</code>，所以此处返回<code>false</code>。</p>
<p>那么返回<code>false</code>后接下来应该是会调用哪个方法呢，根据<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在<code>mParentView</code>的所有子View中寻找响应这个Touch事件的View（会调用每个子View的<code>dispatchTouchEvent()</code>方法，<code>dispatchTouchEvent</code>里一般又会调用<code>onTouchEvent()</code>）；</p>
<ul>
<li><p>如果没有子View消费这次事件（子View的<code>dispatchTouchEvent()</code>返回都是<code>false</code>），会调用<code>mParentView</code>的<code>super.dispatchTouchEvent(ev)</code>，即<code>View</code>中的<code>dispatchTouchEvent(ev)</code>，然后调用<code>mParentView</code>的<code>onTouchEvent()</code>方法，再调用<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>方法。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动（除了<code>ACTION_DOWN</code>外的其他事件发生时返回<code>true</code>或<code>false</code>都不会影响接下来的事件接受），因为拖动的相关代码是写在<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分的。要注意的是返回<code>true</code>后<code>mParentView</code>的<code>onInterceptTouchEvent()</code>就不会收到后续的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件了。</p>
</li>
<li><p>如果有子View消费了本次<code>ACTION_DOWN</code>事件，<code>mParentView</code>的<code>onTouchEvent()</code>就收不到<code>ACTION_DOWN</code>事件了，也就是<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>收不到<code>ACTION_DOWN</code>事件了。不过只要该View没有调用过<code>requestDisallowInterceptTouchEvent(true)</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分还是会执行的，如果在此时返回了<code>true</code>拦截了<code>ACTION_MOVE</code>事件，<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分也就会正常执行，拖动也就没问题了。<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分具体做了怎样的处理，稍后再来解析。</p>
</li>
</ul>
<p>接下来对这两种情况逐一解析。</p>
<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用<code>processTouchEvent(MotionEvent ev)</code>的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process a touch event received by the parent view. This method will dispatch callback events</span></span><br><span class="line"><span class="comment"> * as needed before returning. The parent view&#x27;s onTouchEvent implementation should call this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev The touch event received by the parent view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">			<span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">			<span class="comment">// Start immediately if possible.</span></span><br><span class="line">			tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跟<code>shouldInterceptTouchEvent()</code>里<code>ACTION_DOWN</code>那部分基本一致，唯一区别就是这里没有约束条件直接调用了<code>tryCaptureViewForDrag()</code>方法，现在来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to capture the view with the given pointer ID. The callback will be involved.</span></span><br><span class="line"><span class="comment"> * This will put us into the &quot;dragging&quot; state. If we&#x27;ve already captured this view with</span></span><br><span class="line"><span class="comment"> * this pointer this method will immediately return true without consulting the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCapture View to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pointerId Pointer to capture with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if capture was successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;</span><br><span class="line">		<span class="comment">// Already done!</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;</span><br><span class="line">		mActivePointerId = pointerId;</span><br><span class="line">		captureChildView(toCapture, pointerId);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>Callback</code>的<code>tryCaptureView(View child, int pointerId)</code>方法，把当前触摸到的View和触摸手指编号传递了过去，在<code>tryCaptureView()</code>中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在<code>tryCaptureView()</code>中返回<code>true</code>，让<code>ViewDragHelper</code>把当前触摸的View捕获下来，接着就调用了<code>captureChildView(toCapture, pointerId)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Capture a specific child view for dragging within the parent. The callback will be notified</span></span><br><span class="line"><span class="comment"> * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span></span><br><span class="line"><span class="comment"> * capture this view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childView Child view to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;captureChildView: parameter must be a descendant &quot;</span> +</span><br><span class="line">				<span class="string">&quot;of the ViewDragHelper&#x27;s tracked parent view (&quot;</span> + mParentView + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCapturedView = childView;</span><br><span class="line">	mActivePointerId = activePointerId;</span><br><span class="line">	mCallback.onViewCaptured(childView, activePointerId);</span><br><span class="line">	setDragState(STATE_DRAGGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，在<code>captureChildView(toCapture, pointerId)</code>中将要拖动的View和触摸的手指编号记录下来，并调用<code>Callback</code>的<code>onViewCaptured(childView, activePointerId)</code>通知外部有子View被捕获到了，再调用<code>setDragState()</code>设置当前的状态为<code>STATE_DRAGGING</code>，看<code>setDragState()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">		mDragState = state;</span><br><span class="line">		mCallback.onViewDragStateChanged(state);</span><br><span class="line">		<span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">			mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态改变后会调用<code>Callback</code>的<code>onViewDragStateChanged()</code>通知状态的变化。</p>
<p>假设<code>ACTION_DOWN</code>发生后在<code>mParentView</code>的<code>onTouchEvent()</code>返回了<code>true</code>，接下来就会执行<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);</span><br><span class="line"></span><br><span class="line">				dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</span><br><span class="line"></span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">					reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">					<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">						<span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">					<span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">							tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断<code>mDragState</code>是否为<code>STATE_DRAGGING</code>，而唯一调用<code>setDragState(STATE_DRAGGING)</code>的地方就是<code>tryCaptureViewForDrag()</code>了，刚才在<code>ACTION_DOWN</code>里调用过<code>tryCaptureViewForDrag()</code>，现在又要分两种情况。<br>如果刚才在<code>ACTION_DOWN</code>里捕获到要拖动的View，那么就执行<code>if</code>部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，<code>mDragState</code>依然是<code>STATE_IDLE</code>，然后会执行<code>else</code>部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让<code>mDragState</code>变为<code>STATE_DRAGGING</code>，之后就会执行<code>if</code>部分的代码了。这里还有两个方法涉及到了<code>Callback</code>里的方法，需要来解析一下，分别是<code>reportNewEdgeDrags()</code>和<code>checkTouchSlop()</code>，先看<code>reportNewEdgeDrags()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_LEFT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_TOP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_RIGHT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">		mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">		mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在<code>mEdgeDragsInProgress</code>中，再调用<code>Callback</code>的<code>onEdgeDragStarted(int edgeFlags, int pointerId)</code>通知某个边缘开始产生拖动了。虽然<code>reportNewEdgeDrags()</code>会被调用很多次（因为<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分会执行很多次），但<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code>只会调用一次，具体的要看<code>checkNewEdgeDrag()</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">			(mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;</span><br><span class="line">		mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>checkNewEdgeDrag()</code>返回<code>true</code>表示在指定的<code>edge</code>（边缘）开始产生拖动了。</li>
<li>方法的两个参数<code>delta</code>和<code>odelta</code>需要解释一下，<code>odelta</code>里的o应该代表opposite，这是什么意思呢，以<code>reportNewEdgeDrags()</code>里调用<code>checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)</code>为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里<code>delta</code>为<code>dx</code>，<code>odelta</code>为<code>dy</code>，也就是说<code>delta</code>是指我们主要监测的方向上的变化，<code>odelta</code>是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>
<li><code>mInitialEdgesTouched</code>是在<code>ACTION_DOWN</code>部分的<code>saveInitialMotion()</code>里生成的，<code>ACTION_DOWN</code>发生时触摸到的边缘会被记录在<code>mInitialEdgesTouched</code>中。如果<code>ACTION_DOWN</code>发生时没有触摸到边缘，或者触摸到的边缘不是指定的<code>edge</code>，就直接返回false了。</li>
<li><code>mTrackingEdges</code>是由<code>setEdgeTrackingEnabled(int edgeFlags)</code>设置的，当我们想要追踪监听边缘触摸时才需要调用<code>setEdgeTrackingEnabled(int edgeFlags)</code>，如果我们没有调用过它，这里就直接返回<code>false</code>了。</li>
<li><code>mEdgeDragsLocked</code>它在这个方法里被引用了多次，它在整个<code>ViewDragHelper</code>里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行<code>mEdgeDragsLocked[pointerId] &amp; edge) == edge</code>执行的结果是<code>false</code>。我们再跳到11到14行看看，<code>absDelta &lt; absODelta * 0.5f</code>的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用<code>Callback</code>的<code>onEdgeLock(edge)</code>检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在<code>mEdgeDragsInProgress</code>里了，也不会收到<code>Callback</code>的<code>onEdgeDragStarted()</code>通知了。并且将锁定的边缘记录在<code>mEdgeDragsLocked</code>变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的<code>edge</code>被锁定，就直接返回<code>false</code>了。</li>
<li>回到第7行的<code>(mEdgeDragsInProgress[pointerId] &amp; edge) == edge</code>，<code>mEdgeDragsInProgress</code>是保存已发生过拖动事件的边缘的，如果给定的<code>edge</code>已经保存过了，那就没必要再检测其他东西了，直接返回<code>false</code>了。</li>
<li>第8行<code>(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)</code>很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>
<li>最后一句返回的时候再次检查给定的<code>edge</code>有没有记录过，确保了每个边缘只会调用一次<code>reportNewEdgeDrags</code>的<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code></li>
</ul>
<p>再来看<code>checkTouchSlop()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if we&#x27;ve crossed a reasonable touch slop for the given child view.</span></span><br><span class="line"><span class="comment"> * If the child cannot be dragged along the horizontal or vertical axis, motion</span></span><br><span class="line"><span class="comment"> * along that axis will not count toward the slop check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx Motion since initial position along X axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the touch slop has been crossed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（<code>mTouchSlop</code>）了，注意<code>dx</code>和<code>dy</code>指的是当前触摸点到<code>ACTION_DOWN</code>触摸到的点的距离。这里先检查<code>Callback</code>的<code>getViewHorizontalDragRange(child)</code>和<code>getViewVerticalDragRange(child)</code>是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分就不会调用<code>tryCaptureViewForDrag()</code>来捕获当前触摸到的View了，拖动也就没办法进行了。</p>
<p>回到<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了<code>Callback</code>中的相关方法，让<code>tryCaptureViewForDrag()</code>正常的捕获到触摸到的View了，下一次<code>ACTION_MOVE</code>时就执行<code>if</code>部分的代码了，也就是开始不停的调用<code>dragTo()</code>对<code>mCaptureView</code>进行真正拖动了，看<code>dragTo()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clampedX = left;</span><br><span class="line">	<span class="keyword">int</span> clampedY = top;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</span><br><span class="line">		mCapturedView.offsetLeftAndRight(clampedX - oldLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</span><br><span class="line">		mCapturedView.offsetTopAndBottom(clampedY - oldTop);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">		mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">				clampedDx, clampedDy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>dx</code>和<code>dy</code>是前后两次<code>ACTION_MOVE</code>移动的距离，<code>left</code>和<code>top</code>分别为<code>mCapturedView.getLeft() + dx</code>, <code>mCapturedView.getTop() + dy</code>，也就是期望的移动后的坐标，对<code>View</code>的<code>getLeft()</code>等方法不理解的请参阅<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>
<p>这里通过调用<code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>来完成对<code>mCapturedView</code>移动，这两个是<code>View</code>中定义的方法，看它们的源码就知道内部是通过改变<code>View</code>的<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>、<code>mBottom</code>，即改变<code>View</code>在父容器中的坐标位置，达到移动<code>View</code>的效果，所以如果调用<code>mCapturedView</code>的<code>layout(int l, int t, int r, int b)</code>方法也可以实现移动<code>View</code>的效果。</p>
<p>具体要移动到哪里，由<code>Callback</code>的<code>clampViewPositionHorizontal()</code>和<code>clampViewPositionVertical()</code>来决定的，如果不想在水平方向上移动，在<code>clampViewPositionHorizontal(View child, int left, int dx)</code>里直接返回<code>child.getLeft()</code>就可以了，这样<code>clampedX - oldLeft</code>的值为0，这里调用<code>mCapturedView.offsetLeftAndRight(clampedX - oldLeft)</code>就不会起作用了。垂直方向上同理。</p>
<p>最后会调用<code>Callback</code>的<code>onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)</code>通知捕获到的View位置改变了，并把最终的坐标（<code>clampedX</code>、<code>clampedY</code>）和最终的移动距离（<code>clampedDx</code>、 <code>clampedDy</code>）传递过去。</p>
<p><code>ACTION_MOVE</code>部分就算告一段落了，接下来应该是用户松手触发<code>ACTION_UP</code>，或者是达到某个条件导致后续的<code>ACTION_MOVE</code>被<code>mParentView</code>的上层View给拦截了而收到<code>ACTION_CANCEL</code>，一起来看这两个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				releaseViewForPointerUp();</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下<code>releaseViewForPointerUp()</code>和<code>dispatchViewReleased()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releaseViewForPointerUp()</code>里也调用了<code>dispatchViewReleased()</code>，只不过传递了速率给它，这个速率就是由<code>processTouchEvent()</code>的<code>mVelocityTracker</code>追踪算出来的。再看<code>dispatchViewReleased()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like all callback events this must happen on the UI thread, but release</span></span><br><span class="line"><span class="comment"> * involves some extra semantics. During a release (mReleaseInProgress)</span></span><br><span class="line"><span class="comment"> * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">	mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">	mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">	mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">		<span class="comment">// onViewReleased didn&#x27;t call a method that would have changed this. Go idle.</span></span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>Callback</code>的<code>onViewReleased(mCapturedView, xvel, yvel)</code>通知外部捕获到的View被释放了，而在<code>onViewReleased()</code>前后有个<code>mReleaseInProgress</code>值得注意，注释里说唯一可以调用<code>ViewDragHelper</code>的<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方就是在<code>Callback</code>的<code>onViewReleased()</code>里了。</p>
<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（<code>flingCapturedView</code>的四个参数<code>int minLeft, int minTop, int maxLeft, int maxTop</code>可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用<code>settleCapturedViewAt(int finalLeft, int finalTop)</code>。</p>
<p>为什么唯一可以调用<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方是<code>Callback</code>的<code>onViewReleased()</code>呢？看看它们的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * The appropriate velocity from prior motion will be taken into account.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot settleCapturedViewAt outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view based on standard free-moving fling behavior.</span></span><br><span class="line"><span class="comment"> * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span></span><br><span class="line"><span class="comment"> * to continue the motion until it returns false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minLeft Minimum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minTop Minimum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLeft Maximum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxTop Maximum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot flingCapturedView outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法里一开始都会判断<code>mReleaseInProgress</code>为<code>false</code>，如果为<code>false</code>就会抛一个<code>IllegalStateException</code>异常，而<code>mReleaseInProgress</code>唯一为<code>true</code>的时候就是在<code>dispatchViewReleased()</code>里调用<code>onViewReleased()</code>的时候。</p>
<p><code>Scroller</code>的用法请参阅<a target="_blank" rel="noopener" href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读<code>Scroller</code>源码，代码量不多。</p>
<p><code>ViewDragHelper</code>还有一个移动View的方法是<code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code>，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span></span><br><span class="line"><span class="comment"> * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child view to capture and animate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Final left position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Final top position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	mCapturedView = child;</span><br><span class="line">	mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If we&#x27;re in an IDLE state to begin with and aren&#x27;t moving anywhere, we</span></span><br><span class="line">		<span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">		mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> continueSliding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它不受<code>mReleaseInProgress</code>的限制，所以可以在任何地方调用，效果和<code>settleCapturedViewAt()</code>类似，因为它们最终都调用了<code>forceSettleCapturedViewAt()</code>来启动自动滚动，区别在于<code>settleCapturedViewAt()</code>会以最后松手前的滑动速率为初速度将View滚动到最终位置，而<code>smoothSlideViewTo()</code>滚动的初速度是0。<code>forceSettleCapturedViewAt()</code>里有地方调用了<code>Callback</code>里的方法，所以再来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Target top position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xvel Horizontal velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> yvel Vertical velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">		mScroller.abortAnimation();</span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">	mScroller.startScroll(startLeft, startTop, dx, dy, duration);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到自动滑动是靠<code>Scroll</code>类完成，在这里生成了调用<code>mScroller.startScroll()</code>需要的参数。再来看看计算滚动时间的方法<code>computeSettleDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">	<span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clampMag()</code>方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过<code>computeAxisDuration()</code>算出来，通过它的参数可以看到最终的滚动时间是由<code>dx</code>、<code>xvel</code>、<code>mCallback.getViewHorizontalDragRange()</code>共同影响的。看<code>computeAxisDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">			distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> duration;</span><br><span class="line">	velocity = Math.abs(velocity);</span><br><span class="line">	<span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">		duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6<del>10行没看明白，直接看14</del>19行，如果给定的速率<code>velocity</code>不为0，就通过距离除以速率来算出时间；如果<code>velocity</code>为0，就通过要滑动的距离（<code>delta</code>）除以总的移动范围（<code>motionRange</code>，就是<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过<code>MAX_SETTLE_DURATION</code>的，源码里的取值是600毫秒，所以不用担心在<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回错误的数而导致自动滚动时间过长了。</p>
<p>在调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>和<code>smoothSlideViewTo()</code>时，还需要实现<code>mParentView</code>的<code>computeScroll()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这属于<code>Scroll</code>类用法的范畴，不明白的请参阅<a target="_blank" rel="noopener" href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>
<p>至此，整个触摸流程和<code>ViewDragHelper</code>的重要的方法都过了一遍。之前在讨论<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次<code>ACTION_DOWN</code>事件的情况，现在来看看这种情况。</p>
<p>假设现在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完了，也有子View消费了这次的<code>ACTION_DOWN</code>事件，那么接下来就会调用<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分，不明白为什么的请参阅<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">				<span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">					<span class="comment">// check the callback&#x27;s</span></span><br><span class="line">					<span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">					<span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">					<span class="comment">// would clamp to the same value. If you can&#x27;t move at</span></span><br><span class="line">					<span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">							targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">							(<span class="keyword">int</span>) dy);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">							toCapture);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">					<span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">							&amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">							|| verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">				<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">					<span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			saveLastMotion(ev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用<code>findTopChildUnder(int x, int y)</code>寻找触摸点处的子View，再用<code>checkTouchSlop(View child, float dx, float dy)</code>检查当前触摸点到<code>ACTION_DOWN</code>触摸点的距离是否达到了<code>mTouchSlop</code>，达到了才会去捕获View。<br>接着看19~41行<code>if (pastSlop)&#123;...&#125;</code>部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到<code>getView[Horizontal|Vertical]DragRange</code>和<code>clampViewPosition[Horizontal|Vertical]</code>四个方法。如果<code>getView[Horizontal|Vertical]DragRange</code>返回都是0，就会认作是不会产生拖动。<code>clampViewPosition[Horizontal|Vertical]</code>返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接<code>break</code>，不会执行后续的代码，而后续代码里有调用<code>tryCaptureViewForDrag()</code>，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的<code>tryCaptureViewForDrag()</code>捕获子View，如果捕获成功，<code>mDragState</code>就会变成<code>STATE_DRAGGING</code>，<code>shouldInterceptTouchEvent()</code>返回<code>true</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，后续的移动事件就会在<code>mParentView</code>的<code>onTouchEvent()</code>执行了，最后执行的就是<code>mParentView</code>的<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，拖动正常进行。</p>
<p>回头再看之前在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分留下的坑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他部分...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的<code>tryCaptureViewForDrag()</code>尝试捕获View，如果捕获成功，<code>mDragState</code>就变为<code>STATE_DRAGGING</code>了，<code>shouldInterceptTouchEvent()</code>就返回<code>true</code>了，然后就是<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，接着执行<code>mParentView</code>的<code>onTouchEvent()</code>，再执行<code>processTouchEvent()</code>的<code>ACTION_DOWN</code>部分。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动。</p>
<p>至此整个事件传递流程和<code>ViewDragHelper</code>的重要方法基本都解析完了，<code>shouldInterceptTouchEvent()</code>和<code>processTouchEvent()</code>的<code>ACTION_POINTER_DOWN</code>、<code>ACTION_POINTER_UP</code>部分就留给读者自己解析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.processon.com/view/link/5550a7bae4b09739f465ec64">单点触摸，没有考虑边缘滑动检测的最简流程图</a><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827220255.png"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.processon.com/view/link/5550d3dce4b09739f46789bd">单点触摸，考虑了边缘滑动检测的流程图</a><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827220313.png"></p>
</li>
</ul>
<p>多点触摸情况我就没研究了，在这里忽略~</p>
<p>三个开启自动滚动的方法：</p>
<ul>
<li><code>settleCapturedViewAt(int finalLeft, int finalTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code><br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>
</ul>
<p><code>Callback</code>的各个方法总结：</p>
<ul>
<li><p><code>void onViewDragStateChanged(int state)</code><br>拖动状态改变时会调用此方法，状态<code>state</code>有<code>STATE_IDLE</code>、<code>STATE_DRAGGING</code>、<code>STATE_SETTLING</code>三种取值。<br>它在<code>setDragState()</code>里被调用，而<code>setDragState()</code>被调用的地方有</p>
<ul>
<li><code>tryCaptureViewForDrag()</code>成功捕获到子View时<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分捕获到</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
</ul>
</li>
<li>调用<code>settleCapturedViewAt()</code>、<code>smoothSlideViewTo()</code>、<code>flingCapturedView()</code>时</li>
<li>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>、<code>ACTION_CANCEL</code>）</li>
<li>自动滚动停止时（<code>continueSettling()</code>里检测到滚动结束时）</li>
<li>外部调用<code>abort()</code>时</li>
</ul>
</li>
<li><p><code>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</code><br>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>
<ul>
<li>在<code>dragTo()</code>里被调用（正在被拖动时）</li>
<li>在<code>continueSettling()</code>里被调用（自动滚动时）</li>
<li>外部调用<code>abort()</code>时被调用</li>
</ul>
</li>
<li><p><code>void onViewCaptured(View capturedChild, int activePointerId)</code><br><code>tryCaptureViewForDrag()</code>成功捕获到子View时会调用此方法。</p>
<ul>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里成功捕获</li>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>手动调用<code>captureChildView()</code></li>
</ul>
</li>
<li><p><code>void onViewReleased(View releasedChild, float xvel, float yvel)</code><br>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>）或被父View拦截事件时（<code>processTouchEvent()</code>的<code>ACTION_CANCEL</code>）会调用此方法。</p>
</li>
<li><p><code>void onEdgeTouched(int edgeFlags, int pointerId)</code><br><code>ACTION_DOWN</code>或<code>ACTION_POINTER_DOWN</code>事件发生时如果触摸到监听的边缘会调用此方法。<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。</p>
</li>
<li><p><code>boolean onEdgeLock(int edgeFlags)</code><br>返回<code>true</code>表示锁定<code>edgeFlags</code>对应的边缘，锁定后的那些边缘就不会在<code>onEdgeDragStarted()</code>被通知了，默认返回<code>false</code>不锁定给定的边缘，<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>其中之一。</p>
</li>
<li><p><code>void onEdgeDragStarted(int edgeFlags, int pointerId)</code><br><code>ACTION_MOVE</code>事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。<code>edgeFlags</code>取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。可在此手动调用<code>captureChildView()</code>触发从边缘拖动子View的效果。</p>
</li>
<li><p><code>int getOrderedChildIndex(int index)</code><br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给<code>tryCaptureViewForDrag()</code>来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>
</li>
<li><p><code>int getViewHorizontalDragRange(View child)</code>、<code>int getViewVerticalDragRange(View child)</code><br>返回给定的<code>child</code>在相应的方向上可以被拖动的最远距离，默认返回0。<code>ACTION_DOWN</code>发生时，若触摸点处的<code>child</code>消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。<br>被调用的地方有三处：</p>
<ul>
<li>在<code>checkTouchSlop()</code>中被调用，返回值大于0才会去检查<code>mTouchSlop</code>。在<code>ACTION_MOVE</code>里调用<code>tryCaptureViewForDrag()</code>之前会调用<code>checkTouchSlop()</code>。如果<code>checkTouchSlop()</code>失败，就不会去捕获View了。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>
<li>在调用<code>smoothSlideViewTo()</code>时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在<code>getView[Horizontal|Vertical]DragRange</code>里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>
</ul>
</li>
<li><p><code>boolean tryCaptureView(View child, int pointerId)</code><br>在<code>tryCaptureViewForDrag()</code>中被调用，返回<code>true</code>表示捕获给定的<code>child</code>。<code>tryCaptureViewForDrag()</code>被调用的地方有</p>
<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
</ul>
</li>
<li><p><code>int clampViewPositionHorizontal(View child, int left, int dx)</code>、<code>int clampViewPositionVertical(View child, int top, int dy)</code><br><code>child</code>在某方向上被拖动时会调用对应方法，返回值是<code>child</code>移动过后的坐标位置，<code>clampViewPositionHorizontal()</code>返回<code>child</code>移动过后的left值，<code>clampViewPositionVertical()</code>返回<code>child</code>移动过后的top值。<br>两个方法被调用的地方有两处：</p>
<ul>
<li>在<code>dragTo()</code>中被调用，<code>dragTo()</code>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里被调用。用来获取被拖动的View要移动到的位置。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>
</ul>
</li>
</ul>
<h2 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h2><p>在这里列举一部分对<code>ViewDragHelper</code>的应用案例，大家自己剖析它们的源码来实践巩固。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a>，这是最简单的Demo</li>
<li><a target="_blank" rel="noopener" href="https://github.com/BlueMor/DragLayout">QQ5.x侧滑菜单</a>、<a target="_blank" rel="noopener" href="https://github.com/kyze8439690/ResideLayout">ResideLayout</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a>、<a target="_blank" rel="noopener" href="https://github.com/liuguangqiang/SwipeBack">SwipeBack</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/umano/AndroidSlidingUpPanel">SlidingUpPanel</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java">DrawerLayout</a></li>
</ol>
<h2 id="其他关于ViewDragHelper的分析文章"><a href="#其他关于ViewDragHelper的分析文章" class="headerlink" title="其他关于ViewDragHelper的分析文章"></a>其他关于ViewDragHelper的分析文章</h2><ul>
<li><a target="_blank" rel="noopener" href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a target="_blank" rel="noopener" href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/pi9nc/article/details/39583377">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Ricky.L
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Android ViewDragHelper源码解析">http://rickyqliu.github.io/Android/Android ViewDragHelper源码解析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
              <a href="/tags/ViewDragHelper/" rel="tag"># ViewDragHelper</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Android/Android%20Task/" rel="prev" title="Android Task">
      <i class="fa fa-chevron-left"></i> Android Task
    </a></div>
      <div class="post-nav-item">
    <a href="/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/" rel="next" title="序列化：Serializable与Parceable">
      序列化：Serializable与Parceable <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">源码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="nav-number">3.1.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewDragHelper%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.2.</span> <span class="nav-text">ViewDragHelper实例的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9Touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">对Touch事件的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">案例参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%85%B3%E4%BA%8EViewDragHelper%E7%9A%84%E5%88%86%E6%9E%90%E6%96%87%E7%AB%A0"><span class="nav-number">6.</span> <span class="nav-text">其他关于ViewDragHelper的分析文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky.L"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ricky.L</p>
  <div class="site-description" itemprop="description">Follow your heart</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">251</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AvatarQing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AvatarQing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/2011291/ricky" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;2011291&#x2F;ricky" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/avatarqing/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;avatarqing&#x2F;" rel="noopener" target="_blank"><i class="fab fa-leetcode fa-fw"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ricky.q.liu@foxmail.com" title="E-Mail → ricky.q.liu@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky.L</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rickyqliu-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://rickyqliu.github.io/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/";
    this.page.identifier = "Android/Android ViewDragHelper源码解析/";
    this.page.title = "Android ViewDragHelper源码解析";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://rickyqliu-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
