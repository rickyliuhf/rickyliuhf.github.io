<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Task 相关</title>
    <url>/Android/Task/2015-07-20-android-task-about/</url>
    <content><![CDATA[<p>在日常开发过程中，只要涉及到activity，那么对task相关的东西总会或多或少的接触到，不过对task相关的一些配置的作用理解的还不是很透彻，官方文档在细节上说的也不够清楚，要透彻理解还是得自己写demo实践检验，所以便有了这篇总结。</p>
<span id="more"></span>

<h2 id="task的概念"><a href="#task的概念" class="headerlink" title="task的概念"></a>task的概念</h2><p>参考<a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></p>
<h2 id="查看设备当前task的方法"><a href="#查看设备当前task的方法" class="headerlink" title="查看设备当前task的方法"></a>查看设备当前task的方法</h2><ul>
<li><a href="http://stackoverflow.com/questions/2442713/view-the-tasks-activity-stack">View the Task’s activity stack</a></li>
<li><a href="http://stackoverflow.com/a/22392616/2011291">Show Back Stack of Android</a></li>
</ul>
<h2 id="AndroidManifest中activity标签下和task有关的属性"><a href="#AndroidManifest中activity标签下和task有关的属性" class="headerlink" title="AndroidManifest中activity标签下和task有关的属性"></a>AndroidManifest中activity标签下和task有关的属性</h2><h3 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#aff">taskAffinity</a></h3><ul>
<li>此属性用来标记activity应该属于哪个task。</li>
<li>拥有相同affinity的activity从理论上属于同一个task（在用户的角度看来好像这些activity属于同一个应用），一个task的affinity是由其根activity的taskAffinity取值决定的。</li>
<li>affinity决定了两件事。<ul>
<li>一个是在使用allowTaskReparenting修饰activity时，activity要重新宿主到哪个task。</li>
<li>另一个是使用FLAG_ACTIVITY_NEW_TASK启动activity时，activity要放入哪个task。</li>
</ul>
</li>
<li>如果没有给activity设置taskAffinity，默认都会读取application标签下的taskAffinity属性值，如果application标签下也没有设置taskAffinity，那taskAffinity默认值就是manifest标签下设置的包名。</li>
<li>不仅可以给同一个应用的不同activity设置不同的affinity，也可以给不同应用的activity设置相同的affinity，使它们在用户角度看来好像属于同一个应用。</li>
</ul>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#lmode">launchMode</a></h3><p>launchMode有四种取值，与Intent里以<code>FLAG_ACTIVITY_</code>开头的flag结合，可以对activity的启动达到各种不同的效果。</p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>activity默认的启动模式，每次启动一个standard模式的activity时，都新建一个实例。</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>当前task栈顶存在本activity的实例，直接使用该实例，调用该activity的onNewIntent()，否则新建一个activity的实例入栈。</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>当启动一个singleTask模式的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。 </p>
<ul>
<li>如果存在，那么检查该task栈里是否存在该activity实例。<ul>
<li>如果存在，则将该task调入前台，销毁在该activity以上的activity，并调用该activity的onNewIntent()。</li>
<li>如果不存在，则新建一个该activity实例，并入栈。 </li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他activity，允许其他activity跟自己处于同一个task栈中，也允许其他activity重新宿主到本activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard。</p>
<ul>
<li>从B启动C，C是singleTask，C的affinity和A、B相同，C会进入taskA栈顶。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C相同，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C不同，D会进入新建的taskB中。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskB中，taskB的affinity为D的affinity。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
<li>从B启动C，C是singleTask，C的affinity和A、B不同，C会进入新建的taskB中。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B相同，D会进入taskA栈顶。<ul>
<li>从D启动C，taskB调入前台，放在taskA的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同但与C相同，D会进入新建的taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同且与C也不同，D会进入新建的taskC中。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskC中，taskC的affinity为D的affinity。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>当启动一个singleInstance的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。</p>
<ul>
<li>如果存在，检查这个task中是否存在该activity的实例。<ul>
<li>如果存在，则将该task调入前台，并调用该activity实例的onNewIntent()。</li>
<li>如果不存在，则新建一个task，再新建该activity实例放入新建的task中，系统允许多个相同affinity的task同时存在。</li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他任何activity，都会放到其他task中（新建task或者寻找已存在的task，即使要启动的activity与该activity具有相同的affinity），也不允许其他activity宿主到本task，该activity是task中唯一的activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard</p>
<ul>
<li>从B中启动C，C是singleInstance，C的affinity和A、B相同，C会放入新建的taskB中，taskA和taskB的affinity相同，因为两个task的根activity的affinity相同。<ul>
<li>从C中启动D，D的affinity和A、B、C相同。<ul>
<li>D是standard、singleTop、singleTask时，D会放入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA、taskB的affinity相同，因为三个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B、C不同，不论D是何种launchMode，D都会进入新建的taskC中，taskC的affinity是D的affinity。</li>
</ul>
</li>
<li>从B中启动C，C是singleInstance，C的affinity和A、B不同，C会放入新建的taskB中，taskA和taskB的affinity不同，因为两个task的根activity的affinity不同。<ul>
<li>从C中启动D，D的affinity和A、B相同。<ul>
<li>D是standard、singleTop、singleTask时，D都会进入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA的affinity相同，因为两个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B不同，不论和C是否相同，D都会进入新建的taskC中，因为C所在的task不允许其他activity的存在，taskC的affinity为D的affinity。</li>
</ul>
</li>
</ul>
<p>使用场景：<br>使用singleInstance时，尽量给此activity设置单独的taskAffinity，以保证此activity处于不同名的task中，这样在“最近应用”的列表中可以看到这个task。否则如果有相同task名称的task存在，在“最近应用”的列表中就看不到这个含有singleInstance的activity的task了，只能通过代码启动这个activity来切换回这个task中。<br>而两个不同的task在用户角度来看是两个不同的应用，也就是两种不同的功能，所以使用singleInstance的activity功能上要与其他activity的功能区别较大。并且singleInstance是单例，也就是这个activity是公用的，可以在其他地方启动它来重复使用（可以是被同一个应用的其他地方重复使用，也可以是被其他的应用重复使用）。<br>例如，UC浏览器中有一个可以浏览office文档的activity（launchMode为singleInstance，taskAffinity也是独立的），这显然不是浏览器的主要功能。在文件管理器中点击一个excel文件（或者word、ppt文档）的时候，可以选择使用UC浏览器的这个activity来打开它，并且从用户角度看起来这个activity和UC浏览器是两个不同的应用（在“最近应用”的列表中可以看出来）。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#reparent">allowTaskReparenting</a></h3><p>此属性为true的activity被启动后，若有和此activity相同affinity的task转入前台，则此activity会从启动它的task移动到具有相同affinity的这个task。</p>
<p>例如，现在有两个应用分别为appA和appB，appA中有三个activity分别为activityA1、activityA2、activityA3，其中activityA1、activityA2的taskAffinity为taskA，activityA3的taskAffinity为taskB，appB中有一个activity为activityB1，其taskAffinity为taskB。所有activity都是standard模式。<br>启动appA，默认启动activityA1，再依次启动activityA2、activityA3，此时这三个activity都属于taskA。<br>按home键回到launcher，此时这三个activity扔都属于taskA。</p>
<ul>
<li>此时若点击appA的图标启动appA，看到的是activityA2，activityA3会进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskA、Launcher所在的task、taskB。<ul>
<li>按home键回到launcher，点击appB的图标启动appB，taskB调入前台显示，看到的是activityA3，而不是activityB1。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。</li>
</ul>
</li>
<li>此时若点击appB的图标启动appB，看到的是activityA3，activityA3进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。taskB中还有activityB1在栈底部，在activityA3中按返回键可以回到activityB1。taskA中仅剩activityA1、activityA2。</li>
</ul>
<h3 id="alwaysRetainTaskState"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#always">alwaysRetainTaskState</a></h3><p>如果用户离开一个task已经很久了，系统会在某个时刻清理掉这个task中除了根activity外所有的activity。当用户再次回到这个task，只有根activity被恢复。这样做是因为长期离开一个task，用户很有可能已经放弃了他之前所做的事情，转而要开始做新的事情，所以只保留根activity。<br>若根activity上的alwaysRetainTaskState为true，强制保留本task中的所有activity，即使过了很长时间，也不让系统清理task。<br>例如浏览器打开了很多个tab页，长时间不操作后也要保证再次回来时还是上次浏览的页面。</p>
<h3 id="clearTaskOnLaunch"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#clear">clearTaskOnLaunch</a></h3><p>与alwaysRetainTaskState相反，若根activity上的clearTaskOnLaunch为true，不论何时用户再次从Launcher回到这个task时，除了根activity以外的其他activity都销毁。</p>
<h3 id="finishOnTaskLaunch"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#finish">finishOnTaskLaunch</a></h3><p>此属性为true的activity，不论何时用户再次回到这个activity所属的task时，此activity会被销毁。此属性优先级优于allowTaskReparenting。</p>
<h2 id="Intent中和task有关的部分flag"><a href="#Intent中和task有关的部分flag" class="headerlink" title="Intent中和task有关的部分flag"></a>Intent中和task有关的部分flag</h2><h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_NEW_TASK">FLAG_ACTIVITY_NEW_TASK</a></h3><p>和launchMode的属性值singleTask等效。如果一个Intent中包含此flag，尝试将要启动的activity放在一个新的task中，如果已经有一个task栈里存在目标activity的实例，将此task从后台调到前台来，调用已存在的activity实例的onNewIntent()方法。此flag不能用于startActivityForResult()。</p>
<h3 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_SINGLE_TOP">FLAG_ACTIVITY_SINGLE_TOP</a></h3><p>和launchMode的属性值singleTop等效。如果一个Intent中包含此属性，并且要启动的Activity就是当前的Activity（当前task栈顶activity），直接调用该activity的onNewIntent()，否则新建一个activity实例。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP">FLAG_ACTIVITY_CLEAR_TOP</a></h3><p>如果一个Intent中包含此属性，并且当前task栈存存在目标activity的实例，清除该实例上面的所有的activity。<br>如果目标activity的launcherMode为standard，且Intent没有添加FLAG_ACTIVITY_SINGLE_TOP标记，则会销毁目标activity再重新创建，否则会重用该实例，调用onNewIntent()。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET"><a href="#FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET" class="headerlink" title="FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET">FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</a></h3><p>如果一个Intent中包含此属性，则它转向的那个Activity以及在那个Activity其上的所有Activity都会在task重置时被清除出task，这只发生在task重置的时候，而从Launcher中点击应用图标启动应用的时候会发生task重置（从Launcher启动应用会在Intent中附带一个FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></li>
<li><a href="http://blog.csdn.net/ff20081528/article/details/17219951">Tasks and Back Stack中文翻译</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html">AndroidManifest中activity标签API Doc</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html">Intent API Doc</a></li>
<li><a href="http://blog.csdn.net/liuhe688/article/details/6761337">Activity的task相关</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Task</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Task</tag>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ViewDragHelper源码解析</title>
    <url>/Android/ViewDragHelper/2015-05-21-viewdraghelper-source-analysis/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p>在自定义ViewGroup的构造方法里调用<code>ViewDragHelper</code>的静态工厂方法<code>create</code>()创建<code>ViewDragHelper</code>实例</p>
</li>
<li><p>实现<code>ViewDragHelper.Callback</code><br>最重要的几个方法是</p>
<ul>
<li><code>tryCaptureView()</code>里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>clampViewPositionVertical()</code>决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>
<li><code>clampViewPositionHorizontal()</code>与<code>clampViewPositionVertical()</code>同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>
<li><code>getViewVerticalDragRange()</code>要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>
<li><code>getViewHorizontalDragRange()</code>与<code>getViewVerticalDragRange()</code>同理，只不过是发生在水平方向上。</li>
</ul>
</li>
<li><p>在<code>onInterceptTouchEvent()</code>方法里调用并返回<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>方法</p>
</li>
<li><p>在<code>onTouchEvent()</code>方法里调用<code>ViewDragHelper()</code>的<code>processTouchEvent()</code>方法。<code>ACTION_DOWN</code>事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在<code>onTouchEvent()</code>返回<code>true</code>，否则将收不到后续事件，不会产生拖动。</p>
</li>
<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的<code>computeScroll()</code>方法，方法实现如下：</p>
<pre><code> @Override
 public void computeScroll() &#123;
     if (mDragHelper.continueSettling(true)) &#123;
         postInvalidate();
     &#125;
 &#125;
</code></pre>
<p>并在<code>ViewDragHelper.Callback</code>的<code>onViewReleased()</code>方法里调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>，或在任意地方调用<code>smoothSlideViewTo()</code>方法。</p>
</li>
<li><p>如果要实现边缘拖动的效果，需要调用<code>ViewDragHelper</code>的<code>setEdgeTrackingEnabled()</code>方法，注册想要监听的边缘。然后实现<code>ViewDragHelper.Callback</code>里的<code>onEdgeDragStarted()</code>方法，在此手动调用<code>captureChildView()</code>传递要拖动的子View。</p>
</li>
</ol>
<p>具体的使用Demo请见最后面公布的几个案例。</p>
<h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><p>ViewDragHelper的完整源码可在<a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java">GitHub</a>或<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol>
<li>了解View的坐标系统，<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a></li>
<li>了解MotionEvent中关于多点触控的机制，<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a></li>
<li>了解Scroller类原理，<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li>了解Touch事件的分发机制，<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>
</ol>
<h3 id="ViewDragHelper实例的创建"><a href="#ViewDragHelper实例的创建" class="headerlink" title="ViewDragHelper实例的创建"></a>ViewDragHelper实例的创建</h3><p><code>ViewDragHelper</code>重载了两个<code>create()</code>静态方法，先看两个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code>的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。<code>create()</code>直接调用了<code>ViewDragHelper</code>构造方法，我们再来看看这个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apps should use ViewDragHelper.create() to get a new instance.</span></span><br><span class="line"><span class="comment"> * This will allow VDH to use internal compatibility implementations for different</span></span><br><span class="line"><span class="comment"> * platform versions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parent view may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Callback may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mParentView = forParent;</span><br><span class="line">	mCallback = cb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">	mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">	mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">	mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">	mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">	mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过<code>create()</code>工厂方法来创建<code>ViewDragHelper</code>实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li><code>mParentView</code>和<code>mCallback</code>分别保存传递过来的对应参数</li>
<li><code>ViewConfiguration</code>类里定义了<code>View</code>相关的一系列时间、大小、距离等常量</li>
<li><code>mEdgeSize</code>表示边缘触摸的范围。例如<code>mEdgeSize</code>为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于<code>mParentView.getLeft() + mEdgeSize</code>时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见<code>ViewDragHelper</code>的<code>getEdgesTouched()</code>方法。</li>
<li><code>mTouchSlop</code>是一个很小的距离值，只有在前后两次触摸点的距离超过<code>mTouchSlop</code>的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>
<li><code>mMaxVelocity</code>、<code>mMinVelocity</code>是fling时的最大、最小速率，单位是像素每秒。</li>
<li><code>mScroller</code>是<code>View</code>滚动的辅助类，该类的详细解析参见下面几篇文章<ul>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html">Android中Scroller类的分析</a></li>
</ul>
</li>
</ul>
<p>再看三个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span></span><br><span class="line"><span class="comment"> *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">	helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">	<span class="keyword">return</span> helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数<code>sensitivity</code>是用来调节<code>mTouchSlop</code>的值。<code>sensitivity</code>越大，<code>mTouchSlop</code>越小，对滑动的检测就越敏感。例如<code>sensitivity</code>为1时，前后触摸点距离超过20dp才进行滑动处理，现在<code>sensitivity</code>为2的话，前后触摸点距离超过10dp就进行处理了。</p>
<h3 id="对Touch事件的处理"><a href="#对Touch事件的处理" class="headerlink" title="对Touch事件的处理"></a>对Touch事件的处理</h3><p>当<code>mParentView</code>（自定义ViewGroup）被触摸时，首先会调用<code>mParentView</code>的<code>onInterceptTouchEvent(MotionEvent ev)</code>，接着就调用<code>shouldInterceptTouchEvent(MotionEvent ev)</code> ，所以先来看看这个方法的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if this event as provided to the parent view&#x27;s onInterceptTouchEvent should</span></span><br><span class="line"><span class="comment"> * cause the parent to intercept the touch event stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看9~21行，首先是关于多点触控（<code>MotionEvent</code>的<code>actionIndex</code>、<code>ACTION_POINTER_DOWN </code>等概念），不明白的请参阅<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a>。</p>
<p><code>mVelocityTracker</code>记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生<code>ACTION_DOWN</code>事件都会调用<code>cancel()</code>，而在<code>cancel()</code>方法里<code>mVelocityTracker</code>又被清空了，所以<code>mVelocityTracker </code>记录下的是本次<code>ACTION_DOWN</code>事件直至<code>ACTION_UP</code>事件发生后（下次<code>ACTION_DOWN</code>事件发生前）的所有触摸点的信息。</p>
<p>再来看24~42行<code>case MotionEvent.ACTION_DOWN</code>部分，先是调用<code>saveInitialMotion(x, y, pointerId)</code>保存手势的初始信息，即<code>ACTION_DOWN</code>发生时的触摸点坐标（x、y）、触摸手指编号（<code>pointerId</code>），如果触摸到了<code>mParentView</code>的边缘还会记录触摸的是哪个边缘。接着调用<code>findTopChildUnder((int) x, (int) y);</code>来获取当前触摸点下最顶层的子View，看<code>findTopChildUnder </code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the topmost child under the given point within the parent view&#x27;s coordinate system.</span></span><br><span class="line"><span class="comment"> * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x X position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y Y position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">				y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">			<span class="keyword">return</span> child;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现<code>Callback</code>里的<code>getOrderedChildIndex(int index)</code>方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（<code>getOrderedChildIndex()</code>默认直接返回<code>index</code>），会选择到topView，要想让bottomView被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">	<span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">	<span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">		<span class="keyword">return</span> indexBottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32~35行，这里还看到了一个<code>mDragState</code>成员变量，它共有三种取值：</p>
<ol>
<li><code>STATE_IDLE</code>：所有的View处于静止空闲状态</li>
<li><code>STATE_DRAGGING</code>：某个View正在被用户拖动（用户正在与设备交互）</li>
<li><code>STATE_SETTLING</code>：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br><code>mCapturedView</code>默认为<code>null</code>，所以一开始不会执行这里的代码，<code>mDragState</code>处于<code>STATE_SETTLING</code>状态时才会执行<code>tryCaptureViewForDrag()</code>，执行的情况到后面再分析，这里先跳过。</li>
</ol>
<p>37~40行调用了<code>Callback.onEdgeTouched</code>向外部通知<code>mParentView</code>的某些边缘被触摸到了，<code>mInitialEdgesTouched</code>是在刚才调用过的<code>saveInitialMotion</code>方法里进行赋值的。</p>
<p><code>ACTION_DOWN </code>部分处理完了，跳过<code>switch</code>语句块，剩下的代码就只有<code>return mDragState == STATE_DRAGGING;</code>。在<code>ACTION_DOWN</code>部分没有对<code>mDragState</code>进行赋值，其默认值为<code>STATE_IDLE</code>，所以此处返回<code>false</code>。</p>
<p>那么返回<code>false</code>后接下来应该是会调用哪个方法呢，根据<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在<code>mParentView</code>的所有子View中寻找响应这个Touch事件的View（会调用每个子View的<code>dispatchTouchEvent()</code>方法，<code>dispatchTouchEvent</code>里一般又会调用<code>onTouchEvent()</code>）；</p>
<ul>
<li><p>如果没有子View消费这次事件（子View的<code>dispatchTouchEvent()</code>返回都是<code>false</code>），会调用<code>mParentView</code>的<code>super.dispatchTouchEvent(ev)</code>，即<code>View</code>中的<code>dispatchTouchEvent(ev)</code>，然后调用<code>mParentView</code>的<code>onTouchEvent()</code>方法，再调用<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>方法。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动（除了<code>ACTION_DOWN</code>外的其他事件发生时返回<code>true</code>或<code>false</code>都不会影响接下来的事件接受），因为拖动的相关代码是写在<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分的。要注意的是返回<code>true</code>后<code>mParentView</code>的<code>onInterceptTouchEvent()</code>就不会收到后续的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件了。</p>
</li>
<li><p>如果有子View消费了本次<code>ACTION_DOWN</code>事件，<code>mParentView</code>的<code>onTouchEvent()</code>就收不到<code>ACTION_DOWN</code>事件了，也就是<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>收不到<code>ACTION_DOWN</code>事件了。不过只要该View没有调用过<code>requestDisallowInterceptTouchEvent(true)</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分还是会执行的，如果在此时返回了<code>true</code>拦截了<code>ACTION_MOVE</code>事件，<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分也就会正常执行，拖动也就没问题了。<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分具体做了怎样的处理，稍后再来解析。</p>
</li>
</ul>
<p>接下来对这两种情况逐一解析。</p>
<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用<code>processTouchEvent(MotionEvent ev)</code>的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process a touch event received by the parent view. This method will dispatch callback events</span></span><br><span class="line"><span class="comment"> * as needed before returning. The parent view&#x27;s onTouchEvent implementation should call this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev The touch event received by the parent view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">			<span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">			<span class="comment">// Start immediately if possible.</span></span><br><span class="line">			tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跟<code>shouldInterceptTouchEvent()</code>里<code>ACTION_DOWN</code>那部分基本一致，唯一区别就是这里没有约束条件直接调用了<code>tryCaptureViewForDrag()</code>方法，现在来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to capture the view with the given pointer ID. The callback will be involved.</span></span><br><span class="line"><span class="comment"> * This will put us into the &quot;dragging&quot; state. If we&#x27;ve already captured this view with</span></span><br><span class="line"><span class="comment"> * this pointer this method will immediately return true without consulting the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCapture View to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pointerId Pointer to capture with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if capture was successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;</span><br><span class="line">		<span class="comment">// Already done!</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;</span><br><span class="line">		mActivePointerId = pointerId;</span><br><span class="line">		captureChildView(toCapture, pointerId);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>Callback</code>的<code>tryCaptureView(View child, int pointerId)</code>方法，把当前触摸到的View和触摸手指编号传递了过去，在<code>tryCaptureView()</code>中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在<code>tryCaptureView()</code>中返回<code>true</code>，让<code>ViewDragHelper</code>把当前触摸的View捕获下来，接着就调用了<code>captureChildView(toCapture, pointerId)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Capture a specific child view for dragging within the parent. The callback will be notified</span></span><br><span class="line"><span class="comment"> * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span></span><br><span class="line"><span class="comment"> * capture this view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childView Child view to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;captureChildView: parameter must be a descendant &quot;</span> +</span><br><span class="line">				<span class="string">&quot;of the ViewDragHelper&#x27;s tracked parent view (&quot;</span> + mParentView + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCapturedView = childView;</span><br><span class="line">	mActivePointerId = activePointerId;</span><br><span class="line">	mCallback.onViewCaptured(childView, activePointerId);</span><br><span class="line">	setDragState(STATE_DRAGGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，在<code>captureChildView(toCapture, pointerId)</code>中将要拖动的View和触摸的手指编号记录下来，并调用<code>Callback</code>的<code>onViewCaptured(childView, activePointerId)</code>通知外部有子View被捕获到了，再调用<code>setDragState()</code>设置当前的状态为<code>STATE_DRAGGING</code>，看<code>setDragState()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">		mDragState = state;</span><br><span class="line">		mCallback.onViewDragStateChanged(state);</span><br><span class="line">		<span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">			mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态改变后会调用<code>Callback</code>的<code>onViewDragStateChanged()</code>通知状态的变化。</p>
<p>假设<code>ACTION_DOWN</code>发生后在<code>mParentView</code>的<code>onTouchEvent()</code>返回了<code>true</code>，接下来就会执行<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);</span><br><span class="line"></span><br><span class="line">				dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</span><br><span class="line"></span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">					reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">					<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">						<span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">					<span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">							tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断<code>mDragState</code>是否为<code>STATE_DRAGGING</code>，而唯一调用<code>setDragState(STATE_DRAGGING)</code>的地方就是<code>tryCaptureViewForDrag()</code>了，刚才在<code>ACTION_DOWN</code>里调用过<code>tryCaptureViewForDrag()</code>，现在又要分两种情况。<br>如果刚才在<code>ACTION_DOWN</code>里捕获到要拖动的View，那么就执行<code>if</code>部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，<code>mDragState</code>依然是<code>STATE_IDLE</code>，然后会执行<code>else</code>部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让<code>mDragState</code>变为<code>STATE_DRAGGING</code>，之后就会执行<code>if</code>部分的代码了。这里还有两个方法涉及到了<code>Callback</code>里的方法，需要来解析一下，分别是<code>reportNewEdgeDrags()</code>和<code>checkTouchSlop()</code>，先看<code>reportNewEdgeDrags()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_LEFT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_TOP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_RIGHT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">		mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">		mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在<code>mEdgeDragsInProgress</code>中，再调用<code>Callback</code>的<code>onEdgeDragStarted(int edgeFlags, int pointerId)</code>通知某个边缘开始产生拖动了。虽然<code>reportNewEdgeDrags()</code>会被调用很多次（因为<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分会执行很多次），但<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code>只会调用一次，具体的要看<code>checkNewEdgeDrag()</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">			(mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;</span><br><span class="line">		mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>checkNewEdgeDrag()</code>返回<code>true</code>表示在指定的<code>edge</code>（边缘）开始产生拖动了。</li>
<li>方法的两个参数<code>delta</code>和<code>odelta</code>需要解释一下，<code>odelta</code>里的o应该代表opposite，这是什么意思呢，以<code>reportNewEdgeDrags()</code>里调用<code>checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)</code>为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里<code>delta</code>为<code>dx</code>，<code>odelta</code>为<code>dy</code>，也就是说<code>delta</code>是指我们主要监测的方向上的变化，<code>odelta</code>是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>
<li><code>mInitialEdgesTouched</code>是在<code>ACTION_DOWN</code>部分的<code>saveInitialMotion()</code>里生成的，<code>ACTION_DOWN</code>发生时触摸到的边缘会被记录在<code>mInitialEdgesTouched</code>中。如果<code>ACTION_DOWN</code>发生时没有触摸到边缘，或者触摸到的边缘不是指定的<code>edge</code>，就直接返回false了。</li>
<li><code>mTrackingEdges</code>是由<code>setEdgeTrackingEnabled(int edgeFlags)</code>设置的，当我们想要追踪监听边缘触摸时才需要调用<code>setEdgeTrackingEnabled(int edgeFlags)</code>，如果我们没有调用过它，这里就直接返回<code>false</code>了。</li>
<li><code>mEdgeDragsLocked</code>它在这个方法里被引用了多次，它在整个<code>ViewDragHelper</code>里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行<code>mEdgeDragsLocked[pointerId] &amp; edge) == edge</code>执行的结果是<code>false</code>。我们再跳到11到14行看看，<code>absDelta &lt; absODelta * 0.5f</code>的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用<code>Callback</code>的<code>onEdgeLock(edge)</code>检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在<code>mEdgeDragsInProgress</code>里了，也不会收到<code>Callback</code>的<code>onEdgeDragStarted()</code>通知了。并且将锁定的边缘记录在<code>mEdgeDragsLocked</code>变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的<code>edge</code>被锁定，就直接返回<code>false</code>了。</li>
<li>回到第7行的<code>(mEdgeDragsInProgress[pointerId] &amp; edge) == edge</code>，<code>mEdgeDragsInProgress</code>是保存已发生过拖动事件的边缘的，如果给定的<code>edge</code>已经保存过了，那就没必要再检测其他东西了，直接返回<code>false</code>了。</li>
<li>第8行<code>(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)</code>很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>
<li>最后一句返回的时候再次检查给定的<code>edge</code>有没有记录过，确保了每个边缘只会调用一次<code>reportNewEdgeDrags</code>的<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code></li>
</ul>
<p>再来看<code>checkTouchSlop()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if we&#x27;ve crossed a reasonable touch slop for the given child view.</span></span><br><span class="line"><span class="comment"> * If the child cannot be dragged along the horizontal or vertical axis, motion</span></span><br><span class="line"><span class="comment"> * along that axis will not count toward the slop check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx Motion since initial position along X axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the touch slop has been crossed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（<code>mTouchSlop</code>）了，注意<code>dx</code>和<code>dy</code>指的是当前触摸点到<code>ACTION_DOWN</code>触摸到的点的距离。这里先检查<code>Callback</code>的<code>getViewHorizontalDragRange(child)</code>和<code>getViewVerticalDragRange(child)</code>是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分就不会调用<code>tryCaptureViewForDrag()</code>来捕获当前触摸到的View了，拖动也就没办法进行了。</p>
<p>回到<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了<code>Callback</code>中的相关方法，让<code>tryCaptureViewForDrag()</code>正常的捕获到触摸到的View了，下一次<code>ACTION_MOVE</code>时就执行<code>if</code>部分的代码了，也就是开始不停的调用<code>dragTo()</code>对<code>mCaptureView</code>进行真正拖动了，看<code>dragTo()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clampedX = left;</span><br><span class="line">	<span class="keyword">int</span> clampedY = top;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</span><br><span class="line">		mCapturedView.offsetLeftAndRight(clampedX - oldLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</span><br><span class="line">		mCapturedView.offsetTopAndBottom(clampedY - oldTop);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">		mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">				clampedDx, clampedDy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>dx</code>和<code>dy</code>是前后两次<code>ACTION_MOVE</code>移动的距离，<code>left</code>和<code>top</code>分别为<code>mCapturedView.getLeft() + dx</code>, <code>mCapturedView.getTop() + dy</code>，也就是期望的移动后的坐标，对<code>View</code>的<code>getLeft()</code>等方法不理解的请参阅<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>
<p>这里通过调用<code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>来完成对<code>mCapturedView</code>移动，这两个是<code>View</code>中定义的方法，看它们的源码就知道内部是通过改变<code>View</code>的<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>、<code>mBottom</code>，即改变<code>View</code>在父容器中的坐标位置，达到移动<code>View</code>的效果，所以如果调用<code>mCapturedView</code>的<code>layout(int l, int t, int r, int b)</code>方法也可以实现移动<code>View</code>的效果。</p>
<p>具体要移动到哪里，由<code>Callback</code>的<code>clampViewPositionHorizontal()</code>和<code>clampViewPositionVertical()</code>来决定的，如果不想在水平方向上移动，在<code>clampViewPositionHorizontal(View child, int left, int dx)</code>里直接返回<code>child.getLeft()</code>就可以了，这样<code>clampedX - oldLeft</code>的值为0，这里调用<code>mCapturedView.offsetLeftAndRight(clampedX - oldLeft)</code>就不会起作用了。垂直方向上同理。</p>
<p>最后会调用<code>Callback</code>的<code>onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)</code>通知捕获到的View位置改变了，并把最终的坐标（<code>clampedX</code>、<code>clampedY</code>）和最终的移动距离（<code>clampedDx</code>、 <code>clampedDy</code>）传递过去。</p>
<p><code>ACTION_MOVE</code>部分就算告一段落了，接下来应该是用户松手触发<code>ACTION_UP</code>，或者是达到某个条件导致后续的<code>ACTION_MOVE</code>被<code>mParentView</code>的上层View给拦截了而收到<code>ACTION_CANCEL</code>，一起来看这两个部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				releaseViewForPointerUp();</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下<code>releaseViewForPointerUp()</code>和<code>dispatchViewReleased()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releaseViewForPointerUp()</code>里也调用了<code>dispatchViewReleased()</code>，只不过传递了速率给它，这个速率就是由<code>processTouchEvent()</code>的<code>mVelocityTracker</code>追踪算出来的。再看<code>dispatchViewReleased()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like all callback events this must happen on the UI thread, but release</span></span><br><span class="line"><span class="comment"> * involves some extra semantics. During a release (mReleaseInProgress)</span></span><br><span class="line"><span class="comment"> * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">	mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">	mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">	mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">		<span class="comment">// onViewReleased didn&#x27;t call a method that would have changed this. Go idle.</span></span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>Callback</code>的<code>onViewReleased(mCapturedView, xvel, yvel)</code>通知外部捕获到的View被释放了，而在<code>onViewReleased()</code>前后有个<code>mReleaseInProgress</code>值得注意，注释里说唯一可以调用<code>ViewDragHelper</code>的<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方就是在<code>Callback</code>的<code>onViewReleased()</code>里了。</p>
<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（<code>flingCapturedView</code>的四个参数<code>int minLeft, int minTop, int maxLeft, int maxTop</code>可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用<code>settleCapturedViewAt(int finalLeft, int finalTop)</code>。</p>
<p>为什么唯一可以调用<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方是<code>Callback</code>的<code>onViewReleased()</code>呢？看看它们的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * The appropriate velocity from prior motion will be taken into account.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot settleCapturedViewAt outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view based on standard free-moving fling behavior.</span></span><br><span class="line"><span class="comment"> * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span></span><br><span class="line"><span class="comment"> * to continue the motion until it returns false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minLeft Minimum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minTop Minimum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLeft Maximum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxTop Maximum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot flingCapturedView outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法里一开始都会判断<code>mReleaseInProgress</code>为<code>false</code>，如果为<code>false</code>就会抛一个<code>IllegalStateException</code>异常，而<code>mReleaseInProgress</code>唯一为<code>true</code>的时候就是在<code>dispatchViewReleased()</code>里调用<code>onViewReleased()</code>的时候。</p>
<p><code>Scroller</code>的用法请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读<code>Scroller</code>源码，代码量不多。</p>
<p><code>ViewDragHelper</code>还有一个移动View的方法是<code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code>，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span></span><br><span class="line"><span class="comment"> * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child view to capture and animate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Final left position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Final top position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	mCapturedView = child;</span><br><span class="line">	mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If we&#x27;re in an IDLE state to begin with and aren&#x27;t moving anywhere, we</span></span><br><span class="line">		<span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">		mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> continueSliding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它不受<code>mReleaseInProgress</code>的限制，所以可以在任何地方调用，效果和<code>settleCapturedViewAt()</code>类似，因为它们最终都调用了<code>forceSettleCapturedViewAt()</code>来启动自动滚动，区别在于<code>settleCapturedViewAt()</code>会以最后松手前的滑动速率为初速度将View滚动到最终位置，而<code>smoothSlideViewTo()</code>滚动的初速度是0。<code>forceSettleCapturedViewAt()</code>里有地方调用了<code>Callback</code>里的方法，所以再来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Target top position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xvel Horizontal velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> yvel Vertical velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">		mScroller.abortAnimation();</span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">	mScroller.startScroll(startLeft, startTop, dx, dy, duration);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到自动滑动是靠<code>Scroll</code>类完成，在这里生成了调用<code>mScroller.startScroll()</code>需要的参数。再来看看计算滚动时间的方法<code>computeSettleDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">	<span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clampMag()</code>方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过<code>computeAxisDuration()</code>算出来，通过它的参数可以看到最终的滚动时间是由<code>dx</code>、<code>xvel</code>、<code>mCallback.getViewHorizontalDragRange()</code>共同影响的。看<code>computeAxisDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">			distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> duration;</span><br><span class="line">	velocity = Math.abs(velocity);</span><br><span class="line">	<span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">		duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6<del>10行没看明白，直接看14</del>19行，如果给定的速率<code>velocity</code>不为0，就通过距离除以速率来算出时间；如果<code>velocity</code>为0，就通过要滑动的距离（<code>delta</code>）除以总的移动范围（<code>motionRange</code>，就是<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过<code>MAX_SETTLE_DURATION</code>的，源码里的取值是600毫秒，所以不用担心在<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回错误的数而导致自动滚动时间过长了。</p>
<p>在调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>和<code>smoothSlideViewTo()</code>时，还需要实现<code>mParentView</code>的<code>computeScroll()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这属于<code>Scroll</code>类用法的范畴，不明白的请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>
<p>至此，整个触摸流程和<code>ViewDragHelper</code>的重要的方法都过了一遍。之前在讨论<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次<code>ACTION_DOWN</code>事件的情况，现在来看看这种情况。</p>
<p>假设现在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完了，也有子View消费了这次的<code>ACTION_DOWN</code>事件，那么接下来就会调用<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分，不明白为什么的请参阅<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">				<span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">					<span class="comment">// check the callback&#x27;s</span></span><br><span class="line">					<span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">					<span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">					<span class="comment">// would clamp to the same value. If you can&#x27;t move at</span></span><br><span class="line">					<span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">							targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">							(<span class="keyword">int</span>) dy);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">							toCapture);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">					<span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">							&amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">							|| verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">				<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">					<span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			saveLastMotion(ev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用<code>findTopChildUnder(int x, int y)</code>寻找触摸点处的子View，再用<code>checkTouchSlop(View child, float dx, float dy)</code>检查当前触摸点到<code>ACTION_DOWN</code>触摸点的距离是否达到了<code>mTouchSlop</code>，达到了才会去捕获View。<br>接着看19~41行<code>if (pastSlop)&#123;...&#125;</code>部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到<code>getView[Horizontal|Vertical]DragRange</code>和<code>clampViewPosition[Horizontal|Vertical]</code>四个方法。如果<code>getView[Horizontal|Vertical]DragRange</code>返回都是0，就会认作是不会产生拖动。<code>clampViewPosition[Horizontal|Vertical]</code>返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接<code>break</code>，不会执行后续的代码，而后续代码里有调用<code>tryCaptureViewForDrag()</code>，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的<code>tryCaptureViewForDrag()</code>捕获子View，如果捕获成功，<code>mDragState</code>就会变成<code>STATE_DRAGGING</code>，<code>shouldInterceptTouchEvent()</code>返回<code>true</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，后续的移动事件就会在<code>mParentView</code>的<code>onTouchEvent()</code>执行了，最后执行的就是<code>mParentView</code>的<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，拖动正常进行。</p>
<p>回头再看之前在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分留下的坑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他部分...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的<code>tryCaptureViewForDrag()</code>尝试捕获View，如果捕获成功，<code>mDragState</code>就变为<code>STATE_DRAGGING</code>了，<code>shouldInterceptTouchEvent()</code>就返回<code>true</code>了，然后就是<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，接着执行<code>mParentView</code>的<code>onTouchEvent()</code>，再执行<code>processTouchEvent()</code>的<code>ACTION_DOWN</code>部分。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动。</p>
<p>至此整个事件传递流程和<code>ViewDragHelper</code>的重要方法基本都解析完了，<code>shouldInterceptTouchEvent()</code>和<code>processTouchEvent()</code>的<code>ACTION_POINTER_DOWN</code>、<code>ACTION_POINTER_UP</code>部分就留给读者自己解析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>
<ul>
<li><p><a href="http://www.processon.com/view/link/5550a7bae4b09739f465ec64">单点触摸，没有考虑边缘滑动检测的最简流程图</a><br><img src="viewdraghelper-toucheventflow-basic.png"></p>
</li>
<li><p><a href="http://www.processon.com/view/link/5550d3dce4b09739f46789bd">单点触摸，考虑了边缘滑动检测的流程图</a><br><img src="viewdraghelper-toucheventflow-withedgetouch.png"></p>
</li>
</ul>
<p>多点触摸情况我就没研究了，在这里忽略~</p>
<p>三个开启自动滚动的方法：</p>
<ul>
<li><code>settleCapturedViewAt(int finalLeft, int finalTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code><br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>
</ul>
<p><code>Callback</code>的各个方法总结：</p>
<ul>
<li><p><code>void onViewDragStateChanged(int state)</code><br>拖动状态改变时会调用此方法，状态<code>state</code>有<code>STATE_IDLE</code>、<code>STATE_DRAGGING</code>、<code>STATE_SETTLING</code>三种取值。<br>它在<code>setDragState()</code>里被调用，而<code>setDragState()</code>被调用的地方有</p>
<ul>
<li><code>tryCaptureViewForDrag()</code>成功捕获到子View时<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分捕获到</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
</ul>
</li>
<li>调用<code>settleCapturedViewAt()</code>、<code>smoothSlideViewTo()</code>、<code>flingCapturedView()</code>时</li>
<li>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>、<code>ACTION_CANCEL</code>）</li>
<li>自动滚动停止时（<code>continueSettling()</code>里检测到滚动结束时）</li>
<li>外部调用<code>abort()</code>时</li>
</ul>
</li>
<li><p><code>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</code><br>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>
<ul>
<li>在<code>dragTo()</code>里被调用（正在被拖动时）</li>
<li>在<code>continueSettling()</code>里被调用（自动滚动时）</li>
<li>外部调用<code>abort()</code>时被调用</li>
</ul>
</li>
<li><p><code>void onViewCaptured(View capturedChild, int activePointerId)</code><br><code>tryCaptureViewForDrag()</code>成功捕获到子View时会调用此方法。</p>
<ul>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里成功捕获</li>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>手动调用<code>captureChildView()</code></li>
</ul>
</li>
<li><p><code>void onViewReleased(View releasedChild, float xvel, float yvel)</code><br>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>）或被父View拦截事件时（<code>processTouchEvent()</code>的<code>ACTION_CANCEL</code>）会调用此方法。</p>
</li>
<li><p><code>void onEdgeTouched(int edgeFlags, int pointerId)</code><br><code>ACTION_DOWN</code>或<code>ACTION_POINTER_DOWN</code>事件发生时如果触摸到监听的边缘会调用此方法。<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。</p>
</li>
<li><p><code>boolean onEdgeLock(int edgeFlags)</code><br>返回<code>true</code>表示锁定<code>edgeFlags</code>对应的边缘，锁定后的那些边缘就不会在<code>onEdgeDragStarted()</code>被通知了，默认返回<code>false</code>不锁定给定的边缘，<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>其中之一。</p>
</li>
<li><p><code>void onEdgeDragStarted(int edgeFlags, int pointerId)</code><br><code>ACTION_MOVE</code>事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。<code>edgeFlags</code>取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。可在此手动调用<code>captureChildView()</code>触发从边缘拖动子View的效果。</p>
</li>
<li><p><code>int getOrderedChildIndex(int index)</code><br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给<code>tryCaptureViewForDrag()</code>来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>
</li>
<li><p><code>int getViewHorizontalDragRange(View child)</code>、<code>int getViewVerticalDragRange(View child)</code><br>返回给定的<code>child</code>在相应的方向上可以被拖动的最远距离，默认返回0。<code>ACTION_DOWN</code>发生时，若触摸点处的<code>child</code>消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。<br>被调用的地方有三处：</p>
<ul>
<li>在<code>checkTouchSlop()</code>中被调用，返回值大于0才会去检查<code>mTouchSlop</code>。在<code>ACTION_MOVE</code>里调用<code>tryCaptureViewForDrag()</code>之前会调用<code>checkTouchSlop()</code>。如果<code>checkTouchSlop()</code>失败，就不会去捕获View了。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>
<li>在调用<code>smoothSlideViewTo()</code>时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在<code>getView[Horizontal|Vertical]DragRange</code>里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>
</ul>
</li>
<li><p><code>boolean tryCaptureView(View child, int pointerId)</code><br>在<code>tryCaptureViewForDrag()</code>中被调用，返回<code>true</code>表示捕获给定的<code>child</code>。<code>tryCaptureViewForDrag()</code>被调用的地方有</p>
<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
</ul>
</li>
<li><p><code>int clampViewPositionHorizontal(View child, int left, int dx)</code>、<code>int clampViewPositionVertical(View child, int top, int dy)</code><br><code>child</code>在某方向上被拖动时会调用对应方法，返回值是<code>child</code>移动过后的坐标位置，<code>clampViewPositionHorizontal()</code>返回<code>child</code>移动过后的left值，<code>clampViewPositionVertical()</code>返回<code>child</code>移动过后的top值。<br>两个方法被调用的地方有两处：</p>
<ul>
<li>在<code>dragTo()</code>中被调用，<code>dragTo()</code>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里被调用。用来获取被拖动的View要移动到的位置。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>
</ul>
</li>
</ul>
<h2 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h2><p>在这里列举一部分对<code>ViewDragHelper</code>的应用案例，大家自己剖析它们的源码来实践巩固。</p>
<ol>
<li><a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a>，这是最简单的Demo</li>
<li><a href="https://github.com/BlueMor/DragLayout">QQ5.x侧滑菜单</a>、<a href="https://github.com/kyze8439690/ResideLayout">ResideLayout</a></li>
<li><a href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a>、<a href="https://github.com/liuguangqiang/SwipeBack">SwipeBack</a></li>
<li><a href="https://github.com/umano/AndroidSlidingUpPanel">SlidingUpPanel</a></li>
<li><a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java">DrawerLayout</a></li>
</ol>
<h2 id="其他关于ViewDragHelper的分析文章"><a href="#其他关于ViewDragHelper的分析文章" class="headerlink" title="其他关于ViewDragHelper的分析文章"></a>其他关于ViewDragHelper的分析文章</h2><ul>
<li><a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a></li>
<li><a href="http://blog.csdn.net/pi9nc/article/details/39583377">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>
</ul>
<p>转载请注明出处</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>ViewDragHelper</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewDragHelper</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.509. 斐波那契数（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number">LeetCode.509. 斐波那契数（简单）</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<blockquote>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
</blockquote>
<p>给你 n ，请计算 F(n) 。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h4><p>根据定义，可以直接写出递归式，最简单。<br>但是递归会有很多重叠子问题，重复计算很耗时。</p>
<p>可以想象出函数调用的递归树，F(n)总共调用次数就是树的节点数。<br>从F(n)到F(n - 1)一直分解到F(1)，这样逐一递减，一共n层递归树。<br>第i层(从上到下数)节点数为2的i次方，递归树总节点数为 2的0次方 + 2的1次方 + 2的2次方 + …… + 2的n - 1次方，等比数列求和为2的n次方。递归求解的时间复杂度为O(2^n)。</p>
<p>把会重复使用到的计算结果记下来，每一项只计算一次，时间复杂度降低为线性。<br>自上而下做动态规划。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            memo[n] = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：自下而上的动态规划"><a href="#解法2：自下而上的动态规划" class="headerlink" title="解法2：自下而上的动态规划"></a>解法2：自下而上的动态规划</h4><p>直接根据公式递推</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            cur = prepre + pre</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1137.第N个泰波那契数（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">LeetCode.1137.第 N 个泰波那契数（简单）</a></p>
<p>泰波那契序列 Tn 定义如下：<br>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据公式直接递推，比斐波那契数列多一项。<br>记忆化递归就不写了。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tribonacci</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre3 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2 + pre3</span><br><span class="line">            pre3 = pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.198.打家劫舍（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">LeetCode.198.打家劫舍（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>从最终状态做倒推，穷举列出到达最终状态所需要的最小步骤，看是否能从上一个状态加上有限步骤得到最终状态，检查上一个状态的最优解是否也能通过不停的倒推拆解得到，拆分步骤的过程可得出状态转移方程。拆分到最开始，做边界条件处理。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>设<code>nums[i]</code>为第i间房屋金额。<br>设<code>dp[i]</code>为达到第i个房屋时能偷到的最高金额。</p>
<ol>
<li>偷第i间房，就不能偷第i - 1房，<code>dp[i] = dp[i - 2] + nums[i]</code></li>
<li>不偷第i间房，<code>dp[i] = dp[i - 1]</code></li>
</ol>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ol>
<li>只有1间房，直接偷</li>
<li>只有2间房，由于不能偷相邻的房间，就偷钱多的。 </li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只从前两项递推得来，所以不需要数组记录所有状态，只需要两个变量记录递推的状态。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1 </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.152.乘积最大子数组（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode.152.乘积最大子数组（中等）</a></p>
<p>给你一个整数数组  <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。</p>
<p>为了方便描述，设<code>maxProduct[i]</code>为以<code>nums[i]</code>结尾的子数组的最大乘积。</p>
<p>求<code>maxProduct[i]</code>，<code>nums[i]</code>肯定少不了，因为子数组最少需要一个元素。</p>
<h3 id="求maxProduct-i-有哪些可能的组合情况？"><a href="#求maxProduct-i-有哪些可能的组合情况？" class="headerlink" title="求maxProduct[i]有哪些可能的组合情况？"></a>求maxProduct[i]有哪些可能的组合情况？</h3><ol>
<li><code>nums[i]</code>自己单独成为一个子数组。<br>比如前面子数组乘积是0，<code>nums[i]</code>为正数，就没必要跟前面相乘了。但是<code>nums[i]</code>可能会比前面子数组乘积要小，所以要看看其他情况。</li>
<li><code>nums[i]</code>跟前面的子数组的乘积相乘。<br>接下来就是看怎么跟<code>nums[i]</code>相乘可以得到尽可能大的乘积。</li>
</ol>
<h3 id="有哪些乘法情况可以使乘积变大？"><a href="#有哪些乘法情况可以使乘积变大？" class="headerlink" title="有哪些乘法情况可以使乘积变大？"></a>有哪些乘法情况可以使乘积变大？</h3><ol>
<li>正数 * 正数</li>
<li>负数 * 负数</li>
</ol>
<p>也就是说求<code>maxProduct[i]</code>要记录<code>nums[i]</code>前面的子数组的最大乘积和最小乘积。</p>
<h3 id="穷举求maxProduct-i-要考虑的情况"><a href="#穷举求maxProduct-i-要考虑的情况" class="headerlink" title="穷举求maxProduct[i]要考虑的情况"></a>穷举求maxProduct[i]要考虑的情况</h3><ol>
<li><code>nums[i]</code>单独成为一个子数组</li>
<li><code>nums[i]</code>乘以i前面的子数组最大的乘积</li>
<li><code>nums[i]</code>乘以i前面的子数组最小的乘积</li>
</ol>
<p>求<code>maxProduct[i]</code>就是取三者最大值</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>maxProduct[i] = max(nums[i],  nums[i] * maxProduct[i - 1], nums[i] * minProduct[i - 1])</code></p>
<h3 id="怎么求以nums-i-结尾的连续子数组的最小乘积？"><a href="#怎么求以nums-i-结尾的连续子数组的最小乘积？" class="headerlink" title="怎么求以nums[i]结尾的连续子数组的最小乘积？"></a>怎么求以nums[i]结尾的连续子数组的最小乘积？</h3><p>跟考虑求最大乘积思路一样。<br>使乘积变得更小的方式就是正数和负数相乘。<br><code>nums[i]</code>可能为正也可能为负，所以<code>minProduct[i]</code>的求解也是有<code>maxProduct[i]</code>的那三种情况，只不过是求最小值。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p><code>maxProduct[0]</code>就是<code>nums[i]</code>本身，因为以<code>nums[0]</code>为结尾的子数组就是<code>nums[0]</code>本身构成的一个元素的子数组。<br>同理，<code>minProduct[0]</code>也是<code>nums[i]</code>。</p>
<p>递推要从<code>i = 1</code>开始。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>当前状态只跟上一步状态有关，所以不需要用数组存储所有状态，用几个变量记录上一步状态即可。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProduct</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> minProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> maxProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> result = maxProduct</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> num = nums[i]</span><br><span class="line">            <span class="keyword">val</span> newMaxProduct = maxOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            minProduct = minOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            maxProduct = newMaxProduct</span><br><span class="line">            result = maxOf(result, maxProduct)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.213.打家劫舍 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">LeetCode.213.打家劫舍 II（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="环形排列影响了什么？"><a href="#环形排列影响了什么？" class="headerlink" title="环形排列影响了什么？"></a>环形排列影响了什么？</h3><p>第1间房子和最后一间房子只能偷一个，不知道偷哪个金额最高。</p>
<h3 id="不知道偷第一间还是最后一间，怎么办？"><a href="#不知道偷第一间还是最后一间，怎么办？" class="headerlink" title="不知道偷第一间还是最后一间，怎么办？"></a>不知道偷第一间还是最后一间，怎么办？</h3><p>两种情况都偷一下，取金额大的那个方案。即：</p>
<ol>
<li>偷第1间房子，不偷最后一间房子</li>
<li>不偷第1间房子，偷最后一间房子</li>
</ol>
<p>转换为两个非环问题取较大值的问题。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">0</span>, n - <span class="number">1</span>)),</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">1</span>, n))</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">linearRob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> n = nums.size</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">var</span> cur = pre1</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">                cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">                pre2 = pre1</span><br><span class="line">                pre1 = cur</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.45.跳跃游戏 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/jump-game-ii/">LeetCode.45.跳跃游戏 II（中等）</a></p>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>不知道怎么办，先模拟一遍跳跃过程。<br>假设<code>nums[0]</code>是3，那么可以选择跳到1、2、3的位置。<br>假设<code>nums[1]</code>是1、<code>nums[2]</code>是10、<code>nums[3]</code>是3，那么肯定选择先跳到2的位置，再跳10个长度，这样跳跃次数最少。<br>后面再跳跃还是重复这个同样的选择过程。</p>
<h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><p>可以得知下一步的跳跃选择，应该在当前可以跳跃到的范围内找一个最远的长度来跳。就是贪心选择，从局部最优得出全局最优。</p>
<h3 id="怎么找最远可以跳跃的长度？"><a href="#怎么找最远可以跳跃的长度？" class="headerlink" title="怎么找最远可以跳跃的长度？"></a>怎么找最远可以跳跃的长度？</h3><p>只有一个个遍历数组，漏一个都不行</p>
<h3 id="什么时候计数跳跃次数？"><a href="#什么时候计数跳跃次数？" class="headerlink" title="什么时候计数跳跃次数？"></a>什么时候计数跳跃次数？</h3><p>因为会在可以跳跃到的范围内找到一个最远的长度来跳，也就是说这个范围内只会跳一次。那就顺便在遍历数组的时候等到达了跳跃范围的边界就可以计数跳跃次数了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxNext = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            maxNext = maxOf(maxNext, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxNext</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.53.最大子序和（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode.53.最大子序和（简单）</a></p>
<p>给定一个整数数组  <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最值问题考虑用动态规划，从某个状态倒推，拆解为上一个状态+所有可能的最小步骤，看是否符合动态规划的条件。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>设<code>dp[i]</code>为以<code>nums[i]</code>为结尾的连续子数组的最大和。</p>
<p>求<code>dp[i]</code>肯定是要加上<code>nums[i]</code>的，此时合成子数组有两种选择：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>和前面的连续子数组合并</li>
</ol>
<p>如何选择？</p>
<ol>
<li>如果 <code>dp[i - 1] + nums[i] &gt; nums[i]</code>，那么<code>dp[i] = dp[i - 1] + nums[i]</code>。</li>
<li>如果 <code>dp[i - 1] + nums[i] &lt; nums[i]</code>，那<code>nums[i]</code>单独成子数组后和反而更大，<code>dp[i] = nums[i]</code>。</li>
</ol>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i] = max(dp[i - 1] + nums[i], nums[i]) </code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p><code>dp[0]</code>就是<code>nums[0]</code>本身了，只包含自己的子数组。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只依赖于前一项的递推，可以不用数组，只用一个变量记录上一个值。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            <span class="keyword">val</span> cur = maxOf(pre + num, num)</span><br><span class="line">            maxSum = maxOf(maxSum, cur)</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.55.跳跃游戏（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">LeetCode.55.跳跃游戏（中等）</a></p>
<p>给定一个非负整数数组 <code>nums</code>  ，你最初位于数组的  <strong>第一个下标</strong>  。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="到达最后一个下标需要什么条件？"><a href="#到达最后一个下标需要什么条件？" class="headerlink" title="到达最后一个下标需要什么条件？"></a>到达最后一个下标需要什么条件？</h3><p>跳过的长度要大于等于数组长度</p>
<h3 id="什么情况下不能到达最后一个下标？"><a href="#什么情况下不能到达最后一个下标？" class="headerlink" title="什么情况下不能到达最后一个下标？"></a>什么情况下不能到达最后一个下标？</h3><p>到达某个位置后，不继续往后跳了，比如到了某个位置，可跳跃长度为0，就不会往后跳了，跳到最后一个位置就无从谈起。</p>
<h3 id="我怎么知道总共跳跃的长度有没有超过数组的长度？"><a href="#我怎么知道总共跳跃的长度有没有超过数组的长度？" class="headerlink" title="我怎么知道总共跳跃的长度有没有超过数组的长度？"></a>我怎么知道总共跳跃的长度有没有超过数组的长度？</h3><p>只能从头到尾遍历数组，记录最多能跳多远，会不会在某个位置停止跳跃，如果不会停止跳跃，肯定能跳到终点。</p>
<h3 id="停止跳跃有什么特征？怎么判断有没有停止跳跃？"><a href="#停止跳跃有什么特征？怎么判断有没有停止跳跃？" class="headerlink" title="停止跳跃有什么特征？怎么判断有没有停止跳跃？"></a>停止跳跃有什么特征？怎么判断有没有停止跳跃？</h3><p>如果记录最远能够跳到的位置，停止跳跃的时候，记录的位置不会再改变了。<br>在遍历数组检查最多能跳多远的时候，如果发现数组当前遍历的下标超过记录的最远跳过的位置，说明跳跃停止了。因为遍历数组相当于每次跳1步，是最低速度，如果能持续跳跃，不会低于这个速度，最低也是持平。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            j = maxOf(j, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums.size) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.70.爬楼梯（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.70.%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/climbing-stairs/">LeetCode.70.爬楼梯（简单）</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑用动态规划，看是否符合动态规划的条件。<br>一般从最终状态做倒推，拆解当前状态问题为上一个状态+有限的步骤。</p>
<h3 id="倒推"><a href="#倒推" class="headerlink" title="倒推"></a>倒推</h3><p>爬到第n阶，最后一步一定是只有两种可能：</p>
<ol>
<li>先爬到第n-1个台阶，再爬1个台阶</li>
<li>先爬到第n-2个台阶，再爬2个台阶</li>
</ol>
<p>把两种可能的方法数累加就是爬到第n阶第方法数。</p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>爬到第1阶，只有1种爬法，即爬1个台阶。<br>爬到第2阶，可以从第0阶爬2个台阶，也可以从第1阶爬1个台阶，共2种爬法。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.740.删除并获得点数（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.740.%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">LeetCode.740.删除并获得点数（中等）</a></p>
<p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于要删除值相邻的元素，可以在脑海里先按元素值对nums数组排序，方便梳理题意，最终求解的东西跟数组顺序也没关系。</p>
<p>删除一个<code>nums[i]</code>获得点数后，所有<code>nums[i] - 1</code>和<code>nums[i] + 1</code>的相邻元素被删除了（不计点数），数组里剩下的所有等于<code>nums[i]</code>的值都还是要逐个主动删除并且计入点数的，因为它们不会因为是某个被删除元素的相邻元素而被删除，因为相邻元素从删除第一个<code>nums[i]</code>就删完了。</p>
<p>所以，假设<code>nums[i]</code>在数组里有<code>c</code>个，删除<code>nums[i]</code>可以获得的点数是<code>nums[i] * c</code>。</p>
<p>可以用一个数组<code>sum</code>记录<code>nums</code>数组中所有相同元素的和，以<code>nums[i]</code>作为<code>sum</code>数组的下标，方便查询点数。即<code>sum[nums[i]] = nums[i] * c</code>。</p>
<p>获取了<code>sum[nums[i]]</code>就不能选取<code>sum[nums[i] - 1]</code>和<code>sum[nums[i] + 1]</code>了，这就转变为打家劫舍的最优化问题。  </p>
<p><code>sum</code>数组的长度为<code>nums数组的最大值 + 1</code>，是一个常数空间，对性能影响可以接受。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteAndEarn</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> maxValue = nums.max()!!</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(maxValue + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            sum[num] += num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until nums.size) &#123;</span><br><span class="line">            cur = maxOf(pre2 + nums[i], pre1)</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.918.环形子数组的最大和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">LeetCode.918.环形子数组的最大和（中等）</a></p>
<p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p>
<p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，且当 i &gt;= 0 时 C[i+A.length] = C[i]）</p>
<p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="环形数组跟非环形数组的区别是什么？"><a href="#环形数组跟非环形数组的区别是什么？" class="headerlink" title="环形数组跟非环形数组的区别是什么？"></a>环形数组跟非环形数组的区别是什么？</h3><p>环形数组中最终求得的最大和子数组有两种情况</p>
<ol>
<li>数组A的首尾元素不会连接</li>
<li>数组A的首尾元素会连接</li>
</ol>
<h3 id="数组A的首尾元素不会连接的情况如何求解？"><a href="#数组A的首尾元素不会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素不会连接的情况如何求解？"></a>数组A的首尾元素不会连接的情况如何求解？</h3><p>第1种情况就是非环形数组的普通求法，参与计算的区间为<code>[0, n - 1]</code></p>
<h3 id="数组A的首尾元素会连接的情况如何求解？"><a href="#数组A的首尾元素会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素会连接的情况如何求解？"></a>数组A的首尾元素会连接的情况如何求解？</h3><p>第2种情况不好用非环形数组的方法求解，实际观察结果可以得到等价情况：先求出中间部分的子数组的最小和，再用整个数组A的和减去中间的最小和就是两端首尾相连的子数组的最大和。<br>这时只在数组A的<code>[1, n - 2]</code>区间求解，这才能保证首尾不连接。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubarraySumCircular</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMaxSumInLinearCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = maxOf(pre + nums[i], nums[i])</span><br><span class="line">                maxSum = maxOf(maxSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMinSumInCyclicCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minSum = nums[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = minOf(pre + nums[i], nums[i])</span><br><span class="line">                minSum = minOf(minSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            getMaxSumInLinearCase(), </span><br><span class="line">            nums.sum() - getMinSumInCyclicCase()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.746.使用最小花费爬楼梯（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">LeetCode.746.使用最小花费爬楼梯（简单）</a></p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，往动态规划上考虑，看是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>一般从最终状态做倒推，拆分步骤，列出所有到达最终状态的步骤，看能否拆分为上一个同性质的子问题+有限步骤，拆分步骤的过程得出状态转移方程。</p>
<p>cost数组长度为n，到达楼顶就是到达下标n的地方。<br>设<code>dp[i]</code>表示达到到达下标i所需的最小花费，<code>0 &lt;= i &lt;= n</code>。</p>
<h3 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h3><p>可以从下标为0或1的阶梯开始爬，说明<code>dp[0] = dp[1] = 0</code>。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>达到第i个阶梯，最后一步有两种选择：</p>
<ol>
<li>在第i-1层爬1个阶梯。</li>
<li>在第i-2层爬2个阶梯。</li>
</ol>
<p>到达第i-1层的最小花费是<code>dp[i-1]</code>，爬1个阶梯需要耗费<code>cost[i-1]</code><br>到达第i-2层的最小花费是<code>dp[i-2]</code>，爬2个阶梯需要耗费<code>cost[i-2]</code><br>那么，到达第i层阶梯就是取两者中较小值。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只与前两项值有关，所以不需要数组，用两个变量保存前面两项值即可。</p>
<h3 id="代码（Kotlin）"><a href="#代码（Kotlin）" class="headerlink" title="代码（Kotlin）"></a>代码（Kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">            cur = minOf(pre1 + cost[i - <span class="number">1</span>], pre2 + cost[i - <span class="number">2</span>])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1014.最佳观光组合（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.1014.%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">LeetCode.1014.最佳观光组合（中等）</a></p>
<p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。<br>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。<br>返回一对观光景点能取得的最高分。、</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ol>
<li>对一个确定的<code>j</code>，需要在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得观光组合得分最高。</li>
<li>不知道选哪个<code>j</code>能让得分最高，就需要穷举所有<code>j</code>的取值可能性。</li>
</ol>
<h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p>目标是求最大的观察观光组合得分，那么就得思考得分与什么相关，能否分解为独立的几个部分，再穷举每个部分所有的可能性，看这些可能性是怎么操作得到的，就可以知道得分是怎么来的了。</p>
<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>得分公式<code>values[i] + values[j] + i - j</code>里会变的东西就是<code>i</code>和<code>j</code>，这两个是独立变化的，那么就可以把公式拆成两部分：</p>
<ol>
<li>仅跟<code>i</code>相关的，即 <code>values[i] + i</code>，可以称为<code>scoreI</code></li>
<li>仅跟<code>j</code>相关的，即 <code>values[j] - j</code>，可以称为<code>scoreJ</code></li>
</ol>
<p>总分<code>score = scoreI + scoreJ</code></p>
<h3 id="对于一个确定的j，怎么使得得分最高呢？"><a href="#对于一个确定的j，怎么使得得分最高呢？" class="headerlink" title="对于一个确定的j，怎么使得得分最高呢？"></a>对于一个确定的j，怎么使得得分最高呢？</h3><ol>
<li><code>j</code>确定了， <code>scoreJ</code> 是确定的，不会变动。</li>
<li>然后在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得<code>scoreI</code> 最大，得分就是最高了。</li>
</ol>
<p>不确定选哪个<code>j</code>可以得分最高，那就遍历数组，穷举<code>j</code>所有的取值可能。</p>
<p>但是按照这个思路，先穷举<code>j</code>，再在每个<code>j</code>处往回穷举<code>i</code>，时间复杂度是O($n^2$)，是否存在不必要的操作？</p>
<h3 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h3><p>仔细分析两个步骤可以发现，没有必要往回穷举<code>i</code>，因为<code>i &lt; j</code>，在数组中遍历到<code>j</code>，<code>j</code>前面的位置肯定都遍历过了，<code>i</code>已经可以确定了；简单点说，<code>j</code>确定了，<code>i</code>就确定了。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(values: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = values.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxScoreI = values[<span class="number">0</span>] + <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxScore = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 穷举所有的j</span></span><br><span class="line">        <span class="comment">// 只有1个景点无法形成观光组合，所以从1开始遍历，这样至少2个有两个景点能形成观光组合</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> scoreJ = values[j] - j</span><br><span class="line">            <span class="keyword">val</span> score = maxScoreI + scoreJ</span><br><span class="line">            maxScore = maxOf(maxScore, score)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 上面已经处理过j，对于下一个j而言，需要知道下一个j前面最大的scoreI是多少</span></span><br><span class="line">            <span class="keyword">val</span> scoreI = values[j] + j</span><br><span class="line">            maxScoreI = maxOf(maxScoreI, scoreI)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxScore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.118.杨辉三角（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></p>
<p>给定一个非负整数 _<code>numRows</code>，_生成「杨辉三角」的前 <em><code>numRows</code></em> 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递推公式题目已经给出，讨论一下边界情况，把问题具体定义就好了。</p>
<h3 id="问题公式化"><a href="#问题公式化" class="headerlink" title="问题公式化"></a>问题公式化</h3><p>三角形每行用List存储，所有行也用List存储。<br>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>把三角形左侧对齐可以观察到：<br>左上方的数就是<code>dp[r - 1][c - 1]</code>；<br>右上方的数就是<code>dp[r - 1][c]</code>；</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>r = 0时，没有上方，但其实知道第一行是1，只有1个元素，直接添加到结果集就行了。<br>r &gt; 0后：<br>c = 0 处于第一列时，没有左上方，左上方当作0，只累加右上方，<code>dp[r][0] = dp[r - 1][c]</code>。<br>c = r 处于最后一列时，没有右上方，右上方当作0，只累加左上方，<code>dp[r][r] = dp[r - 1][r - 1]</code>。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(numRows: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> triangle = mutableListOf&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">        triangle.add(listOf(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until numRows) &#123;</span><br><span class="line">            <span class="keyword">val</span> rows = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0.</span>.r) &#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 第一列，只能加右上方</span></span><br><span class="line">                    c == <span class="number">0</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                    <span class="comment">// 最后一列，只能加左上方</span></span><br><span class="line">                    c == r -&gt; rows.add(triangle[r - <span class="number">1</span>][r - <span class="number">1</span>])</span><br><span class="line">                    <span class="comment">// 中间列，左上方+右上方</span></span><br><span class="line">                    <span class="keyword">else</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][c - <span class="number">1</span>] + triangle[r - <span class="number">1</span>][c])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            triangle.add(rows)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.119.杨辉三角 II（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></p>
<p>给定一个非负索引  <code>rowIndex</code>，返回「杨辉三角」的第  <code>rowIndex</code>  行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最直观就是求出杨辉三角所有行，取第<code>rowIndex</code>行。<br>实际每一行由上一行推导而来，不需要存储所有行，只需要保存上一行，递推来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>左上方的数：<code>dp[r - 1][c - 1]</code>；<br>右上方的数：<code>dp[r - 1][c]</code>；<br><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>用一个数组就可以完成每行迭代。<br><code>dp[c] = dp[c - 1] + dp[c]</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>更新第c列时，会读取c - 1列的旧值；<br>但是c - 1列在更新数组的时候已经被新值覆盖了。<br>解决方案：</p>
<ol>
<li>从左向右遍历数组时，临时存储一下旧值。</li>
<li>从右向左遍历数组。</li>
</ol>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRow</span><span class="params">(rowIndex: <span class="type">Int</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = IntArray(rowIndex + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        rows[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1.</span>.rowIndex) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> r - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">                rows[c] = rows[c - <span class="number">1</span>] + rows[c]</span><br><span class="line">            &#125;</span><br><span class="line">            rows[r] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows.toList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.121.买卖股票的最佳时机（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode.121.买卖股票的最佳时机（简单）</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>设dp[i]为第0天到第i天获取最大利润。</p>
<p>在第i天，可以选择不卖股票或卖出股票。</p>
<ol>
<li>不卖股票，dp[i] = dp[i - 1]</li>
<li>卖出股票，由于只能买入一次和卖出一次，那要获得最大利润，肯定要在第0天到第i -1中股票最低的时候买入，dp[i] = prices[i] - minPrice</li>
</ol>
<p>dp[i]只与上一个状态有关，所以可以用变量存储状态，不需要数组记录。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxProfit = maxOf(maxProfit, prices[i] - minPrice)</span><br><span class="line">            minPrice = minOf(minPrice, prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="comment">// dp[i][k]表示前i天持有和未持有第i天的股票的最大收益</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 第i天未持有，可能是前i-1天就未持有然后今天不操作，或者以前持有了今天卖出了</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            <span class="comment">// 第i天持有，可能是前i-1天就持有了然后今天不操作，或者以前就未持有今天买入了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.122.买卖股票的最佳时机 II（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划。</p>
<h3 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h3><p>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。<br>归纳合并一下，这些操作会产生的结果状态是：</p>
<ol>
<li>第<code>i</code>天持有股票</li>
<li>第<code>i</code>天不持有股票</li>
</ol>
<h3 id="为什么要关注操作得到的结果状态？"><a href="#为什么要关注操作得到的结果状态？" class="headerlink" title="为什么要关注操作得到的结果状态？"></a>为什么要关注操作得到的结果状态？</h3><p>因为选择某个操作，就是上一个状态转变为下一个状态，所以需要知道操作前后的状态是什么。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>第<code>i</code>天有两个股票持有状态，不同股票持有状态的收益是不一样的。<br>一个状态经过选择操作后可能会转化为另一个状态，所以要记录所有状态的信息。<br>也就是要把天数和股票持有状态组合的所有状态都要记录下来。</p>
<p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p>根据第<code>i</code>天的选择操作来梳理状态转移方程：</p>
<ol>
<li>第<code>i</code>天买入，变成持有股票的状态，利润要减去<code>prices[i]</code>，题目要求买入前不能持有股票，所以<code>dp[i][1] = dp[i - 1][0] - prices[i]</code>。</li>
<li>第<code>i</code>天卖出，变成不持有股票的状态，利润要加上<code>prices[i]</code>，卖出前肯定要持有股票才能卖，所以<code>dp[i][0] = dp[i - 1][1] + prices[i]</code>。</li>
<li>第<code>i</code>天什么也不做，不管是持有还是不持有股票，前<code>i</code>天的利润跟前<code>i - 1</code>天的利润一样，所以<code>dp[i][0] = dp[i - 1][0]，dp[i][1] = dp[i - 1][1]</code>。</li>
</ol>
<p>综合一下：<br><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code><br><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></p>
<h3 id="到了最后一天，应该取dp-n-1-0-还是dp-n-1-1-？"><a href="#到了最后一天，应该取dp-n-1-0-还是dp-n-1-1-？" class="headerlink" title="到了最后一天，应该取dp[n - 1][0]还是dp[n - 1][1]？**"></a>到了最后一天，应该取dp[n - 1][0]还是dp[n - 1][1]？**</h3><p>最后一天如果还持有股票，利润肯定要变小，肯定是不持有股票的时候收益最大，取<code>dp[n - 1][0]</code>。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p><code>dp[0][0] = 0</code>，第0天不持有股票利润就是0。<br><code>dp[0][1] = -prices[i]</code>，第0天持有股票只能买入，利润为负。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i][k]</code>只跟上一个状态有关，用变量记录上一个状态，不需要用数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1314.矩阵区域和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a></p>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p>
<ul>
<li>i - k &lt;= r &lt;= i + k,</li>
<li>j - k &lt;= c &lt;= j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
<span id="more"></span>

<p>提示：</p>
<blockquote>
<p>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, k &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力解法需要O($n^4$)时间复杂度，考虑时间更优化的算法。</p>
<h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>题目要求解区域和是二维的，可以简化问题，先看看一维数组某一区间的元素和怎么求，因为二维的区域相当于一维的叠加。</p>
<h3 id="一维数组某区间内元素和怎么快速求解？"><a href="#一维数组某区间内元素和怎么快速求解？" class="headerlink" title="一维数组某区间内元素和怎么快速求解？"></a>一维数组某区间内元素和怎么快速求解？</h3><p>可以预先计算和存储每个位置的前缀和（第0个到第i个元素之间所有元素的和），要计算某个区间的和，用区间端点的前缀和相减就可以在O(1)时间复杂度内求解，但需要占用O(n)空间。</p>
<p>考虑用二维前缀和快速求解面积问题。</p>
<h3 id="二维前缀和定义"><a href="#二维前缀和定义" class="headerlink" title="二维前缀和定义"></a>二维前缀和定义</h3><p>第0行第0列到第r行第c列形成的矩形区域内所有元素的和。<br>记为<code>preSum[r][c]</code>。</p>
<h3 id="怎么利用二维前缀和求解区域面积？"><a href="#怎么利用二维前缀和求解区域面积？" class="headerlink" title="怎么利用二维前缀和求解区域面积？"></a>怎么利用二维前缀和求解区域面积？</h3><p>比如要求区域d的元素和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列：                  </span><br><span class="line">0   a a a b b b b b   </span><br><span class="line">1   a a a b b b b b</span><br><span class="line">2   c c c d d d d d</span><br><span class="line">3   c c c d d d d d</span><br><span class="line">4   c c c d d d d d</span><br><span class="line">行： 0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>公式表达：<br><code>区域d所有元素和 = preSum[7,4] - preSum[2, 4] - preSum[7, 1] + preSum[2, 1]</code><br><code>preSum[7,4]</code>：整个区域所有元素和<br><code>preSum[2, 4]</code>：区域a + 区域c<br><code>preSum[7, 1]</code>：区域a + 区域b<br><code>preSum[2, 1]</code>：区域a</p>
<h3 id="二维前缀和怎么推导？"><a href="#二维前缀和怎么推导？" class="headerlink" title="二维前缀和怎么推导？"></a>二维前缀和怎么推导？</h3><ul>
<li>第一行和第一列前缀和不用推导，左边和上边都没有元素，直接等于元素本身。</li>
<li>第一行上方没有元素，当作一维前缀和求解。</li>
<li>第一列和第一行情况相同，方向变了一下，还是当作一维前缀和求解。</li>
<li>非第一行和非第一列位置的前缀和，跟求解区域和类似，前缀和 = 上方二维前缀和 + 左方二维前缀和 - 左上方二维前缀和 + 本元素值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">matrixBlockSum</span><span class="params">(mat: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, k: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> m = mat.size</span><br><span class="line">        <span class="keyword">val</span> n = mat[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> answer = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) preSum[r][<span class="number">0</span>] = mat[r][<span class="number">0</span>] + preSum[r - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) preSum[<span class="number">0</span>][c] = mat[<span class="number">0</span>][c] + preSum[<span class="number">0</span>][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                preSum[r][c] = mat[r][c] + preSum[r - <span class="number">1</span>][c] + preSum[r][c - <span class="number">1</span>] - preSum[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解区域和</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> leftTopX = maxOf(r - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> leftTopY = maxOf(c - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomX = minOf(r + k, m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomY = minOf(c + k, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> wholeArea = preSum[rightBottomX][rightBottomY]</span><br><span class="line">                <span class="keyword">val</span> leftArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][rightBottomY] </span><br><span class="line">                <span class="keyword">val</span> topArea = <span class="keyword">if</span> (leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[rightBottomX][leftTopY - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> leftTopArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span> || leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][leftTopY - <span class="number">1</span>]</span><br><span class="line">                answer[r][c] = wholeArea - leftArea - topArea + leftTopArea</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.139.单词拆分（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h3><p>提到拆分，我们可以考虑能不能把大问题拆分为子问题+有限步骤，给问题建模，简化讨论。</p>
<ol>
<li>如果s可以被拆分，那么至少s的末尾字符组成的单词肯定是在wordDict中的。<ul>
<li>s的末尾字符组成的单词，可以从s的末尾位置开始，依次穷举取长度为1、2、3……n的子字符串，看子字符串是否在wordDict中。</li>
<li>接下来再去看剩下的前半部分的子字符串能不能继续拆分成功。</li>
</ul>
</li>
<li>如果s不能被拆分，有两种情况:<ol>
<li>穷举s所有末尾子字符串，是没有一个子字符串是在wordDict中的。</li>
<li>末尾有一部分子字符串组成的单词在wordDict中，最后s剩下前半段的子字符串不能被wordDict拆分。</li>
</ol>
</li>
</ol>
<p>这里已经划分出了子问题+有限步骤，可以用递归来解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 如果字符串能拆完，最后索引肯定为-1</span></span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 在字符串s[0,end]中，从末尾依次取长度为1、2、3……end+1的子字符串，检查子字符串是否在wordDict里</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 截取末尾字符串</span></span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 末尾字符串在wordDict里</span></span><br><span class="line">                <span class="comment">// 剩下的前半段子字符串s[0,start - 1]有可能可以被继续拆分，也有可能不可以被拆分，不知道能不能就只能每个情况都试一下</span></span><br><span class="line">                <span class="comment">// 所以这里不是直接return，而是要试一下每一种的单词拆分，看哪一种行的通</span></span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    <span class="comment">// end指向剩下的前半部分子字符串末尾</span></span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试拆分s[0, n - 1]</span></span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h3><p>递归的问题在于有重叠子问题，有很多重复计算耗时，保存一下中间计算结果就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(s.length) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (memo[end] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">if</span> (memo[end] == <span class="number">1</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[end] = <span class="keyword">if</span> (result) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法3：自下而上递推式动态规划"><a href="#解法3：自下而上递推式动态规划" class="headerlink" title="解法3：自下而上递推式动态规划"></a>解法3：自下而上递推式动态规划</h3><p>能用记忆化递归的，也可以用自下而上递推的方式做。</p>
<p>设<code>dp[end]</code>为第0个到第end个字符组成的字符串是否可以被wordDict中的单词拆分。<br>穷举所有<code>s[0, end]</code>的末尾字符串，判断能否拆分。<br>设<code>s[0, end]</code>的末尾字符串的开始索引为<code>start</code>，<code>0 &lt;= start &lt;= end</code>。</p>
<p><strong>状态转移方程</strong><br><code>dp[end] = dp[start - 1] &amp;&amp; s[start, end] in wordDict</code></p>
<p><code>start==0</code> 时，截取的是整个字符串，直接判断整个字符串是否在wordDict里就行了，<code>dp[0] = s[start, end] in wordDict</code>。</p>
<p>由于计算新的状态需要读取之前的每个最优化的状态，所以空间无法优化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> dp = BooleanArray(n) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (end <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.end) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[start - <span class="number">1</span>] &amp;&amp; word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1567.乘积为正数的最长子数组长度（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.1567.%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">LeetCode.1567.乘积为正数的最长子数组长度（中等）</a></p>
<p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。<br>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。<br>请你返回乘积为正数的最长子数组长度。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划，先从某个状态倒推拆解问题。</p>
<h3 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h3><p>设<code>positive[i]</code>是以<code>nums[i]</code>结尾的子数组中，乘积为正数的最长连续子数组的长度。</p>
<h3 id="如何保证乘积为正数？"><a href="#如何保证乘积为正数？" class="headerlink" title="如何保证乘积为正数？"></a>如何保证乘积为正数？</h3><p>正数 * 正数<br>负数 * 负数</p>
<h3 id="以nums-i-结尾的子数组有哪些组合情况？"><a href="#以nums-i-结尾的子数组有哪些组合情况？" class="headerlink" title="以nums[i]结尾的子数组有哪些组合情况？"></a>以nums[i]结尾的子数组有哪些组合情况？</h3><p>按照<code>nums[i]</code>要不要拿去做乘法，分为：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>跟前面的子数组连接</li>
</ol>
<p>实际去求<code>positive[i]</code>，肯定是尽量与前面的子数组的乘积去相乘，这样会得到尽可能大的结果长度。<br>如果<code>nums[i]</code>没法跟前面的子数组乘积相乘，再单独把<code>nums[i]</code>作为子数组。</p>
<h3 id="如何保证以nums-i-结尾的子数组乘积为正数？"><a href="#如何保证以nums-i-结尾的子数组乘积为正数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为正数？"></a>如何保证以nums[i]结尾的子数组乘积为正数？</h3><ol>
<li><code>nums[i]</code>单独为一个子数组时，<code>nums[i]</code>要为正数</li>
<li><code>nums[i]</code>跟前面的子数组连接时<ol>
<li><code>nums[i]</code>为正，前面子数组乘积为正</li>
<li><code>nums[i]</code>为负，前面子数组乘积为负</li>
</ol>
</li>
</ol>
<p>这里还要记录前面子数组乘积为负数的最长长度，可以定义<code>negative[i]</code>是以<code>nums[i]</code>结尾的子数组中乘积为负数的最长连续子数组的长度。</p>
<h3 id="考虑边界情况"><a href="#考虑边界情况" class="headerlink" title="考虑边界情况"></a>考虑边界情况</h3><ol>
<li>在<code>nums[i]</code>要跟前面的子数组连接时，如果：<ol>
<li><code>nums[i]</code>为正数，前面没有乘积是正数的子数组（比如乘积是0或者负数或者没有任何数），这个时候<code>nums[i]</code>可以单独做一个子数组，<code>positive[i] = 1</code>。</li>
<li><code>nums[i]</code>为负数，前面没有乘积是负数的子数组，这个时候<code>nums[i]</code>单独作为子数组也不是正的，<code>positive[i]</code>是0。</li>
</ol>
</li>
<li><code>nums[i]</code>为0时，<code>positive[0]</code>只能为0，因为单独让<code>nums[i]</code>成为子数组乘积是0，<code>nums[i]</code>跟前面子数组乘积相乘也是0。</li>
</ol>
<h3 id="positive-i-的状态转移方程"><a href="#positive-i-的状态转移方程" class="headerlink" title="positive[i]的状态转移方程"></a>positive[i]的状态转移方程</h3><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1. `positive[i] = positive[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0`，前面有乘积为正数的子数组，正数*正数乘积是正数
 2. `positive[i] = 1`，当`i &gt; 0 &amp;&amp; positive[i - 1] == 0`，前面没有乘积为正数的子数组，`nums[i]`单独作为一个子数组
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `positive[i] = negative[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0`，前面有乘积为负数的子数组，负数*负数乘积是正数
 2. `positive[i] = 0`，当 `i &gt; 0 &amp;&amp; negative[i - 1] == 0`，前面没有乘积为负数的子数组，`nums[i]`没的乘，以`nums[i]`结尾的子数组的乘积没办法变为正数
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>positive[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>positive[0] = if (nums[0] &gt; 0) 1 else 0</code></li>
</ol>
<h3 id="如何保证以nums-i-结尾的子数组乘积为负数？"><a href="#如何保证以nums-i-结尾的子数组乘积为负数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为负数？"></a>如何保证以nums[i]结尾的子数组乘积为负数？</h3><p>跟<code>positive[i]</code>正好相反。<br><code>nums[i]</code>跟前面的子数组连接时：<br>    1. <code>nums[i]</code>为正，前面子数组乘积为负<br>    2. <code>nums[i]</code>为负，前面子数组乘积为正</p>
<h3 id="negative-i-的状态转移方程"><a href="#negative-i-的状态转移方程" class="headerlink" title="negative[i]的状态转移方程"></a>negative[i]的状态转移方程</h3><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1.` i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0` 时，`negative[i] = negative[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; negative[i - 1] == 0` 时，`negative[i] = 0`
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0` 时，`negative[i] = positive[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; positive[i - 1] == 0` 时，`negative[i] = 1`
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>negative[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>negative[0] = if (nums[0] &lt; 0) 1 else 0</code></li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>positive[i]</code>和<code>negative[i]</code>只与上一个状态有关，不需要数据存储所有状态，用变量记录上一个状态即可。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMaxLen</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> positive = <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> negative = <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxLength = positive</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                nums[i] &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (positive == 0)*/</span> <span class="number">1</span> </span><br><span class="line">                    negative = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (negative[i - 1] == 0)*/</span> <span class="number">0</span> </span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] &lt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newPositive = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (negative == 0) */</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">val</span> newNegative = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (positive == 0) */</span> <span class="number">1</span></span><br><span class="line">                    positive = newPositive</span><br><span class="line">                    negative = newNegative</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] == <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="number">0</span></span><br><span class="line">                    negative = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, positive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.264.丑数 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.264.%E4%B8%91%E6%95%B0%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II（中等）</a></p>
<p>给你一个整数  <code>n</code>  ，请你找出并返回第  <code>n</code>  个  <strong>丑数</strong>  。<br><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code>  和/或 <code>5</code> 的正整数。<br>提示：<code>1 &lt;= n &lt;= 1690</code></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h3><p>根据丑数定义，除了1这个丑数，其他丑数都是从小的丑数乘以2或3或5得到，那么递推就好了。</p>
<p>主要问题是，几个小的丑数乘以2、3、5后的丑数，你不知道哪个大哪个小，不好确定下一个丑数是哪个。比如：</p>
<ol>
<li>丑数3乘以质因数后得到丑数：6、9、15。</li>
<li>丑数4乘以质因数后得到丑数：8、12、20。</li>
</ol>
<p>所以需要排个序，由于参与排序的元素位置和个数并不确定，所以需要在线算法实现，优先队列（堆）恰好适合元素不确定的排序，入队和出队时调整堆只需要O(log n)的时间复杂度。</p>
<p>还有个问题是要去重，比如 <code>丑数4 * 3 = 12</code>， <code>丑数6 * 2 = 12</code>，丑数肯定不重复，从优先队列取出元素后，检查有重复去去除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            pq.add(u * <span class="number">2</span>)</span><br><span class="line">            pq.add(u * <span class="number">3</span>)</span><br><span class="line">            pq.add(u * <span class="number">5</span>)</span><br><span class="line">            u = pq.remove()</span><br><span class="line">            <span class="keyword">while</span> (pq.isNotEmpty() &amp;&amp; pq.peek() == u) pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用哈希表来去重，用空间换时间，出队入队还是要占用一点不必要的时间的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> factors = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (factor <span class="keyword">in</span> factors) &#123;</span><br><span class="line">                <span class="keyword">val</span> nextU = u * factor</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nextU)) &#123;</span><br><span class="line">                    pq.add(nextU)</span><br><span class="line">                    visited.add(nextU)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            u = pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：三指针"><a href="#解法2：三指针" class="headerlink" title="解法2：三指针"></a>解法2：三指针</h3><p>3个质因数都要跟每个丑数乘一次，相当于形成3个丑数序列，每次取3个序列中最小值，作为新数组的元素，这很像归并排序，可以用3个指针3路归并。</p>
<p>已经递推出来的丑数要用数组记录下来，因为3个指针位置不确定，可能某个指针会访问到以前较小的丑数。</p>
<p>由于不能有重复值，再取完3个序列左边最小值后，要把相同值给跳过。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p3 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p5 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> u = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        u[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">val</span> v2 = u[p2] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> v3 = u[p3] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">val</span> v5 = u[p5] * <span class="number">5</span></span><br><span class="line">            <span class="keyword">val</span> nextU = minOf(v2, v3, v5)</span><br><span class="line">            <span class="comment">// 多个序列有重复元素要跳过，丑数不能有重复</span></span><br><span class="line">            <span class="keyword">if</span> (nextU == v2) p2++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v3) p3++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v5) p5++</span><br><span class="line">            u[i] = nextU</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.309.最佳买卖股票时机含冷冻期（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode.309.最佳买卖股票时机含冷冻期（中等）</a></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划。</p>
<h3 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h3><p>第<code>i</code>天的基本操作有：买入、卖出、什么都不做。<br>买入有冷冻期限制，第i天可能无法买入，也就是只能什么都不做了，所有的操作还是这三种，不影响确定最终状态。<br>经过选择操作后可得第i天的最终状态只有：持有股票或不持有股票。<br>买入冷冻期的限制在状态转移方程中做状态转移时体现出来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p><code>dp[i][0]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1</code>天一样</li>
<li>之前持有股票，第<code>i</code>天卖出</li>
</ol>
<p>可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code></p>
<p><code>dp[i][1]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1天</code>一样</li>
<li>之前不持有股票，第<code>i</code>天买入；买入有冷冻期限制，如果是第<code>i - 1</code>天卖出的，第<code>i</code>天就不能买入了。</li>
</ol>
<p>可得<code>dp[i][1] = max(dp[i - 1], dp[i - 2][0] - prices[i])</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i][k]</code>只与前面两个状态有关，用变量记录前面的状态，不需要数组记录所有状态。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 0</span></span><br><span class="line">        <span class="keyword">var</span> preNoholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> preHoldProfit = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 1</span></span><br><span class="line">        <span class="keyword">var</span> curNoholdProfit = maxOf(preNoholdProfit, preHoldProfit + prices[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> curHoldProfit = maxOf(preHoldProfit, preNoholdProfit - prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(curNoholdProfit, curHoldProfit + prices[i])</span><br><span class="line">            <span class="comment">// 买入有冷冻期，只能从前天没有持有股票的状态转移而来</span></span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(curHoldProfit, preNoholdProfit - prices[i])</span><br><span class="line"></span><br><span class="line">            preNoholdProfit = curNoholdProfit</span><br><span class="line">            preHoldProfit = curHoldProfit</span><br><span class="line"></span><br><span class="line">            curNoholdProfit = newNoholdProfit</span><br><span class="line">            curHoldProfit = newHoldProfit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curNoholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.413.等差数列划分（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">LeetCode.413.等差数列划分（中等）</a></p>
<p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<blockquote>
<p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。</p>
</blockquote>
<p>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。<br>子数组 是数组中的一个连续序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>子数组起始索引和结束索引各不相同，可以先按结束索引给子数组分类，分析统计相同结束索引下的等差数列子数组个数，最后累加所有不同结束索引的等差数列子数组个数。</p>
<p>先看以<code>nums[i]</code>结尾的数组中等差子数组个数，可以设其值为<code>a[i]</code>。</p>
<h3 id="等差数列如何判断？"><a href="#等差数列如何判断？" class="headerlink" title="等差数列如何判断？"></a>等差数列如何判断？</h3><p><code>nums[i] - nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]</code></p>
<h3 id="如果已知a-i-1-，如何得到a-i-？即如何递推？"><a href="#如果已知a-i-1-，如何得到a-i-？即如何递推？" class="headerlink" title="如果已知a[i - 1]，如何得到a[i]？即如何递推？"></a>如果已知a[i - 1]，如何得到a[i]？即如何递推？</h3><p>分两种情况：</p>
<ol>
<li><code>nums[i]</code>不能跟前面的元素形成等差数列，那么<code>a[i] = 0</code></li>
<li><code>nums[i]</code>能跟前面的元素形成等差数列，这时候会新增几个等差数列子数组？<ol>
<li>新增长度最短的等差数列：<code>nums[i - 2]、nums[i - 1]、nums[i]</code></li>
<li>所有以<code>nums[i - 1]</code>结尾的子数组，末尾加上<code>nums[i]</code>，所形成的新数组。所有以<code>nums[i - 1]</code>结尾的子数组的个数为<code>a[i - 1]</code>。</li>
</ol>
 即<code>a[i] = a[i - 1] + 1</code></li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>a[i]</code>只跟上一个状态有关，所以可以不用数组记录每一个状态，用一个变量记录上一个状态即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> isCommonDiff = nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">val</span> cur = <span class="keyword">if</span> (isCommonDiff) pre + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum += cur</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.42.接雨水（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.42.%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode.42.接雨水（困难）</a></p>
<p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度数组height，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划，O-n-空间复杂度"><a href="#解法1：动态规划，O-n-空间复杂度" class="headerlink" title="解法1：动态规划，O(n)空间复杂度"></a>解法1：动态规划，O(n)空间复杂度</h3><h4 id="拆分问题"><a href="#拆分问题" class="headerlink" title="拆分问题"></a>拆分问题</h4><p>所有的积水由每一列的积水量累加得来。</p>
<h4 id="某一列的积水量由什么决定？"><a href="#某一列的积水量由什么决定？" class="headerlink" title="某一列的积水量由什么决定？"></a>某一列的积水量由什么决定？</h4><ol>
<li>先要看左右两边最高的柱子有多高，这决定了当前列能积多高的水，并且最多只能积到较矮的那个柱子的高度，否则水会溢出。</li>
<li>这个高度减去当前柱子高度，就是当前列可以积的水量。</li>
</ol>
<h4 id="第i列的积水量求解公式"><a href="#第i列的积水量求解公式" class="headerlink" title="第i列的积水量求解公式"></a>第i列的积水量求解公式</h4><p><code>第i列的积水量 = min(0到i - 1列中最高的柱子的高度, i + 1列到n - 1列中最高柱子的高度) - 当前列柱子高度</code></p>
<p>所以要把每一列左边和右边最高的柱子先求出来。</p>
<h4 id="第i列左边的最高的柱子怎么找？"><a href="#第i列左边的最高的柱子怎么找？" class="headerlink" title="第i列左边的最高的柱子怎么找？"></a>第i列左边的最高的柱子怎么找？</h4><p>从0到i - 1遍历一遍height数组，找最大的。<br>实际可以从左到右遍历一遍height数组，把前面记录的最大的柱子高度跟第i - 1个柱子高度比较，取较大值就行了。</p>
<h4 id="第i列右边的最高的柱子的高度怎么找？"><a href="#第i列右边的最高的柱子的高度怎么找？" class="headerlink" title="第i列右边的最高的柱子的高度怎么找？"></a>第i列右边的最高的柱子的高度怎么找？</h4><p>从右向左遍历一遍height数组，把前面记录的最大的柱子高度跟第i + 1个柱子高度做对比，取较大的。</p>
<h4 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h4><p>第1个柱子左边没有柱子，其左边最高柱子高度是0，也无法积水。<br>最后1个柱子右边没有柱子，其右边最高柱子高度是0，也无法积水。</p>
<h4 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">val</span> maxLeft = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> maxRight = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxLeft[i] = maxOf(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> (n - <span class="number">2</span>) downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxRight[i] = maxOf(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">val</span> h = maxOf(maxLeft[i], maxRight[i])</span><br><span class="line">            <span class="keyword">if</span> (h &gt; height[i]) &#123;</span><br><span class="line">                water += h - height[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：  O(n)<br>空间复杂度：  O(n)</p>
</blockquote>
<h3 id="解法2：动态规划，O-1-空间复杂度"><a href="#解法2：动态规划，O-1-空间复杂度" class="headerlink" title="解法2：动态规划，O(1)空间复杂度"></a>解法2：动态规划，O(1)空间复杂度</h3><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>求每一列的积水的时候，<code>maxLeft[i]</code>和<code>maxRight[i]</code>只用到了一次，后续不会再查询之前的值，所以可以用两个变量<code>leftMax</code>、<code>rightMax</code>代替数组。</p>
<h4 id="怎么用leftMax代替maxLeft数组？"><a href="#怎么用leftMax代替maxLeft数组？" class="headerlink" title="怎么用leftMax代替maxLeft数组？"></a>怎么用leftMax代替maxLeft数组？</h4><p><code>maxLeft</code>数组是从左到右遍历数组height求得的，在从左到右遍历height数组求第i列积水量的时候，就可以顺便计算出第i个柱子左边最高的柱子的高度，即<code>leftMax</code>。</p>
<h4 id="怎么用rightMax代替maxRight数组？"><a href="#怎么用rightMax代替maxRight数组？" class="headerlink" title="怎么用rightMax代替maxRight数组？"></a>怎么用rightMax代替maxRight数组？</h4><p><code>maxRight</code>数组是从右到左遍历数组height求得的，想办法能想办法能从右到左遍历数组就行了。</p>
<h4 id="什么时候应该从右到左遍历？什么时候从左到右？"><a href="#什么时候应该从右到左遍历？什么时候从左到右？" class="headerlink" title="什么时候应该从右到左遍历？什么时候从左到右？"></a>什么时候应该从右到左遍历？什么时候从左到右？</h4><p>当左侧的柱子高度比右侧柱子高，需要看较矮的右侧的柱子高度，才能决定某一列能积多少水，左边不管多高都不会决定能积多少水，此时应该从右到左遍历。<br>直到右侧柱子比左侧柱子高，才需要从左边到右边检查。</p>
<h4 id="初始情况是怎样的？怎么开始？"><a href="#初始情况是怎样的？怎么开始？" class="headerlink" title="初始情况是怎样的？怎么开始？"></a>初始情况是怎样的？怎么开始？</h4><p>第一列左边没有柱子，无法积水。<br>最后一列右边没有柱子，无法积水。<br>计算积水只考虑区间<code>[1, n - 2]</code>。<br>可以直接令：<br><code>leftMax = height[0]</code><br><code>rightMax = height[n - 1]</code></p>
<h4 id="具体怎么判断决定height数组的遍历方向？"><a href="#具体怎么判断决定height数组的遍历方向？" class="headerlink" title="具体怎么判断决定height数组的遍历方向？"></a>具体怎么判断决定height数组的遍历方向？</h4><ol>
<li>如果发现左边柱子比右边矮，即<code>leftMax &lt; rightMax</code>，可以先计算左边的积水，随后如果发现当前柱子高度比leftMax高，再更新leftMax。</li>
<li>如果发现右边柱子比左边矮，即<code>leftMax &gt; rightMax</code>，先计算右边的积水，随后如果发现当前柱子高度比rightMax高，再更新rightMax。</li>
</ol>
<h4 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> leftMax = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> rightMax = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> right = n - <span class="number">2</span></span><br><span class="line">        <span class="comment">// 要计算区间[1, n - 2]中所有列的积水情况，所以边界条件要包含left == right的情况，才能包含所有的情况</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftMax &gt; height[left]) &#123;</span><br><span class="line">                    water += leftMax - height[left]</span><br><span class="line">                &#125;</span><br><span class="line">                leftMax = maxOf(leftMax, height[left])</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightMax &gt; height[right]) &#123;</span><br><span class="line">                    water += rightMax - height[right]</span><br><span class="line">                &#125;</span><br><span class="line">                rightMax = maxOf(rightMax, height[right])</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度： O(n)<br>空间复杂度： O(1)</p>
</blockquote>
<h3 id="解法3：直观模拟-gt-单调栈"><a href="#解法3：直观模拟-gt-单调栈" class="headerlink" title="解法3：直观模拟 -&gt; 单调栈"></a>解法3：直观模拟 -&gt; 单调栈</h3><h4 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h4><p>要能积水，需要多根柱子形成凹槽。</p>
<h4 id="如何判断形成了凹槽？"><a href="#如何判断形成了凹槽？" class="headerlink" title="如何判断形成了凹槽？"></a>如何判断形成了凹槽？</h4><p>朝一个方向依次看柱子高低，是否能形成高、低、高的排列。<br>在已经形成下坡的情况下，一旦发现出现了上坡，就形成了凹槽，就可以计算积水量了。<br>如果发现上坡，但是前面没有下坡，无法积水。</p>
<h4 id="如何计算凹槽的积水量"><a href="#如何计算凹槽的积水量" class="headerlink" title="如何计算凹槽的积水量"></a>如何计算凹槽的积水量</h4><p>穷举出凹槽的所有可能情况，逐个分析，再归纳。<br>从最基本的情况看起，再添加有限的步骤，推导出更复杂的情况。</p>
<h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>一个凹槽最少也要3个柱子，假设3个柱子从左到右依次叫L、M、R，高度排列依次是高、低、高。<br><code>凹槽积水量 = minOf(L高度, R高度) - M高度</code></p>
<h4 id="如果有多个相同高度的M，计算方式会怎么变化？"><a href="#如果有多个相同高度的M，计算方式会怎么变化？" class="headerlink" title="如果有多个相同高度的M，计算方式会怎么变化？"></a>如果有多个相同高度的M，计算方式会怎么变化？</h4><p>就变成求矩形面积了：<br><code>凹槽积水量 = (minOf(L高度, R高度) - M高度) * L到R的距离</code><br><code>L到R的距离 = R索引 - L索引 - 1</code></p>
<h4 id="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"><a href="#如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？" class="headerlink" title="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"></a>如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？</h4><p>因为是从左到右看柱子高度的，一旦发现上坡就触发计算，所以可以先看下坡中柱子多的情况，比如：[3,2,1,4]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             #   </span><br><span class="line">       # a b #</span><br><span class="line">       # # c #</span><br><span class="line">       # # # #</span><br><span class="line">index: 0 1 2 3</span><br><span class="line"></span><br><span class="line">#表示柱子，小写字母表示积水区域</span><br></pre></td></tr></table></figure>
<p>此时积水面积不是矩形，左下方是一个阶梯型。<br>如果按之前的办法求解，从3依次回看2、1，会检测到凹槽形成，可以求得c的面积。<br>积水面积剩下a、b，可以发现刚好是一个矩形，面积为<code>(minOf(3高度, 2高度) - 1高度) * 1到3的距离</code>。<br>如果左边还有更高的柱子，会形成新的矩形，还是一样的计算过程。</p>
<h4 id="计算规律"><a href="#计算规律" class="headerlink" title="计算规律"></a>计算规律</h4><p>这种阶梯形状的积水面积，可以按行拆分为不同的矩形，先求下面的矩形面积，再求上面的矩形面积，最后累加。</p>
<p>然后再看右边柱子多的情况，得看右边形成新的凹槽才有讨论意义，那就是看一下有两个凹槽的情况会怎样。</p>
<h4 id="有两个凹槽时，计算方式会怎样变化？"><a href="#有两个凹槽时，计算方式会怎样变化？" class="headerlink" title="有两个凹槽时，计算方式会怎样变化？"></a>有两个凹槽时，计算方式会怎样变化？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   #</span><br><span class="line">       # b b b b b #</span><br><span class="line">       # a a # b b #</span><br><span class="line">       # # a # b b #</span><br><span class="line">       # # # # # # #</span><br><span class="line">index: 0 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>可以发现0到3的第一个凹槽中第0个最高的柱子会影响到4到6的第二个凹槽的积水面积的计算。<br>第一个凹槽积水量计算过后，1和2两个柱子对于第二个凹槽积水面积计算没有影响了。<br>在计算新凹槽积水量的时候，需要读取以前比较高的柱子高度，太低的柱子就可以忽略了。</p>
<h4 id="怎么获取和存储计算积水量需要的信息？"><a href="#怎么获取和存储计算积水量需要的信息？" class="headerlink" title="怎么获取和存储计算积水量需要的信息？"></a>怎么获取和存储计算积水量需要的信息？</h4><p>每个矩形面积的计算，是在发现有上坡后开始的，检测上坡就是需要知道当前柱子高度和前一个柱子高度，这个在遍历height数组时可以直接获取。</p>
<p>发现上坡后，需要知道：</p>
<ol>
<li>前面有没有形成下坡的柱子</li>
<li>柱子之间的距离</li>
<li>柱子的高度</li>
</ol>
<p>柱子距离必须要记录柱子索引位置；<br>形成下坡意思就是柱子高度要单调递减；<br>柱子高度可以根据柱子索引查询height数组；<br>访问下坡中柱子还要从右到左依次访问。</p>
<p>我们遍历检查的顺序是从左到右，访问顺序反过来，符合这个特点的数据结构就是栈。<br>入栈时保存的是柱子索引。<br>栈内柱子保持高度单调递减，不存储递增的柱子，因为对于后续计算积水没有意义。<br>当前柱子前面一个柱子也算下坡中，也存储在栈中，方便统一处理。<br>判断前面有没有形成下坡，就判断栈是否不为空。</p>
<h4 id="代码（kotlin）-2"><a href="#代码（kotlin）-2" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 栈存储形成下坡的柱子</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> height.indices) &#123;</span><br><span class="line">            <span class="comment">// 之前有下坡，现在发现上坡，形成凹槽了，可以计算积水面积了</span></span><br><span class="line">            <span class="comment">// 凹槽积水面积可能是阶梯形，所以要不停的读取前面下坡中的柱子计算矩形积水面积，这里需要一个循环</span></span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;</span><br><span class="line">                <span class="comment">// 前面凹槽中高度低的柱子要出栈，因为其对于后面凹槽的计算没有意义</span></span><br><span class="line">                <span class="keyword">val</span> cur = stack.pop()</span><br><span class="line">                <span class="comment">// 相同高度的柱子会形成矩形面积的积水，一起计算积水量</span></span><br><span class="line">                <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] == height[cur]) &#123;</span><br><span class="line">                    stack.pop()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前面有下坡，才能形成凹槽，计算积水才有意义，所以要对栈判空，有可能之前栈里只存储了一个柱子</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 现在栈顶的柱子高度是大于curHeight的，形成凹槽了</span></span><br><span class="line">                    <span class="keyword">val</span> h = minOf(height[stack.peek()], height[i]) - height[cur]</span><br><span class="line">                    <span class="keyword">val</span> w = i - stack.peek() - <span class="number">1</span></span><br><span class="line">                    water += w * h</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法4：数学拆解-gt-O-1-空间复杂度"><a href="#解法4：数学拆解-gt-O-1-空间复杂度" class="headerlink" title="解法4：数学拆解 -&gt; O(1)空间复杂度"></a>解法4：数学拆解 -&gt; O(1)空间复杂度</h3><p>从图形上看积水区域特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        b  b  b  b  b  #  a  a  #  c  c  c  c  c</span><br><span class="line">        b  b  #  a  a  #  a  a  #  a  #  c  c  c</span><br><span class="line">        #  a  #  a  a  #  a  a  #  a  #  a  #  c</span><br><span class="line">index:  0  1  2  3  4  5  6  7  8  9 10 11 12 13</span><br></pre></td></tr></table></figure>
<p>观察得知：<br><code>区间矩形面积 = a的面积 + #的面积 + b的面积 + c的面积</code></p>
<p>区间矩形面积已知。<br><code>区间矩形面积 = 区间宽度 * 最高柱子高度</code></p>
<p>#的面积已知。<br><code>#的面积 = 所有柱子高度的和</code></p>
<p><strong>有没有办法知道b和c的面积？</strong><br>b和c是阶梯状的，不好单独计算。<br>可以看其处于哪个好计算的部分，再看能不能把b和c的面积拆解出来。</p>
<ol>
<li>如果从左到右遍历height数组，是可以知道 <code>#的面积 + a的面积 + c的面积</code>，遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为left。</li>
<li>如果从右到左遍历height数组，是可以知道 <code>#的面积 + a的面积 + b的面积</code>，也是遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为right。</li>
</ol>
<p><code>left + right = #的面积 + a的面积 + (#的面积 + a的面积 + b的面积 + c的面积)</code><br>化简得：<br><code>left + right = #的面积 + a的面积 + 区间矩形面积</code><br>可得：<br><code>a的面积 = left + right - #的面积 - 区间矩形面积</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            left += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            right += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rectArea = n * maxHeight</span><br><span class="line">        <span class="keyword">val</span> pillarArea = height.sum()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left + right - rectArea - pillarArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.714.买卖股票的最佳时机含手续费（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode.714.买卖股票的最佳时机含手续费（中等）</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状态转移方程同<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>卖出时计算利润时把交易费扣除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>, fee: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            noholdProfit = maxOf(noholdProfit, holdProfit + prices[i] - fee)</span><br><span class="line">            holdProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.91.解码方法（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://leetcode-cn.com/problems/decode-ways/">LeetCode.91.解码方法（中等）</a></p>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<blockquote>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
</blockquote>
<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<ul>
<li>“AAJF” ，将消息分组为 (1 1 10 6)</li>
<li>“KJF” ，将消息分组为 (11 10 6)</li>
</ul>
<p>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>思考能否将某个状态下的问题拆分为子问题+有限步骤。</p>
<p>设<code>a[i]</code>为<code>s[0..i]</code>中解码方法总数。</p>
<h3 id="a-i-取值受什么影响？"><a href="#a-i-取值受什么影响？" class="headerlink" title="a[i]取值受什么影响？"></a>a[i]取值受什么影响？</h3><p>受<code>s[i - 1]</code>和<code>s[i - 2]</code>的取值影响，因为要决定是解析一个字符还是两个字符。<br><code>a[i]</code>可以通过<code>a[i - 1]</code>或<code>a[i - 2]</code>递推而来。</p>
<h3 id="s-i-1-和s-i-2-组合的数有哪些情况？"><a href="#s-i-1-和s-i-2-组合的数有哪些情况？" class="headerlink" title="s[i - 1]和s[i - 2]组合的数有哪些情况？"></a><code>s[i - 1]</code>和<code>s[i - 2]</code>组合的数有哪些情况？</h3><p>根据题意，没有直接映射到0的情况，要注意：</p>
<ol>
<li>不能单独映射0，只能作为10或者20整体解析，方案数不变，<code>a[i] = a[i - 1]</code>。一旦出现0的前面不是1或2，整个s无法解析，直接返回0方案数。</li>
<li>06这样的0处在十位数的也不能作为个位数解析，只能一个个解析，方案数不变，<code>a[i] = a[i - 1]</code></li>
</ol>
<p>两个数字剩余的合法取值范围在[11, 19]、[21, 26]，此时可以映射一个字母，也可以映射两个字母。<br><code>a[i] = a[i - 1] + a[i - 2]</code></p>
<p>其他大于26的情况，只能映射一个字母，方案数不变，<code>a[i] = a[i - 1]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>a[i]</code>只与前两个状态有关，只用两个保存状态即可，不需要数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numDecodings</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始的一个字符只有一种映射方案</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始时，前两个字符的解析方案数</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> num = parseInt(s[<span class="number">0</span>], s[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cur = pre</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第3个字符开始解析</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> num = parseInt(s[i - <span class="number">1</span>], s[i])</span><br><span class="line">                <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) pre + prepre <span class="keyword">else</span> pre</span><br><span class="line">            &#125;</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(a: <span class="type">Char</span>, b: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tens = (a.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()) * <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> units = b.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line">        <span class="keyword">return</span> tens + units</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.931.下降路径最小和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">LeetCode.931.下降路径最小和（中等）</a></p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，拆分大问题为子问题+有限步骤。</p>
<p>下降路径在第一行任何元素都能开始。</p>
<p>针对第一行某个元素，要选取左下方、正下方、右下方三条向下路径中和最小的路径的和，再加上当前元素的值，就是当前元素开始的下降路径的最小和。<br>第二行每个元素的和最小的下降路径求法一样，直到最后一行。</p>
<p>第一行每个元素的下降路径最小和都逐个求出后，选取一个最小的。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是第r行第c列下降路径最小和。<br><code>dp[r][c] = matrix[r][c] + minOf(dp[r + 1, c - 1], dp[r + 1, c], dp[r + 1, c + 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>最后一行，没有下面一行了<br><code>dp[r][c] = matrix[r][c]</code></li>
<li>第一列，只能读取下方和右下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c], dp[r + 1, c + 1])</code></li>
<li>最后一列，只能读取下方和左下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c - 1], dp[r + 1, c])</code></li>
</ul>
<h3 id="递推顺序"><a href="#递推顺序" class="headerlink" title="递推顺序"></a>递推顺序</h3><p>从下往上</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> dp = Array(rows) &#123; IntArray(columns) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            dp[rows - <span class="number">1</span>][c] = matrix[rows - <span class="number">1</span>][c]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                dp[r][c] = matrix[r][c] + </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, dp[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>因为是逐行递推的，所以可以用原数组存储，不用额外开辟二维数组。</p>
<h3 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                matrix[r][c] += </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, matrix[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.96.不同的二叉搜索树（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode.96.不同的二叉搜索树（中等）</a></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<blockquote>
<p>提示：  <code>1 &lt;= n &lt;= 19</code></p>
<span id="more"></span>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树的问题第一反应会想到递归，进而想到能不能划分子问题。</p>
<p>从基本情况开始梳理。<br>构造一棵树，要选一个根节点。<br>如果以某个数字为根节点，左子树有a种，右子树有b种，那么这棵树就有a * b种可能。</p>
<p>左子树和右子树的构建，也要选择根节点，选择逻辑一样，可以递归进行，但是能选的根节点数量少了一个。</p>
<p>递推下去可以发现，如果剩余可选节点数越少，种数就越少。</p>
<p>设<code>sum[i]</code>为节点总数为<code>i</code>的二叉搜索树的种数。<br>除去根节点，假设左子树有<code>j</code>个节点，右子树就有<code>i - 1 - j</code>个节点，其中<code>j</code>的取值范围是<code>0 &lt;= j &lt;= i - 1</code>，得把所有的<code>j</code>可能情况都取一遍值，最后累加结果，就得到<code>sum[i]</code>。</p>
<p><strong>状态转移方程</strong><br><code>sum[i]= ∑ sum[j] * sum[i - 1 - j]</code>，<code>0 &lt;= j &lt;= i - 1</code></p>
<p><strong>边界处理</strong><br>总共只有0个节点，是空树，也算一种树，<code>sum[0] = 1</code>。想象一下如果左子树为空，右子树有n种，那么当前树也应该有n种。<br>总共只有1个节点，只有一种情况，<code>sum[1] = 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        sum[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                sum[i] += sum[j] * sum[i - <span class="number">1</span> - j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.120.三角形最小路径和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/triangle/">LeetCode.120.三角形最小路径和（中等）</a></p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目已经给出了递推公式，是从上往下取值的，所以要从最后一行往上递推，最后得到结果。<br>如果用递归写，这个顺序就会比较明白，递归划分为子问题后，实际是自底向上传递计算结果的。</p>
<p>设<code>dp[i][j]</code>为第i行第j列向下的最小路径和。<br>总共<code>n</code>行。</p>
<p>最后一行没有下一行了，所以<br><code>dp[n - 1][j] = triangle[n - 1][j]</code></p>
<p>上面的行，状态转移方程为：<br><code>dp[i][j] = triangle[i][j] + minOf(dp[i + 1][j], dp[i + 1][j + 1]</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minimumTotal</span><span class="params">(triangle: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Int</span>&gt;&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = triangle.size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[n - <span class="number">1</span>][j] = triangle[n - <span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.i) &#123;</span><br><span class="line">                dp[i][j] = triangle[i][j] + minOf(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.304.%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</a></p>
<p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<ul>
<li>计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。<br>实现 NumMatrix 类：</li>
<li>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化</li>
<li>int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。<span id="more"></span></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>与<a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a>思路相同。</p>
<p>NumMatrix.sumRegion()要想做到O(1)时间复杂度查询，就要提前计算好二位前缀和。</p>
<p>设<code>preSum[i][j]</code>为<code>[0, 0]</code>到<code>[i, j]</code>矩形区域所有元素和。</p>
<p>求矩形区域d的元素和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a a a b b b b b   </span><br><span class="line">a a a b b b b b</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>设矩形d左上角坐标<code>(x1, y1)</code>，右下角坐标<code>(x2, y2)</code>。<br><code>整个区域所有元素和 = preSum[x2][y2]</code><br><code>区域a所有元素和 + 区域b所有元素和 = preSum[x1 - 1][y2]</code><br><code>区域a所有元素和 + 区域c所有元素和 = preSum[x2][y1 - 1]</code></p>
<p>所以:<br><code>区域d所有元素和 = preSum[x2][y2] - preSum[x1 - 1][y2] - preSum[x2][y1 - 1] + preSum[x1 - 1][y1 - 1]</code></p>
<p>遇到边界特殊处理一下就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span></span>(matrix: Array&lt;IntArray&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> m = matrix.size</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 求二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            preSum[<span class="number">0</span>][j] = preSum[<span class="number">0</span>][j - <span class="number">1</span>] + matrix[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            preSum[i][<span class="number">0</span>] = preSum[i - <span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> left = preSum[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> top = preSum[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">val</span> leftTop = preSum[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                preSum[i][j] = left + top - leftTop + matrix[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sumRegion</span><span class="params">(row1: <span class="type">Int</span>, col1: <span class="type">Int</span>, row2: <span class="type">Int</span>, col2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> all = preSum[row2][col2]</span><br><span class="line">        <span class="keyword">val</span> left = <span class="keyword">if</span> (col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row2][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> top = <span class="keyword">if</span> (row1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col2]</span><br><span class="line">        <span class="keyword">val</span> leftTop = <span class="keyword">if</span> (row1 == <span class="number">0</span> || col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> all - left - top + leftTop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.62.不同路径（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/unique-paths/">LeetCode.62.不同路径（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li>从上边<code>[m - 1, n]</code>来</li>
<li>从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？<br>按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为整个路径是要从上到下的，从下面上来，最后还是要下去，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为整个路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。<br>而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径数，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径数时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径数。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，达到的路径数量就是1。<br>第一行所有格子没有上面，都只能从左边过来，路径数都是1。<br>第一列所有格子没有左边，都只能从上边过来，路径数都是1。</p>
<p><strong>复杂度</strong><br>需要查看所有格子的情况来寻找路径数，所以要遍历所有网格，时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>记录所有达到所有格子的路径数，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径数推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径数？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径数，所以记录一行是必须的。<br>读取上一行格子的路径数，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.63.不同路径 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode.63.不同路径 II（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有障碍物说明不能达到，换句话说，到达障碍物格子的路径数为0。</p>
<p>设<code>dp[i][j]</code>为到达<code>[i, j]</code>格的路径数。</p>
<p><strong>状态转移方程</strong></p>
<ol>
<li><code>[i, j]</code>没有障碍物，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</li>
<li><code>[i, j]</code>有障碍物，<code>dp[i][j] = 0</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，下面格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br>只关心左边和上边的格子的路径数，不需要记录所有行的数据，只需要记录一行。<br>能不能只记录左边和上边，用两个变量完成？<br>不能，终点在最右边，路径可能从最左边过来，所以要记录一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment">// dp[j]: 达到上方格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]: 达到左方格子的路径数</span></span><br><span class="line">                <span class="keyword">else</span> dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.64.最小路径和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">LeetCode.64.最小路径和（中等）</a></p>
<p>给定一个包含非负整数的  <code>_m_ x _n_</code> 网格 <code>grid</code>  ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li> 从上边<code>[m - 1, n]</code>来</li>
<li> 从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？  按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为从起点到终点的路径是要从上到下的，如果从下面上来最后还是要下去，路径和增大了，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为起点到终点的路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。  而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径和，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径和时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径和。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，路径和就是当前元素值。<br>第一行所有格子没有上面，都只能从左边过来，路径和从左边累加。<br>第一列所有格子没有左边，都只能从上边过来，路径和从右边累加。</p>
<p><strong>复杂度</strong><br>要遍历所有网格，才能找到最少路径和，所以时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>如果记录达到所有格子的路径和，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + minOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径和推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径和？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径和，所以记录一行是必须的。  读取上一行格子的路径和，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径和。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 第一行不能从上边过来，特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) grid[i][j] + dp[j]</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] + minOf(dp[j], dp[j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1143.最长公共子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode.1143.最长公共子序列（中等）</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h3><p>尝试划分子问题。</p>
<p><strong>如果text1和text2存在公共子序列，那是怎么得来的？</strong><br>肯定是之前没有公共子序列或者存在公共子序列，然后又发现了两者相同的字符，得到了更长的公共子序列。</p>
<p><strong>如果末尾字符不相同怎么办？</strong></p>
<ol>
<li>删除text1的末尾字符，剩余字符串去跟text2比较。</li>
<li>删除text2的末尾字符，剩余字符串去跟text1比较。</li>
</ol>
<p>取两种情况中可以得到的最长公共子序列的情况。</p>
<p>同时删除text1和text2的末尾字符要不要考虑？</p>
<p>这里划分出了子问题和所有的递推步骤。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span> || i2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (text1[i1] == text2[i2]) <span class="number">1</span> + solve(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> maxOf(solve(i1 - <span class="number">1</span>, i2), solve(i1, i2 - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(text1.length - <span class="number">1</span>, text2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在重叠子问题，有大量重复计算，用数组记录中间计算结果。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun longestCommonSubsequence(text1: String, text2: String): Int &#123;</span><br><span class="line">        val memo = Array(text1.length) &#123; IntArray(text2.length) &#123; 0 &#125; &#125;</span><br><span class="line">        fun solve(i1: Int, i2: Int): Int &#123;</span><br><span class="line">            if (i1 == -1 || i2 == -1) return 0 </span><br><span class="line">            if (memo[i1][i2] &gt; 0) return memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = if (text1[i1] == text2[i2]) 1 + solve(i1 - 1, i2 - 1)</span><br><span class="line">            else maxOf(solve(i1 - 1, i2), solve(i1, i2 - 1))</span><br><span class="line">            return memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(text1.length - 1, text2.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：自底向上动态规划"><a href="#解法2：自底向上动态规划" class="headerlink" title="解法2：自底向上动态规划"></a>解法2：自底向上动态规划</h3><p>设<code>dp[i][j]</code>为<code>text1</code>的前<code>i + 1</code>个字符与<code>text2</code>的前<code>j + 1</code>个字符最长公共子序列的长度。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>text1[i] == text2[j]</code>时，<code>dp[i][j] = 1 + dp[i - 1][j - 1]</code></li>
<li><code>text1[i] != text2[j]</code>时，<code>dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
<p><strong>边界处理</strong><br>设<code>s1</code>是<code>text1</code>子字符串，<code>s2</code>是<code>text2</code>子字符串。</p>
<ul>
<li><code>s1</code>和<code>s2</code>为一个字符时，只需要判断字符是否相同，可以计算<code>dp[0][0]</code>。</li>
<li><code>s1</code>只有一个字符时，如果跟<code>s2</code>的字符不相同，<code>s1</code>没办法再删减，直接取<code>s2</code>删减后的结果。</li>
<li><code>s2</code>只有一个字符时，如果跟<code>s1</code>的字符不相同，<code>s2</code>没办法再删减，直接取<code>s1</code>删减后的结果。</li>
</ul>
<p><strong>复杂度</strong><br>设<code>text1</code>长度为<code>m</code>，<code>text2</code>长度为<code>n</code>。<br>时间复杂度O(mn)：双循环无法省略。<br>空间复杂度O(mn)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = text1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = text2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n1) &#123; IntArray(n2) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) dp[i][<span class="number">0</span>] = <span class="keyword">if</span> (text1[i] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) dp[<span class="number">0</span>][j] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[j]) <span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (text1[i] == text2[j]) <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1 - <span class="number">1</span>][n2 - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1143.最长公共子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.1277.%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode.1143.最长公共子序列（中等）</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h3><p>尝试划分子问题。</p>
<p><strong>如果text1和text2存在公共子序列，那是怎么得来的？</strong><br>肯定是之前没有公共子序列或者存在公共子序列，然后又发现了两者相同的字符，得到了更长的公共子序列。</p>
<p><strong>如果末尾字符不相同怎么办？</strong></p>
<ol>
<li>删除text1的末尾字符，剩余字符串去跟text2比较。</li>
<li>删除text2的末尾字符，剩余字符串去跟text1比较。</li>
</ol>
<p>取两种情况中可以得到的最长公共子序列的情况。</p>
<p>同时删除text1和text2的末尾字符要不要考虑？</p>
<p>这里划分出了子问题和所有的递推步骤。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span> || i2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (text1[i1] == text2[i2]) <span class="number">1</span> + solve(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> maxOf(solve(i1 - <span class="number">1</span>, i2), solve(i1, i2 - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(text1.length - <span class="number">1</span>, text2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在重叠子问题，有大量重复计算，用数组记录中间计算结果。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun longestCommonSubsequence(text1: String, text2: String): Int &#123;</span><br><span class="line">        val memo = Array(text1.length) &#123; IntArray(text2.length) &#123; 0 &#125; &#125;</span><br><span class="line">        fun solve(i1: Int, i2: Int): Int &#123;</span><br><span class="line">            if (i1 == -1 || i2 == -1) return 0 </span><br><span class="line">            if (memo[i1][i2] &gt; 0) return memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = if (text1[i1] == text2[i2]) 1 + solve(i1 - 1, i2 - 1)</span><br><span class="line">            else maxOf(solve(i1 - 1, i2), solve(i1, i2 - 1))</span><br><span class="line">            return memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(text1.length - 1, text2.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：自底向上动态规划"><a href="#解法2：自底向上动态规划" class="headerlink" title="解法2：自底向上动态规划"></a>解法2：自底向上动态规划</h3><p>设<code>dp[i][j]</code>为<code>text1</code>的前<code>i + 1</code>个字符与<code>text2</code>的前<code>j + 1</code>个字符最长公共子序列的长度。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>text1[i] == text2[j]</code>时，<code>dp[i][j] = 1 + dp[i - 1][j - 1]</code></li>
<li><code>text1[i] != text2[j]</code>时，<code>dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
<p><strong>边界处理</strong><br>设<code>s1</code>是<code>text1</code>子字符串，<code>s2</code>是<code>text2</code>子字符串。</p>
<ul>
<li><code>s1</code>和<code>s2</code>为一个字符时，只需要判断字符是否相同，可以计算<code>dp[0][0]</code>。</li>
<li><code>s1</code>只有一个字符时，如果跟<code>s2</code>的字符不相同，<code>s1</code>没办法再删减，直接取<code>s2</code>删减后的结果。</li>
<li><code>s2</code>只有一个字符时，如果跟<code>s1</code>的字符不相同，<code>s2</code>没办法再删减，直接取<code>s1</code>删减后的结果。</li>
</ul>
<p><strong>复杂度</strong><br>设<code>text1</code>长度为<code>m</code>，<code>text2</code>长度为<code>n</code>。<br>时间复杂度O(mn)：双循环无法省略。<br>空间复杂度O(mn)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = text1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = text2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n1) &#123; IntArray(n2) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) dp[i][<span class="number">0</span>] = <span class="keyword">if</span> (text1[i] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) dp[<span class="number">0</span>][j] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[j]) <span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (text1[i] == text2[j]) <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1 - <span class="number">1</span>][n2 - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.221.最大正方形（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode.221.最大正方形（中等）</a></p>
<p>在一个由  <code>&#39;0&#39;</code>  和  <code>&#39;1&#39;</code>  组成的二维矩阵内，找到只包含  <code>&#39;1&#39;</code>  的最大正方形，并返回其面积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。<br>想办法把大问题划分子问题+有限步骤。</p>
<h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p>记录最大的<code>side[i][j]</code>，再求平方就是最终结果</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>二维数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxLength = maxOf(maxLength, side[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[i][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[<span class="number">0</span>][j])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    maxLength = maxOf(maxLength, side[i][j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化的代码（kotlin）"><a href="#优化的代码（kotlin）" class="headerlink" title="优化的代码（kotlin）"></a>优化的代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一行状态</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[j])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储上一行状态，以方便接下来读取左上方的状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">	                <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">					<span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">					<span class="comment">// pre[j]: 上方状态</span></span><br><span class="line">                    side[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>], pre[j])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    side[j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = maxOf(maxLength, side[j])</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.221.最大正方形（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode.221.最大正方形（中等）</a></p>
<p>在一个由  <code>&#39;0&#39;</code>  和  <code>&#39;1&#39;</code>  组成的二维矩阵内，找到只包含  <code>&#39;1&#39;</code>  的最大正方形，并返回其面积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。<br>想办法把大问题划分子问题+有限步骤。</p>
<h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p>记录最大的<code>side[i][j]</code>，再求平方就是最终结果</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>二维数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxLength = maxOf(maxLength, side[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[i][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[<span class="number">0</span>][j])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    maxLength = maxOf(maxLength, side[i][j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化的代码（kotlin）"><a href="#优化的代码（kotlin）" class="headerlink" title="优化的代码（kotlin）"></a>优化的代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一行状态</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[j])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储上一行状态，以方便接下来读取左上方的状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">	                <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">					<span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">					<span class="comment">// pre[j]: 上方状态</span></span><br><span class="line">                    side[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>], pre[j])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    side[j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = maxOf(maxLength, side[j])</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.221.最大正方形（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode.221.最大正方形（中等）</a></p>
<p>在一个由  <code>&#39;0&#39;</code>  和  <code>&#39;1&#39;</code>  组成的二维矩阵内，找到只包含  <code>&#39;1&#39;</code>  的最大正方形，并返回其面积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。<br>想办法把大问题划分子问题+有限步骤。</p>
<h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p>记录最大的<code>side[i][j]</code>，再求平方就是最终结果</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>二维数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxLength = maxOf(maxLength, side[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[i][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[<span class="number">0</span>][j])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    maxLength = maxOf(maxLength, side[i][j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化的代码（kotlin）"><a href="#优化的代码（kotlin）" class="headerlink" title="优化的代码（kotlin）"></a>优化的代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一行状态</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[j])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储上一行状态，以方便接下来读取左上方的状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">	                <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">					<span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">					<span class="comment">// pre[j]: 上方状态</span></span><br><span class="line">                    side[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>], pre[j])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    side[j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = maxOf(maxLength, side[j])</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.322.零钱兑换（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">LeetCode.322.零钱兑换（中等）</a></p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一组东西中进行多种选择最终达到一个目标值，联想到背包问题，尝试划分子问题。</p>
<p>得到amount的上一步一定是从coins选择一个硬币得来的，但是不知道哪种选择所需的硬币数最少，那么就每个都试一下，取硬币数最少的。</p>
<p>选取一个硬币coin后，剩下amout - coin的金额是怎么得来的，也是同样的选择过程，并且这个子问题加上新的选择过程得到最优的最终结果，符合最优子结构。</p>
<p>如果一直选择先去有可能发现不能用选择过的硬币累加成amount，那就是无法组合。</p>
<p>如果一直选下去，发现可以凑成amount，记录选择过的硬币数量，同时每次对比最终取一个最少的硬币数量。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重叠子问题</strong><br>画出递归树，会发现会有重叠子问题，有大量的重复计算。<br>例如<code>coins = [1,2,4]</code>。<br>四次<code>select(amount - 1)</code>跟一次<code>select(amount - 4)</code>是重复计算的。<br>两次<code>select(amount - 2)</code>跟一次<code>select(amount - 4)</code>是重复计算的。</p>
<p><strong>记忆化递归</strong><br>消除重叠子问题就是记录中间计算结果。<br>计算的结果是硬币数，中间状态是跟<code>amount</code>有关，但是并不是0到<code>amount</code>都会有计算结果，所以可以用哈希表来存储中间状态，节省一点空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[amount] != <span class="literal">null</span>) memo[amount]!!</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">            memo[amount] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>记忆化递归从大的amount往小的amount去算，也可以从小的amount去递推大的amount。<br>初始值<code>dp[0] = 0</code>要存储一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (a <span class="keyword">in</span> <span class="number">1.</span>.amount) &#123;</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = dp.getOrDefault(a - coin, -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, count + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            dp[a] = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[amount]!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.376.摆动序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LeetCode.376.摆动序列（中等）</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，先划分子问题。</p>
<p>从某个摆动序列最后一个元素开始倒推，得到这个摆动序列有两个情况：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递增的。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递减的。</li>
</ol>
<p>子摆动序列怎么得来的，也是同样的递归划分。</p>
<p>这里有两个状态变化，一个是元素位置，一个是末尾差值。</p>
<p>设<code>dp[i][k]</code>表示数组中第0个到第<code>i</code>元素之间最长摆动序列长度；<br>k表示<code>nums[i]</code>和前面元素是递增或递减的情况；<br><code>k == 0</code> 时，表示递减；<br><code>k == 1</code> 时，表示递增。</p>
<p>考虑之前相反的情况，如果：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递减的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递增，也就更有可能得到更长的摆动序列。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递增的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递减，也就更有可能得到更长的摆动序列。</li>
</ol>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>nums[i] &lt; nums[i - 1]</code>，递减：<br>  <code>dp[i][0] = maxOf(dp[i][0], dp[i - 1][1] + 1)</code></li>
<li><code>nums[i] &gt; nums[i - 1]</code>，递增：<br>  <code>dp[i][1] = maxOf(dp[i][1], dp[i - 1][0] + 1)</code></li>
<li><code>nums[i] == nums[i - 1]</code>，持平：<br>  <code>dp[i][0] = dp[i - 1][0]</code><br>  <code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p><strong>边界处理</strong><br>最一开始只有一个元素，没有形成递增或递减，所以摆动序列长度为0。<br><code>dp[0][0] = 0</code><br><code>dp[0][1] = 0</code></p>
<p><strong>最后取值</strong><br>取<code>dp[n - 1][0]</code>和<code>dp[n - 1][1]</code>中较大的。<br>最后结果还要加1，因为我们是在发生新的摆动的时候才给序列增加长度的，遍历到最后时没有新的摆动了，但是目前的摆动没有算进长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br><code>dp[i]</code>只与<code>dp[i - 1]</code>有关，可以用变量记录状态，不用数组。</p>
<p>用<code>up</code>记录末尾递增的摆动序列的最长长度。<br>用<code>down</code>记录末尾递减的摆动序列的最长长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> up = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> down = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = maxOf(down, up + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = maxOf(up, down + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(up, down) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.377.组合总和 Ⅳ（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">LeetCode.377.组合总和 Ⅳ（中等）</a></p>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<span id="more"></span>

<p>示例 1：</p>
<blockquote>
<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只要看到目标值、数组、选择，这三要素，就直接可以反应想到是背包问题。</p>
<p>这里数组中的元素是可以重复选取的，所以是完全背包问题。</p>
<p>大的target可以拆解为小target加一系列选择求解，所以要遍历所有的target取值可能，还要遍历所有数字取值可能，有两层循环。</p>
<p>这里要注意顺序不同的序列被视作不同的组合，这涉及到双层循环的哪一个循环应该放在外层。<br>由于不锁定数字选择顺序，<code>nums</code>数组遍历应该放在内层，这样target才可以由不同顺序的选择得到。<br>如果<code>nums</code>数组遍历放在外层，会锁定<code>nums</code>数组的选取顺序，一个target只会有一种顺序的选择得到。<br>这与<a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a>情况正好相反。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum4</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(target + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (t <span class="keyword">in</span> <span class="number">0.</span>.target) &#123;</span><br><span class="line">            <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= num) &#123;</span><br><span class="line">                    dp[t] += dp[t - num]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/uncategorized/LeetCode.392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/is-subsequence">LeetCode.392.判断子序列（中等）</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：<br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h3><p>可以直接拿s和t做比较，遇到不相同的字符就跳过，只要保证s所有字符在t中，并且顺序没有改变即可。</p>
<p>时间复杂度O(m + n)：m为字符串s长度，n为字符串t长度，最坏情况下两个指针都要移动到字符串末尾。<br>空间复杂度O(1)：没有额外空间占用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：后续挑战-动态规划"><a href="#解法2：后续挑战-动态规划" class="headerlink" title="解法2：后续挑战 - 动态规划"></a>解法2：后续挑战 - 动态规划</h3><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。</p>
<p>双指针的问题在于：<br>S中的一个字符跟T中的字符匹配后，再去匹配下一个字符，需要在T中顺序查找，如果能直接查表得到位置，时间就降下来了。<br>假设S的长度为m，那么复杂度就可以降低为O(m)。</p>
<p>可以对T做预处理，记录位于<code>T</code>中第<code>i</code>个位置时字符<code>j</code>第一次出现的索引位置，用<code>dp[i][j]</code>来表示。<br>字符集是常数个，所以<code>j</code>的取值范围是一个常量。</p>
<p><strong>状态转移方程</strong><br>因为<code>dp[i][j]</code>记录的是<code>j</code>在<code>i</code>或<code>i</code>之后第一次出现的位置；<br>如果<code>T[i] == j</code>，<code>dp[i][j] = i</code>。<br>如果<code>T[i] != j</code>，<code>dp[i][j] = dp[i + 1][j]</code>。<br>如果<code>i</code>之后不存在字符<code>j</code>，令<code>dp[i][j] = -1</code><br>要从后往前递推。</p>
<p><strong>复杂度</strong><br>设m为S长度，n为T长度。<br>预处理时间复杂度O(n)。<br>判断子序列时间复杂度O(m)。</p>
<p>空间复杂度O(n * 字符集个数)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (t.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = t.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">26</span>) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = (<span class="string">&#x27;a&#x27;</span>.toInt() + j).toChar()</span><br><span class="line">                <span class="keyword">if</span> (t[i] == c) dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> indexT = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="comment">// t已经没有后续字符了，s还没匹配完，那肯定不是子序列</span></span><br><span class="line">            <span class="keyword">if</span> (indexT == n) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">val</span> cIndex = c.toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">            <span class="keyword">if</span> (dp[indexT][cIndex] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="comment">// s中的字符c匹配到了T中的字符，从T中下一个字符开始继续匹配</span></span><br><span class="line">            indexT = dp[indexT][cIndex] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>LeetCode.5.最长回文子串（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode.5.最长回文子串（中等）</a></p>
<p>给你一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h3><p>最值问题考虑动态规划，先拆分大问题为子问题+有限步骤。</p>
<p>判断一个字符串是不是回文串，先看字符串两端字符是否相同，然后去除首尾两端字符后的剩余字符串如果是回文串，整个字符串就是回文串。<br>剩余字符串是不是回文串判断方法是一样的。<br>整个判断可以递归进行，符合最优子结构，无后效性。<br>重叠子问题也有，长度大的回文串是由长度小的回文串推导而来，而长度相同的字符串有很多，会有重复判断。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文串。<br><code>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>
<p><strong>边界处理</strong><br>字符串<code>s</code>长度只有1时，是对称的，是回文串，<code>dp[i][j] = 1</code>。<br>字符串<code>s</code>为2时，去除首尾字符后没有子串了，只需要判断首尾字符是否相同即可，<code>dp[i][j] = s[i] == s[j]</code>。</p>
<p><strong>结果如何求解</strong><br>要遍历所有长度的子字符串，寻找有没有回文串，并记录最大长度的回文串。<br>长度相同的子字符串有很多，都要列举出来。</p>
<p><strong>复杂度</strong><br>设字符串长度为n。<br>穷举所有长度子串需要O(n)时间。<br>穷举每个长度的可能的子串也需要O(n)时间。<br>总的时间复杂度$O(n^2)$。</p>
<p>用二维数组记录了所有子串的是否是回文串状态，空间复杂度$O(n^2)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; BooleanArray(n) &#123; j -&gt; i == j &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 穷举子串左端起点</span></span><br><span class="line">            <span class="keyword">for</span> (l <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="comment">// 子串右端终点</span></span><br><span class="line">                <span class="keyword">val</span> r = l + len - <span class="number">1</span></span><br><span class="line">                dp[l][r] = <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">else</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> (dp[l][r] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len</span><br><span class="line">                    maxLeft = l</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLeft, maxLeft + maxLen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：中心扩散"><a href="#解法2：中心扩散" class="headerlink" title="解法2：中心扩散"></a>解法2：中心扩散</h3><p>解法1动态规划是从外向里判断的，也可以从里向外扩散判断。</p>
<p>穷举所有所有可能的中心点，向左右两端扩散，如果左右两端字符相同，说明能构成回文串，再继续扩散查看。</p>
<p>但是回文的中心点有两种可能。<br>回文串字符数是奇数，中心只有一个字符。<br>回文串字符数是偶数，中心有两个字符。</p>
<p>不知道哪种中心扩散生成的回文串长度最大，那就两个都试一下，取最大值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">centerSpread</span><span class="params">(l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">var</span> left = l</span><br><span class="line">            <span class="keyword">var</span> right = r</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] != s[right]) <span class="keyword">break</span></span><br><span class="line">                left--</span><br><span class="line">                right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里扩散完发现的回文串索引范围是[left + 1, right - 1]</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(left + <span class="number">1</span>, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> odd = centerSpread(i, i)</span><br><span class="line">            <span class="keyword">val</span> even = centerSpread(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> longer = <span class="keyword">if</span> (odd.length &gt; even.length) odd <span class="keyword">else</span> even</span><br><span class="line">            <span class="keyword">if</span> (longer.length &gt; longest.length) longest = longer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong><br>穷举中心点，需要遍历所有元素，消耗时间$O(n)$。<br>从中心点向两边扩散，最多扩展到整个字符串，所以最大消耗时间$O(n)$。<br>总体时间复杂度$O(n^2)$。</p>
<p>没有占用额外存储空间，空间复杂度$O(1)$。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.516.最长回文子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">LeetCode.516.最长回文子序列（中等）</a></p>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回文子序列的定义一定要搞清，不然不知道怎么求解。</p>
<p>根据示例，一个回文子序列是要求首尾字符是相同的，中间可以不是回文子串，但是求解序列长度其实是要删除不能构成回文子串的字符，然后再看剩下能构成回文子串的字符数是多少。</p>
<p><strong>那么什么情况下不能构成回文串？</strong><br>一个字符串首尾字符不相同，一定不是回文串。</p>
<p><strong>那应该删除首尾哪一个字符？</strong><br>因为要求最长的回文子序列，删除哪个字符后能够得到最长的回文子序列就删除哪个，但是不知道是哪个是最长的，所以都分别删除试一下，然后取最大值。</p>
<p><strong>删除字符后怎么办？</strong><br>删除字符后剩余字符串判断是不是回文子序列，还是一样的方法，所以可以递归进行。</p>
<p><strong>递归处理</strong><br>先看字符串两端字符是否相同：</p>
<ul>
<li>如果相同，可以算作回文子序列了，长度加2，但是总长度多少还得看去除首尾字符后剩余的字符串的回文子序列长度。</li>
<li>如果不相同，删除最左边字符，或者删除最右边字符，再看剩下的字符串的回文子序列长度。</li>
</ul>
<p><strong>边界</strong><br>递归一直在缩减字符串。<br>如果字符串是偶数个字符，每次两个字符的删减，最后肯定只剩两个字符，再缩减，会出现左指针索引大于指针右索引，直接返回0就行。<br>如果字符串一直一个个的缩减，最后左指针和右指针都会指向一个字符，一个字符是回文子串，长度返回1。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">	                <span class="comment">// 删除最左边字符</span></span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    <span class="comment">// 删除最右边字符</span></span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现递归是存在很多重叠子问题的，因为长的序列要依赖短的序列求解，比较短的序列结果就要反复被递归，这增加了耗时，所以给中间计算过的状态记录一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">`            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            memo[i][j] = <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>状态转移方程：<br>设<code>dp[i][j]</code>为字符串<code>s[i, j]</code>最长回文子序列长度。<br><code>s[i] == s[j]</code>时，<code>dp[i][j] = 2 + dp[i + 1][j - 1]</code><br><code>s[i] != s[j]</code>时，<code>dp[i][j] = maxOf(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>注意递推顺序，<code>i</code>是从<code>i + 1</code>递推来的，所以要从大到小遍历。<br><code>j</code>依赖<code>j - 1</code>，所以<code>j</code>是从小到大遍历。</p>
<p>由于<code>s[i, j]</code>要构成字符串，所以<code>i &lt;= j &lt; n</code>。<br><code>i == j</code>时，<code>dp[i][j] = 1</code>，可以单独处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; IntArray(n) &#123; j -&gt; <span class="keyword">if</span> (i == j) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (s[i] == s[j]) <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n^2)<br>空间复杂度O(n^2)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.516.最长回文子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">LeetCode.516.最长回文子序列（中等）</a></p>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回文子序列的定义一定要搞清，不然不知道怎么求解。</p>
<p>根据示例，一个回文子序列是要求首尾字符是相同的，中间可以不是回文子串，但是求解序列长度其实是要删除不能构成回文子串的字符，然后再看剩下能构成回文子串的字符数是多少。</p>
<p><strong>那么什么情况下不能构成回文串？</strong><br>一个字符串首尾字符不相同，一定不是回文串。</p>
<p><strong>那应该删除首尾哪一个字符？</strong><br>因为要求最长的回文子序列，删除哪个字符后能够得到最长的回文子序列就删除哪个，但是不知道是哪个是最长的，所以都分别删除试一下，然后取最大值。</p>
<p><strong>删除字符后怎么办？</strong><br>删除字符后剩余字符串判断是不是回文子序列，还是一样的方法，所以可以递归进行。</p>
<p><strong>递归处理</strong><br>先看字符串两端字符是否相同：</p>
<ul>
<li>如果相同，可以算作回文子序列了，长度加2，但是总长度多少还得看去除首尾字符后剩余的字符串的回文子序列长度。</li>
<li>如果不相同，删除最左边字符，或者删除最右边字符，再看剩下的字符串的回文子序列长度。</li>
</ul>
<p><strong>边界</strong><br>递归一直在缩减字符串。<br>如果字符串是偶数个字符，每次两个字符的删减，最后肯定只剩两个字符，再缩减，会出现左指针索引大于指针右索引，直接返回0就行。<br>如果字符串一直一个个的缩减，最后左指针和右指针都会指向一个字符，一个字符是回文子串，长度返回1。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">	                <span class="comment">// 删除最左边字符</span></span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    <span class="comment">// 删除最右边字符</span></span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现递归是存在很多重叠子问题的，因为长的序列要依赖短的序列求解，比较短的序列结果就要反复被递归，这增加了耗时，所以给中间计算过的状态记录一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">`            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            memo[i][j] = <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>状态转移方程：<br>设<code>dp[i][j]</code>为字符串<code>s[i, j]</code>最长回文子序列长度。<br><code>s[i] == s[j]</code>时，<code>dp[i][j] = 2 + dp[i + 1][j - 1]</code><br><code>s[i] != s[j]</code>时，<code>dp[i][j] = maxOf(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>注意递推顺序，<code>i</code>是从<code>i + 1</code>递推来的，所以要从大到小遍历。<br><code>j</code>依赖<code>j - 1</code>，所以<code>j</code>是从小到大遍历。</p>
<p>由于<code>s[i, j]</code>要构成字符串，所以<code>i &lt;= j &lt; n</code>。<br><code>i == j</code>时，<code>dp[i][j] = 1</code>，可以单独处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; IntArray(n) &#123; j -&gt; <span class="keyword">if</span> (i == j) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (s[i] == s[j]) <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n^2)<br>空间复杂度O(n^2)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.72.编辑距离（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode.72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/">LeetCode.72.编辑距离（困难）</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看着题目就给出了原子化的最小操作步骤了，看着就能拆成子问题的样子。</p>
<p>从两个单词末尾开始看起。</p>
<ul>
<li>如果<code>word1[i1] == word2[i2]</code>，就不用操作；<br>  接着就是去对比<code>word1[0, i1 - 1]</code>和<code>word2[0, i2 - 1]</code>这两个子字符串是不是一样，看子问题。</li>
<li>如果<code>word1[i1] != word2[i2]</code>，那么每个单词都有三种操作可以变成另一个；<br>具体哪种操作后的总操作数最少呢？只能每个都试一下，然后选个操作数最少的。</li>
</ul>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>是<code>word1[0, i]</code>转换为<code>word2[0, j]</code>的操作数。</p>
<ul>
<li><code>word1[i] == word2[j]</code>时，<br><code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>word1[i] != word2[j]</code>时：<ul>
<li><code>word1</code>末尾插入一个与<code>word2[j]</code>相同的字符，插入之前的操作数是<code>dp[i][j - 1]</code>。</li>
<li><code>word1</code>末尾删除一个字符，删除之前的操作数是<code>dp[i - 1][j]</code>。</li>
<li><code>word1</code>末尾字符替换为<code>word2[j]</code>，替换之前的操作数是<code>dp[i - 1][j - 1]</code>。</li>
<li>取插入、删除、替换操作数中最小的一个，<code>dp[i][j] = 1 + minOf(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])</code></li>
</ul>
</li>
</ul>
<p><strong>边界条件</strong></p>
<ul>
<li><code>i == 0</code>时，<ul>
<li><code>dp[i - 1][j]</code>表示空字符串变换到<code>word2[0, j]</code>需要的操作数，很显然要插入<code>j + 1</code>个字符，操作数是<code>j + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>j == 0</code>时，<ul>
<li><code>dp[i][j - 1]</code>表示空字符串变换到<code>word1[0, i]</code>需要的操作数，很显然要插入<code>i + 1</code>个字符，操作数是<code>i + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>i == 0 &amp;&amp; j == 0</code>时，<ul>
<li><code>dp[i - 1][j - 1]</code>（即<code>dp[-1][-1]</code>）表时空字符串转换到空字符串，操作数为0。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(word1.length - <span class="number">1</span>, word2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度</p>
<p>设m为word1长度，n为word2长度，m &lt; n。</p>
<p>画出递归树可以观察到，一个大问题最多可以拆解为3个子问题，也就是一个结点的下一层最多有3个结点，可以一直这样扩张，树高也就是m和n中的较大值。<br>最坏时间复杂度就是递归树的所有结点数，通过等比数列求和公式可得结点总数为 $O(3^n)$。</p>
<p>一次递归占用一个方法栈，空间复杂度就看同一时刻最多会有多少个方法栈存在，因为递归没有发现结果会回溯，所以得到正确答案的时候递归深度最深，也就是方法栈最多的时候。<br>空间复杂度 $O(n)$。</p>
</blockquote>
<p>递归有大量重叠子问题，比如<code>min(i1 - 1, i2 - 1)</code>在依次经历过<code>min(i1 - 1, i2)</code>和<code>min(i1 - 1, i2 - 1)</code>后可以得到，计算了两次，后续递归还有更多重叠子问题，得把中间计算结果保存一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n1) &#123; IntArray(n2) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1 - <span class="number">1</span>, n2 - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong><br>自底向上递推会用到前一项的值，为了避免大量边界判断，把dp数组长度加1。<br><code>dp[i][j]</code>表示<code>word1[0, i - 1]</code>和<code>word2[0, j - 1]</code>的最小编辑距离。</p>
<p><code>dp[i][0]</code>表示<code>word1[0, i - 1]</code>变成空字符串需要多少步操作，很显然是要删除<code>word1[0,i - 1]</code>所有字符，共有<code>i</code>个字符。</p>
<p><code>dp[0][j]</code>表示空字符串要变成<code>word2[0,j - 1]</code>需要多少步操作，很显然是要插入<code>word2[0, j - 1]</code>全部字符，总共<code>j</code>个字符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(len1 + <span class="number">1</span>) &#123; IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len1) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len2) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until len1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until len2) &#123;</span><br><span class="line">	            <span class="comment">// 当前字符相等，不需要操作，操作步数看上一个状态</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前字符不等，可以插入、替换、删除</span></span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + dp[i][j]</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[i + <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[i][j + <span class="number">1</span>]</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(mn)，需要用二维dp数组记录中间计算状态。</p>
</blockquote>
<p><strong>空间优化</strong><br><code>dp[i][j]</code>只跟左、上、左上三项有关，不需要用二维数组记录所有状态，只需要一行数组记录上一行状态即可。</p>
<p>这里有个问题在于，从左到右更新<code>dp</code>数组时会把左上角的值给覆盖掉，所以要在更新左边的值之前，把左上角的值先提前保存一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.len2) dp[j] = j</span><br><span class="line">        <span class="comment">// 表示左上角的值</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len1) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.len2) &#123;</span><br><span class="line">	            <span class="comment">// 更新左边的值之前，把左上角的值先提前保存一下</span></span><br><span class="line">                <span class="keyword">val</span> tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[j] = pre</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + pre</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[j]</span><br><span class="line">                    dp[j] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(n)，只需要用一维dp数组记录中间计算状态。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
</search>
