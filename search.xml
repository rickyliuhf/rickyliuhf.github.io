<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Task 相关</title>
    <url>/Android/Task/2015-07-20-android-task-about/</url>
    <content><![CDATA[<p>在日常开发过程中，只要涉及到activity，那么对task相关的东西总会或多或少的接触到，不过对task相关的一些配置的作用理解的还不是很透彻，官方文档在细节上说的也不够清楚，要透彻理解还是得自己写demo实践检验，所以便有了这篇总结。</p>
<span id="more"></span>

<h2 id="task的概念"><a href="#task的概念" class="headerlink" title="task的概念"></a>task的概念</h2><p>参考<a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></p>
<h2 id="查看设备当前task的方法"><a href="#查看设备当前task的方法" class="headerlink" title="查看设备当前task的方法"></a>查看设备当前task的方法</h2><ul>
<li><a href="http://stackoverflow.com/questions/2442713/view-the-tasks-activity-stack">View the Task’s activity stack</a></li>
<li><a href="http://stackoverflow.com/a/22392616/2011291">Show Back Stack of Android</a></li>
</ul>
<h2 id="AndroidManifest中activity标签下和task有关的属性"><a href="#AndroidManifest中activity标签下和task有关的属性" class="headerlink" title="AndroidManifest中activity标签下和task有关的属性"></a>AndroidManifest中activity标签下和task有关的属性</h2><h3 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#aff">taskAffinity</a></h3><ul>
<li>此属性用来标记activity应该属于哪个task。</li>
<li>拥有相同affinity的activity从理论上属于同一个task（在用户的角度看来好像这些activity属于同一个应用），一个task的affinity是由其根activity的taskAffinity取值决定的。</li>
<li>affinity决定了两件事。<ul>
<li>一个是在使用allowTaskReparenting修饰activity时，activity要重新宿主到哪个task。</li>
<li>另一个是使用FLAG_ACTIVITY_NEW_TASK启动activity时，activity要放入哪个task。</li>
</ul>
</li>
<li>如果没有给activity设置taskAffinity，默认都会读取application标签下的taskAffinity属性值，如果application标签下也没有设置taskAffinity，那taskAffinity默认值就是manifest标签下设置的包名。</li>
<li>不仅可以给同一个应用的不同activity设置不同的affinity，也可以给不同应用的activity设置相同的affinity，使它们在用户角度看来好像属于同一个应用。</li>
</ul>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#lmode">launchMode</a></h3><p>launchMode有四种取值，与Intent里以<code>FLAG_ACTIVITY_</code>开头的flag结合，可以对activity的启动达到各种不同的效果。</p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>activity默认的启动模式，每次启动一个standard模式的activity时，都新建一个实例。</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>当前task栈顶存在本activity的实例，直接使用该实例，调用该activity的onNewIntent()，否则新建一个activity的实例入栈。</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>当启动一个singleTask模式的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。 </p>
<ul>
<li>如果存在，那么检查该task栈里是否存在该activity实例。<ul>
<li>如果存在，则将该task调入前台，销毁在该activity以上的activity，并调用该activity的onNewIntent()。</li>
<li>如果不存在，则新建一个该activity实例，并入栈。 </li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他activity，允许其他activity跟自己处于同一个task栈中，也允许其他activity重新宿主到本activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard。</p>
<ul>
<li>从B启动C，C是singleTask，C的affinity和A、B相同，C会进入taskA栈顶。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C相同，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C不同，D会进入新建的taskB中。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskB中，taskB的affinity为D的affinity。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
<li>从B启动C，C是singleTask，C的affinity和A、B不同，C会进入新建的taskB中。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B相同，D会进入taskA栈顶。<ul>
<li>从D启动C，taskB调入前台，放在taskA的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同但与C相同，D会进入新建的taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同且与C也不同，D会进入新建的taskC中。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskC中，taskC的affinity为D的affinity。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>当启动一个singleInstance的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。</p>
<ul>
<li>如果存在，检查这个task中是否存在该activity的实例。<ul>
<li>如果存在，则将该task调入前台，并调用该activity实例的onNewIntent()。</li>
<li>如果不存在，则新建一个task，再新建该activity实例放入新建的task中，系统允许多个相同affinity的task同时存在。</li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他任何activity，都会放到其他task中（新建task或者寻找已存在的task，即使要启动的activity与该activity具有相同的affinity），也不允许其他activity宿主到本task，该activity是task中唯一的activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard</p>
<ul>
<li>从B中启动C，C是singleInstance，C的affinity和A、B相同，C会放入新建的taskB中，taskA和taskB的affinity相同，因为两个task的根activity的affinity相同。<ul>
<li>从C中启动D，D的affinity和A、B、C相同。<ul>
<li>D是standard、singleTop、singleTask时，D会放入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA、taskB的affinity相同，因为三个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B、C不同，不论D是何种launchMode，D都会进入新建的taskC中，taskC的affinity是D的affinity。</li>
</ul>
</li>
<li>从B中启动C，C是singleInstance，C的affinity和A、B不同，C会放入新建的taskB中，taskA和taskB的affinity不同，因为两个task的根activity的affinity不同。<ul>
<li>从C中启动D，D的affinity和A、B相同。<ul>
<li>D是standard、singleTop、singleTask时，D都会进入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA的affinity相同，因为两个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B不同，不论和C是否相同，D都会进入新建的taskC中，因为C所在的task不允许其他activity的存在，taskC的affinity为D的affinity。</li>
</ul>
</li>
</ul>
<p>使用场景：<br>使用singleInstance时，尽量给此activity设置单独的taskAffinity，以保证此activity处于不同名的task中，这样在“最近应用”的列表中可以看到这个task。否则如果有相同task名称的task存在，在“最近应用”的列表中就看不到这个含有singleInstance的activity的task了，只能通过代码启动这个activity来切换回这个task中。<br>而两个不同的task在用户角度来看是两个不同的应用，也就是两种不同的功能，所以使用singleInstance的activity功能上要与其他activity的功能区别较大。并且singleInstance是单例，也就是这个activity是公用的，可以在其他地方启动它来重复使用（可以是被同一个应用的其他地方重复使用，也可以是被其他的应用重复使用）。<br>例如，UC浏览器中有一个可以浏览office文档的activity（launchMode为singleInstance，taskAffinity也是独立的），这显然不是浏览器的主要功能。在文件管理器中点击一个excel文件（或者word、ppt文档）的时候，可以选择使用UC浏览器的这个activity来打开它，并且从用户角度看起来这个activity和UC浏览器是两个不同的应用（在“最近应用”的列表中可以看出来）。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#reparent">allowTaskReparenting</a></h3><p>此属性为true的activity被启动后，若有和此activity相同affinity的task转入前台，则此activity会从启动它的task移动到具有相同affinity的这个task。</p>
<p>例如，现在有两个应用分别为appA和appB，appA中有三个activity分别为activityA1、activityA2、activityA3，其中activityA1、activityA2的taskAffinity为taskA，activityA3的taskAffinity为taskB，appB中有一个activity为activityB1，其taskAffinity为taskB。所有activity都是standard模式。<br>启动appA，默认启动activityA1，再依次启动activityA2、activityA3，此时这三个activity都属于taskA。<br>按home键回到launcher，此时这三个activity扔都属于taskA。</p>
<ul>
<li>此时若点击appA的图标启动appA，看到的是activityA2，activityA3会进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskA、Launcher所在的task、taskB。<ul>
<li>按home键回到launcher，点击appB的图标启动appB，taskB调入前台显示，看到的是activityA3，而不是activityB1。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。</li>
</ul>
</li>
<li>此时若点击appB的图标启动appB，看到的是activityA3，activityA3进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。taskB中还有activityB1在栈底部，在activityA3中按返回键可以回到activityB1。taskA中仅剩activityA1、activityA2。</li>
</ul>
<h3 id="alwaysRetainTaskState"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#always">alwaysRetainTaskState</a></h3><p>如果用户离开一个task已经很久了，系统会在某个时刻清理掉这个task中除了根activity外所有的activity。当用户再次回到这个task，只有根activity被恢复。这样做是因为长期离开一个task，用户很有可能已经放弃了他之前所做的事情，转而要开始做新的事情，所以只保留根activity。<br>若根activity上的alwaysRetainTaskState为true，强制保留本task中的所有activity，即使过了很长时间，也不让系统清理task。<br>例如浏览器打开了很多个tab页，长时间不操作后也要保证再次回来时还是上次浏览的页面。</p>
<h3 id="clearTaskOnLaunch"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#clear">clearTaskOnLaunch</a></h3><p>与alwaysRetainTaskState相反，若根activity上的clearTaskOnLaunch为true，不论何时用户再次从Launcher回到这个task时，除了根activity以外的其他activity都销毁。</p>
<h3 id="finishOnTaskLaunch"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#finish">finishOnTaskLaunch</a></h3><p>此属性为true的activity，不论何时用户再次回到这个activity所属的task时，此activity会被销毁。此属性优先级优于allowTaskReparenting。</p>
<h2 id="Intent中和task有关的部分flag"><a href="#Intent中和task有关的部分flag" class="headerlink" title="Intent中和task有关的部分flag"></a>Intent中和task有关的部分flag</h2><h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_NEW_TASK">FLAG_ACTIVITY_NEW_TASK</a></h3><p>和launchMode的属性值singleTask等效。如果一个Intent中包含此flag，尝试将要启动的activity放在一个新的task中，如果已经有一个task栈里存在目标activity的实例，将此task从后台调到前台来，调用已存在的activity实例的onNewIntent()方法。此flag不能用于startActivityForResult()。</p>
<h3 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_SINGLE_TOP">FLAG_ACTIVITY_SINGLE_TOP</a></h3><p>和launchMode的属性值singleTop等效。如果一个Intent中包含此属性，并且要启动的Activity就是当前的Activity（当前task栈顶activity），直接调用该activity的onNewIntent()，否则新建一个activity实例。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP">FLAG_ACTIVITY_CLEAR_TOP</a></h3><p>如果一个Intent中包含此属性，并且当前task栈存存在目标activity的实例，清除该实例上面的所有的activity。<br>如果目标activity的launcherMode为standard，且Intent没有添加FLAG_ACTIVITY_SINGLE_TOP标记，则会销毁目标activity再重新创建，否则会重用该实例，调用onNewIntent()。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET"><a href="#FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET" class="headerlink" title="FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET">FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</a></h3><p>如果一个Intent中包含此属性，则它转向的那个Activity以及在那个Activity其上的所有Activity都会在task重置时被清除出task，这只发生在task重置的时候，而从Launcher中点击应用图标启动应用的时候会发生task重置（从Launcher启动应用会在Intent中附带一个FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></li>
<li><a href="http://blog.csdn.net/ff20081528/article/details/17219951">Tasks and Back Stack中文翻译</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html">AndroidManifest中activity标签API Doc</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html">Intent API Doc</a></li>
<li><a href="http://blog.csdn.net/liuhe688/article/details/6761337">Activity的task相关</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Task</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Task</tag>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.10.正则表达式匹配（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode.10.正则表达式匹配（困难）</a></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>题目已经给出了匹配规则。</p>
<h3 id="怎么做匹配？"><a href="#怎么做匹配？" class="headerlink" title="怎么做匹配？"></a>怎么做匹配？</h3><p>用两个指针<code>i</code>和<code>j</code>分别指向<code>s</code>和<code>p</code>的开头，一直匹配，如果两个指针都能到达<code>s</code>和<code>p</code>的末尾，说明匹配成功。</p>
<h3 id="的注意事项"><a href="#的注意事项" class="headerlink" title="*的注意事项"></a><code>*</code>的注意事项</h3><p><code>p</code>中遇到<code>*</code>时要考虑它前面一个字符是什么。</p>
<p>但我们是从左向右匹配的，所以在当前位置匹配字符时，要考虑<code>p</code>的下一个位置是不是<code>*</code>。</p>
<h3 id="如何用-匹配多个字符？"><a href="#如何用-匹配多个字符？" class="headerlink" title="如何用*匹配多个字符？"></a>如何用<code>*</code>匹配多个字符？</h3><p>可以匹配0个字符、1个字符，多个字符递归去解决。</p>
<ul>
<li>匹配0个字符时，指针<code>i</code>不动，<code>j</code>跳到<code>j + 2</code></li>
<li>匹配1个字符时，先要看<code>s[i]</code>是不是跟<code>p[j]</code>匹配，匹配的话<code>j</code>是不动的，因为可以匹配多个。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>按道理<code>j == p.length &amp;&amp; i == s.length</code>时，说明匹配完成，否则没有完成匹配。<br>但是因为有<code>*</code>的存在，可能<code>j</code>还指向<code>*</code>前面一个字符，<code>i</code>会先到末尾，即此时<code>j != p.length &amp;&amp; i == s.length</code>，也可能是匹配成功的，<code>i</code>发现<code>s</code>后面没有字符可匹配时，可以走<code>*</code>匹配0个字符的逻辑，这样<code>j</code>就到达末尾了。</p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">val</span> isStarPattern = j &lt;= n - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (isStarPattern) &#123;</span><br><span class="line">                <span class="keyword">val</span> isZeroMatched = match(i, j + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">val</span> isOneMatched = isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j)</span><br><span class="line">                isZeroMatched || isOneMatched</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：平均O(n * 2 ^ 星号数)，最差O(2^n)，</p>
</blockquote>
<h2 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h2><p>普通递归存在很多重叠子问题。</p>
<p>比如执行两次<code>match(i +  1, j)</code>再执行两次<code>match(i, j +  2)</code>的结果跟执行两次<code>match(i +  1, j +  1)</code>的结果是一样的。</p>
<p>所以需要记录中间结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;String, <span class="built_in">Boolean</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">val</span> key = <span class="string">&quot;<span class="variable">$i</span>,<span class="variable">$j</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (memo.contains(key)) <span class="keyword">return</span> memo[key]!!</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">val</span> isStarPattern = j &lt;= n - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">val</span> matched = <span class="keyword">if</span> (isStarPattern) &#123;</span><br><span class="line">                <span class="keyword">val</span> isZeroMatched = match(i, j + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">val</span> isOneMatched = isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j)</span><br><span class="line">                isZeroMatched || isOneMatched</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            memo[key] = matched</span><br><span class="line">            <span class="keyword">return</span> matched</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：平均O(n*(星号数+1))，最差O(n²)</p>
</blockquote>
<h2 id="解法3：自底向上动态规划"><a href="#解法3：自底向上动态规划" class="headerlink" title="解法3：自底向上动态规划"></a>解法3：自底向上动态规划</h2><p>由递归解法分析可知，大问题可以划分为子问题+有限步骤解决，并且符合最优子结构、无后效性、重叠子问题。<br>这里的关键是梳理出子问题是经过怎样的步骤得到大问题，即可得到状态转移方程。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[i][j]</code>为 <code>s</code> 的前<code>i</code>个字符是否能被 <code>p</code> 的前<code>j</code>个字符匹配。</p>
<ul>
<li><code>s[i - 1] == p[j - 1]</code>时，<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>s[i - 1] != p[j - 1]</code>时：<ul>
<li><code>p[j - 1] != &#39;.&#39; &amp;&amp; p[j - 1] != &#39;*&#39;</code>时，<code>dp[i][j] = false</code>。</li>
<li><code>p[j - 1] == &#39;.&#39;</code>时：<br><code>.</code>可以匹配任意字符，跟<code>s[i - 1] == p[j - 1]</code>的处理情况一样，即：<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>p[j - 1] == &#39;*&#39;</code>时：<br><code>*</code>可以匹配前面字符的0个或多个；<ul>
<li>匹配0次：<code>dp[i][j] = dp[i][j - 2]</code></li>
<li>匹配1次：<code>dp[i][j] = dp[i - 1][j] &amp;&amp; (p[j - 2] == s[i - 1] || p[j - 2] == &#39;.&#39;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> ls = s.length</span><br><span class="line">        <span class="keyword">val</span> lp = p.length</span><br><span class="line">        <span class="comment">// dp[i][j]表示s的前i个字符否能与p的前j个字符匹配，i和j分别从0开始取值</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(ls + <span class="number">1</span>) &#123; BooleanArray(lp + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">		<span class="comment">// 0个字符跟0个字符是匹配的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// p中有*是可以匹配0个字符的，所以做一下初始化</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">2</span> until dp[<span class="number">0</span>].size) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until dp.size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until dp[i].size) &#123;</span><br><span class="line">                <span class="keyword">val</span> si = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> pi = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (p[pi] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 匹配0次，字符可以不相等</span></span><br><span class="line">                    <span class="comment">// 匹配1次，字符要相同</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                            || dp[i - <span class="number">1</span>][j] &amp;&amp; (s[si] == p[pi - <span class="number">1</span>] || p[pi - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[si] == p[pi] || p[pi] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ls][lp]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 O(mn)：m、n分别为s、p长度，填充二维dp数组所需的时间。<br>空间复杂度 O(mn)：二维dp数组占用的空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1014.最佳观光组合（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.1014.%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">LeetCode.1014.最佳观光组合（中等）</a></p>
<p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。<br>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。<br>返回一对观光景点能取得的最高分。、</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ol>
<li>对一个确定的<code>j</code>，需要在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得观光组合得分最高。</li>
<li>不知道选哪个<code>j</code>能让得分最高，就需要穷举所有<code>j</code>的取值可能性。</li>
</ol>
<h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p>目标是求最大的观察观光组合得分，那么就得思考得分与什么相关，能否分解为独立的几个部分，再穷举每个部分所有的可能性，看这些可能性是怎么操作得到的，就可以知道得分是怎么来的了。</p>
<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>得分公式<code>values[i] + values[j] + i - j</code>里会变的东西就是<code>i</code>和<code>j</code>，这两个是独立变化的，那么就可以把公式拆成两部分：</p>
<ol>
<li>仅跟<code>i</code>相关的，即 <code>values[i] + i</code>，可以称为<code>scoreI</code></li>
<li>仅跟<code>j</code>相关的，即 <code>values[j] - j</code>，可以称为<code>scoreJ</code></li>
</ol>
<p>总分<code>score = scoreI + scoreJ</code></p>
<h3 id="对于一个确定的j，怎么使得得分最高呢？"><a href="#对于一个确定的j，怎么使得得分最高呢？" class="headerlink" title="对于一个确定的j，怎么使得得分最高呢？"></a>对于一个确定的j，怎么使得得分最高呢？</h3><ol>
<li><code>j</code>确定了， <code>scoreJ</code> 是确定的，不会变动。</li>
<li>然后在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得<code>scoreI</code> 最大，得分就是最高了。</li>
</ol>
<p>不确定选哪个<code>j</code>可以得分最高，那就遍历数组，穷举<code>j</code>所有的取值可能。</p>
<p>但是按照这个思路，先穷举<code>j</code>，再在每个<code>j</code>处往回穷举<code>i</code>，时间复杂度是O($n^2$)，是否存在不必要的操作？</p>
<h3 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h3><p>仔细分析两个步骤可以发现，没有必要往回穷举<code>i</code>，因为<code>i &lt; j</code>，在数组中遍历到<code>j</code>，<code>j</code>前面的位置肯定都遍历过了，<code>i</code>已经可以确定了；简单点说，<code>j</code>确定了，<code>i</code>就确定了。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(values: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = values.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxScoreI = values[<span class="number">0</span>] + <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxScore = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 穷举所有的j</span></span><br><span class="line">        <span class="comment">// 只有1个景点无法形成观光组合，所以从1开始遍历，这样至少2个有两个景点能形成观光组合</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> scoreJ = values[j] - j</span><br><span class="line">            <span class="keyword">val</span> score = maxScoreI + scoreJ</span><br><span class="line">            maxScore = maxOf(maxScore, score)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 上面已经处理过j，对于下一个j而言，需要知道下一个j前面最大的scoreI是多少</span></span><br><span class="line">            <span class="keyword">val</span> scoreI = values[j] + j</span><br><span class="line">            maxScoreI = maxOf(maxScoreI, scoreI)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxScore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1137.第N个泰波那契数（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">LeetCode.1137.第 N 个泰波那契数（简单）</a></p>
<p>泰波那契序列 Tn 定义如下：<br>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据公式直接递推，比斐波那契数列多一项。<br>记忆化递归就不写了。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tribonacci</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre3 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2 + pre3</span><br><span class="line">            pre3 = pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1143.最长公共子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode.1143.最长公共子序列（中等）</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h3><p>尝试划分子问题。</p>
<p><strong>如果text1和text2存在公共子序列，那是怎么得来的？</strong><br>肯定是之前没有公共子序列或者存在公共子序列，然后又发现了两者相同的字符，得到了更长的公共子序列。</p>
<p><strong>如果末尾字符不相同怎么办？</strong></p>
<ol>
<li>删除text1的末尾字符，剩余字符串去跟text2比较。</li>
<li>删除text2的末尾字符，剩余字符串去跟text1比较。</li>
</ol>
<p>取两种情况中可以得到的最长公共子序列的情况。</p>
<p>同时删除text1和text2的末尾字符要不要考虑？</p>
<p>这里划分出了子问题和所有的递推步骤。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span> || i2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (text1[i1] == text2[i2]) <span class="number">1</span> + solve(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> maxOf(solve(i1 - <span class="number">1</span>, i2), solve(i1, i2 - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(text1.length - <span class="number">1</span>, text2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在重叠子问题，有大量重复计算，用数组记录中间计算结果。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun longestCommonSubsequence(text1: String, text2: String): Int &#123;</span><br><span class="line">        val memo = Array(text1.length) &#123; IntArray(text2.length) &#123; 0 &#125; &#125;</span><br><span class="line">        fun solve(i1: Int, i2: Int): Int &#123;</span><br><span class="line">            if (i1 == -1 || i2 == -1) return 0 </span><br><span class="line">            if (memo[i1][i2] &gt; 0) return memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = if (text1[i1] == text2[i2]) 1 + solve(i1 - 1, i2 - 1)</span><br><span class="line">            else maxOf(solve(i1 - 1, i2), solve(i1, i2 - 1))</span><br><span class="line">            return memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(text1.length - 1, text2.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：自底向上动态规划"><a href="#解法2：自底向上动态规划" class="headerlink" title="解法2：自底向上动态规划"></a>解法2：自底向上动态规划</h3><p>设<code>dp[i][j]</code>为<code>text1</code>的前<code>i + 1</code>个字符与<code>text2</code>的前<code>j + 1</code>个字符最长公共子序列的长度。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>text1[i] == text2[j]</code>时，<code>dp[i][j] = 1 + dp[i - 1][j - 1]</code></li>
<li><code>text1[i] != text2[j]</code>时，<code>dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
<p><strong>边界处理</strong><br>设<code>s1</code>是<code>text1</code>子字符串，<code>s2</code>是<code>text2</code>子字符串。</p>
<ul>
<li><code>s1</code>和<code>s2</code>为一个字符时，只需要判断字符是否相同，可以计算<code>dp[0][0]</code>。</li>
<li><code>s1</code>只有一个字符时，如果跟<code>s2</code>的字符不相同，<code>s1</code>没办法再删减，直接取<code>s2</code>删减后的结果。</li>
<li><code>s2</code>只有一个字符时，如果跟<code>s1</code>的字符不相同，<code>s2</code>没办法再删减，直接取<code>s1</code>删减后的结果。</li>
</ul>
<p><strong>复杂度</strong><br>设<code>text1</code>长度为<code>m</code>，<code>text2</code>长度为<code>n</code>。<br>时间复杂度O(mn)：双循环无法省略。<br>空间复杂度O(mn)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = text1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = text2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n1) &#123; IntArray(n2) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) dp[i][<span class="number">0</span>] = <span class="keyword">if</span> (text1[i] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) dp[<span class="number">0</span>][j] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[j]) <span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (text1[i] == text2[j]) <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1 - <span class="number">1</span>][n2 - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.118.杨辉三角（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></p>
<p>给定一个非负整数 _<code>numRows</code>，_生成「杨辉三角」的前 <em><code>numRows</code></em> 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递推公式题目已经给出，讨论一下边界情况，把问题具体定义就好了。</p>
<h3 id="问题公式化"><a href="#问题公式化" class="headerlink" title="问题公式化"></a>问题公式化</h3><p>三角形每行用List存储，所有行也用List存储。<br>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>把三角形左侧对齐可以观察到：<br>左上方的数就是<code>dp[r - 1][c - 1]</code>；<br>右上方的数就是<code>dp[r - 1][c]</code>；</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>r = 0时，没有上方，但其实知道第一行是1，只有1个元素，直接添加到结果集就行了。<br>r &gt; 0后：<br>c = 0 处于第一列时，没有左上方，左上方当作0，只累加右上方，<code>dp[r][0] = dp[r - 1][c]</code>。<br>c = r 处于最后一列时，没有右上方，右上方当作0，只累加左上方，<code>dp[r][r] = dp[r - 1][r - 1]</code>。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(numRows: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> triangle = mutableListOf&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">        triangle.add(listOf(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until numRows) &#123;</span><br><span class="line">            <span class="keyword">val</span> rows = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0.</span>.r) &#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 第一列，只能加右上方</span></span><br><span class="line">                    c == <span class="number">0</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                    <span class="comment">// 最后一列，只能加左上方</span></span><br><span class="line">                    c == r -&gt; rows.add(triangle[r - <span class="number">1</span>][r - <span class="number">1</span>])</span><br><span class="line">                    <span class="comment">// 中间列，左上方+右上方</span></span><br><span class="line">                    <span class="keyword">else</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][c - <span class="number">1</span>] + triangle[r - <span class="number">1</span>][c])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            triangle.add(rows)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.119.杨辉三角 II（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></p>
<p>给定一个非负索引  <code>rowIndex</code>，返回「杨辉三角」的第  <code>rowIndex</code>  行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最直观就是求出杨辉三角所有行，取第<code>rowIndex</code>行。<br>实际每一行由上一行推导而来，不需要存储所有行，只需要保存上一行，递推来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>左上方的数：<code>dp[r - 1][c - 1]</code>；<br>右上方的数：<code>dp[r - 1][c]</code>；<br><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>用一个数组就可以完成每行迭代。<br><code>dp[c] = dp[c - 1] + dp[c]</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>更新第c列时，会读取c - 1列的旧值；<br>但是c - 1列在更新数组的时候已经被新值覆盖了。<br>解决方案：</p>
<ol>
<li>从左向右遍历数组时，临时存储一下旧值。</li>
<li>从右向左遍历数组。</li>
</ol>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRow</span><span class="params">(rowIndex: <span class="type">Int</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = IntArray(rowIndex + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        rows[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1.</span>.rowIndex) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> r - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">                rows[c] = rows[c - <span class="number">1</span>] + rows[c]</span><br><span class="line">            &#125;</span><br><span class="line">            rows[r] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows.toList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.120.三角形最小路径和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/triangle/">LeetCode.120.三角形最小路径和（中等）</a></p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目已经给出了递推公式，是从上往下取值的，所以要从最后一行往上递推，最后得到结果。<br>如果用递归写，这个顺序就会比较明白，递归划分为子问题后，实际是自底向上传递计算结果的。</p>
<p>设<code>dp[i][j]</code>为第i行第j列向下的最小路径和。<br>总共<code>n</code>行。</p>
<p>最后一行没有下一行了，所以<br><code>dp[n - 1][j] = triangle[n - 1][j]</code></p>
<p>上面的行，状态转移方程为：<br><code>dp[i][j] = triangle[i][j] + minOf(dp[i + 1][j], dp[i + 1][j + 1]</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minimumTotal</span><span class="params">(triangle: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Int</span>&gt;&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = triangle.size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[n - <span class="number">1</span>][j] = triangle[n - <span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.i) &#123;</span><br><span class="line">                dp[i][j] = triangle[i][j] + minOf(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.121.买卖股票的最佳时机（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode.121.买卖股票的最佳时机（简单）</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>设dp[i]为第0天到第i天获取最大利润。</p>
<p>在第i天，可以选择不卖股票或卖出股票。</p>
<ol>
<li>不卖股票，dp[i] = dp[i - 1]</li>
<li>卖出股票，由于只能买入一次和卖出一次，那要获得最大利润，肯定要在第0天到第i -1中股票最低的时候买入，dp[i] = prices[i] - minPrice</li>
</ol>
<p>dp[i]只与上一个状态有关，所以可以用变量存储状态，不需要数组记录。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxProfit = maxOf(maxProfit, prices[i] - minPrice)</span><br><span class="line">            minPrice = minOf(minPrice, prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="comment">// dp[i][k]表示前i天持有和未持有第i天的股票的最大收益</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 第i天未持有，可能是前i-1天就未持有然后今天不操作，或者以前持有了今天卖出了</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            <span class="comment">// 第i天持有，可能是前i-1天就持有了然后今天不操作，或者以前就未持有今天买入了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.122.买卖股票的最佳时机 II（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划。</p>
<h3 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h3><p>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。<br>归纳合并一下，这些操作会产生的结果状态是：</p>
<ol>
<li>第<code>i</code>天持有股票</li>
<li>第<code>i</code>天不持有股票</li>
</ol>
<h3 id="为什么要关注操作得到的结果状态？"><a href="#为什么要关注操作得到的结果状态？" class="headerlink" title="为什么要关注操作得到的结果状态？"></a>为什么要关注操作得到的结果状态？</h3><p>因为选择某个操作，就是上一个状态转变为下一个状态，所以需要知道操作前后的状态是什么。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>第<code>i</code>天有两个股票持有状态，不同股票持有状态的收益是不一样的。<br>一个状态经过选择操作后可能会转化为另一个状态，所以要记录所有状态的信息。<br>也就是要把天数和股票持有状态组合的所有状态都要记录下来。</p>
<p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p>根据第<code>i</code>天的选择操作来梳理状态转移方程：</p>
<ol>
<li>第<code>i</code>天买入，变成持有股票的状态，利润要减去<code>prices[i]</code>，题目要求买入前不能持有股票，所以<code>dp[i][1] = dp[i - 1][0] - prices[i]</code>。</li>
<li>第<code>i</code>天卖出，变成不持有股票的状态，利润要加上<code>prices[i]</code>，卖出前肯定要持有股票才能卖，所以<code>dp[i][0] = dp[i - 1][1] + prices[i]</code>。</li>
<li>第<code>i</code>天什么也不做，不管是持有还是不持有股票，前<code>i</code>天的利润跟前<code>i - 1</code>天的利润一样，所以<code>dp[i][0] = dp[i - 1][0]，dp[i][1] = dp[i - 1][1]</code>。</li>
</ol>
<p>综合一下：<br><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code><br><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></p>
<h3 id="到了最后一天，应该取dp-n-1-0-还是dp-n-1-1-？"><a href="#到了最后一天，应该取dp-n-1-0-还是dp-n-1-1-？" class="headerlink" title="到了最后一天，应该取dp[n - 1][0]还是dp[n - 1][1]？**"></a>到了最后一天，应该取dp[n - 1][0]还是dp[n - 1][1]？**</h3><p>最后一天如果还持有股票，利润肯定要变小，肯定是不持有股票的时候收益最大，取<code>dp[n - 1][0]</code>。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p><code>dp[0][0] = 0</code>，第0天不持有股票利润就是0。<br><code>dp[0][1] = -prices[i]</code>，第0天持有股票只能买入，利润为负。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i][k]</code>只跟上一个状态有关，用变量记录上一个状态，不需要用数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.124.二叉树中的最大路径和（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">LeetCode.124.二叉树中的最大路径和（困难）</a></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设找到了最大路径和的路径，观察这个路径的特点，可以发现路径必然会经过一个根节点，也就是从一个根节点向左和向右延伸可以到达整个路径。</p>
<h3 id="路径和怎么计算？"><a href="#路径和怎么计算？" class="headerlink" title="路径和怎么计算？"></a>路径和怎么计算？</h3><p>可以遍历每一个节点，计算当前节点左、右子树上的最大路径和，再与当前节点的值相加即可。</p>
<h3 id="计算路径和的注意事项"><a href="#计算路径和的注意事项" class="headerlink" title="计算路径和的注意事项"></a>计算路径和的注意事项</h3><p>这里要注意节点值可能是负数，所以左右子树的路径和可能是负的，越加越小，如果是负的肯定就不加了。</p>
<h3 id="左右子树最大路径和怎么求？"><a href="#左右子树最大路径和怎么求？" class="headerlink" title="左右子树最大路径和怎么求？"></a>左右子树最大路径和怎么求？</h3><p>对于某个节点x来说，若其左子树路径和为leftSum，右子树路径和为rightSum，对于x的父节点来说，只能选用leftSum和rightSum种较大的那个，再加上x的值，作为x的父节点的子树路径和。否则就路径就有分叉了，不满足题意。</p>
<h3 id="怎么求最大路径和？"><a href="#怎么求最大路径和？" class="headerlink" title="怎么求最大路径和？"></a>怎么求最大路径和？</h3><p>计算每个节点路径和时，记录最大的那个路径和的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var ti = TreeNode(5)</span></span><br><span class="line"><span class="comment"> * var v = ti.`val`</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var left: TreeNode? = null</span></span><br><span class="line"><span class="comment"> *     var right: TreeNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxSum = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">maxGain</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> leftSum = maxOf(<span class="number">0</span>, maxGain(root.left))</span><br><span class="line">            <span class="keyword">val</span> rightSum = maxOf(<span class="number">0</span>, maxGain(root.right))</span><br><span class="line">            <span class="keyword">val</span> currentPathSum = root.`<span class="keyword">val</span>` + leftSum + rightSum</span><br><span class="line">            maxSum = maxOf(maxSum, currentPathSum)</span><br><span class="line">            <span class="keyword">return</span> root.`<span class="keyword">val</span>` + maxOf(leftSum, rightSum)</span><br><span class="line">        &#125;</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.126.单词接龙 II（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-ladder-ii/">LeetCode.126.单词接龙 II（困难）</a></p>
<p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</li>
<li>sk == endWord</li>
</ul>
<p>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>通过广度优先搜索建立图的邻接表。<ul>
<li>在发现最短转换路径时停止构建图。</li>
<li>有可能有多条最短路径，所以发现了一条最短路径时不要立刻终止，等这一层都遍历完。</li>
</ul>
</li>
<li>通过深度优先搜索，求得最短路径。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findLadders</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 单词列表转为哈希集合，便于快速查找</span></span><br><span class="line">        <span class="keyword">val</span> wordSet = wordList.toSet()</span><br><span class="line">        <span class="comment">// 单词列表中没有endWord直接返回，不用搜索了</span></span><br><span class="line">        <span class="keyword">if</span> (!wordSet.contains(endWord)) <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs建立图的邻接表</span></span><br><span class="line">        <span class="keyword">val</span> graph = mutableMapOf&lt;String, MutableSet&lt;String&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> found = bfs(beginWord, endWord, wordSet, graph)</span><br><span class="line">        <span class="keyword">if</span> (!found) <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs搜索</span></span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;List&lt;String&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> path = mutableListOf(beginWord)</span><br><span class="line">        dfs(beginWord, endWord, graph, path, result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;, graph: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, MutableSet&lt;String&gt;&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = java.util.ArrayDeque&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        queue.add(beginWord)</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> levelVisited = mutableSetOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> levelCount = queue.size</span><br><span class="line">            repeat(levelCount) &#123;</span><br><span class="line">                <span class="keyword">val</span> currentWord = queue.poll()</span><br><span class="line">                <span class="keyword">val</span> nextNodes = getNextLevelNodes(currentWord, wordSet)</span><br><span class="line">                <span class="keyword">for</span> (nextWord <span class="keyword">in</span> nextNodes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited.contains(nextWord)) <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> (nextWord == endWord) &#123;</span><br><span class="line">                        found = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(nextWord)</span><br><span class="line">                    levelVisited.add(nextWord)</span><br><span class="line"></span><br><span class="line">                    graph.getOrPut(currentWord, &#123; mutableSetOf() &#125;)</span><br><span class="line">                            .add(nextWord)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在某一层发现了路径终点，就直接不继续了，这样保证路径是最短的</span></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            visited.addAll(levelVisited)</span><br><span class="line">            levelVisited.clear()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, graph: <span class="type">Map</span>&lt;<span class="type">String</span>, Set&lt;String&gt;&gt;, path: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;, result: <span class="type">MutableList</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginWord == endWord) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(beginWord)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        graph[beginWord]?.forEach &#123; nextWord -&gt;</span><br><span class="line">            path.add(nextWord)</span><br><span class="line">            dfs(nextWord, endWord, graph, path, result)</span><br><span class="line">            path.removeAt(path.lastIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变化[word]每一个位置的字符，看是否存在于单词列表中，存在的话，记录为下一层的顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextLevelNodes</span><span class="params">(word: <span class="type">String</span>, wordSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>: Set&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> nodes = mutableSetOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> chars = word.toCharArray()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> chars.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> oldChar = chars[i]</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = <span class="string">&#x27;a&#x27;</span> + j</span><br><span class="line">                <span class="keyword">if</span> (c == oldChar) <span class="keyword">continue</span></span><br><span class="line">                chars[i] = c</span><br><span class="line">                <span class="keyword">val</span> next = String(chars)</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(next)) &#123;</span><br><span class="line">                    nodes.add(next)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[i] = oldChar</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>图</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.127.单词接龙（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-ladder/">LeetCode.127.单词接龙（困难）</a></p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code>  和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p>
<ul>
<li>序列中第一个单词是 beginWord 。</li>
<li>序列中最后一个单词是 endWord 。</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典 wordList 中的单词。</li>
</ul>
<p>你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p>
<span id="more"></span>
<p>提示：</p>
<ul>
<li>1 &lt;= beginWord.length &lt;= 10</li>
<li>endWord.length == beginWord.length</li>
<li>1 &lt;= wordList.length &lt;= 5000</li>
<li>wordList[i].length == beginWord.length</li>
<li>beginWord、endWord 和 wordList[i] 由小写英文字母组成</li>
<li>beginWord != endWord</li>
<li>wordList 中的所有字符串 互不相同</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>有一个起点、一个终点，加上一系列路径的选择，就是搜索问题。</li>
<li>可以用深度优先搜索或广度优先搜索，每个单词就是图中一个结点。</li>
</ul>
<h3 id="用DFS还是BFS？为什么？"><a href="#用DFS还是BFS？为什么？" class="headerlink" title="用DFS还是BFS？为什么？"></a>用DFS还是BFS？为什么？</h3><ul>
<li>题目要求最短转换序列，也就是求最短路径，用广度优先搜索用时最短，发现到达终点就直接返回。</li>
<li>如果用深度有限搜索，遍历完所有路径还得回溯，会比较耗时。</li>
</ul>
<p>但是搜索需要有路径选择，这就引出了下一个问题。</p>
<h3 id="对于每一个单词，它的邻接单词有哪些？"><a href="#对于每一个单词，它的邻接单词有哪些？" class="headerlink" title="对于每一个单词，它的邻接单词有哪些？"></a>对于每一个单词，它的邻接单词有哪些？</h3><ul>
<li>每次转换单词只能改变一个字母，但是单词有n个字母，不知道转换哪个，那就所有的都尝试转换一遍，看能得到哪些单词。</li>
<li>可以提前存储好每个单词能转换到的单词，直接O(1)时间查询，可以用哈希表存储。</li>
<li>对于转换到的单词而言，他跟转换前的单词的区别也就是那一个字符不同，其他字符都相同，并且可能有多个能转换到的单词。<ul>
<li>我们可以用对要变化的位置上加上*再加上剩余字母作为哈希表的键，单词列表作为哈希表的值。</li>
<li>提前读取所有单词，做预处理。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ladderLength</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 所有单词长度一致</span></span><br><span class="line">        <span class="keyword">val</span> wordLength = beginWord.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key是通配词，value是这个通配词对应的所有词</span></span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()</span><br><span class="line">        wordList.forEach &#123; word -&gt;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until wordLength) &#123;</span><br><span class="line">                <span class="keyword">val</span> key = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, wordLength)</span><br><span class="line">                <span class="keyword">val</span> list = map.getOrDefault(key, mutableListOf())</span><br><span class="line">                list.add(word)</span><br><span class="line">                map[key] = list</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问数组，防止绕环</span></span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">val</span> queue = ArrayDeque&lt;String&gt;()</span><br><span class="line">        queue.add(beginWord)</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> emptyList = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> count = queue.size</span><br><span class="line">            repeat(count) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = queue.poll()</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until wordLength) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, wordLength)</span><br><span class="line">                    <span class="keyword">val</span> adjacentWords = map.getOrDefault(key, emptyList)</span><br><span class="line">                    adjacentWords.forEach &#123; adjacentWord -&gt;</span><br><span class="line">                        <span class="comment">// 加1是因为endWord也算一个步骤，要加上</span></span><br><span class="line">                        <span class="keyword">if</span> (adjacentWord == endWord) <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(adjacentWord)) &#123;</span><br><span class="line">                            visited.add(adjacentWord)</span><br><span class="line">                            queue.add(adjacentWord)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>图</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1277.统计全为 1 的正方形子矩阵（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.1277.%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">LeetCode.1277.统计全为 1 的正方形子矩阵（中等）</a></p>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是  <code>0</code>  就是  <code>1</code>，请你统计并返回其中完全由  <code>1</code>  组成的  <strong>正方形</strong>  子矩阵的个数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p><code>side</code>数组每一项累加，就是所有能用1组成的正方形的个数。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countSquares</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        count += side[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    count += side[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化后代码（kotlin）"><a href="#优化后代码（kotlin）" class="headerlink" title="优化后代码（kotlin）"></a>优化后代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countSquares</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[j]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储上一行状态，以便接下来读取左上方状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                side[j] = <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// side[j]: 上方状态</span></span><br><span class="line">                    <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">                    <span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> </span><br><span class="line">                    <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j], side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>])</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                count += side[j]</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1314.矩阵区域和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a></p>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p>
<ul>
<li>i - k &lt;= r &lt;= i + k,</li>
<li>j - k &lt;= c &lt;= j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
<span id="more"></span>

<p>提示：</p>
<blockquote>
<p>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, k &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力解法需要O($n^4$)时间复杂度，考虑时间更优化的算法。</p>
<h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>题目要求解区域和是二维的，可以简化问题，先看看一维数组某一区间的元素和怎么求，因为二维的区域相当于一维的叠加。</p>
<h3 id="一维数组某区间内元素和怎么快速求解？"><a href="#一维数组某区间内元素和怎么快速求解？" class="headerlink" title="一维数组某区间内元素和怎么快速求解？"></a>一维数组某区间内元素和怎么快速求解？</h3><p>可以预先计算和存储每个位置的前缀和（第0个到第i个元素之间所有元素的和），要计算某个区间的和，用区间端点的前缀和相减就可以在O(1)时间复杂度内求解，但需要占用O(n)空间。</p>
<p>考虑用二维前缀和快速求解面积问题。</p>
<h3 id="二维前缀和定义"><a href="#二维前缀和定义" class="headerlink" title="二维前缀和定义"></a>二维前缀和定义</h3><p>第0行第0列到第r行第c列形成的矩形区域内所有元素的和。<br>记为<code>preSum[r][c]</code>。</p>
<h3 id="怎么利用二维前缀和求解区域面积？"><a href="#怎么利用二维前缀和求解区域面积？" class="headerlink" title="怎么利用二维前缀和求解区域面积？"></a>怎么利用二维前缀和求解区域面积？</h3><p>比如要求区域d的元素和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列：                  </span><br><span class="line">0   a a a b b b b b   </span><br><span class="line">1   a a a b b b b b</span><br><span class="line">2   c c c d d d d d</span><br><span class="line">3   c c c d d d d d</span><br><span class="line">4   c c c d d d d d</span><br><span class="line">行： 0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>公式表达：<br><code>区域d所有元素和 = preSum[7,4] - preSum[2, 4] - preSum[7, 1] + preSum[2, 1]</code><br><code>preSum[7,4]</code>：整个区域所有元素和<br><code>preSum[2, 4]</code>：区域a + 区域c<br><code>preSum[7, 1]</code>：区域a + 区域b<br><code>preSum[2, 1]</code>：区域a</p>
<h3 id="二维前缀和怎么推导？"><a href="#二维前缀和怎么推导？" class="headerlink" title="二维前缀和怎么推导？"></a>二维前缀和怎么推导？</h3><ul>
<li>第一行和第一列前缀和不用推导，左边和上边都没有元素，直接等于元素本身。</li>
<li>第一行上方没有元素，当作一维前缀和求解。</li>
<li>第一列和第一行情况相同，方向变了一下，还是当作一维前缀和求解。</li>
<li>非第一行和非第一列位置的前缀和，跟求解区域和类似，前缀和 = 上方二维前缀和 + 左方二维前缀和 - 左上方二维前缀和 + 本元素值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">matrixBlockSum</span><span class="params">(mat: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, k: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> m = mat.size</span><br><span class="line">        <span class="keyword">val</span> n = mat[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> answer = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) preSum[r][<span class="number">0</span>] = mat[r][<span class="number">0</span>] + preSum[r - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) preSum[<span class="number">0</span>][c] = mat[<span class="number">0</span>][c] + preSum[<span class="number">0</span>][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                preSum[r][c] = mat[r][c] + preSum[r - <span class="number">1</span>][c] + preSum[r][c - <span class="number">1</span>] - preSum[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解区域和</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> leftTopX = maxOf(r - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> leftTopY = maxOf(c - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomX = minOf(r + k, m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomY = minOf(c + k, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> wholeArea = preSum[rightBottomX][rightBottomY]</span><br><span class="line">                <span class="keyword">val</span> leftArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][rightBottomY] </span><br><span class="line">                <span class="keyword">val</span> topArea = <span class="keyword">if</span> (leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[rightBottomX][leftTopY - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> leftTopArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span> || leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][leftTopY - <span class="number">1</span>]</span><br><span class="line">                answer[r][c] = wholeArea - leftArea - topArea + leftTopArea</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.132.分割回文串 II（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">LeetCode.132.分割回文串 II（困难）</a></p>
<p>给你一个字符串  <code>s</code>，请你将  <code>s</code>  分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的  <strong>最少分割次数</strong>  。</p>
<span id="more"></span>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 2000</code></li>
<li>  <code>s</code>  仅由小写英文字母组成</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="拆解问题"><a href="#拆解问题" class="headerlink" title="拆解问题"></a>拆解问题</h3><p>如果已经求得一个子串的最少分割次数，是可以推导出整个串的最少分割次数。</p>
<ul>
<li>要保证分割次数最少，先检查整个串s是不是回文。<ul>
<li>如果是，就不用分割了，分割次数是0。</li>
<li>如果s不是回文，需要在0到<code>n - 1</code>（n为s长度）中找一个分割位置<code>i</code>。<ul>
<li>如果<code>s[0: i]</code>的最少分割次数已经知道<code>（0 &lt;= i &lt; n）</code>，同时<code>s[i + 1:]</code>是回文，说明在<code>s[0: i]</code>的最少分割次数基础上还要再多分割一次才能完成整个串的分割，那么整个字符串s的最少分割次数就是<code>s[0: i]</code>的最少分割次数 + 1。</li>
<li>而<code>s[0: i]</code>的最少分割次数其实是需要把<code>i</code>从0到<code>n - 2</code>全部遍历一遍才知道哪一种分割的次数是最小的，那么<code>s[0: i]</code>的最少分割次数的求法，跟上述过程一样，可以递推。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：s[0: i]是python中截取子串的表示方法，表示截取第0位到第i位的字符)</p>
</blockquote>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>令<code>dp[i]</code>表示<code>s[0: i]</code>的最少分割次数。</p>
<p>如果<code>s[0: i]</code>就是回文，那么<code>dp[i]</code>就是0。<br>如果<code>s[0: i]</code>不是回文，但是它的一个子串<code>s[0: j]</code>的最少分割次数已知(<code>0 &lt;= j &lt; i</code>)，并且<code>s[j + 1: i]</code>是回文，则 <code>dp[i] = dp[j] + 1</code> </p>
<p>最终结果就是求<code>dp[n - 1]</code>，从0开始递推就好了。</p>
<p>递推方程： <code>dp[i] = min(dp[j]) + 1</code>，其中<code>0 &lt;= j &lt; i</code>。</p>
<h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><ul>
<li>初始状态<code>dp[0]</code>就是<code>s[0: 0]</code>的最少分割次数，<code>s[0: 0]</code>就是首字符，单个字符是回文串，所以不用分割，<code>dp[0] = 0</code>。</li>
<li>最坏的情况就是每个字符都分割，因为每个单字符都是回文，最大的分割次数就是<code>n - 1</code>，可以给<code>dp</code>数组初始化。</li>
</ul>
<h3 id="怎么快速判断s-i-j-是回文？"><a href="#怎么快速判断s-i-j-是回文？" class="headerlink" title="怎么快速判断s[i, j]是回文？"></a>怎么快速判断s[i, j]是回文？</h3><p>最好预处理整个s，把s的所有子串都判断一下是不是回文串，这样就可以做到O(1)的查表操作来快速判断了。</p>
<p>这里跟 <a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a> 处理方式一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCut</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n)</span><br><span class="line">        <span class="comment">// s[0: i]的子串最大分割次数，就是每个字符都分割一下，分割i次（1 &lt;= i &lt; n）</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 判断s[0:i]是不是回文</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, i)) &#123;</span><br><span class="line">                <span class="comment">// s[0:i]是回文，不用分割，最少分割次数是0</span></span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s[0:i]不是回文，需要在[0,i)之间找到一个分割位置j，使得s[j+1:i]是回文，同时dp[j]最小</span></span><br><span class="line">            <span class="comment">// 需要从0开始遍历到i-1去寻找出最小的分割位置j</span></span><br><span class="line">            <span class="comment">// 这样也才能利用递推，利用之前存储过的状态，因为是从索引0开始递推的</span></span><br><span class="line">            <span class="keyword">var</span> minCut = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(s, j + <span class="number">1</span>, i)) &#123;</span><br><span class="line">                    <span class="comment">// s[j+1:i]是回文，dp[j]+1是dp[i]可能的一个取值，需要找一个最小的</span></span><br><span class="line">                    minCut = minOf(minCut, dp[j] + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// s[j+1:i]不是回文，当前的分割是无效的，就看下一个分割了，忽略当前的分割</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s[0:i]最大的分割次数，就是i次了，在前面已经初始化过了</span></span><br><span class="line">            <span class="comment">// 如果s[0:i]存在更少的分割，更新dp[i]的值</span></span><br><span class="line">            <span class="keyword">if</span> (minCut != <span class="built_in">Int</span>.MAX_VALUE) &#123;</span><br><span class="line">                dp[i] = minCut</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dpStates: Array&lt;Array&lt;<span class="built_in">Boolean</span>&gt;&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串[s]索引从[start]到[end]的子串是否是回文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isPalindrome</span><span class="params">(s: <span class="type">String</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> states = dpStates ?: getPalindromeStates(s)</span><br><span class="line">        dpStates = states</span><br><span class="line">        <span class="keyword">return</span> states[start][end]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPalindromeStates</span><span class="params">(s: <span class="type">String</span>)</span></span>: Array&lt;Array&lt;<span class="built_in">Boolean</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(n) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="comment">// 遍历所有长度的子串，length代表子串的长度，可以从1一直取值到n</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 把所有是长度为length的子串都检查一遍，看是不是回文，start就要从0开始取值，一直取到n-length</span></span><br><span class="line">            <span class="comment">// start 是应该小于 n-length 还是小于等于?</span></span><br><span class="line">            <span class="comment">// 可以举例n为5，length为2，直观上看最后一个length为2的子串应该是s[3:4]，start为3，是n-length的结果</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.(n - length)) &#123;</span><br><span class="line">                <span class="comment">// end和start之间保持相距length</span></span><br><span class="line">                <span class="keyword">val</span> end = start + length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (start + <span class="number">1</span> &lt;= end - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>] &amp;&amp; s[start] == s[end]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = s[start] == s[end]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n^2)</p>
<p>n 是字符串 s 的长度。<br>预处理计算s所有子串是否是回文和动态规划计算s最小分割次数的时间复杂度均为 O(n^2)。</p>
<p>空间复杂度：O(n^2)</p>
<p>预处理计算s所有子串是否是回文需要O(n^2)的空间占用。<br>动态规划计算s最小分割次数需要O(n)的空间占用。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.135.分发糖果（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/candy/">LeetCode.135.分发糖果（困难）</a></p>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>难点在于<code>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</code></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>化繁为简，这里可以拆解为两个规则：</p>
<ul>
<li>左规则：当 <code>ratings[i − 1] &lt; ratings[i]</code> 时，第<code>i</code> 个学生的糖果数量比第<code>i − 1</code>个孩子的糖果数量多。</li>
<li>右规则：当 <code>ratings[i] &gt; ratings[i + 1]</code> 时，第<code>i</code> 个学生的糖果数量比第<code>i + 1</code>个孩子的糖果数量多。</li>
</ul>
<h3 id="如何求解？"><a href="#如何求解？" class="headerlink" title="如何求解？"></a>如何求解？</h3><ul>
<li>先从左到右遍历评分数组，按左规则分配糖果。</li>
<li>再从右到左遍历评分数组，按右规则分配糖果。</li>
<li>最后同时满足左右规则的糖果数量就是最终结果，也就是取两者较大值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> left = IntArray(ratings.size) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> right = IntArray(ratings.size) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                right[i - <span class="number">1</span>] = right[i] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.indices) &#123;</span><br><span class="line">            sum += maxOf(left[i], right[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n)，n 是孩子的数量，要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。</li>
<li>空间复杂度：O(n)，要保存所有的左、右规则对应的糖果数量。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>之前的解法已经把思路打开了，可以从左到右遍历分析看看能不能不占用额外空间就可以求解。</p>
<p>孩子的分数的排列无非是递增、递减、相等三种情况。</p>
<p>从左向右看：</p>
<ul>
<li><strong>如果孩子分数相等</strong>，就分配1个糖果。</li>
<li><strong>如果孩子处于分数递增的序列中</strong>，可以发现糖果数量从左到右看是会从1开始递增，这样糖果分配数量才最少。</li>
<li><strong>如果孩子处于分数递减的序列中</strong>，可以发现糖果数量从左到右看是会递减到1，这样糖果分配数量才最少。<ul>
<li>如果从分配到1个糖果的孩子从右到左看，糖果数量是会递增到递减序列的开始位置。</li>
<li>所以统计递减序列应该分配多少糖果，只要统计递减序列有多长，看做跟递增情况分配形式一样就行了。</li>
</ul>
</li>
</ul>
<p><strong>递减序列的起点在哪？</strong><br><code>rating[i] &lt; rating[i - 1] &amp;&amp; rating[i - 1] &gt; rating[i - 2]</code>时，<code>i</code>就是递减序列的起点。</p>
<p><strong>边界情况</strong></p>
<p>由于递增序列最后一个元素也可以算是递减序列的一个元素，所以它是受右规则约束的。</p>
<p>比如递增序列有3个元素，递减序列有8个元素，那么递增序列的第3个元素在递增遍历时分配了3个糖果，但最后实际应当分配9个糖果。这多的6个糖果应该怎么算进去？</p>
<p>可以发现如果递增序列和递减序列一样长：</p>
<ul>
<li>递增序列最后一个孩子和递减序列第一个孩子分配的糖果数量是一样的。</li>
<li>这两个孩子的分数可能不一样。</li>
</ul>
<p>这样的话要给递增序列最后一个孩子或递减序列第一个孩子多分配1个糖果的，才能满足左规则和右规则。</p>
<ul>
<li>如果递减序列比递增序列长1，就只能给递增序列最后一个孩子多分配2个糖果。</li>
<li>如果递减序列比递增序列长2，就只能给递增序列最后一个孩子多分配3个糖果。</li>
<li>如果递减序列比递增序列长3，就只能给递增序列最后一个孩子多分配4个糖果。</li>
</ul>
<p>所以：如果递减序列比递增序列长x，就只能给递增序列最后一个孩子多分配x + 1个糖果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = ratings.size</span><br><span class="line">        <span class="comment">// 上一个孩子的糖果数，第一个孩子默认分配1个糖果</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 糖果数量，第一个孩子默认分配1个糖果</span></span><br><span class="line">        <span class="keyword">var</span> candies = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 递增序列长度，已经有一个孩子分配了糖果</span></span><br><span class="line">        <span class="keyword">var</span> inc = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 递减序列长度</span></span><br><span class="line">        <span class="keyword">var</span> dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                ratings[i] == ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 分数持平，分配最少的糖果</span></span><br><span class="line">                    candies += <span class="number">1</span></span><br><span class="line">                    pre = <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 递增序列的开始，算递增序列第1个元素</span></span><br><span class="line">                    inc = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 糖果数为1时，递减序列还没开始或者刚结束</span></span><br><span class="line">                    dec = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                ratings[i] &gt; ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 分数递增，比前一个孩子多分配一个糖果</span></span><br><span class="line">                    <span class="keyword">val</span> cur = pre + <span class="number">1</span></span><br><span class="line">                    candies += cur</span><br><span class="line">                    pre = cur</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 递增序列长度在增加</span></span><br><span class="line">                    inc = cur</span><br><span class="line">                    <span class="comment">// 递减序列还没开始</span></span><br><span class="line">                    dec = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                ratings[i] &lt; ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 递减序列长度累加</span></span><br><span class="line">                    dec++</span><br><span class="line">                    <span class="comment">// 给递增序列最后一个孩子多分配 `递减序列长度 - 递增序列长度` 个糖果</span></span><br><span class="line">                    <span class="keyword">if</span> (inc == dec) dec++</span><br><span class="line">                    <span class="comment">// 把递减序列当做递增序列看，最终分配形式是一样的</span></span><br><span class="line">                    candies += dec</span><br><span class="line">                    <span class="comment">// 糖果数量递减到1时，要记录下来</span></span><br><span class="line">                    pre = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n)，遍历一次数组。</li>
<li>空间复杂度：O(1)，仅适用常数个变量。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.139.单词拆分（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h3><p>提到拆分，我们可以考虑能不能把大问题拆分为子问题+有限步骤，给问题建模，简化讨论。</p>
<ol>
<li>如果s可以被拆分，那么至少s的末尾字符组成的单词肯定是在wordDict中的。<ul>
<li>s的末尾字符组成的单词，可以从s的末尾位置开始，依次穷举取长度为1、2、3……n的子字符串，看子字符串是否在wordDict中。</li>
<li>接下来再去看剩下的前半部分的子字符串能不能继续拆分成功。</li>
</ul>
</li>
<li>如果s不能被拆分，有两种情况:<ol>
<li>穷举s所有末尾子字符串，是没有一个子字符串是在wordDict中的。</li>
<li>末尾有一部分子字符串组成的单词在wordDict中，最后s剩下前半段的子字符串不能被wordDict拆分。</li>
</ol>
</li>
</ol>
<p>这里已经划分出了子问题+有限步骤，可以用递归来解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 如果字符串能拆完，最后索引肯定为-1</span></span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 在字符串s[0,end]中，从末尾依次取长度为1、2、3……end+1的子字符串，检查子字符串是否在wordDict里</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 截取末尾字符串</span></span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 末尾字符串在wordDict里</span></span><br><span class="line">                <span class="comment">// 剩下的前半段子字符串s[0,start - 1]有可能可以被继续拆分，也有可能不可以被拆分，不知道能不能就只能每个情况都试一下</span></span><br><span class="line">                <span class="comment">// 所以这里不是直接return，而是要试一下每一种的单词拆分，看哪一种行的通</span></span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    <span class="comment">// end指向剩下的前半部分子字符串末尾</span></span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试拆分s[0, n - 1]</span></span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h3><p>递归的问题在于有重叠子问题，有很多重复计算耗时，保存一下中间计算结果就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(s.length) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (memo[end] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">if</span> (memo[end] == <span class="number">1</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[end] = <span class="keyword">if</span> (result) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法3：自下而上递推式动态规划"><a href="#解法3：自下而上递推式动态规划" class="headerlink" title="解法3：自下而上递推式动态规划"></a>解法3：自下而上递推式动态规划</h3><p>能用记忆化递归的，也可以用自下而上递推的方式做。</p>
<p>设<code>dp[end]</code>为第0个到第end个字符组成的字符串是否可以被wordDict中的单词拆分。<br>穷举所有<code>s[0, end]</code>的末尾字符串，判断能否拆分。<br>设<code>s[0, end]</code>的末尾字符串的开始索引为<code>start</code>，<code>0 &lt;= start &lt;= end</code>。</p>
<p><strong>状态转移方程</strong><br><code>dp[end] = dp[start - 1] &amp;&amp; s[start, end] in wordDict</code></p>
<p><code>start==0</code> 时，截取的是整个字符串，直接判断整个字符串是否在wordDict里就行了，<code>dp[0] = s[start, end] in wordDict</code>。</p>
<p>由于计算新的状态需要读取之前的每个最优化的状态，所以空间无法优化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> dp = BooleanArray(n) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (end <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.end) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[start - <span class="number">1</span>] &amp;&amp; word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.140.单词拆分 II（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-break-ii/">LeetCode.140.单词拆分 II（困难）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<span id="more"></span>

<p>说明：</p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果知道<code>s</code>的末尾的字符组成的单词处在wordDict中，并且前面的子串也是可以被wordDict拆分，就可以把末尾的单词添加到句子中。</p>
<ul>
<li><code>s</code>的末尾字符能不能组成wordDict中的单词，可以从末尾索引开始往前遍历一个个的试。</li>
<li>前面的子串是否可以被wordDict拆分，需要提前计算好，这里就借用 <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a>中的状态表，即<code>dp[i]</code>：<code>s</code>的前<code>i</code>个字符组成的子串能否拆分成<code>wordDict</code>中的若干个单词。</li>
</ul>
<p>用深度优先搜索递归试一遍就行，直到把<code>s</code>拆分完，结束搜索。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = wordDict.toHashSet()</span><br><span class="line">        <span class="keyword">val</span> dp = getDpState(s, <span class="keyword">set</span>)</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        dfs(s, <span class="keyword">set</span>, s.length, result, dp, Stack())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个一维数组，第i位表示，[s]的前i个字符组成的子串拆分成[wordDict]中的若干个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDpState</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>: Array&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> state = Array(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        state[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">val</span> s2 = s.substring(j, i)</span><br><span class="line">                <span class="keyword">if</span> (state[j] &amp;&amp; wordDict.contains(s2)) &#123;</span><br><span class="line">                    state[i] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;, end: <span class="type">Int</span>, result: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;, dp: <span class="type">Array</span>&lt;<span class="type">Boolean</span>&gt;, path: <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// s[0:end-1]是否是单词，是的话，应当添加到路径中，同时是也是路径的终点，即递归树的叶子节点</span></span><br><span class="line">        <span class="keyword">val</span> prefix = s.substring(<span class="number">0</span>, end)</span><br><span class="line">        <span class="keyword">if</span> (wordDict.contains(prefix)) &#123;</span><br><span class="line">            path.push(prefix)</span><br><span class="line">            result.add(path.reversed().joinToString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            path.pop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检索所有子串的拆分的可能组合</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.end) &#123;</span><br><span class="line">            <span class="comment">// 前i个字符组成的左子串是可以被拆分为若干个单词的</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i]) &#123;</span><br><span class="line">                <span class="comment">// 就看右子串是否是单词</span></span><br><span class="line">                <span class="keyword">val</span> substring = s.substring(i, end)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(substring)) &#123;</span><br><span class="line">                    <span class="comment">// 右子串是一个单词，应当添加到路径中</span></span><br><span class="line">                    path.push(substring)</span><br><span class="line">                    <span class="comment">// 继续探寻左子串s[0:i-1]</span></span><br><span class="line">                    dfs(s, wordDict, i, result, dp, path)</span><br><span class="line">                    <span class="comment">// 左子串探寻完了，从路径中移除当前单词，以不影响寻找下一个组合的单词路径</span></span><br><span class="line">                    path.pop()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.149.直线上最多的点数（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.149.%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">LeetCode.149.直线上最多的点数（困难）</a></p>
<p>给你一个数组  <code>points</code>  ，其中  <code>points[i] = [xi, yi]</code>  表示  <strong>X-Y</strong>  平面上的一个点。求最多有多少个点在同一条直线上。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力法梳理出整体框架，剩下细节问题和边界问题再填充。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>穷举所有可能形成的直线。</li>
<li>统计有多少点在这一条直线上。</li>
<li>记录最大的点数。</li>
</ul>
<h3 id="如何确定一个点是否在一条直线上？"><a href="#如何确定一个点是否在一条直线上？" class="headerlink" title="如何确定一个点是否在一条直线上？"></a>如何确定一个点是否在一条直线上？</h3><p>已知点<code>(x1, y1)</code>和<code>(x2, y2)</code>确定的一条直线L。</p>
<p>判断点<code>(x, y)</code>是否在直线L上，可以判断点<code>(x1, y1)</code>和点<code>(x, y)</code>组成的直线的斜率是否与直线L的斜率相等。</p>
<p>换成数学表达式即判断 <code>(y2 - y1) / (x2 - x1) == (y - y1) / (x - x1)</code>。<br>其中两点不能是同一个点，<code>x1</code>不等于<code>x</code>。</p>
<h3 id="斜率计算是浮点数，比较判断不准确怎么办？"><a href="#斜率计算是浮点数，比较判断不准确怎么办？" class="headerlink" title="斜率计算是浮点数，比较判断不准确怎么办？"></a>斜率计算是浮点数，比较判断不准确怎么办？</h3><ul>
<li>由于计算机除法存在数学精度问题，需要把上述表达式的比较，转换为对分子和分母分别比较。</li>
<li>比较之前需要将分子分母约分到最简，进而就要求分子和父母的最大公约数。</li>
<li>可使用辗转相除法来求最大公约数，约分分子、分母到最简。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxPoints</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">// 一个点和两个点都是在同一个直线上</span></span><br><span class="line">        <span class="keyword">if</span> (points.size &lt; <span class="number">3</span>) <span class="keyword">return</span> points.size</span><br><span class="line">        <span class="comment">// 所有的点都是同一个点，表示所有的点都在同一条直线上</span></span><br><span class="line">        <span class="keyword">if</span> (points.distinctBy &#123; <span class="string">&quot;<span class="subst">$&#123;it[<span class="number">0</span>]&#125;</span>,<span class="subst">$&#123;it[<span class="number">1</span>]&#125;</span>&quot;</span> &#125;.size == <span class="number">1</span>) <span class="keyword">return</span> points.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = points.size</span><br><span class="line">        <span class="keyword">var</span> maxPoints = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> x1 = points[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> y1 = points[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> x2 = points[j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">val</span> y2 = points[j][<span class="number">1</span>]</span><br><span class="line">                <span class="comment">// 同一个点确立不了直线，直接跳过，之后再确立了直线的情况，会考察到跳过的这个点</span></span><br><span class="line">                <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">// (x1,y1)和(x2,y2)确立一条直线</span></span><br><span class="line">                <span class="keyword">val</span> line = Line(x1, y1, x2, y2)</span><br><span class="line">                <span class="comment">// 统计所有其他的点，是否在这条线上</span></span><br><span class="line">                <span class="keyword">var</span> tmpMax = <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == i || k == j) <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">val</span> x3 = points[k][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">val</span> y3 = points[k][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> (line.isOnTheLine(x3, y3)) &#123;</span><br><span class="line">                        <span class="comment">// 发现有一个点在线上，计数</span></span><br><span class="line">                        tmpMax++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpMax &gt; maxPoints) &#123;</span><br><span class="line">                    maxPoints = tmpMax</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPoints</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点([x1],[y1])和点([x2],[y2])确定一条直线</span></span><br><span class="line"><span class="comment">     * 直线的斜率为(y2-y1)/(x2-x1)</span></span><br><span class="line"><span class="comment">     * 限制条件：两点不能是同一个点，同时x1不等于x2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>(</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> x1: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> y1: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> x2: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> y2: <span class="built_in">Int</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 点([x],[y])是否在同一直线上</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 可判断点([x1],[y1])和点([x],[y])组成的直线斜率是否之前的直线相等</span></span><br><span class="line"><span class="comment">         * 换成数学表达式即 (y2-y1)/(x2-x1) == (y-y1)/(x-x1)</span></span><br><span class="line"><span class="comment">         * 其中两点不能是同一个点，x1不等于x</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 由于存在数学精度问题，需要把上述表达式的比较，转换为对分子和分母分别比较，比较之前需要将分子分母约分到最简</span></span><br><span class="line"><span class="comment">         * 进而就要求分子和父母的最大公约数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">isOnTheLine</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == x1 &amp;&amp; y == y1 || x == x2 &amp;&amp; y == y2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> d1 = greatestCommonDivisor(y2 - y1, x2 - x1)</span><br><span class="line">            <span class="keyword">val</span> d2 = greatestCommonDivisor(y - y1, x - x1)</span><br><span class="line">            <span class="keyword">val</span> isSameNumerator = (y2 - y1) / d1 == (y - y1) / d2</span><br><span class="line">            <span class="keyword">val</span> isSameDenominator = (x2 - x1) / d1 == (x - x1) / d2</span><br><span class="line">            <span class="keyword">return</span> isSameNumerator &amp;&amp; isSameDenominator</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 求[a]和[b]的最大公约数</span></span><br><span class="line"><span class="comment">         * 使用辗转相除法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">greatestCommonDivisor</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a</span><br><span class="line">            <span class="keyword">var</span> big = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">var</span> small = <span class="keyword">if</span> (a &lt; b) a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">while</span> (small != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> remainder = big % small</span><br><span class="line">                big = small</span><br><span class="line">                small = remainder</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> big</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n^3)</code></li>
<li>空间复杂度<code>O(1)</code></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.154.寻找旋转排序数组中的最小值 II（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode.154.寻找旋转排序数组中的最小值 II（困难）</a></p>
<span id="more"></span>

<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</li>
<li>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]</li>
</ul>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>提示：</p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p>进阶：</p>
<ul>
<li>这道题是 寻找旋转排序数组中的最小值 的延伸题目。</li>
<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过模拟可知，多次旋转后得到还是跟一次旋转一样的效果。</p>
<p>旋转一次后，数组可以分为左右两个子数组<code>nums1</code>和<code>nums2</code>，其中：</p>
<ul>
<li><code>nums1</code>和<code>nums2</code>本身都有序。</li>
<li><code>nums1中所有元素 &gt;= nums2中所有元素</code>。<ul>
<li><code>nums1</code>的首元素可能与<code>nums2</code>尾元素相等。</li>
</ul>
</li>
</ul>
<p><strong>最小的数字</strong>是<code>nums2</code>的第一个元素。</p>
<p>二分查找的时候，只要知道<code>nums[mid]</code>是位于<code>nums1</code>还是<code>nums2</code>中，就知道下一步应该往哪去缩减寻找范围。</p>
<h3 id="怎么知道nums-mid-是不是位于nums1？"><a href="#怎么知道nums-mid-是不是位于nums1？" class="headerlink" title="怎么知道nums[mid]是不是位于nums1？"></a>怎么知道nums[mid]是不是位于<code>nums1</code>？</h3><p><code>nums[mid] &gt; nums[0]</code>时，<code>nums[mid]</code>一定位于<code>nums1</code>。</p>
<h3 id="nums-mid-位于nums1，接下来往哪找最小的数？"><a href="#nums-mid-位于nums1，接下来往哪找最小的数？" class="headerlink" title="nums[mid]位于nums1，接下来往哪找最小的数？"></a>nums[mid]位于nums1，接下来往哪找最小的数？</h3><p>最小的数字是<code>nums2</code>的第一个元素，接下来要往右找。</p>
<h3 id="怎么知道nums-mid-是不是位于nums2？"><a href="#怎么知道nums-mid-是不是位于nums2？" class="headerlink" title="怎么知道nums[mid]是不是位于nums2？"></a>怎么知道nums[mid]是不是位于nums2？</h3><p><code>nums[mid] &lt; nums[0]</code>时，<code>nums[mid]</code>一定位于<code>nums2</code>。</p>
<h3 id="nums-mid-位于nums2，接下来往哪找最小的数？"><a href="#nums-mid-位于nums2，接下来往哪找最小的数？" class="headerlink" title="nums[mid]位于nums2，接下来往哪找最小的数？"></a>nums[mid]位于nums2，接下来往哪找最小的数？</h3><p>最小的数字是<code>nums2</code>的第一个元素，接下来要往左找。</p>
<h3 id="nums-mid-位于nums2，怎么知道nums-mid-是不是最小的数？"><a href="#nums-mid-位于nums2，怎么知道nums-mid-是不是最小的数？" class="headerlink" title="nums[mid]位于nums2，怎么知道nums[mid]是不是最小的数？"></a>nums[mid]位于nums2，怎么知道nums[mid]是不是最小的数？</h3><p>如果<code>nums[mid]</code>就是最小的数字，<code>mid</code>处于两个升序序列的分割位置，那么<code>nums[mid]</code>一定是比前一个数字要小的，判断<code>nums[mid] &lt; nums[mid - 1]</code>即可。</p>
<h3 id="nums-mid-nums-0-时，接下来应该往哪找？"><a href="#nums-mid-nums-0-时，接下来应该往哪找？" class="headerlink" title="nums[mid] == nums[0]时，接下来应该往哪找？"></a>nums[mid] == nums[0]时，接下来应该往哪找？</h3><p>由于数组允许有重复数字，<code>nums1</code>的首元素可能与<code>nums2</code>尾元素相等，这里就有两种情况：</p>
<ul>
<li>如果<code>nums1</code>的首元素与<code>nums2</code>尾元素相等，不确定<code>nums[mid]</code>是在<code>nums1</code>还是<code>nums2</code>中，只能线性缩减边界。</li>
<li>如果<code>nums1</code>的首元素与<code>nums2</code>尾元素不相等，说明<code>nums[mid]</code>在<code>nums1</code>中，最小元素在<code>nums2</code>中，要向右找。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>只有一个元素，最小的数就是元素本身</li>
<li>如果最后一个数字比第一个数字大，说明没有旋转，第一数字就是最小的了</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMin</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素，最小的数就是元素本身</span></span><br><span class="line">        <span class="comment">// 如果最后一个数字比第一个数字大，说明没有旋转，第一数字就是最小的了</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.size - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> high = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果mid大于第一个数，从第一个数字到mid都是升序的，旋转的部分在右边，最小的数也就在右边，接下来要往右找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) &#123; <span class="comment">// mid比第一个数小，说明mid已处于旋转的部分，最小的数在左边</span></span><br><span class="line">                <span class="comment">// 如果mid就是最小的数字，mid处于两个升序序列的分割位置，那么mid一定是比前一个数字要小的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[mid]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 还没找到最小的，所以要往左边找</span></span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[<span class="number">0</span>]) &#123; <span class="comment">// mid与第一个数相等</span></span><br><span class="line">                <span class="comment">// 如果mid在前面的升序序列接下来就要往右找，在后面的序列就要往左找</span></span><br><span class="line">                <span class="comment">// 但是无法判断这一点，只能从一侧依次递减</span></span><br><span class="line">                <span class="comment">// 如 [1, 0, 1, 1, 1] 和 [1, 1, 1, 0, 1]</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] != nums[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没找到，说明数组元素全部相等</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>平均时间复杂度O(log n)，最坏情况下数组元素全部相同，需要线性扫描整个数组，时间复杂度O(n)。</p>
<p>空间复杂度O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1567.乘积为正数的最长子数组长度（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.1567.%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">LeetCode.1567.乘积为正数的最长子数组长度（中等）</a></p>
<p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。<br>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。<br>请你返回乘积为正数的最长子数组长度。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划，先从某个状态倒推拆解问题。</p>
<h3 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h3><p>设<code>positive[i]</code>是以<code>nums[i]</code>结尾的子数组中，乘积为正数的最长连续子数组的长度。</p>
<h3 id="如何保证乘积为正数？"><a href="#如何保证乘积为正数？" class="headerlink" title="如何保证乘积为正数？"></a>如何保证乘积为正数？</h3><p>正数 * 正数<br>负数 * 负数</p>
<h3 id="以nums-i-结尾的子数组有哪些组合情况？"><a href="#以nums-i-结尾的子数组有哪些组合情况？" class="headerlink" title="以nums[i]结尾的子数组有哪些组合情况？"></a>以nums[i]结尾的子数组有哪些组合情况？</h3><p>按照<code>nums[i]</code>要不要拿去做乘法，分为：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>跟前面的子数组连接</li>
</ol>
<p>实际去求<code>positive[i]</code>，肯定是尽量与前面的子数组的乘积去相乘，这样会得到尽可能大的结果长度。<br>如果<code>nums[i]</code>没法跟前面的子数组乘积相乘，再单独把<code>nums[i]</code>作为子数组。</p>
<h3 id="如何保证以nums-i-结尾的子数组乘积为正数？"><a href="#如何保证以nums-i-结尾的子数组乘积为正数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为正数？"></a>如何保证以nums[i]结尾的子数组乘积为正数？</h3><ol>
<li><code>nums[i]</code>单独为一个子数组时，<code>nums[i]</code>要为正数</li>
<li><code>nums[i]</code>跟前面的子数组连接时<ol>
<li><code>nums[i]</code>为正，前面子数组乘积为正</li>
<li><code>nums[i]</code>为负，前面子数组乘积为负</li>
</ol>
</li>
</ol>
<p>这里还要记录前面子数组乘积为负数的最长长度，可以定义<code>negative[i]</code>是以<code>nums[i]</code>结尾的子数组中乘积为负数的最长连续子数组的长度。</p>
<h3 id="考虑边界情况"><a href="#考虑边界情况" class="headerlink" title="考虑边界情况"></a>考虑边界情况</h3><ol>
<li>在<code>nums[i]</code>要跟前面的子数组连接时，如果：<ol>
<li><code>nums[i]</code>为正数，前面没有乘积是正数的子数组（比如乘积是0或者负数或者没有任何数），这个时候<code>nums[i]</code>可以单独做一个子数组，<code>positive[i] = 1</code>。</li>
<li><code>nums[i]</code>为负数，前面没有乘积是负数的子数组，这个时候<code>nums[i]</code>单独作为子数组也不是正的，<code>positive[i]</code>是0。</li>
</ol>
</li>
<li><code>nums[i]</code>为0时，<code>positive[0]</code>只能为0，因为单独让<code>nums[i]</code>成为子数组乘积是0，<code>nums[i]</code>跟前面子数组乘积相乘也是0。</li>
</ol>
<h3 id="positive-i-的状态转移方程"><a href="#positive-i-的状态转移方程" class="headerlink" title="positive[i]的状态转移方程"></a>positive[i]的状态转移方程</h3><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1. `positive[i] = positive[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0`，前面有乘积为正数的子数组，正数*正数乘积是正数
 2. `positive[i] = 1`，当`i &gt; 0 &amp;&amp; positive[i - 1] == 0`，前面没有乘积为正数的子数组，`nums[i]`单独作为一个子数组
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `positive[i] = negative[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0`，前面有乘积为负数的子数组，负数*负数乘积是正数
 2. `positive[i] = 0`，当 `i &gt; 0 &amp;&amp; negative[i - 1] == 0`，前面没有乘积为负数的子数组，`nums[i]`没的乘，以`nums[i]`结尾的子数组的乘积没办法变为正数
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>positive[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>positive[0] = if (nums[0] &gt; 0) 1 else 0</code></li>
</ol>
<h3 id="如何保证以nums-i-结尾的子数组乘积为负数？"><a href="#如何保证以nums-i-结尾的子数组乘积为负数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为负数？"></a>如何保证以nums[i]结尾的子数组乘积为负数？</h3><p>跟<code>positive[i]</code>正好相反。<br><code>nums[i]</code>跟前面的子数组连接时：<br>    1. <code>nums[i]</code>为正，前面子数组乘积为负<br>    2. <code>nums[i]</code>为负，前面子数组乘积为正</p>
<h3 id="negative-i-的状态转移方程"><a href="#negative-i-的状态转移方程" class="headerlink" title="negative[i]的状态转移方程"></a>negative[i]的状态转移方程</h3><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1.` i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0` 时，`negative[i] = negative[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; negative[i - 1] == 0` 时，`negative[i] = 0`
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0` 时，`negative[i] = positive[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; positive[i - 1] == 0` 时，`negative[i] = 1`
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>negative[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>negative[0] = if (nums[0] &lt; 0) 1 else 0</code></li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>positive[i]</code>和<code>negative[i]</code>只与上一个状态有关，不需要数据存储所有状态，用变量记录上一个状态即可。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMaxLen</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> positive = <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> negative = <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxLength = positive</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                nums[i] &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (positive == 0)*/</span> <span class="number">1</span> </span><br><span class="line">                    negative = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (negative[i - 1] == 0)*/</span> <span class="number">0</span> </span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] &lt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newPositive = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (negative == 0) */</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">val</span> newNegative = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (positive == 0) */</span> <span class="number">1</span></span><br><span class="line">                    positive = newPositive</span><br><span class="line">                    negative = newNegative</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] == <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="number">0</span></span><br><span class="line">                    negative = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, positive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.174.地下城游戏（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.174.%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/dungeon-game/">LeetCode.174.地下城游戏（困难）</a></p>
<span id="more"></span>

<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<p><strong>说明:</strong></p>
<ul>
<li>  骑士的健康点数没有上限。</li>
<li>  任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设<code>dungeon[i][j]</code>为地牢的第<code>i</code>行第<code>j</code>列的点数，可正、可负、可零。</p>
<p>这题跟最小路径和不一样的点在于：<code>在任意格子，都要求骑士的 生命值x &gt;= 1</code>。</p>
<p>如果骑士位于某行某列，则要求<code>x &gt;= 1 &amp;&amp; x + dungeon[i][j] &gt;= 1</code>，不等式两侧的项换个位置也就是：<code>x &gt;= 1 &amp;&amp; x &gt;= 1 - dungeon[i][j]</code>，我们要求最低的生命值，可得<code>x = maxOf(1, 1 - dungeon[i][j])</code>。</p>
<p>但是骑士是要在走动的，光看当前位置的点数，是不知道当前生命值够不够用，需要知道后面的路径需要的最少生命值是多少，假设是<code>y</code>，那么当前位置就要满足<code>x &gt;= 1 &amp;&amp; x + dungeon[i][j] &gt;= y</code>，我们要求最低的生命值，可得<code>x = maxOf(1, y - dungeon[i][j])</code>。</p>
<p>状态转移的过程就出来了，是要从末尾往开头递推，才能得出结果。</p>
<p>从左上到右下的路径，有两种选择，往右走、往下走。不知道往哪走所需的最低初始健康点数最少，就两个都试一遍，取最小的。</p>
<p><strong>边界条件</strong></p>
<ul>
<li>在最后一行，只能向右走，无法向下走。</li>
<li>在最后一列，只能向下走，无法向右走。</li>
</ul>
<p><strong>回溯递归解法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">findMinHp</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                r == m - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r, c + <span class="number">1</span>) - dungeon[r][c])</span><br><span class="line">                c == n - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r + <span class="number">1</span>, c) - dungeon[r][c])</span><br><span class="line">                <span class="keyword">else</span> -&gt; maxOf(<span class="number">1</span>, minOf(findMinHp(r, c + <span class="number">1</span>), findMinHp(r + <span class="number">1</span>, c)) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findMinHp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归存在重叠子问题，例如<code>findMinHp(r + 1, c)</code>会执行多次，需要记录中间状态。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> memo = Array(m) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">findMinHp</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[r][c] != -<span class="number">1</span>) <span class="keyword">return</span> memo[r][c]</span><br><span class="line">            <span class="keyword">val</span> result =  <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[r][c])</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                r == m - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r, c + <span class="number">1</span>) - dungeon[r][c])</span><br><span class="line">                c == n - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r + <span class="number">1</span>, c) - dungeon[r][c])</span><br><span class="line">                <span class="keyword">else</span> -&gt; maxOf(<span class="number">1</span>, minOf(findMinHp(r, c + <span class="number">1</span>), findMinHp(r + <span class="number">1</span>, c)) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">            memo[r][c] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findMinHp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上的动态规划</strong></p>
<p>记忆化递归已经给出了状态转移方程，需要注意的是要从最右下角开始往左上角递推，才能得到结果。</p>
<p>设<code>dp[i][j]</code>表示骑士位于第<code>i</code>行第<code>j</code>列格子时要达到公主处所需要的最小生命值。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li>最右下角：<code>dp[i][j] = maxOf(1, 1 - dungeon[m - 1][n - 1])</code>。</li>
<li>最后一列：<code>dp[i][j] = maxOf(1, dp[r + 1][c] - dungeon[r][c])</code>。</li>
<li>最后一行：<code>dp[i][j] = maxOf(1, dp[r][c + 1] - dungeon[r][c])</code>。</li>
<li>其他行和列：<code>dp[i][j] = maxOf(1, minOf(dp[r][c + 1], dp[r + 1][c]) - dungeon[r][c])</code>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> m - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = maxOf(<span class="number">1</span>, dp[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i][n - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            dp[m - <span class="number">1</span>][i] = maxOf(<span class="number">1</span>, dp[m - <span class="number">1</span>][i + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][i])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> m - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">                dp[r][c] = maxOf(<span class="number">1</span>, minOf(dp[r][c + <span class="number">1</span>], dp[r + <span class="number">1</span>][c]) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.152.乘积最大子数组（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode.152.乘积最大子数组（中等）</a></p>
<p>给你一个整数数组  <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。</p>
<p>为了方便描述，设<code>maxProduct[i]</code>为以<code>nums[i]</code>结尾的子数组的最大乘积。</p>
<p>求<code>maxProduct[i]</code>，<code>nums[i]</code>肯定少不了，因为子数组最少需要一个元素。</p>
<h3 id="求maxProduct-i-有哪些可能的组合情况？"><a href="#求maxProduct-i-有哪些可能的组合情况？" class="headerlink" title="求maxProduct[i]有哪些可能的组合情况？"></a>求maxProduct[i]有哪些可能的组合情况？</h3><ol>
<li><code>nums[i]</code>自己单独成为一个子数组。<br>比如前面子数组乘积是0，<code>nums[i]</code>为正数，就没必要跟前面相乘了。但是<code>nums[i]</code>可能会比前面子数组乘积要小，所以要看看其他情况。</li>
<li><code>nums[i]</code>跟前面的子数组的乘积相乘。<br>接下来就是看怎么跟<code>nums[i]</code>相乘可以得到尽可能大的乘积。</li>
</ol>
<h3 id="有哪些乘法情况可以使乘积变大？"><a href="#有哪些乘法情况可以使乘积变大？" class="headerlink" title="有哪些乘法情况可以使乘积变大？"></a>有哪些乘法情况可以使乘积变大？</h3><ol>
<li>正数 * 正数</li>
<li>负数 * 负数</li>
</ol>
<p>也就是说求<code>maxProduct[i]</code>要记录<code>nums[i]</code>前面的子数组的最大乘积和最小乘积。</p>
<h3 id="穷举求maxProduct-i-要考虑的情况"><a href="#穷举求maxProduct-i-要考虑的情况" class="headerlink" title="穷举求maxProduct[i]要考虑的情况"></a>穷举求maxProduct[i]要考虑的情况</h3><ol>
<li><code>nums[i]</code>单独成为一个子数组</li>
<li><code>nums[i]</code>乘以i前面的子数组最大的乘积</li>
<li><code>nums[i]</code>乘以i前面的子数组最小的乘积</li>
</ol>
<p>求<code>maxProduct[i]</code>就是取三者最大值</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>maxProduct[i] = max(nums[i],  nums[i] * maxProduct[i - 1], nums[i] * minProduct[i - 1])</code></p>
<h3 id="怎么求以nums-i-结尾的连续子数组的最小乘积？"><a href="#怎么求以nums-i-结尾的连续子数组的最小乘积？" class="headerlink" title="怎么求以nums[i]结尾的连续子数组的最小乘积？"></a>怎么求以nums[i]结尾的连续子数组的最小乘积？</h3><p>跟考虑求最大乘积思路一样。<br>使乘积变得更小的方式就是正数和负数相乘。<br><code>nums[i]</code>可能为正也可能为负，所以<code>minProduct[i]</code>的求解也是有<code>maxProduct[i]</code>的那三种情况，只不过是求最小值。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p><code>maxProduct[0]</code>就是<code>nums[i]</code>本身，因为以<code>nums[0]</code>为结尾的子数组就是<code>nums[0]</code>本身构成的一个元素的子数组。<br>同理，<code>minProduct[0]</code>也是<code>nums[i]</code>。</p>
<p>递推要从<code>i = 1</code>开始。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>当前状态只跟上一步状态有关，所以不需要用数组存储所有状态，用几个变量记录上一步状态即可。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProduct</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> minProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> maxProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> result = maxProduct</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> num = nums[i]</span><br><span class="line">            <span class="keyword">val</span> newMaxProduct = maxOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            minProduct = minOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            maxProduct = newMaxProduct</span><br><span class="line">            result = maxOf(result, maxProduct)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.188.买卖股票的最佳时机 IV（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode.188.买卖股票的最佳时机 IV（困难）</a></p>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最优化问题考虑用动态规划。</p>
<p>看最终结果受哪些因素影响，穷举不同因素的所有状态值，就可以推导出最终结果。</p>
<h3 id="最终收益受哪些维度的状态变化影响？"><a href="#最终收益受哪些维度的状态变化影响？" class="headerlink" title="最终收益受哪些维度的状态变化影响？"></a>最终收益受哪些维度的状态变化影响？</h3><ul>
<li>在第几天买入或卖出肯定是会影响最终收益，可能某一天突然暴涨。</li>
<li>交易次数越多，可能赚取的收益越大。</li>
<li>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。归纳合并一下，这些操作会产生的结果状态是：第<code>i</code>天持有或不持有股票。股票持有状态也会影响最终收益。</li>
</ul>
<p>所以从结果上看，一共有三种纬度的状态变化：</p>
<ul>
<li>第几天做出选择</li>
<li>已经交易了多少次</li>
<li>当前是否持有股票</li>
</ul>
<h3 id="买入的时候算一次交易，还是卖出的时候算一次交易？"><a href="#买入的时候算一次交易，还是卖出的时候算一次交易？" class="headerlink" title="买入的时候算一次交易，还是卖出的时候算一次交易？"></a>买入的时候算一次交易，还是卖出的时候算一次交易？</h3><p>其实都可以，不影响最终结果，只是状态转移过程会有所变化。<br>这里定义买入的时候算一次交易。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i][j][k]</code>表示，前<code>i</code>天，交易了<code>j</code>次，在第<code>i</code>天持有或不持有股票，所获得最大的收益。其中<code>k == 0</code>表示不持有，<code>k == 1</code>表示持有。</p>
<ul>
<li><code>dp[i][j][0]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][0]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天卖出。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][1] + prices[i]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>dp[i][j][1]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j][1]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天买入。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j - 1][0] - prices[i]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>第0天<ul>
<li>持有股票的话，不论多少次交易，只能直接买入一次。</li>
<li>不持有股票的话，收益就是0。</li>
</ul>
</li>
<li>第<code>i</code>天之前都没有交易（即<code>j == 0</code>），第<code>i</code>天要交易操作就是买入。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>如果给定的最多交易次数<code>k</code>非常大，状态数组开辟空间也会非常大，考虑是否有优化的可能。</p>
<p><strong>交易次数上限是多少？</strong></p>
<p>一次交易要买入和卖出，总共n天，交易次数不应该超过n / 2。</p>
<p><strong>交易次数超过n / 2要怎么办？</strong></p>
<p>这就等于不限交易次数，与<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a>解法相同，可以复用这种情况下最优化空间的解答。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(k: <span class="type">Int</span>, prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty() || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfitNonLimitCount(prices)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三种状态：第几天买入或卖出、已经交易了多少次、当前是否持有股票</span></span><br><span class="line">        <span class="comment">// dp[i][j][0或1]表示，前i天，交易了j次，在第i天持有或不持有股票，所获得最大的收益</span></span><br><span class="line">        <span class="comment">// 这里定义买入的时候算一次交易</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(k) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 第0天持有股票的话，最多k次交易，只能直接买入</span></span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第i天，交易了j次，持有股票</span></span><br><span class="line">                    <span class="comment">// 可能是前i-1天就交易了j次并持有股票，也可能前i-1天交易了j-1次在今天买入了</span></span><br><span class="line">                    <span class="comment">// 如果之前没有交易，今天就直接买入就好了</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], -prices[i])</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">maxProfitNonLimitCount</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n * k)</code>。</li>
<li><code>k &gt;= n / 2</code>时，空间复杂度<code>O(1)</code>；<code>k &lt; n / 2</code>时，空间复杂度<code>O(n * k)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.198.打家劫舍（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">LeetCode.198.打家劫舍（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>从最终状态做倒推，穷举列出到达最终状态所需要的最小步骤，看是否能从上一个状态加上有限步骤得到最终状态，检查上一个状态的最优解是否也能通过不停的倒推拆解得到，拆分步骤的过程可得出状态转移方程。拆分到最开始，做边界条件处理。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>设<code>nums[i]</code>为第i间房屋金额。<br>设<code>dp[i]</code>为达到第i个房屋时能偷到的最高金额。</p>
<ol>
<li>偷第i间房，就不能偷第i - 1房，<code>dp[i] = dp[i - 2] + nums[i]</code></li>
<li>不偷第i间房，<code>dp[i] = dp[i - 1]</code></li>
</ol>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ol>
<li>只有1间房，直接偷</li>
<li>只有2间房，由于不能偷相邻的房间，就偷钱多的。 </li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只从前两项递推得来，所以不需要数组记录所有状态，只需要两个变量记录递推的状态。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1 </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.213.打家劫舍 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">LeetCode.213.打家劫舍 II（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="环形排列影响了什么？"><a href="#环形排列影响了什么？" class="headerlink" title="环形排列影响了什么？"></a>环形排列影响了什么？</h3><p>第1间房子和最后一间房子只能偷一个，不知道偷哪个金额最高。</p>
<h3 id="不知道偷第一间还是最后一间，怎么办？"><a href="#不知道偷第一间还是最后一间，怎么办？" class="headerlink" title="不知道偷第一间还是最后一间，怎么办？"></a>不知道偷第一间还是最后一间，怎么办？</h3><p>两种情况都偷一下，取金额大的那个方案。即：</p>
<ol>
<li>偷第1间房子，不偷最后一间房子</li>
<li>不偷第1间房子，偷最后一间房子</li>
</ol>
<p>转换为两个非环问题取较大值的问题。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">0</span>, n - <span class="number">1</span>)),</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">1</span>, n))</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">linearRob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> n = nums.size</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">var</span> cur = pre1</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">                cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">                pre2 = pre1</span><br><span class="line">                pre1 = cur</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.221.最大正方形（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode.221.最大正方形（中等）</a></p>
<p>在一个由  <code>&#39;0&#39;</code>  和  <code>&#39;1&#39;</code>  组成的二维矩阵内，找到只包含  <code>&#39;1&#39;</code>  的最大正方形，并返回其面积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。<br>想办法把大问题划分子问题+有限步骤。</p>
<h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p>记录最大的<code>side[i][j]</code>，再求平方就是最终结果</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>二维数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxLength = maxOf(maxLength, side[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[i][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[<span class="number">0</span>][j])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    maxLength = maxOf(maxLength, side[i][j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化的代码（kotlin）"><a href="#优化的代码（kotlin）" class="headerlink" title="优化的代码（kotlin）"></a>优化的代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一行状态</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[j])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储上一行状态，以方便接下来读取左上方的状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">	                <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">					<span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">					<span class="comment">// pre[j]: 上方状态</span></span><br><span class="line">                    side[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>], pre[j])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    side[j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = maxOf(maxLength, side[j])</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.23.合并K个升序链表（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode.23.合并K个升序链表（困难）</a></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h2><p>普通二路归并排序直接比较两个链表首元素即可。</p>
<p><strong>多个链表首元素怎么比较？</strong></p>
<p>用优先队列，构建小顶堆，每次加入一个节点，优先队列会调整堆把最小的元素放在堆顶。</p>
<p>调整一次堆需要<code>O(log k)</code>时间，<code>k</code>为列表个数。</p>
<p>由于要把所有节点都加入堆中，设链表节点总数为<code>n</code>，总时间复杂度为<code>O(n * log k)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;ListNode&gt; &#123; n1, n2 -&gt; n1.`<span class="keyword">val</span>` - n2.`<span class="keyword">val</span>` &#125;</span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> p: ListNode? = dummy</span><br><span class="line">        lists.forEach &#123; node -&gt; <span class="keyword">if</span> (node != <span class="literal">null</span>) pq.add(node) &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> smallest = pq.poll()</span><br><span class="line">            <span class="keyword">if</span> (smallest.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(smallest.next)</span><br><span class="line">            &#125;</span><br><span class="line">            p?.next = smallest</span><br><span class="line">            p = p?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> newHead = dummy.next</span><br><span class="line">        dummy.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：分治"><a href="#解法2：分治" class="headerlink" title="解法2：分治"></a>解法2：分治</h2><p>对所有链表两两归并，这样每次链表数量减半，假设总共有k个链表，需要归并<code>log k</code>次。</p>
<p>假设所有链表结点总数为<code>n</code>，每一次的两两归并都要遍历所有结点，所以总时间复杂度为<code>O(n * log k)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) <span class="keyword">return</span> lists[low]</span><br><span class="line">        <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">val</span> l1 = merge(lists, low, mid);</span><br><span class="line">        <span class="keyword">val</span> l2 = merge(lists, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeTwoList</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> tail: ListNode? = dummy</span><br><span class="line">        <span class="keyword">var</span> p1 = l1</span><br><span class="line">        <span class="keyword">var</span> p2 = l2</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.`<span class="keyword">val</span>` &lt; p2.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                tail?.next = p1</span><br><span class="line">                p1 = p1?.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail?.next = p2</span><br><span class="line">                p2 = p2?.next</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail?.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail?.next = <span class="keyword">if</span> (p1 != <span class="literal">null</span>) p1 <span class="keyword">else</span> p2</span><br><span class="line">        <span class="keyword">val</span> newHead = dummy.next</span><br><span class="line">        dummy.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>优先队列</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.25.K 个一组翻转链表（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.25.K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">LeetCode.25.K 个一组翻转链表（困难）</a></p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>进阶：</p>
<p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>每组翻转后最关键的在于每一组的头尾节点变化了，要把每组重新正确的连接上，梳理整个翻转过程就比较清楚了。</p>
<p>从左到右找到第k个节点，相当于知道了一组节点的头节点和尾节点，对这一组节点进行翻转，记录翻转后的尾节点，在下一组翻转过后，把上一组记录的新尾节点指向下一组的新头节点即可。</p>
<p><strong>边界处理</strong></p>
<p>如果发现最后一组不足k个，不做翻转。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseKGroup</span><span class="params">(head: <span class="type">ListNode</span>?, k: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> tail: ListNode? = head</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line">            tail = tail.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> newHead = reverse(head, tail)</span><br><span class="line">        head.next = reverseKGroup(tail, k)</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表，返回新链表头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverse</span><span class="params">(head: <span class="type">ListNode</span>?, tail: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> pre: ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> cur: ListNode? = head</span><br><span class="line">        <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = cur?.next</span><br><span class="line">            cur?.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n)：n为链表节点总数。<br>空间复杂度O(n/k)：递归一次占用一个方法栈，空间占用多少就看递归深度多少，n个节点每次划分k个一组，一共要递归n/k次。</p>
</blockquote>
<p><strong>迭代</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果一边遍历一边翻转，最后一段长度不足k时也反转了就不对了，所以得先有一个指针往后探路，探到有路了再进行反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseKGroup</span><span class="params">(head: <span class="type">ListNode</span>, k: <span class="type">Int</span>)</span></span>: ListNode &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个虚节点，这样可以统一操作链表的代码，不用做边界情况处理</span></span><br><span class="line">        <span class="keyword">val</span> dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummyHead.next = head</span><br><span class="line">        <span class="comment">// 2. 开拓者指针，往后走k次，如果走了k次后，开拓者不为null，说明是有k个节点，可以翻转；初始时还没走，所以应该在头节点的前一个位置</span></span><br><span class="line">        <span class="keyword">var</span> pioneer: ListNode? = dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 记录当前待翻转区域前面的一个节点，用于把之前已反转的部分跟当前区域反转后重新连接起来，初始时是头节点的前一个节点</span></span><br><span class="line">        <span class="keyword">var</span> predecessor: ListNode? = dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. while循环一开始可能不知道是什么条件，可以先写while(true)，先写遍历代码</span></span><br><span class="line">        <span class="comment">// 13. pioneer探路前，指向的是要翻转的区域的前驱结点，如果不存在要翻转的区域，就不用遍历了，如果还有要翻转的区域则需要继续探路；如果后面不足k个节点，会在循环内break</span></span><br><span class="line">        <span class="keyword">while</span> (pioneer?.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 4. 开拓者要探k次路，如果后面不足k个结点，pioneer应当为null</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                pioneer = pioneer?.next</span><br><span class="line">                <span class="keyword">if</span> (pioneer == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 一开始还没开始翻转，就发现链表不足k个节点的话，按照题意不用翻转，所以就什么都不用做了，先break</span></span><br><span class="line">            <span class="keyword">if</span> (pioneer == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. pioneer不为null，说明是有k个节点的，可以翻转</span></span><br><span class="line">            <span class="comment">// 翻转主要是要解决翻转区域前后节点的连接问题，翻转后翻转区域的头尾都变了</span></span><br><span class="line">            <span class="comment">// 需要把翻转区域前后节点先保存下来，翻转后再重新连接翻转区域到主链表上</span></span><br><span class="line">            <span class="comment">// 当前待翻转区域尾节点就是pioneer，翻转区域后面的节点就是pioneer.next</span></span><br><span class="line">            <span class="keyword">val</span> successor = pioneer?.next</span><br><span class="line">            <span class="comment">// 翻转区域前面的节点还没有记录过，需要有个变量记录一下，到上面定义一下</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 翻转链表链表需要知道头结点，需要记录待翻转区域头节点，翻转后这个节点就变成了尾节点</span></span><br><span class="line">            <span class="keyword">val</span> newTail = predecessor?.next</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 把当前正要翻转区域跟主链表断开连接再做翻转，这样会比较方便，因为本来就是要重新连接的，最后再重新连接上</span></span><br><span class="line">            predecessor?.next = <span class="literal">null</span></span><br><span class="line">            pioneer?.next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10. 翻转链表</span></span><br><span class="line">            <span class="keyword">val</span> newHead = reverse(newTail)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 11. 重新把翻转后的链表连接到原链表</span></span><br><span class="line">            predecessor?.next = newHead</span><br><span class="line">            newTail?.next = successor</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12. 重置前驱指针和开拓者指针，都指向当前翻转区域的尾节点</span></span><br><span class="line">            predecessor = newTail</span><br><span class="line">            pioneer = newTail</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的头节点</span></span><br><span class="line">        <span class="keyword">val</span> newHead = dummyHead.next</span><br><span class="line">        dummyHead.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转链表，返回翻转后的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverse</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> pre: ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> cur: ListNode? = head</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n)：n为链表节点总数，需要遍历所有节点。<br>空间复杂度O(1)：只用了常数个变量。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.264.丑数 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.264.%E4%B8%91%E6%95%B0%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II（中等）</a></p>
<p>给你一个整数  <code>n</code>  ，请你找出并返回第  <code>n</code>  个  <strong>丑数</strong>  。<br><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code>  和/或 <code>5</code> 的正整数。<br>提示：<code>1 &lt;= n &lt;= 1690</code></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h3><p>根据丑数定义，除了1这个丑数，其他丑数都是从小的丑数乘以2或3或5得到，那么递推就好了。</p>
<p>主要问题是，几个小的丑数乘以2、3、5后的丑数，你不知道哪个大哪个小，不好确定下一个丑数是哪个。比如：</p>
<ol>
<li>丑数3乘以质因数后得到丑数：6、9、15。</li>
<li>丑数4乘以质因数后得到丑数：8、12、20。</li>
</ol>
<p>所以需要排个序，由于参与排序的元素位置和个数并不确定，所以需要在线算法实现，优先队列（堆）恰好适合元素不确定的排序，入队和出队时调整堆只需要O(log n)的时间复杂度。</p>
<p>还有个问题是要去重，比如 <code>丑数4 * 3 = 12</code>， <code>丑数6 * 2 = 12</code>，丑数肯定不重复，从优先队列取出元素后，检查有重复去去除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            pq.add(u * <span class="number">2</span>)</span><br><span class="line">            pq.add(u * <span class="number">3</span>)</span><br><span class="line">            pq.add(u * <span class="number">5</span>)</span><br><span class="line">            u = pq.remove()</span><br><span class="line">            <span class="keyword">while</span> (pq.isNotEmpty() &amp;&amp; pq.peek() == u) pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用哈希表来去重，用空间换时间，出队入队还是要占用一点不必要的时间的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> factors = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (factor <span class="keyword">in</span> factors) &#123;</span><br><span class="line">                <span class="keyword">val</span> nextU = u * factor</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nextU)) &#123;</span><br><span class="line">                    pq.add(nextU)</span><br><span class="line">                    visited.add(nextU)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            u = pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：三指针"><a href="#解法2：三指针" class="headerlink" title="解法2：三指针"></a>解法2：三指针</h3><p>3个质因数都要跟每个丑数乘一次，相当于形成3个丑数序列，每次取3个序列中最小值，作为新数组的元素，这很像归并排序，可以用3个指针3路归并。</p>
<p>已经递推出来的丑数要用数组记录下来，因为3个指针位置不确定，可能某个指针会访问到以前较小的丑数。</p>
<p>由于不能有重复值，再取完3个序列左边最小值后，要把相同值给跳过。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p3 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p5 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> u = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        u[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">val</span> v2 = u[p2] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> v3 = u[p3] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">val</span> v5 = u[p5] * <span class="number">5</span></span><br><span class="line">            <span class="keyword">val</span> nextU = minOf(v2, v3, v5)</span><br><span class="line">            <span class="comment">// 多个序列有重复元素要跳过，丑数不能有重复</span></span><br><span class="line">            <span class="keyword">if</span> (nextU == v2) p2++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v3) p3++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v5) p5++</span><br><span class="line">            u[i] = nextU</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.279.完全平方数（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-squares/">LeetCode.279.完全平方数（中等）</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h3><p>给定一个目标，有一组选择，做出选择，得出最优的结果，就是背包问题。<br>完全平方数没有限定选择个数，所以是完全背包问题。</p>
<p>设<code>dp[i]</code>表示和为i的完全平方数的最少数量。<br>对于每个<code>dp[i]</code>求解，从小到大穷举所有可选的完全平方数做出一次选择，挑选一个使用平方数数量最少的。</p>
<p>状态转移方程<br><code>dp[i] = minOf(dp[i], 1 + dp[i - j * j] + 1</code>，其中<code>1 &lt;= j &lt;= i</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numSquares</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i]表示和为i的完全平方数的最少数量</span></span><br><span class="line">        <span class="comment">// dp[0]没意义</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// dp[i]最多数量就是全部1相加，当做默认值，看有没有小的</span></span><br><span class="line">            dp[i] = i</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (j * j &lt;= i) &#123;</span><br><span class="line">                dp[i] = minOf(dp[i], <span class="number">1</span> + dp[i - j * j])</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：$O(n *\sqrt{n})$<br>空间复杂度：$O(n)$</p>
</blockquote>
<h3 id="解法2：bfs"><a href="#解法2：bfs" class="headerlink" title="解法2：bfs"></a>解法2：bfs</h3><p>如果先用递归求解，画出递归树就很好想象了。<br>可以进行层序遍历一层一层的算。<br>第一层依次减去一个平方数得到第二层；<br>第二层依次减去一个平方数得到第三层；<br>每递进一层，使用过的平方数个数加1；<br>当某一层出现了0，当前层数就是答案。</p>
<p><strong>注意点</strong><br>因为会有重叠子问题，所以要避免重复纳入已经计算过的节点，用visited数组记录访问过的节点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numSquares</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        queue.add(n)</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            level++</span><br><span class="line">            <span class="keyword">val</span> size = queue.size</span><br><span class="line">            repeat(size) &#123;</span><br><span class="line">                <span class="keyword">val</span> num = queue.poll()</span><br><span class="line">                visited.add(num)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (j * j &lt;= num) &#123;</span><br><span class="line">                    <span class="keyword">val</span> small = num - j * j</span><br><span class="line">                    <span class="keyword">if</span> (small == <span class="number">0</span>) <span class="keyword">return</span> level</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(small)) &#123;</span><br><span class="line">                        queue.add(small)</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.30.串联所有单词的子串（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.30.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">LeetCode.30.串联所有单词的子串（困难）</a></p>
<p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力推导"><a href="#暴力推导" class="headerlink" title="暴力推导"></a>暴力推导</h3><ol>
<li>穷举出所有s可能的子串。</li>
<li>对每个子串检查能不能拿words中所有单词串联得出。</li>
</ol>
<h3 id="穷举出所有s可能的子串，有什么优化？"><a href="#穷举出所有s可能的子串，有什么优化？" class="headerlink" title="穷举出所有s可能的子串，有什么优化？"></a>穷举出所有s可能的子串，有什么优化？</h3><p>题目要求恰好可以用words中所有单词串联形成的子串，所以子串的长度是确定的，只要穷举这个特定长度所有子串就行了，不需要穷举所有长度的子串。</p>
<p>其实这就相当于弄一个滑动窗口依次检测。</p>
<h3 id="怎么检查子串能不能拿words中所有单词串联得出？"><a href="#怎么检查子串能不能拿words中所有单词串联得出？" class="headerlink" title="怎么检查子串能不能拿words中所有单词串联得出？"></a>怎么检查子串能不能拿words中所有单词串联得出？</h3><p>按道理得组合所有words中单词的情况。</p>
<p>但是题目说所有单词长度相同，假设长度为n，可以把大子串再分割成m分长度为n的小子串，看小子串是不是在words里。</p>
<p>检查一个东西是不是在某个集合里，可以想到用哈希表，用O(1)时间查询得出结果。</p>
<p>但是哈希表不能存储相同的单词，所以要给重复出现的单词计数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findSubstring</span><span class="params">(s: <span class="type">String</span>, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (words.isEmpty()) <span class="keyword">return</span> emptyList()</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> wordCount = words.size</span><br><span class="line">        <span class="comment">// 每个单词的长度</span></span><br><span class="line">        <span class="keyword">val</span> wordLength = words.first().length</span><br><span class="line">        <span class="comment">// 生成哈希表：记录每个单词有多少个</span></span><br><span class="line">        <span class="keyword">val</span> allWords = words.groupingBy &#123; it &#125;.eachCount()</span><br><span class="line">        <span class="comment">// 穷举所有可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.(s.length - wordCount * wordLength)) &#123;</span><br><span class="line">            <span class="keyword">val</span> countMap = mutableMapOf&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; wordCount) &#123;</span><br><span class="line">	            <span class="comment">// 子串按单词长度切片，检查每一片是否在单词列表里</span></span><br><span class="line">                <span class="keyword">val</span> word = s.substring(i + j * wordLength, i + (j + <span class="number">1</span>) * wordLength)</span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(word)) &#123;</span><br><span class="line">                    <span class="comment">// 注意对重复单词计数，单词在子串中出现过的次数与在words出现的次数应该一致</span></span><br><span class="line">                    <span class="keyword">val</span> count = countMap.getOrDefault(word, <span class="number">0</span>)</span><br><span class="line">                    countMap[word] = count + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> (countMap[word]!! &gt; allWords[word]!!) &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span></span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == wordCount) &#123;</span><br><span class="line">                result.add(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度O(mn)：<br>假设字符串s长度为m，滑动窗口穿过整个s，最坏情况下滑动窗口大小为1，需要移动m次。<br>判断每个滑动窗口的子串是不是能由words所有单词组成，最坏情况需要遍历words所有单词，假设words长度为n，就就要遍历n次。</p>
<p>空间复杂度O(n)：<br>用哈希表记录words中所有单词出现的次数。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>滑动窗口</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.300.最长递增子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">LeetCode.300.最长递增子序列（中等）</a></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，看能不能把大问题先拆分为子问题+有限步骤。</p>
<p><strong>如果已知最长严格递增子序列，它是怎么得来的呢？上一步的最小操作是什么？</strong></p>
<ul>
<li>如果前面没有递增子序列，当前字符作为新的递增子序列起点。</li>
<li>如果前面有了递增子序列，当前字符比前面子序列最后一个数字大，可以形成新的递增子序列，长度加1。</li>
</ul>
<p><strong>前面的递增子序列可能有很多个，应该追加到哪个递增子序列的后面？</strong><br>找长度最大的递增子序列。</p>
<p><strong>数组前面的部分又是怎么找到最长递增子序列的？</strong><br>还是一样的拆解，递归进行，这里划分出了子问题+有限步骤。</p>
<ul>
<li>子问题是最优的，经过有限步骤得出下一个问题的最优解，符合最优子结构。</li>
<li>子问题的结果不受更大问题的影响，无后效性。</li>
<li>计算长的子数组的最长递增子序列的长度，都要访问前面的递增子序列的长度，有重叠子问题。</li>
</ul>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i]</code>为以<code>nums[i]</code>结尾的最长递增子序列的长度。<br>遍历<code>nums[0, i - 1]</code>，寻找<code>j</code>（<code>0 &lt;= j &lt;= i - 1</code>）：</p>
<ul>
<li>对于所有满足<code>nums[i] &gt; nums[j]</code>的<code>j</code>，找出最大<code>dp[j]</code>，<code>dp[i] = 1 + 最大的dp[j]</code>。</li>
<li>如果<code>nums[i]</code>比<code>nums[0, i - 1]</code>都小，<code>dp[i] = 1</code>。</li>
</ul>
<p><strong>复杂度</strong><br>时间复杂度$O(n^2)$：<br>计算所有<code>dp[i]</code>得遍历整个数组，需要$O(n)$；<br>计算每个<code>dp[i]</code>需要遍历<code>[0, i - 1]</code>，即$O(n)$。<br>双循环共执行<code>1 + 2 + 3 + ... + n - 1 = (1 + n - 1) * (n - 1) / 2 = n(n - 1) / 2次</code>。</p>
<p>空间复杂度$O(n)$：<br><code>dp</code>数组占用线性空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLIS</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> preMaxLen = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    preMaxLen = maxOf(preMaxLen, dp[j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = <span class="number">1</span> + preMaxLen</span><br><span class="line">            maxLen = maxOf(maxLen, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间优化</strong></p>
<p><strong>计算所有<code>dp[i]</code>的时间能不能优化？</strong><br>计算所有<code>dp[i]</code>必须要遍历整个数组，无法优化。</p>
<p><strong>计算每个<code>dp[i]</code>的时间能不能优化？</strong><br>先看计算单个<code>dp[i]</code>的过程：<br>是要在已经发现的递增子序列中看<code>nums[i]</code>能接到哪些子序列后面，再在能接上去的这些子序列中找一个长度最大的。</p>
<p><strong>直接找之前最长子序列的去接行不行？</strong><br>行，如果能接上肯定最好。</p>
<p><strong>如果接不上最长的，还有必要去接短的递增子序列吗？</strong><br>有必要的，比如数组<code>[1, 6, 7, 2, 3, 4]</code>，有递增子序列是<code>[1]</code>、<code>[1, 6]</code>和<code>[1, 6, 7]</code>，2是接不到<code>[1, 6, 7]</code>后面的，但是可以接在<code>[1]</code>后面形成<code>[1, 2]</code>，最后遇到3和4，可以接在<code>[1, 2]</code>后面形成长度为4的递增子序列，比<code>[1, 6, 7]</code>还要长。</p>
<p>这里就引发一个问题，如果<strong>之前最长的子序列可能会有多个，应该去接哪个？</strong><br>跟末尾元素最小的比较，是最快的；否则要是接不上，得比较多次。<br>比如上面长度为2的子序列有<code>[1, 6]</code>和<code>[1, 2]</code>，后面遇到3和4肯定直接跟2比较，比较次数是最少的。</p>
<p>所以如果当前数字接不到最长的，但是能接到短的子序列后面，如果当前数字比之前子序列末尾元素小，接上去对后面接更长的子序列是有意义的。</p>
<p><strong>能否在查找方法上做优化？</strong><br>一说到查找和比较，就能想到最优化的查找元素方法是二分查找，可以把时间复杂度降低到$O(log n)$。</p>
<p>二分查找是要求在有序数组里做查找比较的，那就把递增子序列的末尾数字从小到大排序。</p>
<p>我们想通过比较末尾元素，是想更新某个长度的递增子序列的末尾元素为更小的。</p>
<p>递增子序列末尾元素的大小顺序和子序列的长度有没有什么关联？</p>
<p>可以发现，如果相同长度的子序列只保留最小的末尾数字，那么长度大的子序列的末尾元素一定比长度小的子序列的末尾元素大。<br>因为只有新的数字比原来短的递增子序列的末尾元素大，才能形成长度更长的递增子序列；如果新的数字比原来短的递增子序列的末尾元素小，是无法形成长度更长的递增子序列的。</p>
<hr>
<p><strong>能否在查找方法上做优化？</strong><br>一说到查找和比较，就能想到最优化的查找元素方法是二分查找，可以把时间复杂度降低到$O(log n)$。</p>
<p>二分查找是要求在有序数组里做查找比较的，那就把递增子序列的末尾数字从小到大排序。<br>新的数字去二分比较后，能否确定新数字可以拼接的子序列最长长度？只有能确定，才可以不跟所有末尾数字比较，二分查找才能节约出时间，否则还得顺序扫描所有元素。</p>
<p>换句话说，递增子序列末尾元素的大小顺序和子序列的长度有没有什么关联？</p>
<p>可以发现，如果相同长度的子序列只保留最小的末尾数字，那么长度大的子序列的末尾元素一定比长度小的子序列的末尾元素大。<br>因为只有新的数字比原来短的递增子序列的末尾元素大，才能形成长度更长的递增子序列；如果新的数字比原来短的递增子序列的末尾元素小，是无法形成长度更长的递增子序列的；如果新数字比某长度的递增子序列的最小的末尾数字都要小，那肯定是无法接在它后面形成长度更长的递增子子序列了。</p>
<p>所以二分查找是可行的，可以保存每个长度的递增子序列的最小末尾数字形成数组，递增子序列长度作为数组索引，数组元素默认就是严格递增。<br>遇到新的数字用二分查找，就可以知道应该更新哪个长度的子序列的末尾元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLIS</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// dp[i]表示以长度为i + 1的所有上升子序列中结尾最小的数，0 &lt;= i &lt;= n - 1，n为数组长度</span></span><br><span class="line">        <span class="comment">// 由于上升子序列的长度可能是小于n的，所以这里创建动态列表来作为状态存储</span></span><br><span class="line">        <span class="keyword">val</span> dp = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp.add(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 可以形成更长的子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; dp.last()) &#123;</span><br><span class="line">                dp.add(nums[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不能形成更长的子序列，但是要更新之前子序列末尾的元素为更小的，方便后续快速比较</span></span><br><span class="line">                <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">                <span class="keyword">var</span> right = dp.size - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">when</span> &#123;</span><br><span class="line">                        <span class="comment">// 要找比子序列末尾元素大的位置，所以不会是mid本身，要mid + 1</span></span><br><span class="line">                        dp[mid] &lt; nums[i] -&gt; left = mid + <span class="number">1</span></span><br><span class="line">                        <span class="comment">// dp[mid] &gt; nums[i]，dp严格递增，不存在dp[mid] == nums[i]</span></span><br><span class="line">                        <span class="keyword">else</span> -&gt; right = mid - <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 熟悉二分法可知，循环结束后，一定会有 nums[left - 1] &lt; nums[i] &lt; nums[left]</span></span><br><span class="line">                <span class="comment">// 更新子序列末尾元素为更小的</span></span><br><span class="line">                dp[left] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.304.%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</a></p>
<p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<ul>
<li>计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。<br>实现 NumMatrix 类：</li>
<li>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化</li>
<li>int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。<span id="more"></span></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>与<a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a>思路相同。</p>
<p>NumMatrix.sumRegion()要想做到O(1)时间复杂度查询，就要提前计算好二位前缀和。</p>
<p>设<code>preSum[i][j]</code>为<code>[0, 0]</code>到<code>[i, j]</code>矩形区域所有元素和。</p>
<p>求矩形区域d的元素和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a a a b b b b b   </span><br><span class="line">a a a b b b b b</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>设矩形d左上角坐标<code>(x1, y1)</code>，右下角坐标<code>(x2, y2)</code>。<br><code>整个区域所有元素和 = preSum[x2][y2]</code><br><code>区域a所有元素和 + 区域b所有元素和 = preSum[x1 - 1][y2]</code><br><code>区域a所有元素和 + 区域c所有元素和 = preSum[x2][y1 - 1]</code></p>
<p>所以:<br><code>区域d所有元素和 = preSum[x2][y2] - preSum[x1 - 1][y2] - preSum[x2][y1 - 1] + preSum[x1 - 1][y1 - 1]</code></p>
<p>遇到边界特殊处理一下就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span></span>(matrix: Array&lt;IntArray&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> m = matrix.size</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 求二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            preSum[<span class="number">0</span>][j] = preSum[<span class="number">0</span>][j - <span class="number">1</span>] + matrix[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            preSum[i][<span class="number">0</span>] = preSum[i - <span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> left = preSum[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> top = preSum[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">val</span> leftTop = preSum[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                preSum[i][j] = left + top - leftTop + matrix[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sumRegion</span><span class="params">(row1: <span class="type">Int</span>, col1: <span class="type">Int</span>, row2: <span class="type">Int</span>, col2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> all = preSum[row2][col2]</span><br><span class="line">        <span class="keyword">val</span> left = <span class="keyword">if</span> (col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row2][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> top = <span class="keyword">if</span> (row1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col2]</span><br><span class="line">        <span class="keyword">val</span> leftTop = <span class="keyword">if</span> (row1 == <span class="number">0</span> || col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> all - left - top + leftTop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.309.最佳买卖股票时机含冷冻期（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode.309.最佳买卖股票时机含冷冻期（中等）</a></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划。</p>
<h3 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h3><p>第<code>i</code>天的基本操作有：买入、卖出、什么都不做。<br>买入有冷冻期限制，第i天可能无法买入，也就是只能什么都不做了，所有的操作还是这三种，不影响确定最终状态。<br>经过选择操作后可得第i天的最终状态只有：持有股票或不持有股票。<br>买入冷冻期的限制在状态转移方程中做状态转移时体现出来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p><code>dp[i][0]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1</code>天一样</li>
<li>之前持有股票，第<code>i</code>天卖出</li>
</ol>
<p>可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code></p>
<p><code>dp[i][1]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1天</code>一样</li>
<li>之前不持有股票，第<code>i</code>天买入；买入有冷冻期限制，如果是第<code>i - 1</code>天卖出的，第<code>i</code>天就不能买入了。</li>
</ol>
<p>可得<code>dp[i][1] = max(dp[i - 1], dp[i - 2][0] - prices[i])</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i][k]</code>只与前面两个状态有关，用变量记录前面的状态，不需要数组记录所有状态。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 0</span></span><br><span class="line">        <span class="keyword">var</span> preNoholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> preHoldProfit = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 1</span></span><br><span class="line">        <span class="keyword">var</span> curNoholdProfit = maxOf(preNoholdProfit, preHoldProfit + prices[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> curHoldProfit = maxOf(preHoldProfit, preNoholdProfit - prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(curNoholdProfit, curHoldProfit + prices[i])</span><br><span class="line">            <span class="comment">// 买入有冷冻期，只能从前天没有持有股票的状态转移而来</span></span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(curHoldProfit, preNoholdProfit - prices[i])</span><br><span class="line"></span><br><span class="line">            preNoholdProfit = curNoholdProfit</span><br><span class="line">            preHoldProfit = curHoldProfit</span><br><span class="line"></span><br><span class="line">            curNoholdProfit = newNoholdProfit</span><br><span class="line">            curHoldProfit = newHoldProfit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curNoholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.32.最长有效括号（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode.32.最长有效括号（困难）</a></p>
<p>给你一个只包含  <code>&#39;(&#39;</code> 和  <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h2><p>括号匹配时，左右括号数量相等，子串长度就是左右括号之和。</p>
<p>可以从左到右遍历字符串，记录左右括号的数量，通过数量来判断子串是否是是有效括号。</p>
<ul>
<li>当右括号数量大于左括号时，当前子串肯定不是有效的括号，计数对于累加有效括号子串已经无意义，可以清零，以便后续子串。</li>
<li>当左括号数量大于右括号，有可能还有匹配的右括号在后面，只要右括号数量跟左括号相等，就可以认定当前子串是有效的括记录子串长度，并比较最长的长度。<ul>
<li>这种情况下有可能最终左括号的数量一直大于右括号数量，导致无法触发记录，例如((((((((((())。</li>
<li>此时可以从右向左再遍历一次字符串，就可以触发到左右括号相等的时候，当左括号数量大于右括号，括号数量计数清零。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                left == right -&gt; maxLength = maxOf(maxLength, <span class="number">2</span> * right)</span><br><span class="line">                right &gt; left -&gt; &#123;</span><br><span class="line">                    left = <span class="number">0</span></span><br><span class="line">                    right = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.length - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                left == right -&gt; maxLength = maxOf(maxLength, <span class="number">2</span> * left)</span><br><span class="line">                right &lt; left -&gt; &#123;</span><br><span class="line">                    left = <span class="number">0</span></span><br><span class="line">                    right = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：栈"><a href="#解法2：栈" class="headerlink" title="解法2：栈"></a>解法2：栈</h2><h3 id="怎么计算有效括号长度？"><a href="#怎么计算有效括号长度？" class="headerlink" title="怎么计算有效括号长度？"></a>怎么计算有效括号长度？</h3><p>从左到右遍历字符串时，发现如果有一个子串是有效括号，要计算它的长度，就是用结束索引减去起始索引得到长度。所以的想办法记录左括号的起始索引。</p>
<h3 id="怎么存储索引比较合适？"><a href="#怎么存储索引比较合适？" class="headerlink" title="怎么存储索引比较合适？"></a>怎么存储索引比较合适？</h3><p>从左到右遍历发现右括号后，得知道左边有没有左括号，如果有，计算括号匹配长度是要知道这个左括号前面一个位置的索引。</p>
<p>如果发现了多个右括号，是要从右到左依次访问匹配的左括号前面一个位置的索引，遍历顺序和访问顺序相反，可以用栈来存储左括号索引。</p>
<p>遍历到右括号时，发现栈不为空说明有左括号，匹配到左括号出栈后，栈顶就是匹配的左括号的前一个位置的索引。</p>
<p>如果匹配的左括号出栈后栈为空，就要手动记录一下第一个左括号左边的索引。</p>
<h3 id="何时入栈？"><a href="#何时入栈？" class="headerlink" title="何时入栈？"></a>何时入栈？</h3><p>有效括号子串的第一个字符一定是一个左括号，因为如果开头是右括号则不是有效括号子串。<br>所以遇到左括号就要记录其索引，因为它有可能是一个长的有效括号子串的起始索引。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> left = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="comment">// 记录可能的有效括号子串的前一个位置，可以利用此索引计算子串的长度</span></span><br><span class="line">        <span class="keyword">var</span> prev = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left.push(i)</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到右括号，如果前面有左括号，说明匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (left.isNotEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 匹配的左括号从栈中移出</span></span><br><span class="line">                        left.pop()</span><br><span class="line">                        <span class="comment">// 如果前面还有左括号，这个左括号的索引是刚才有效括号子串的前一个位置</span></span><br><span class="line">                        <span class="comment">// 如果前面没有左括号了，读取遇到左括号前记录的位置，也是刚才有效括号子串的前一个位置</span></span><br><span class="line">                        <span class="keyword">val</span> prevOfStart = <span class="keyword">if</span> (left.isNotEmpty()) left.peek() <span class="keyword">else</span> prev</span><br><span class="line">                        <span class="comment">// 当前位置减去有效括号子串的前一个位置就是有效括号子串的长度</span></span><br><span class="line">                        <span class="keyword">val</span> length = i - prevOfStart</span><br><span class="line">                        <span class="comment">// 记录最大长度</span></span><br><span class="line">                        maxLength = max(maxLength, length)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 遇到右括号，但前面没有左括号，说明当前字符结尾的子串没办法构成有效括号</span></span><br><span class="line">                        <span class="comment">// 但后面的子串还有可能是有效的子串，记录当前位置，如果后面紧接着的子串是有效括号子串，可以利用此索引计算子串的长度</span></span><br><span class="line">                        prev = i</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：动态规划"><a href="#解法3：动态规划" class="headerlink" title="解法3：动态规划"></a>解法3：动态规划</h2><p>最值问题考虑用动态规划。尝试划分为子问题+有限步骤。</p>
<p>如果字符串s是一个有效的括号串，最后一个字符一定是右括号。</p>
<ul>
<li>如果最后一个字符不是右括号，去除最后一个字符查看前面的子串是不是有效括号，前面子串查看方法是一样的。</li>
<li>如果最后一个字符是右括号：<ul>
<li>倒数第二个字符是左括号，发生了一次匹配，有效括号长度可以加2了，再继续看前面的子串的有效括号的长度。</li>
<li>倒数第二个字符是右括号，得看前面的有没有左括号能跟最后一个右括号匹配上才行。</li>
</ul>
</li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; length = <span class="number">2</span> + longest(i - <span class="number">2</span>)</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = longest(i - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="comment">// 看前面有没有跟s[i]这个右括号匹配的左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// 匹配到左括号前面的有效括号子串长度还要加上</span></span><br><span class="line">                            length = <span class="number">2</span> + midLen + longest(left - <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (length &gt; maxLength) maxLength = length</span><br><span class="line">            longest(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        &#125;</span><br><span class="line">        longest(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记忆化递归</strong></p>
<p>暴力递归有很多重叠子问题。</p>
<p>例如两次longest(i - 1)和一次longest(i - 2)计算结果是一样的，但是都重复计算了。</p>
<p>需要记录中间计算状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i]</span><br><span class="line">            <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; length = <span class="number">2</span> + longest(i - <span class="number">2</span>)</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = longest(i - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="comment">// 看前面有没有跟s[i]这个右括号匹配的左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// 匹配到左括号前面的有效括号子串长度还要加上</span></span><br><span class="line">                            length = <span class="number">2</span> + midLen + longest(left - <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = length</span><br><span class="line">            <span class="keyword">if</span> (length &gt; maxLength) maxLength = length</span><br><span class="line">            longest(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        &#125;</span><br><span class="line">        longest(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>设<code>dp[i]</code>表示以字符<code>s[i]</code>结尾的最长有效的括号子串的长度。</p>
<p>状态转移方程按照递归的方式写就行了。</p>
<p>边界条件单独判断一下就OK。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 从第2个字符开始遍历，一个字符无法形成有效括号</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; dp[i] = <span class="number">2</span> + <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="number">0</span> <span class="keyword">else</span> dp[i - <span class="number">2</span>]</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = dp[i - <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            dp[i] = <span class="number">2</span> + midLen + <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> dp[left - <span class="number">1</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.322.零钱兑换（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">LeetCode.322.零钱兑换（中等）</a></p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一组东西中进行多种选择最终达到一个目标值，联想到背包问题，尝试划分子问题。</p>
<p>得到amount的上一步一定是从coins选择一个硬币得来的，但是不知道哪种选择所需的硬币数最少，那么就每个都试一下，取硬币数最少的。</p>
<p>选取一个硬币coin后，剩下amout - coin的金额是怎么得来的，也是同样的选择过程，并且这个子问题加上新的选择过程得到最优的最终结果，符合最优子结构。</p>
<p>如果一直选择先去有可能发现不能用选择过的硬币累加成amount，那就是无法组合。</p>
<p>如果一直选下去，发现可以凑成amount，记录选择过的硬币数量，同时每次对比最终取一个最少的硬币数量。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重叠子问题</strong><br>画出递归树，会发现会有重叠子问题，有大量的重复计算。<br>例如<code>coins = [1,2,4]</code>。<br>四次<code>select(amount - 1)</code>跟一次<code>select(amount - 4)</code>是重复计算的。<br>两次<code>select(amount - 2)</code>跟一次<code>select(amount - 4)</code>是重复计算的。</p>
<p><strong>记忆化递归</strong><br>消除重叠子问题就是记录中间计算结果。<br>计算的结果是硬币数，中间状态是跟<code>amount</code>有关，但是并不是0到<code>amount</code>都会有计算结果，所以可以用哈希表来存储中间状态，节省一点空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[amount] != <span class="literal">null</span>) memo[amount]!!</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">            memo[amount] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>记忆化递归从大的amount往小的amount去算，也可以从小的amount去递推大的amount。<br>初始值<code>dp[0] = 0</code>要存储一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (a <span class="keyword">in</span> <span class="number">1.</span>.amount) &#123;</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = dp.getOrDefault(a - coin, -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, count + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            dp[a] = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[amount]!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.343.整数拆分（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/integer-break/">LeetCode.343.整数拆分（中等）</a></p>
<p>给定一个正整数 _n_，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目已经说出了步骤，直接干。</p>
<p>穷举所有n可能被拆解的可能性，看哪种拆分的乘积最大。</p>
<p>n可以被拆解为<code>j</code>和<code>n - j</code>两个正整数，穷举所有的<code>j</code>，看哪个<code>j * (n - j)</code>最大就选哪个<code>j</code>，<code>1 &lt;= j &lt;= n - 1</code>。</p>
<p>题目说至少是拆分两个，还可以继续拆分，所以可以对<code>n - j</code>继续拆分，也可以不继续拆分。<br><code>n - j</code>继续拆解，就划分为子问题了。</p>
<p><strong>暴力递归拆解</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxProduct = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> i = n - j</span><br><span class="line">            maxProduct = maxOf(</span><br><span class="line">                maxProduct,</span><br><span class="line">                j * i,</span><br><span class="line">                j * integerBreak(i)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProduct</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记忆化递归</strong><br>存在很多重叠子问题，计算量过大，时间复杂度指数级别，需要记录中间计算结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            <span class="keyword">var</span> maxProduct = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> i = n - j</span><br><span class="line">                maxProduct = maxOf(</span><br><span class="line">                    maxProduct,</span><br><span class="line">                    j * i,</span><br><span class="line">                    j * integerBreak(i)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            memo[n] = maxProduct</span><br><span class="line">            <span class="keyword">return</span> maxProduct</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>设<code>dp[i]</code>为<code>i</code>拆解为多个正整数后的最大乘积。<br>先求出小的<code>dp[i]</code>再求大的；每个<code>dp[i]</code>穷举所有拆解情况。</p>
<pre><code class="kotlin">class Solution &#123;
    fun integerBreak(n: Int): Int &#123;
        val dp = IntArray(n + 1) &#123; 0 &#125;
        dp[2] = 1
        for (i in 2..n) &#123;
            for (j in 1 until i) &#123;
                dp[i] = maxOf(
                    dp[i],
                    j * (i - j),
                    j * dp[i - j]
                )
            &#125;
        &#125;
        return dp[n]
    &#125;
&#125;
```xxxxxxxxxx class Solution &#123;    fun coinChange(coins: IntArray, amount: Int): Int &#123;        val dp = mutableMapOf&lt;Int, Int&gt;()        dp[0] = 0        for (a in 1..amount) &#123;            var minCount = Int.MAX_VALUE            for (coin in coins) &#123;                val count = dp.getOrDefault(a - coin, -1)                if (count == -1) continue                minCount = minOf(minCount, count + 1)            &#125;            dp[a] = if (minCount == Int.MAX_VALUE) -1 else minCount        &#125;         return dp[amount]!!    &#125;&#125;kotlin
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.37.解数独（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.37.%E8%A7%A3%E6%95%B0%E7%8B%AC%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">LeetCode.37.解数独（困难）</a></p>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ul>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右从上到下遍历所有没有填空的位置，尝试去填数字；填过的位置就跳过。</p>
<p>填过的数字就不能再用了，但是不知道填哪个数字，所以要尝试所有的可能性，采用暴力回溯解法。</p>
<p>填数字时要有三个限制条件，都是保证数字不重复，那么就要存储已访问过的数字，按行、按列、按3x3宫格分开记录和判断，这样最方便快速。</p>
<p>如果能按照限制条件填满一种可能性，就不用再尝试其他可能性了，直接结束程序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solveSudoku</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.isEmpty()) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> n = board.size</span><br><span class="line">        <span class="keyword">val</span> rowUsed = Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> columnUsed = Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> boxUsed = Array(<span class="number">3</span>) &#123; Array(<span class="number">3</span>) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] <span class="keyword">in</span> <span class="string">&#x27;1&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    rowUsed[i][num] = <span class="literal">true</span></span><br><span class="line">                    columnUsed[j][num] = <span class="literal">true</span></span><br><span class="line">                    boxUsed[i / <span class="number">3</span>][j / <span class="number">3</span>][num] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(row: <span class="type">Int</span>, column: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> r = row</span><br><span class="line">            <span class="keyword">var</span> c = column</span><br><span class="line">            <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">                c = <span class="number">0</span></span><br><span class="line">                r++</span><br><span class="line">                <span class="keyword">if</span> (r == n) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rowUsed[r][i] || columnUsed[c][i] || boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i]) <span class="keyword">continue</span></span><br><span class="line">                    board[r][c] = i.toString()[<span class="number">0</span>]</span><br><span class="line">                    rowUsed[r][i] = <span class="literal">true</span></span><br><span class="line">                    columnUsed[c][i] = <span class="literal">true</span></span><br><span class="line">                    boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(r, c + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    board[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    rowUsed[r][i] = <span class="literal">false</span></span><br><span class="line">                    columnUsed[c][i] = <span class="literal">false</span></span><br><span class="line">                    boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(r, c + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.376.摆动序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LeetCode.376.摆动序列（中等）</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，先划分子问题。</p>
<p>从某个摆动序列最后一个元素开始倒推，得到这个摆动序列有两个情况：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递增的。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递减的。</li>
</ol>
<p>子摆动序列怎么得来的，也是同样的递归划分。</p>
<p>这里有两个状态变化，一个是元素位置，一个是末尾差值。</p>
<p>设<code>dp[i][k]</code>表示数组中第0个到第<code>i</code>元素之间最长摆动序列长度；<br>k表示<code>nums[i]</code>和前面元素是递增或递减的情况；<br><code>k == 0</code> 时，表示递减；<br><code>k == 1</code> 时，表示递增。</p>
<p>考虑之前相反的情况，如果：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递减的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递增，也就更有可能得到更长的摆动序列。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递增的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递减，也就更有可能得到更长的摆动序列。</li>
</ol>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>nums[i] &lt; nums[i - 1]</code>，递减：<br>  <code>dp[i][0] = maxOf(dp[i][0], dp[i - 1][1] + 1)</code></li>
<li><code>nums[i] &gt; nums[i - 1]</code>，递增：<br>  <code>dp[i][1] = maxOf(dp[i][1], dp[i - 1][0] + 1)</code></li>
<li><code>nums[i] == nums[i - 1]</code>，持平：<br>  <code>dp[i][0] = dp[i - 1][0]</code><br>  <code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p><strong>边界处理</strong><br>最一开始只有一个元素，没有形成递增或递减，所以摆动序列长度为0。<br><code>dp[0][0] = 0</code><br><code>dp[0][1] = 0</code></p>
<p><strong>最后取值</strong><br>取<code>dp[n - 1][0]</code>和<code>dp[n - 1][1]</code>中较大的。<br>最后结果还要加1，因为我们是在发生新的摆动的时候才给序列增加长度的，遍历到最后时没有新的摆动了，但是目前的摆动没有算进长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br><code>dp[i]</code>只与<code>dp[i - 1]</code>有关，可以用变量记录状态，不用数组。</p>
<p>用<code>up</code>记录末尾递增的摆动序列的最长长度。<br>用<code>down</code>记录末尾递减的摆动序列的最长长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> up = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> down = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = maxOf(down, up + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = maxOf(up, down + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(up, down) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.377.组合总和 Ⅳ（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">LeetCode.377.组合总和 Ⅳ（中等）</a></p>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<span id="more"></span>

<p>示例 1：</p>
<blockquote>
<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只要看到目标值、数组、选择，这三要素，就直接可以反应想到是背包问题。</p>
<p>这里数组中的元素是可以重复选取的，所以是完全背包问题。</p>
<p>大的target可以拆解为小target加一系列选择求解，所以要遍历所有的target取值可能，还要遍历所有数字取值可能，有两层循环。</p>
<p>这里要注意顺序不同的序列被视作不同的组合，这涉及到双层循环的哪一个循环应该放在外层。<br>由于不锁定数字选择顺序，<code>nums</code>数组遍历应该放在内层，这样target才可以由不同顺序的选择得到。<br>如果<code>nums</code>数组遍历放在外层，会锁定<code>nums</code>数组的选取顺序，一个target只会有一种顺序的选择得到。<br>这与<a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a>情况正好相反。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum4</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(target + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (t <span class="keyword">in</span> <span class="number">0.</span>.target) &#123;</span><br><span class="line">            <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= num) &#123;</span><br><span class="line">                    dp[t] += dp[t - num]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.392.判断子序列（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/is-subsequence">LeetCode.392.判断子序列（简单）</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：<br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h3><p>可以直接拿s和t做比较，遇到不相同的字符就跳过，只要保证s所有字符在t中，并且顺序没有改变即可。</p>
<p>时间复杂度O(m + n)：m为字符串s长度，n为字符串t长度，最坏情况下两个指针都要移动到字符串末尾。<br>空间复杂度O(1)：没有额外空间占用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：后续挑战-动态规划"><a href="#解法2：后续挑战-动态规划" class="headerlink" title="解法2：后续挑战 - 动态规划"></a>解法2：后续挑战 - 动态规划</h3><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。</p>
<p>双指针的问题在于：<br>S中的一个字符跟T中的字符匹配后，再去匹配下一个字符，需要在T中顺序查找，如果能直接查表得到位置，时间就降下来了。<br>假设S的长度为m，那么复杂度就可以降低为O(m)。</p>
<p>可以对T做预处理，记录位于<code>T</code>中第<code>i</code>个位置时字符<code>j</code>第一次出现的索引位置，用<code>dp[i][j]</code>来表示。<br>字符集是常数个，所以<code>j</code>的取值范围是一个常量。</p>
<p><strong>状态转移方程</strong><br>因为<code>dp[i][j]</code>记录的是<code>j</code>在<code>i</code>或<code>i</code>之后第一次出现的位置；<br>如果<code>T[i] == j</code>，<code>dp[i][j] = i</code>。<br>如果<code>T[i] != j</code>，<code>dp[i][j] = dp[i + 1][j]</code>。<br>如果<code>i</code>之后不存在字符<code>j</code>，令<code>dp[i][j] = -1</code><br>要从后往前递推。</p>
<p><strong>复杂度</strong><br>设m为S长度，n为T长度。<br>预处理时间复杂度O(n)。<br>判断子序列时间复杂度O(m)。</p>
<p>空间复杂度O(n * 字符集个数)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (t.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = t.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">26</span>) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = (<span class="string">&#x27;a&#x27;</span>.toInt() + j).toChar()</span><br><span class="line">                <span class="keyword">if</span> (t[i] == c) dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> indexT = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="comment">// t已经没有后续字符了，s还没匹配完，那肯定不是子序列</span></span><br><span class="line">            <span class="keyword">if</span> (indexT == n) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">val</span> cIndex = c.toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">            <span class="keyword">if</span> (dp[indexT][cIndex] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="comment">// s中的字符c匹配到了T中的字符，从T中下一个字符开始继续匹配</span></span><br><span class="line">            indexT = dp[indexT][cIndex] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.4.寻找两个正序数组的中位数（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode.4.寻找两个正序数组的中位数（困难）</a></p>
<p>给定两个大小分别为  <code>m</code>  和  <code>n</code>  的正序（从小到大）数组 <code>nums1</code>  和 <code>nums2</code>。请你找出并返回这两个正序数组的  <strong>中位数</strong>  。</p>
<p>进阶：你能设计一个时间复杂度为  <code>O(log (m+n))</code>  的算法解决此问题吗？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1-归并"><a href="#解法1-归并" class="headerlink" title="解法1: 归并"></a>解法1: 归并</h2><h3 id="一个数组怎么找中位数？"><a href="#一个数组怎么找中位数？" class="headerlink" title="一个数组怎么找中位数？"></a>一个数组怎么找中位数？</h3><ul>
<li>数组元素有奇数个，中位数是最中间的一个数。</li>
<li>数组元素有偶数个，中位数是最中间的两个数的平均值。</li>
</ul>
<p>设数组长度为n。</p>
<ul>
<li>n为奇数时，中位数应该是第<code>n / 2 + 1</code>个数，由于数组索引从0开始，所以中位数是<code>nums[n / 2]</code>。</li>
<li>n为偶数时，左中位数是第<code>n / 2</code>个数，右中位数是第<code>n / 2 + 1</code>个数；由于数组索引从0开始，左中位数为<code>nums[n / 2 - 1]</code>，右中位数为<code>nums[n / 2]</code>，实际中位数为<code>(nums[n / 2 - 1] + nums[n / 2]) / 2</code>。</li>
</ul>
<h3 id="两个数组怎么找中位数？"><a href="#两个数组怎么找中位数？" class="headerlink" title="两个数组怎么找中位数？"></a>两个数组怎么找中位数？</h3><p>把两个数组归并为一个有序数组。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(m + n)</code>：需要遍历两个数组所有元素做归并。</li>
<li>空间复杂度<code>O(m + n)</code>：额外需要一个<code>m + n</code>长度的数组存储归并后的元素。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = nums1.size</span><br><span class="line">        <span class="keyword">val</span> n = nums2.size</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二路归并</span></span><br><span class="line">        <span class="keyword">val</span> nums = IntArray(m + n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> i1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> i2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; m &amp;&amp; i2 &lt; n) &#123;</span><br><span class="line">            nums[j++] = <span class="keyword">if</span> (nums1[i1] &lt; nums2[i2]) nums1[i1++] <span class="keyword">else</span> nums2[i2++]            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; m) nums[j++] = nums1[i1++]</span><br><span class="line">        <span class="keyword">while</span> (i2 &lt; n) nums[j++] = nums2[i2++]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取中位数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = (m + n) / <span class="number">2</span></span><br><span class="line">            nums[mid].toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMid = (m + n) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rightMid = leftMid + <span class="number">1</span></span><br><span class="line">            (nums[leftMid] + nums[rightMid]).toDouble() / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：二分"><a href="#解法2：二分" class="headerlink" title="解法2：二分"></a>解法2：二分</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>归并排序产生了新数组，增加了空间复杂度。</p>
<p>既然在一个数组中找中位数不需要额外空间，两个数组应该也能。</p>
<p>我们的思路还是把两个数组往一个数组的情况上考虑，也就是把不熟悉的情况往熟悉的情况上靠拢。</p>
<h3 id="合二为一"><a href="#合二为一" class="headerlink" title="合二为一"></a>合二为一</h3><p>找中位数是跟数组总个数有关的，如果把小的元素和大的元素正好能各分一半，那么看中间的数就行。</p>
<p>可以把两个数组分割为左右两部分，两个数组的左半部分元素个数跟右半部分元素个数相等的时候，直接看中间的元素就行了。</p>
<p>设<code>nums1</code>数组长度为<code>m</code>，<code>nums2</code>数组长度为<code>n</code>。<br>把<code>nums1</code>分为前<code>i</code>个元素和后<code>m - i</code>个元素。<br>把<code>nums2</code>分为前<code>j</code>个元素和后<code>n - j</code>个元素。</p>
<p>如果<code>m + n</code>是偶数，<code>i + j = (m + n) / 2</code>。<br>如果<code>m + n</code>是奇数，<code>i + j = (m + n) / 2 + 1</code>。<br>知道了<code>i</code>就可以确定<code>j</code>。</p>
<h3 id="怎么确定i-？"><a href="#怎么确定i-？" class="headerlink" title="怎么确定i ？"></a>怎么确定<code>i</code> ？</h3><p>左半部分所有元素都小于右半部分的元素。</p>
<p>数组本身是有序的，所以要求两个数组的不同部分也保持顺序，即：<br><code>nums1[i - 1] &lt; nums2[j] &amp;&amp; nums2[j - 1] &lt; nums1[i]</code></p>
<p>这个条件等价于在<code>nums1</code>数组中查找最大的<code>i</code>来满足<code>nums1[i - 1] &lt; nums2[j]</code>，查找过程可以用二分查找。</p>
<h3 id="二分查找的细节"><a href="#二分查找的细节" class="headerlink" title="二分查找的细节"></a>二分查找的细节</h3><p>当发现<code>nums[i - 1] &gt; nums2[j]</code>，说明左半部分的元素多了，要减少，应当继续寻找更小的<code>i</code>。<br>当发现<code>nums[i - 1] &lt;= nums2[j]</code>，说明左半部分可能正好，也可能少了，可以尝试寻找更大的<code>i</code>。</p>
<h3 id="查找完毕后怎么确定中位数？"><a href="#查找完毕后怎么确定中位数？" class="headerlink" title="查找完毕后怎么确定中位数？"></a>查找完毕后怎么确定中位数？</h3><p>查找到最大的<code>i</code>过后，就可以选取中位数了。</p>
<ul>
<li>如果<code>m + n</code>是奇数，分割数组的时候可以让左半部分多一个元素，两数组左半部分最大值即为中位数。</li>
<li>如果<code>m + n</code>是偶数，两数组左半部分最大值和右半部分最小值的平均数即为中位数。</li>
</ul>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(log(min(m, n)))</code>，在短的数组里做了二分查找。</li>
<li>空间复杂度<code>O(1)</code>，只使用了常数个的辅助变量。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = nums1.size</span><br><span class="line">        <span class="keyword">val</span> n = nums2.size</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> leftCount = <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">0</span>) (m + n) / <span class="number">2</span> <span class="keyword">else</span> (m + n) / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = m</span><br><span class="line">        <span class="comment">// 循环结束时left == right，不用思考选取left还是right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算mid向上取整，否则最后只剩两个元素的时候，下面一直走到else，左边界不会更新</span></span><br><span class="line">            <span class="keyword">val</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> j = leftCount - i</span><br><span class="line">            <span class="comment">// i不满足条件，要找更小的</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) right = i - <span class="number">1</span></span><br><span class="line">            <span class="comment">// i满足条件，i可能是要求解的结果，不要跳过i</span></span><br><span class="line">            <span class="keyword">else</span> left = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> i = left</span><br><span class="line">        <span class="keyword">val</span> j = leftCount - left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> nums1LeftMax = <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> nums2LeftMax = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> nums1RightMin = <span class="keyword">if</span> (i == m) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[i]</span><br><span class="line">        <span class="keyword">val</span> nums2RightMin = <span class="keyword">if</span> (j == n) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMax = maxOf(nums1LeftMax, nums2LeftMax)</span><br><span class="line">            <span class="keyword">val</span> rightMin = minOf(nums1RightMin, nums2RightMin)</span><br><span class="line">            (leftMax + rightMin).toDouble() / <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMax = maxOf(nums1LeftMax, nums2LeftMax).toDouble()</span><br><span class="line">            leftMax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：分治"><a href="#解法3：分治" class="headerlink" title="解法3：分治"></a>解法3：分治</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们可以从简单理想的情况开始着手，逐步改变条件，看需要考虑的因素会发生什么变化。</p>
<h3 id="理想情况"><a href="#理想情况" class="headerlink" title="理想情况"></a>理想情况</h3><p>假设m + n是奇数，中位数是第(m + n) / 2个数，令k = (m + n) / 2。</p>
<p>如果两数组长度相同，那么直接比较nums1[k / 2]和nums2[k / 2]的大小，就知道应该取哪个数是中位数了，这是很自然推导。</p>
<h3 id="如果m-n，再比较nums1-k-2-和nums2-k-2-的大小，还能直接得出中位数是哪个吗？"><a href="#如果m-n，再比较nums1-k-2-和nums2-k-2-的大小，还能直接得出中位数是哪个吗？" class="headerlink" title="如果m != n，再比较nums1[k / 2]和nums2[k / 2]的大小，还能直接得出中位数是哪个吗？"></a>如果m != n，再比较nums1[k / 2]和nums2[k / 2]的大小，还能直接得出中位数是哪个吗？</h3><p>不能，但是可以排除掉k / 2个元素不用再参与比较，这样其实就优化了时间复杂度。</p>
<p>比如nums1[k / 2] &lt; nums2[k / 2]时，可得：</p>
<ul>
<li>nums2[k / 2]有可能是第k大的数字，也有可能不是。</li>
<li>但是nums1[k / 2]绝对不是第k大的数。</li>
<li>nums1数组的前k / 2个元素也都不可能是第k大的数，因为nums1是从小到大排序的。</li>
</ul>
<p>第k大的数是有可能出现在nums2的0到k / 2之中的，考虑极端情况：</p>
<ul>
<li>如果nums1[k / 2]后续如果正好有个k / 2 - 1个元素比nums2[0]小，那么nums2[0]就是第k大的数。</li>
<li>如果nums1[k / 2]之后没有元素了，只能在在nums2[k / 2]后面再继续找第k大的数。</li>
</ul>
<h3 id="接下来怎么找第k大的数？"><a href="#接下来怎么找第k大的数？" class="headerlink" title="接下来怎么找第k大的数？"></a>接下来怎么找第k大的数？</h3><p>已经排除了k / 2个元素不用比较后，接着其实是要寻找第 k - k / 2 个数，寻找过程是一样的，这里就划分出了子问题，可以递归进行。<br>并且每次折半查找，时间复杂度是对数级别的。</p>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul>
<li>k一直缩减到1，就是最终想要得到的中位数。</li>
<li>如果数组没有第k / 2个数可选择，就取数组末尾的数比较。</li>
</ul>
<h3 id="m-n是偶数怎么办？"><a href="#m-n是偶数怎么办？" class="headerlink" title="m + n是偶数怎么办？"></a>m + n是偶数怎么办？</h3><p>可以分别查找到左中位数和右中位数，再求平均值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = nums1.size</span><br><span class="line">        <span class="keyword">val</span> len2 = nums2.size</span><br><span class="line">        <span class="keyword">val</span> len = len1 + len2</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> left = len / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> (getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, left) + getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, right)) / <span class="number">2.</span>toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = len / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, mid).toDouble()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getKth</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>, i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = nums1.size - i1</span><br><span class="line">        <span class="keyword">val</span> len2 = nums2.size - i2</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, nums1, i2, i1, k)</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[i2 + k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> minOf(nums1[i1], nums2[i2])</span><br><span class="line">        <span class="keyword">val</span> j1 = i1 + minOf(k / <span class="number">2</span>, len1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> j2 = i2 + minOf(k / <span class="number">2</span>, len2) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (nums1[j1] &lt; nums2[j2]) &#123;</span><br><span class="line">            getKth(nums1, nums2, j1 + <span class="number">1</span>, i2, k - (j1 - i1 + <span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getKth(nums1, nums2, i1, j2 + <span class="number">1</span>, k - (j2 - i2 + <span class="number">1</span>))</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.41.缺失的第一个正数（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.41.%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">LeetCode.41.缺失的第一个正数（困难）</a></p>
<p>给你一个未排序的整数数组  <code>nums</code>  ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><ul>
<li>如果用哈希表记录，空间复杂度超过<code>O(1)</code>。</li>
<li>如果用排序，时间复杂度超过<code>O(n)</code> 。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>虽然不能用排序，但是可以先看正常判断过程是怎样的，看能不能换一种方式达到同样的目的。</li>
<li>如果排序完了，从左到右遍历数组，如果发现<code>nums[i] != i + 1</code>，<code>i + 1</code>就是没有出现的最小正整数。</li>
<li>换句话说有没有办法不用排序也能把数组中<code>i + 1</code>这个数放到第<code>i</code>个位置存储，这样就能判断了。</li>
<li>可以在遍历的时候直接把数字放到对应位置上，只耗费常数级别时间复杂度。</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>设<code>nums</code>数组长度为<code>n</code>，如果<code>nums[i]</code>是<code>1</code>到<code>n</code>之间的数，就把<code>nums[i]</code>放到<code>nums[i] - 1</code>的索引位置上。</p>
<p>这样从左到右遍历数组就可以知道没有出现的最小正整数是哪个了。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><ul>
<li><code>1</code>到<code>n</code>之间的数交换到数组对应索引上只需要一次交换。</li>
<li>需要遍历整个数组检查每个元素是否在对应索引位置上。</li>
</ul>
<h4 id="空间复杂度O-1"><a href="#空间复杂度O-1" class="headerlink" title="空间复杂度O(1)"></a>空间复杂度O(1)</h4><p>没有额外的空间开辟，只用了常数个变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">firstMissingPositive</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把1放到索引0</span></span><br><span class="line"><span class="comment">        把2放到索引1</span></span><br><span class="line"><span class="comment">        把3放到索引2</span></span><br><span class="line"><span class="comment">        把4放到索引3</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        如[3,4,-1,1]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] <span class="keyword">in</span> <span class="number">1.</span>.nums.size &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums.swap(i, nums[i] - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所求一定是在[1,n+1]之间</span></span><br><span class="line">        <span class="comment">// 如果是[1,2,3,4]，最小的就是n+1</span></span><br><span class="line">        <span class="comment">// 如果是[7,8,9,10]，最小的是1</span></span><br><span class="line">        <span class="keyword">return</span> nums.size + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.413.等差数列划分（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">LeetCode.413.等差数列划分（中等）</a></p>
<p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<blockquote>
<p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。</p>
</blockquote>
<p>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。<br>子数组 是数组中的一个连续序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>子数组起始索引和结束索引各不相同，可以先按结束索引给子数组分类，分析统计相同结束索引下的等差数列子数组个数，最后累加所有不同结束索引的等差数列子数组个数。</p>
<p>先看以<code>nums[i]</code>结尾的数组中等差子数组个数，可以设其值为<code>a[i]</code>。</p>
<h3 id="等差数列如何判断？"><a href="#等差数列如何判断？" class="headerlink" title="等差数列如何判断？"></a>等差数列如何判断？</h3><p><code>nums[i] - nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]</code></p>
<h3 id="如果已知a-i-1-，如何得到a-i-？即如何递推？"><a href="#如果已知a-i-1-，如何得到a-i-？即如何递推？" class="headerlink" title="如果已知a[i - 1]，如何得到a[i]？即如何递推？"></a>如果已知a[i - 1]，如何得到a[i]？即如何递推？</h3><p>分两种情况：</p>
<ol>
<li><code>nums[i]</code>不能跟前面的元素形成等差数列，那么<code>a[i] = 0</code></li>
<li><code>nums[i]</code>能跟前面的元素形成等差数列，这时候会新增几个等差数列子数组？<ol>
<li>新增长度最短的等差数列：<code>nums[i - 2]、nums[i - 1]、nums[i]</code></li>
<li>所有以<code>nums[i - 1]</code>结尾的子数组，末尾加上<code>nums[i]</code>，所形成的新数组。所有以<code>nums[i - 1]</code>结尾的子数组的个数为<code>a[i - 1]</code>。</li>
</ol>
 即<code>a[i] = a[i - 1] + 1</code></li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>a[i]</code>只跟上一个状态有关，所以可以不用数组记录每一个状态，用一个变量记录上一个状态即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> isCommonDiff = nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">val</span> cur = <span class="keyword">if</span> (isCommonDiff) pre + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum += cur</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.42.接雨水（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.42.%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode.42.接雨水（困难）</a></p>
<p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度数组height，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划，O-n-空间复杂度"><a href="#解法1：动态规划，O-n-空间复杂度" class="headerlink" title="解法1：动态规划，O(n)空间复杂度"></a>解法1：动态规划，O(n)空间复杂度</h3><h4 id="拆分问题"><a href="#拆分问题" class="headerlink" title="拆分问题"></a>拆分问题</h4><p>所有的积水由每一列的积水量累加得来。</p>
<h4 id="某一列的积水量由什么决定？"><a href="#某一列的积水量由什么决定？" class="headerlink" title="某一列的积水量由什么决定？"></a>某一列的积水量由什么决定？</h4><ol>
<li>先要看左右两边最高的柱子有多高，这决定了当前列能积多高的水，并且最多只能积到较矮的那个柱子的高度，否则水会溢出。</li>
<li>这个高度减去当前柱子高度，就是当前列可以积的水量。</li>
</ol>
<h4 id="第i列的积水量求解公式"><a href="#第i列的积水量求解公式" class="headerlink" title="第i列的积水量求解公式"></a>第i列的积水量求解公式</h4><p><code>第i列的积水量 = min(0到i - 1列中最高的柱子的高度, i + 1列到n - 1列中最高柱子的高度) - 当前列柱子高度</code></p>
<p>所以要把每一列左边和右边最高的柱子先求出来。</p>
<h4 id="第i列左边的最高的柱子怎么找？"><a href="#第i列左边的最高的柱子怎么找？" class="headerlink" title="第i列左边的最高的柱子怎么找？"></a>第i列左边的最高的柱子怎么找？</h4><p>从0到i - 1遍历一遍height数组，找最大的。<br>实际可以从左到右遍历一遍height数组，把前面记录的最大的柱子高度跟第i - 1个柱子高度比较，取较大值就行了。</p>
<h4 id="第i列右边的最高的柱子的高度怎么找？"><a href="#第i列右边的最高的柱子的高度怎么找？" class="headerlink" title="第i列右边的最高的柱子的高度怎么找？"></a>第i列右边的最高的柱子的高度怎么找？</h4><p>从右向左遍历一遍height数组，把前面记录的最大的柱子高度跟第i + 1个柱子高度做对比，取较大的。</p>
<h4 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h4><p>第1个柱子左边没有柱子，其左边最高柱子高度是0，也无法积水。<br>最后1个柱子右边没有柱子，其右边最高柱子高度是0，也无法积水。</p>
<h4 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">val</span> maxLeft = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> maxRight = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxLeft[i] = maxOf(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> (n - <span class="number">2</span>) downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxRight[i] = maxOf(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">val</span> h = maxOf(maxLeft[i], maxRight[i])</span><br><span class="line">            <span class="keyword">if</span> (h &gt; height[i]) &#123;</span><br><span class="line">                water += h - height[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：  O(n)<br>空间复杂度：  O(n)</p>
</blockquote>
<h3 id="解法2：动态规划，O-1-空间复杂度"><a href="#解法2：动态规划，O-1-空间复杂度" class="headerlink" title="解法2：动态规划，O(1)空间复杂度"></a>解法2：动态规划，O(1)空间复杂度</h3><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>求每一列的积水的时候，<code>maxLeft[i]</code>和<code>maxRight[i]</code>只用到了一次，后续不会再查询之前的值，所以可以用两个变量<code>leftMax</code>、<code>rightMax</code>代替数组。</p>
<h4 id="怎么用leftMax代替maxLeft数组？"><a href="#怎么用leftMax代替maxLeft数组？" class="headerlink" title="怎么用leftMax代替maxLeft数组？"></a>怎么用leftMax代替maxLeft数组？</h4><p><code>maxLeft</code>数组是从左到右遍历数组height求得的，在从左到右遍历height数组求第i列积水量的时候，就可以顺便计算出第i个柱子左边最高的柱子的高度，即<code>leftMax</code>。</p>
<h4 id="怎么用rightMax代替maxRight数组？"><a href="#怎么用rightMax代替maxRight数组？" class="headerlink" title="怎么用rightMax代替maxRight数组？"></a>怎么用rightMax代替maxRight数组？</h4><p><code>maxRight</code>数组是从右到左遍历数组height求得的，想办法能想办法能从右到左遍历数组就行了。</p>
<h4 id="什么时候应该从右到左遍历？什么时候从左到右？"><a href="#什么时候应该从右到左遍历？什么时候从左到右？" class="headerlink" title="什么时候应该从右到左遍历？什么时候从左到右？"></a>什么时候应该从右到左遍历？什么时候从左到右？</h4><p>当左侧的柱子高度比右侧柱子高，需要看较矮的右侧的柱子高度，才能决定某一列能积多少水，左边不管多高都不会决定能积多少水，此时应该从右到左遍历。<br>直到右侧柱子比左侧柱子高，才需要从左边到右边检查。</p>
<h4 id="初始情况是怎样的？怎么开始？"><a href="#初始情况是怎样的？怎么开始？" class="headerlink" title="初始情况是怎样的？怎么开始？"></a>初始情况是怎样的？怎么开始？</h4><p>第一列左边没有柱子，无法积水。<br>最后一列右边没有柱子，无法积水。<br>计算积水只考虑区间<code>[1, n - 2]</code>。<br>可以直接令：<br><code>leftMax = height[0]</code><br><code>rightMax = height[n - 1]</code></p>
<h4 id="具体怎么判断决定height数组的遍历方向？"><a href="#具体怎么判断决定height数组的遍历方向？" class="headerlink" title="具体怎么判断决定height数组的遍历方向？"></a>具体怎么判断决定height数组的遍历方向？</h4><ol>
<li>如果发现左边柱子比右边矮，即<code>leftMax &lt; rightMax</code>，可以先计算左边的积水，随后如果发现当前柱子高度比leftMax高，再更新leftMax。</li>
<li>如果发现右边柱子比左边矮，即<code>leftMax &gt; rightMax</code>，先计算右边的积水，随后如果发现当前柱子高度比rightMax高，再更新rightMax。</li>
</ol>
<h4 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> leftMax = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> rightMax = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> right = n - <span class="number">2</span></span><br><span class="line">        <span class="comment">// 要计算区间[1, n - 2]中所有列的积水情况，所以边界条件要包含left == right的情况，才能包含所有的情况</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftMax &gt; height[left]) &#123;</span><br><span class="line">                    water += leftMax - height[left]</span><br><span class="line">                &#125;</span><br><span class="line">                leftMax = maxOf(leftMax, height[left])</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightMax &gt; height[right]) &#123;</span><br><span class="line">                    water += rightMax - height[right]</span><br><span class="line">                &#125;</span><br><span class="line">                rightMax = maxOf(rightMax, height[right])</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度： O(n)<br>空间复杂度： O(1)</p>
</blockquote>
<h3 id="解法3：直观模拟-gt-单调栈"><a href="#解法3：直观模拟-gt-单调栈" class="headerlink" title="解法3：直观模拟 -&gt; 单调栈"></a>解法3：直观模拟 -&gt; 单调栈</h3><h4 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h4><p>要能积水，需要多根柱子形成凹槽。</p>
<h4 id="如何判断形成了凹槽？"><a href="#如何判断形成了凹槽？" class="headerlink" title="如何判断形成了凹槽？"></a>如何判断形成了凹槽？</h4><p>朝一个方向依次看柱子高低，是否能形成高、低、高的排列。<br>在已经形成下坡的情况下，一旦发现出现了上坡，就形成了凹槽，就可以计算积水量了。<br>如果发现上坡，但是前面没有下坡，无法积水。</p>
<h4 id="如何计算凹槽的积水量"><a href="#如何计算凹槽的积水量" class="headerlink" title="如何计算凹槽的积水量"></a>如何计算凹槽的积水量</h4><p>穷举出凹槽的所有可能情况，逐个分析，再归纳。<br>从最基本的情况看起，再添加有限的步骤，推导出更复杂的情况。</p>
<h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>一个凹槽最少也要3个柱子，假设3个柱子从左到右依次叫L、M、R，高度排列依次是高、低、高。<br><code>凹槽积水量 = minOf(L高度, R高度) - M高度</code></p>
<h4 id="如果有多个相同高度的M，计算方式会怎么变化？"><a href="#如果有多个相同高度的M，计算方式会怎么变化？" class="headerlink" title="如果有多个相同高度的M，计算方式会怎么变化？"></a>如果有多个相同高度的M，计算方式会怎么变化？</h4><p>就变成求矩形面积了：<br><code>凹槽积水量 = (minOf(L高度, R高度) - M高度) * L到R的距离</code><br><code>L到R的距离 = R索引 - L索引 - 1</code></p>
<h4 id="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"><a href="#如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？" class="headerlink" title="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"></a>如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？</h4><p>因为是从左到右看柱子高度的，一旦发现上坡就触发计算，所以可以先看下坡中柱子多的情况，比如：[3,2,1,4]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             #   </span><br><span class="line">       # a b #</span><br><span class="line">       # # c #</span><br><span class="line">       # # # #</span><br><span class="line">index: 0 1 2 3</span><br><span class="line"></span><br><span class="line">#表示柱子，小写字母表示积水区域</span><br></pre></td></tr></table></figure>
<p>此时积水面积不是矩形，左下方是一个阶梯型。<br>如果按之前的办法求解，从3依次回看2、1，会检测到凹槽形成，可以求得c的面积。<br>积水面积剩下a、b，可以发现刚好是一个矩形，面积为<code>(minOf(3高度, 2高度) - 1高度) * 1到3的距离</code>。<br>如果左边还有更高的柱子，会形成新的矩形，还是一样的计算过程。</p>
<h4 id="计算规律"><a href="#计算规律" class="headerlink" title="计算规律"></a>计算规律</h4><p>这种阶梯形状的积水面积，可以按行拆分为不同的矩形，先求下面的矩形面积，再求上面的矩形面积，最后累加。</p>
<p>然后再看右边柱子多的情况，得看右边形成新的凹槽才有讨论意义，那就是看一下有两个凹槽的情况会怎样。</p>
<h4 id="有两个凹槽时，计算方式会怎样变化？"><a href="#有两个凹槽时，计算方式会怎样变化？" class="headerlink" title="有两个凹槽时，计算方式会怎样变化？"></a>有两个凹槽时，计算方式会怎样变化？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   #</span><br><span class="line">       # b b b b b #</span><br><span class="line">       # a a # b b #</span><br><span class="line">       # # a # b b #</span><br><span class="line">       # # # # # # #</span><br><span class="line">index: 0 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>可以发现0到3的第一个凹槽中第0个最高的柱子会影响到4到6的第二个凹槽的积水面积的计算。<br>第一个凹槽积水量计算过后，1和2两个柱子对于第二个凹槽积水面积计算没有影响了。<br>在计算新凹槽积水量的时候，需要读取以前比较高的柱子高度，太低的柱子就可以忽略了。</p>
<h4 id="怎么获取和存储计算积水量需要的信息？"><a href="#怎么获取和存储计算积水量需要的信息？" class="headerlink" title="怎么获取和存储计算积水量需要的信息？"></a>怎么获取和存储计算积水量需要的信息？</h4><p>每个矩形面积的计算，是在发现有上坡后开始的，检测上坡就是需要知道当前柱子高度和前一个柱子高度，这个在遍历height数组时可以直接获取。</p>
<p>发现上坡后，需要知道：</p>
<ol>
<li>前面有没有形成下坡的柱子</li>
<li>柱子之间的距离</li>
<li>柱子的高度</li>
</ol>
<p>柱子距离必须要记录柱子索引位置；<br>形成下坡意思就是柱子高度要单调递减；<br>柱子高度可以根据柱子索引查询height数组；<br>访问下坡中柱子还要从右到左依次访问。</p>
<p>我们遍历检查的顺序是从左到右，访问顺序反过来，符合这个特点的数据结构就是栈。<br>入栈时保存的是柱子索引。<br>栈内柱子保持高度单调递减，不存储递增的柱子，因为对于后续计算积水没有意义。<br>当前柱子前面一个柱子也算下坡中，也存储在栈中，方便统一处理。<br>判断前面有没有形成下坡，就判断栈是否不为空。</p>
<h4 id="代码（kotlin）-2"><a href="#代码（kotlin）-2" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 栈存储形成下坡的柱子</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> height.indices) &#123;</span><br><span class="line">            <span class="comment">// 之前有下坡，现在发现上坡，形成凹槽了，可以计算积水面积了</span></span><br><span class="line">            <span class="comment">// 凹槽积水面积可能是阶梯形，所以要不停的读取前面下坡中的柱子计算矩形积水面积，这里需要一个循环</span></span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;</span><br><span class="line">                <span class="comment">// 前面凹槽中高度低的柱子要出栈，因为其对于后面凹槽的计算没有意义</span></span><br><span class="line">                <span class="keyword">val</span> cur = stack.pop()</span><br><span class="line">                <span class="comment">// 相同高度的柱子会形成矩形面积的积水，一起计算积水量</span></span><br><span class="line">                <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] == height[cur]) &#123;</span><br><span class="line">                    stack.pop()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前面有下坡，才能形成凹槽，计算积水才有意义，所以要对栈判空，有可能之前栈里只存储了一个柱子</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 现在栈顶的柱子高度是大于curHeight的，形成凹槽了</span></span><br><span class="line">                    <span class="keyword">val</span> h = minOf(height[stack.peek()], height[i]) - height[cur]</span><br><span class="line">                    <span class="keyword">val</span> w = i - stack.peek() - <span class="number">1</span></span><br><span class="line">                    water += w * h</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法4：数学拆解-gt-O-1-空间复杂度"><a href="#解法4：数学拆解-gt-O-1-空间复杂度" class="headerlink" title="解法4：数学拆解 -&gt; O(1)空间复杂度"></a>解法4：数学拆解 -&gt; O(1)空间复杂度</h3><p>从图形上看积水区域特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        b  b  b  b  b  #  a  a  #  c  c  c  c  c</span><br><span class="line">        b  b  #  a  a  #  a  a  #  a  #  c  c  c</span><br><span class="line">        #  a  #  a  a  #  a  a  #  a  #  a  #  c</span><br><span class="line">index:  0  1  2  3  4  5  6  7  8  9 10 11 12 13</span><br></pre></td></tr></table></figure>
<p>观察得知：<br><code>区间矩形面积 = a的面积 + #的面积 + b的面积 + c的面积</code></p>
<p>区间矩形面积已知。<br><code>区间矩形面积 = 区间宽度 * 最高柱子高度</code></p>
<p>#的面积已知。<br><code>#的面积 = 所有柱子高度的和</code></p>
<p><strong>有没有办法知道b和c的面积？</strong><br>b和c是阶梯状的，不好单独计算。<br>可以看其处于哪个好计算的部分，再看能不能把b和c的面积拆解出来。</p>
<ol>
<li>如果从左到右遍历height数组，是可以知道 <code>#的面积 + a的面积 + c的面积</code>，遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为left。</li>
<li>如果从右到左遍历height数组，是可以知道 <code>#的面积 + a的面积 + b的面积</code>，也是遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为right。</li>
</ol>
<p><code>left + right = #的面积 + a的面积 + (#的面积 + a的面积 + b的面积 + c的面积)</code><br>化简得：<br><code>left + right = #的面积 + a的面积 + 区间矩形面积</code><br>可得：<br><code>a的面积 = left + right - #的面积 - 区间矩形面积</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            left += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            right += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rectArea = n * maxHeight</span><br><span class="line">        <span class="keyword">val</span> pillarArea = height.sum()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left + right - rectArea - pillarArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.44.通配符匹配（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.44.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/wildcard-matching/">LeetCode.44.通配符匹配（困难）</a></p>
<p>给定一个字符串 s 和一个字符模式 p，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<blockquote>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。</p>
</blockquote>
<p>两个字符串完全匹配才算匹配成功。</p>
<span id="more"></span>

<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右遍历<code>s</code>和<code>p</code>做匹配，用双指针<code>i</code>、<code>j</code>分别做匹配。</p>
<p><code>p[j] == ?</code>时，当作普通字符跟<code>s[i]</code>匹配就好了。</p>
<p><code>p[j] == *</code>时：</p>
<ul>
<li>匹配0个字符时，让<code>s[i]</code>跟<code>p[j + 1]</code>继续匹配。</li>
<li>匹配1个或多个字符时，让<code>s[i + 1]</code>跟<code>p[j]</code>继续匹配，因为<code>*</code>可以匹配多个字符。</li>
</ul>
<p><strong>边界处理</strong></p>
<p>由于<code>*</code>是会匹配多个字符或0个字符的，如果<code>p</code>后面有很多个<code>*</code>，在<code>i</code>走到头后，<code>j</code>还没走到头的时候，对<code>p</code>尾部的<code>*</code>要做处理。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                <span class="keyword">var</span> k = j</span><br><span class="line">                <span class="keyword">while</span> (k &lt; n &amp;&amp; p[k] == <span class="string">&#x27;*&#x27;</span>) k++</span><br><span class="line">                <span class="keyword">return</span> k == n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (isCharMatch) match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) match(i, j + <span class="number">1</span>) || match(i + <span class="number">1</span>, j) <span class="comment">// 匹配s中的0个或1个字符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>自底向上动态规划</strong></p>
<p>递归已经给出了状态转移方程。</p>
<p>设<code>dp[i][j]</code>  表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前 <code>j</code> 个字符是否匹配。</p>
<ul>
<li><code>s[i - 1] == p[j - 1] || p[j - 1] == &#39;?&#39;</code>时，直接匹配上了，<code>dp[i][j] = dp[i - 1][j - 1]</code>。</li>
<li><code>p[j - 1] == &#39;*&#39;</code>时，匹配0个或1个字符，<code>dp[i][j] = dp[i - 1][j] || dp[i][j - 1]</code>。</li>
</ul>
<p>边界处理：</p>
<p>p开头都是<code>*</code>时可以匹配空字符串，要单独处理一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m + <span class="number">1</span>) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="comment">// 空字符串跟空字符串可以匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// *可以匹配空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 匹配1个字符</span></span><br><span class="line">                    s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> -&gt; dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment">// *匹配0个字符或1个字符</span></span><br><span class="line">                    p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> -&gt; dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.45.跳跃游戏 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/jump-game-ii/">LeetCode.45.跳跃游戏 II（中等）</a></p>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>不知道怎么办，先模拟一遍跳跃过程。<br>假设<code>nums[0]</code>是3，那么可以选择跳到1、2、3的位置。<br>假设<code>nums[1]</code>是1、<code>nums[2]</code>是10、<code>nums[3]</code>是3，那么肯定选择先跳到2的位置，再跳10个长度，这样跳跃次数最少。<br>后面再跳跃还是重复这个同样的选择过程。</p>
<h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><p>可以得知下一步的跳跃选择，应该在当前可以跳跃到的范围内找一个最远的长度来跳。就是贪心选择，从局部最优得出全局最优。</p>
<h3 id="怎么找最远可以跳跃的长度？"><a href="#怎么找最远可以跳跃的长度？" class="headerlink" title="怎么找最远可以跳跃的长度？"></a>怎么找最远可以跳跃的长度？</h3><p>只有一个个遍历数组，漏一个都不行</p>
<h3 id="什么时候计数跳跃次数？"><a href="#什么时候计数跳跃次数？" class="headerlink" title="什么时候计数跳跃次数？"></a>什么时候计数跳跃次数？</h3><p>因为会在可以跳跃到的范围内找到一个最远的长度来跳，也就是说这个范围内只会跳一次。那就顺便在遍历数组的时候等到达了跳跃范围的边界就可以计数跳跃次数了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxNext = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            maxNext = maxOf(maxNext, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxNext</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.5.最长回文子串（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode.5.最长回文子串（中等）</a></p>
<p>给你一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h3><p>最值问题考虑动态规划，先拆分大问题为子问题+有限步骤。</p>
<p>判断一个字符串是不是回文串，先看字符串两端字符是否相同，然后去除首尾两端字符后的剩余字符串如果是回文串，整个字符串就是回文串。<br>剩余字符串是不是回文串判断方法是一样的。<br>整个判断可以递归进行，符合最优子结构，无后效性。<br>重叠子问题也有，长度大的回文串是由长度小的回文串推导而来，而长度相同的字符串有很多，会有重复判断。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文串。<br><code>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>
<p><strong>边界处理</strong><br>字符串<code>s</code>长度只有1时，是对称的，是回文串，<code>dp[i][j] = 1</code>。<br>字符串<code>s</code>为2时，去除首尾字符后没有子串了，只需要判断首尾字符是否相同即可，<code>dp[i][j] = s[i] == s[j]</code>。</p>
<p><strong>结果如何求解</strong><br>要遍历所有长度的子字符串，寻找有没有回文串，并记录最大长度的回文串。<br>长度相同的子字符串有很多，都要列举出来。</p>
<p><strong>复杂度</strong><br>设字符串长度为n。<br>穷举所有长度子串需要O(n)时间。<br>穷举每个长度的可能的子串也需要O(n)时间。<br>总的时间复杂度$O(n^2)$。</p>
<p>用二维数组记录了所有子串的是否是回文串状态，空间复杂度$O(n^2)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; BooleanArray(n) &#123; j -&gt; i == j &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 穷举子串左端起点</span></span><br><span class="line">            <span class="keyword">for</span> (l <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="comment">// 子串右端终点</span></span><br><span class="line">                <span class="keyword">val</span> r = l + len - <span class="number">1</span></span><br><span class="line">                dp[l][r] = <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">else</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> (dp[l][r] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len</span><br><span class="line">                    maxLeft = l</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLeft, maxLeft + maxLen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：中心扩散"><a href="#解法2：中心扩散" class="headerlink" title="解法2：中心扩散"></a>解法2：中心扩散</h3><p>解法1动态规划是从外向里判断的，也可以从里向外扩散判断。</p>
<p>穷举所有所有可能的中心点，向左右两端扩散，如果左右两端字符相同，说明能构成回文串，再继续扩散查看。</p>
<p>但是回文的中心点有两种可能。<br>回文串字符数是奇数，中心只有一个字符。<br>回文串字符数是偶数，中心有两个字符。</p>
<p>不知道哪种中心扩散生成的回文串长度最大，那就两个都试一下，取最大值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">centerSpread</span><span class="params">(l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">var</span> left = l</span><br><span class="line">            <span class="keyword">var</span> right = r</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] != s[right]) <span class="keyword">break</span></span><br><span class="line">                left--</span><br><span class="line">                right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里扩散完发现的回文串索引范围是[left + 1, right - 1]</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(left + <span class="number">1</span>, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> odd = centerSpread(i, i)</span><br><span class="line">            <span class="keyword">val</span> even = centerSpread(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> longer = <span class="keyword">if</span> (odd.length &gt; even.length) odd <span class="keyword">else</span> even</span><br><span class="line">            <span class="keyword">if</span> (longer.length &gt; longest.length) longest = longer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong><br>穷举中心点，需要遍历所有元素，消耗时间$O(n)$。<br>从中心点向两边扩散，最多扩展到整个字符串，所以最大消耗时间$O(n)$。<br>总体时间复杂度$O(n^2)$。</p>
<p>没有占用额外存储空间，空间复杂度$O(1)$。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.509. 斐波那契数（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number">LeetCode.509. 斐波那契数（简单）</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<blockquote>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
</blockquote>
<p>给你 n ，请计算 F(n) 。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h4><p>根据定义，可以直接写出递归式，最简单。<br>但是递归会有很多重叠子问题，重复计算很耗时。</p>
<p>可以想象出函数调用的递归树，F(n)总共调用次数就是树的节点数。<br>从F(n)到F(n - 1)一直分解到F(1)，这样逐一递减，一共n层递归树。<br>第i层(从上到下数)节点数为2的i次方，递归树总节点数为 2的0次方 + 2的1次方 + 2的2次方 + …… + 2的n - 1次方，等比数列求和为2的n次方。递归求解的时间复杂度为O(2^n)。</p>
<p>把会重复使用到的计算结果记下来，每一项只计算一次，时间复杂度降低为线性。<br>自上而下做动态规划。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            memo[n] = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：自下而上的动态规划"><a href="#解法2：自下而上的动态规划" class="headerlink" title="解法2：自下而上的动态规划"></a>解法2：自下而上的动态规划</h4><p>直接根据公式递推</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            cur = prepre + pre</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.51.N皇后（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.51.N%E7%9A%87%E5%90%8E%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">LeetCode.51.N皇后（困难）</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>提示：</p>
<ul>
<li>  <code>1 &lt;= n &lt;= 9</code></li>
<li>  皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul>
<li>尝试所有摆放的可能，用回溯。</li>
<li>每一行都放一个皇后，需要遍历所有行。</li>
<li>但是每一行放哪一列不确定，就遍历所有的列，都尝试一遍。</li>
<li>所有行放完了，完成了一种放置结果，添加到结果集。</li>
</ul>
<p><strong>限制条件如何检查？</strong></p>
<p>因为是从上到下放皇后的，当前行肯定没有其他皇后，只需检查当前列、左上方斜线、右上方斜线有没有放置过皇后，若有有放置过，当前行的当前列不能选择，得选择下一列。</p>
<p>标准的dfs，时间复杂度O(n!)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> result: MutableList&lt;List&lt;String&gt;&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> grid: Array&lt;CharArray&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理解题意是关键</span></span><br><span class="line"><span class="comment">     * 期盼上每一行每一列都只能有1个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solveNQueens</span><span class="params">(n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        grid = Array(n) &#123; CharArray(n) &#123; <span class="string">&#x27;.&#x27;</span> &#125; &#125;</span><br><span class="line">        result = mutableListOf()</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(r: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = grid.size</span><br><span class="line">        <span class="comment">// 所有的行选择完了，n个皇后也摆放完了，可以添加结果了</span></span><br><span class="line">        <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">            <span class="keyword">val</span> solution = grid.map &#123; row -&gt; row.joinToString(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">            result.add(solution)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前后的每一列都可以做出选择</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(r, c)) <span class="keyword">continue</span></span><br><span class="line">            grid[r][c] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            backtrack(r + <span class="number">1</span>)</span><br><span class="line">            grid[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = grid.size</span><br><span class="line">        <span class="comment">// 检查第c列有没有皇后，有皇后了就不能选这列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][c] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 斜着的也能走，要考虑斜着的四个方向，但其实我们选择的时候是从上往下选择的，所以只要考虑左上和右上的方向有没有皇后</span></span><br><span class="line">        <span class="comment">// 检查左上方有没有皇后</span></span><br><span class="line">        <span class="keyword">var</span> i = r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> j = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            i--</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方有没有皇后</span></span><br><span class="line">        i = r - <span class="number">1</span></span><br><span class="line">        j = c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            i--</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.516.最长回文子序列（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">LeetCode.516.最长回文子序列（中等）</a></p>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回文子序列的定义一定要搞清，不然不知道怎么求解。</p>
<p>根据示例，一个回文子序列是要求首尾字符是相同的，中间可以不是回文子串，但是求解序列长度其实是要删除不能构成回文子串的字符，然后再看剩下能构成回文子串的字符数是多少。</p>
<p><strong>那么什么情况下不能构成回文串？</strong><br>一个字符串首尾字符不相同，一定不是回文串。</p>
<p><strong>那应该删除首尾哪一个字符？</strong><br>因为要求最长的回文子序列，删除哪个字符后能够得到最长的回文子序列就删除哪个，但是不知道是哪个是最长的，所以都分别删除试一下，然后取最大值。</p>
<p><strong>删除字符后怎么办？</strong><br>删除字符后剩余字符串判断是不是回文子序列，还是一样的方法，所以可以递归进行。</p>
<p><strong>递归处理</strong><br>先看字符串两端字符是否相同：</p>
<ul>
<li>如果相同，可以算作回文子序列了，长度加2，但是总长度多少还得看去除首尾字符后剩余的字符串的回文子序列长度。</li>
<li>如果不相同，删除最左边字符，或者删除最右边字符，再看剩下的字符串的回文子序列长度。</li>
</ul>
<p><strong>边界</strong><br>递归一直在缩减字符串。<br>如果字符串是偶数个字符，每次两个字符的删减，最后肯定只剩两个字符，再缩减，会出现左指针索引大于指针右索引，直接返回0就行。<br>如果字符串一直一个个的缩减，最后左指针和右指针都会指向一个字符，一个字符是回文子串，长度返回1。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">	                <span class="comment">// 删除最左边字符</span></span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    <span class="comment">// 删除最右边字符</span></span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现递归是存在很多重叠子问题的，因为长的序列要依赖短的序列求解，比较短的序列结果就要反复被递归，这增加了耗时，所以给中间计算过的状态记录一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">`            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            memo[i][j] = <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>状态转移方程：<br>设<code>dp[i][j]</code>为字符串<code>s[i, j]</code>最长回文子序列长度。<br><code>s[i] == s[j]</code>时，<code>dp[i][j] = 2 + dp[i + 1][j - 1]</code><br><code>s[i] != s[j]</code>时，<code>dp[i][j] = maxOf(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>注意递推顺序，<code>i</code>是从<code>i + 1</code>递推来的，所以要从大到小遍历。<br><code>j</code>依赖<code>j - 1</code>，所以<code>j</code>是从小到大遍历。</p>
<p>由于<code>s[i, j]</code>要构成字符串，所以<code>i &lt;= j &lt; n</code>。<br><code>i == j</code>时，<code>dp[i][j] = 1</code>，可以单独处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; IntArray(n) &#123; j -&gt; <span class="keyword">if</span> (i == j) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (s[i] == s[j]) <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n^2)<br>空间复杂度O(n^2)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.518.零钱兑换 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a></p>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>划分子问题</strong><br>设<code>dp[i]</code>为凑成总金额<code>i</code>的硬币组合数。<br>假设<code>coins = [1, 2, 5]</code>，那么<code>dp[i]</code>其实就是硬币总额<code>i - 1</code>、<code>i - 2</code>、<code>i - 5</code>子问题之和。</p>
<p><strong>状态转移方程</strong><br><code>for (coin: coins) dp[i] += dp[i - coin]</code></p>
<p><strong>注意点</strong><br>所求的是硬币的组合数，不是排列数。<br>比如<code>coins = [1, 2]</code>，<code>amount = 3</code>，<code>1 + 2</code>和<code>2 + 1</code>是同一种组合，但是两个排列。<br>如果我们是先确定一个<code>amount</code>，再去用所有硬币去凑，就会凑出来不同的排列。<br>所以要锁定硬币使用的顺序，同一个金额下就不会有不同顺序的硬币的使用情况了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">change</span><span class="params">(amount: <span class="type">Int</span>, coins: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(amount + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (a <span class="keyword">in</span> coin..amount) &#123;</span><br><span class="line">                dp[a] += dp[a - coin]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.52.N皇后 II（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.52.N%E7%9A%87%E5%90%8E%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-queens-ii/">LeetCode.52.N皇后 II（困难）</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<span id="more"></span>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 9</code></li>
<li>  皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最笨的办法就跟求出N皇后所有选择方案，取选择方案的个数，但这样空间复杂度大，本题只要求方案数，我们得看看空间复杂度能不能降低。</p>
<h3 id="N皇后问题的求解步骤"><a href="#N皇后问题的求解步骤" class="headerlink" title="N皇后问题的求解步骤"></a>N皇后问题的求解步骤</h3><ol>
<li>遍历先所有行</li>
<li>每一行遍历所有列</li>
<li>判断当前列可以放置，进行放置</li>
<li>然后再深度优先搜索，继续放置</li>
<li>直到放置完最后一行</li>
</ol>
<h3 id="什么情况下需要占用额外空间？"><a href="#什么情况下需要占用额外空间？" class="headerlink" title="什么情况下需要占用额外空间？"></a>什么情况下需要占用额外空间？</h3><p>在判断当前行当前列是不是可以放置皇后这个问题上，可能会需要一定的空间记录之前放置过皇后的情况。</p>
<h3 id="怎么判断某一列之前是否已经放置过皇后了？"><a href="#怎么判断某一列之前是否已经放置过皇后了？" class="headerlink" title="怎么判断某一列之前是否已经放置过皇后了？"></a>怎么判断某一列之前是否已经放置过皇后了？</h3><p>如果在某一列放置过皇后之后，就把这一列记录下来，到下一行再遍历所有列进行列选择时，就可以查询之前哪些列是放过的，放过的就不在这一列放了。</p>
<p>假设列总数是n，最多也就记录n个列有没有被放过皇后，可以用一个数组保存。</p>
<h3 id="怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？"><a href="#怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？" class="headerlink" title="怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？"></a>怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？</h3><p>如果从上往下斜着看，当在上一行第x列放置过皇后之后，我们可以知道下一行的第x + 1列和第x - 1列肯定也不能再放皇后了，因为都处于斜线位置上。</p>
<p>所以在遍历下一行的时候可以直接排除第x + 1列和第x - 1列，就相当于排除了斜线上不能放的位置。</p>
<p>但是到再下一行时，斜线会蔓延到第x + 2列和第x - 2列不可以放皇后。</p>
<p>也就是说斜线上禁止放皇后的位置随着行的增大而平移，位置需要随行保持更新，而且两个方向的斜线更新的方向也不一样。</p>
<p>所以这里需要两个数组存储两个方向斜线列的变化，每增加一行，数组值都要往左和往右移动一个位置。</p>
<h3 id="如何优化空间复杂度？"><a href="#如何优化空间复杂度？" class="headerlink" title="如何优化空间复杂度？"></a>如何优化空间复杂度？</h3><p>使用数组记录状态会占用O(n)的空间复杂度。</p>
<p>可以注意到<code>1 &lt;= n &lt;= 9</code>，能够使用二进制的位来记录状态，这样就节省了数组的空间开销，每个状态各自需要一个整数就可以判断，整数总共有32位，足以容纳9个状态值。</p>
<h3 id="怎么用二进制记录三种状态？"><a href="#怎么用二进制记录三种状态？" class="headerlink" title="怎么用二进制记录三种状态？"></a>怎么用二进制记录三种状态？</h3><ul>
<li>用整数变量<code>c</code>的每一位是否是1，表示某一列是否已经已经放过皇后了</li>
<li>用整数变量<code>ld</code>的每一位是否是1，表示某一列的右上角是否已经已经放过皇后了</li>
<li>用整数变量<code>rd</code>的每一位是否是1，表示某一列的左上角是否已经已经放过皇后了</li>
</ul>
<h3 id="怎么知道哪些列还能放皇后？"><a href="#怎么知道哪些列还能放皇后？" class="headerlink" title="怎么知道哪些列还能放皇后？"></a>怎么知道哪些列还能放皇后？</h3><p>具体到某一行时，需要知道哪些列还能放皇后。</p>
<p>哪些列不能放皇后，我们求<code>c</code>、<code>ld</code>、<code>rd</code>三个变量的或的结果<code>q</code>就知道了。</p>
<p><code>q</code>的二进制中所有为1的位就是已经放过皇后的，不能再放了。</p>
<p>找<code>q</code>中所有为0的位就是可以放皇后的位置；位数不超过n。</p>
<p>0不方便找，也不方便判断，1方便判断，所以可以反过来，把<code>q</code>取反，这样所有为1的位置都是可以放皇后的，但是高位会有多余的1，所以再跟n个1做与操作，把高位多余的1给截取掉。</p>
<p>n个1怎么快速求？可以把1左移n位，再减1。模拟一下就知道。</p>
<p>用<code>bits</code>变量来存储 <code>q</code>取反再跟n个1与操作的结果，<code>bits</code>的某一位为1表示这一位可以放皇后。</p>
<h3 id="怎么遍历所有可以放皇后的列？"><a href="#怎么遍历所有可以放皇后的列？" class="headerlink" title="怎么遍历所有可以放皇后的列？"></a>怎么遍历所有可以放皇后的列？</h3><ul>
<li>依次取<code>bits</code>每一位的1。</li>
<li>遍历何时结束？可以把访问过的1都消除掉，bits为0说明遍历完所有的1了。同时把访问过的1消除掉，也方便取下一个1。</li>
</ul>
<h4 id="怎么依次取bits每一位的1？"><a href="#怎么依次取bits每一位的1？" class="headerlink" title="怎么依次取bits每一位的1？"></a>怎么依次取<code>bits</code>每一位的1？</h4><p>可以想办法通过位运算快速求解，充分发挥二进制的优势。</p>
<p>可以每次取最低位的1，我们只要构造一个二进制数，跟bits前面的所有位都相反，就在最后一个1的位置跟bits一样，这样两者做一下与操作就可以得到最低位1。</p>
<p>取反可以想到反码，如果对bits取反，最低位1变成0，接着后面全部都是1，我们可以给反码加1，就可以把最低位的0和1变回来。</p>
<p>反码加1就是补码，所以取<code>-bits</code>跟<code>bits</code>做与操作，得到<code>bits</code>最低位的1。</p>
<h4 id="怎么消除最低位的1？"><a href="#怎么消除最低位的1？" class="headerlink" title="怎么消除最低位的1？"></a>怎么消除最低位的1？</h4><p><code>bits - 1</code>后，最低位1就没了，但是更低位本来全部是0现在都变成1，再跟<code>bits</code>与一下，它们的高位都相同，而<code>bits</code>低位都是0，这样就把<code>bit</code>最低位的1给消除了。</p>
<h4 id="怎么更新c、ld、rd？"><a href="#怎么更新c、ld、rd？" class="headerlink" title="怎么更新c、ld、rd？"></a>怎么更新<code>c</code>、<code>ld</code>、<code>rd</code>？</h4><p>取出的<code>bits</code>的最低位的1为<code>pick</code>。</p>
<p><code>pick</code>二进制中的1代表的列是不能被下一行再访问了，<code>c</code>要多增加这一列的1，<code>c = c or pick</code> 。</p>
<p><code>pick</code>二进制中的1代表的列的左下方的列在下一行是不能被访问的，并且<code>ld</code>中所有不能访问的列都要左移1位，正好可以用移位运算符很方便的做移动，<code>ld = (ld or pick) shl 1</code>。</p>
<p><code>pick</code>二进制中的1代表的列的右下方的列在下一行是不能被访问的，并且<code>rd</code>中所有不能访问的列都要右移1位，正好可以用移位运算符很方便的做移动，<code>rd = (rd or pick) shr 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">totalNQueens</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(row: <span class="type">Int</span>, c: <span class="type">Int</span>, ld: <span class="type">Int</span>, rd: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> bits = (c or ld or rd).inv() and ((<span class="number">1</span> shl n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (bits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> pick = bits and -bits</span><br><span class="line">                find(row + <span class="number">1</span>, c or pick, (pick or ld) shl <span class="number">1</span>, (pick or rd) shr <span class="number">1</span>)</span><br><span class="line">                bits = bits and (bits - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>回溯</tag>
        <tag>二进制</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.53.最大子序和（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode.53.最大子序和（简单）</a></p>
<p>给定一个整数数组  <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最值问题考虑用动态规划，从某个状态倒推，拆解为上一个状态+所有可能的最小步骤，看是否符合动态规划的条件。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>设<code>dp[i]</code>为以<code>nums[i]</code>为结尾的连续子数组的最大和。</p>
<p>求<code>dp[i]</code>肯定是要加上<code>nums[i]</code>的，此时合成子数组有两种选择：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>和前面的连续子数组合并</li>
</ol>
<p>如何选择？</p>
<ol>
<li>如果 <code>dp[i - 1] + nums[i] &gt; nums[i]</code>，那么<code>dp[i] = dp[i - 1] + nums[i]</code>。</li>
<li>如果 <code>dp[i - 1] + nums[i] &lt; nums[i]</code>，那<code>nums[i]</code>单独成子数组后和反而更大，<code>dp[i] = nums[i]</code>。</li>
</ol>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i] = max(dp[i - 1] + nums[i], nums[i]) </code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p><code>dp[0]</code>就是<code>nums[0]</code>本身了，只包含自己的子数组。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只依赖于前一项的递推，可以不用数组，只用一个变量记录上一个值。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            <span class="keyword">val</span> cur = maxOf(pre + num, num)</span><br><span class="line">            maxSum = maxOf(maxSum, cur)</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.55.跳跃游戏（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">LeetCode.55.跳跃游戏（中等）</a></p>
<p>给定一个非负整数数组 <code>nums</code>  ，你最初位于数组的  <strong>第一个下标</strong>  。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="到达最后一个下标需要什么条件？"><a href="#到达最后一个下标需要什么条件？" class="headerlink" title="到达最后一个下标需要什么条件？"></a>到达最后一个下标需要什么条件？</h3><p>跳过的长度要大于等于数组长度</p>
<h3 id="什么情况下不能到达最后一个下标？"><a href="#什么情况下不能到达最后一个下标？" class="headerlink" title="什么情况下不能到达最后一个下标？"></a>什么情况下不能到达最后一个下标？</h3><p>到达某个位置后，不继续往后跳了，比如到了某个位置，可跳跃长度为0，就不会往后跳了，跳到最后一个位置就无从谈起。</p>
<h3 id="我怎么知道总共跳跃的长度有没有超过数组的长度？"><a href="#我怎么知道总共跳跃的长度有没有超过数组的长度？" class="headerlink" title="我怎么知道总共跳跃的长度有没有超过数组的长度？"></a>我怎么知道总共跳跃的长度有没有超过数组的长度？</h3><p>只能从头到尾遍历数组，记录最多能跳多远，会不会在某个位置停止跳跃，如果不会停止跳跃，肯定能跳到终点。</p>
<h3 id="停止跳跃有什么特征？怎么判断有没有停止跳跃？"><a href="#停止跳跃有什么特征？怎么判断有没有停止跳跃？" class="headerlink" title="停止跳跃有什么特征？怎么判断有没有停止跳跃？"></a>停止跳跃有什么特征？怎么判断有没有停止跳跃？</h3><p>如果记录最远能够跳到的位置，停止跳跃的时候，记录的位置不会再改变了。<br>在遍历数组检查最多能跳多远的时候，如果发现数组当前遍历的下标超过记录的最远跳过的位置，说明跳跃停止了。因为遍历数组相当于每次跳1步，是最低速度，如果能持续跳跃，不会低于这个速度，最低也是持平。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            j = maxOf(j, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums.size) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.62.不同路径（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/unique-paths/">LeetCode.62.不同路径（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li>从上边<code>[m - 1, n]</code>来</li>
<li>从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？<br>按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为整个路径是要从上到下的，从下面上来，最后还是要下去，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为整个路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。<br>而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径数，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径数时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径数。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，达到的路径数量就是1。<br>第一行所有格子没有上面，都只能从左边过来，路径数都是1。<br>第一列所有格子没有左边，都只能从上边过来，路径数都是1。</p>
<p><strong>复杂度</strong><br>需要查看所有格子的情况来寻找路径数，所以要遍历所有网格，时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>记录所有达到所有格子的路径数，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径数推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径数？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径数，所以记录一行是必须的。<br>读取上一行格子的路径数，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.63.不同路径 II（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode.63.不同路径 II（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有障碍物说明不能达到，换句话说，到达障碍物格子的路径数为0。</p>
<p>设<code>dp[i][j]</code>为到达<code>[i, j]</code>格的路径数。</p>
<p><strong>状态转移方程</strong></p>
<ol>
<li><code>[i, j]</code>没有障碍物，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</li>
<li><code>[i, j]</code>有障碍物，<code>dp[i][j] = 0</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，下面格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br>只关心左边和上边的格子的路径数，不需要记录所有行的数据，只需要记录一行。<br>能不能只记录左边和上边，用两个变量完成？<br>不能，终点在最右边，路径可能从最左边过来，所以要记录一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment">// dp[j]: 达到上方格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]: 达到左方格子的路径数</span></span><br><span class="line">                <span class="keyword">else</span> dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.64.最小路径和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">LeetCode.64.最小路径和（中等）</a></p>
<p>给定一个包含非负整数的  <code>_m_ x _n_</code> 网格 <code>grid</code>  ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li> 从上边<code>[m - 1, n]</code>来</li>
<li> 从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？  按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为从起点到终点的路径是要从上到下的，如果从下面上来最后还是要下去，路径和增大了，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为起点到终点的路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。  而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径和，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径和时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径和。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，路径和就是当前元素值。<br>第一行所有格子没有上面，都只能从左边过来，路径和从左边累加。<br>第一列所有格子没有左边，都只能从上边过来，路径和从右边累加。</p>
<p><strong>复杂度</strong><br>要遍历所有网格，才能找到最少路径和，所以时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>如果记录达到所有格子的路径和，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + minOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径和推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径和？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径和，所以记录一行是必须的。  读取上一行格子的路径和，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径和。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 第一行不能从上边过来，特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) grid[i][j] + dp[j]</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] + minOf(dp[j], dp[j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.65.有效数字（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.65.%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/valid-number/">LeetCode.65.有效数字（困难）</a></p>
<span id="more"></span>

<p>有效数字（按顺序）可以分成以下几个部分：</p>
<ul>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
</ul>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：<ul>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ul>
</li>
</ul>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
<p>部分有效数字列举如下：</p>
<ul>
<li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li>
</ul>
<p>部分无效数字列举如下：</p>
<ul>
<li>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</li>
</ul>
<p>给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 20</code></li>
<li>  <code>s</code>  仅含英文字母（大写和小写），数字（<code>0-9</code>），加号  <code>&#39;+&#39;</code>  ，减号  <code>&#39;-&#39;</code>  ，或者点  <code>&#39;.&#39;</code>  。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：正则表达式"><a href="#解法1：正则表达式" class="headerlink" title="解法1：正则表达式"></a>解法1：正则表达式</h2><p>检查字符串是不是符合某种规则，用正则表达式是最直接的想法。</p>
<h3 id="怎么表示一个整数？"><a href="#怎么表示一个整数？" class="headerlink" title="怎么表示一个整数？"></a>怎么表示一个整数？</h3><p><code>[+-]?\\d+</code></p>
<ul>
<li><code>[+-]?</code>满足整数条件1：<code>（可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）</code>。</li>
<li><code>\\d+</code>满足整数条件2：<code>至少一位数字</code>。</li>
</ul>
<h3 id="怎么表示一个小数？"><a href="#怎么表示一个小数？" class="headerlink" title="怎么表示一个小数？"></a>怎么表示一个小数？</h3><p><code>[+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)</code></p>
<ul>
<li><code>[+-]?</code>满足条件<code>（可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）</code>。</li>
<li><code>(\\d+\\.)</code>满足条件<code>至少一位数字，后面跟着一个点 &#39;.&#39;</code>。</li>
<li><code>(\\d+\\.\\d+)</code>    满足条件<code>至少一位数字，后面跟着一个点 &#39;.&#39; ，后面再跟着至少一位数字</code>。</li>
<li><code>(\\.\\d+)</code>满足条件<code>一个点 &#39;.&#39; ，后面跟着至少一位数字</code>。</li>
</ul>
<h3 id="怎么表示科学计数法？"><a href="#怎么表示科学计数法？" class="headerlink" title="怎么表示科学计数法？"></a>怎么表示科学计数法？</h3><p>一个整数或者小数 + <code>([eE][+-]?\\d+) </code></p>
<p><code>([eE][+-]?\\d+) </code>满足条件<code>一个 &#39;e&#39; 或 &#39;E&#39; ，后面跟着一个 整数</code>，根据示例，e后面的整数前面可以带正负号。</p>
<h3 id="满足题意的正则表达式？"><a href="#满足题意的正则表达式？" class="headerlink" title="满足题意的正则表达式？"></a>满足题意的正则表达式？</h3><p>把上面三个综合起来，就能得到最终的表达式：</p>
<p><code>([+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)|(\\d+)))([eE][+-]?\\d+)?</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> regex = Regex(<span class="string">&quot;([+-]?(\\d+(\\.\\d*)?|(\\.\\d+)))([eE][+-]?\\d+)?&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> regex.matches(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：模拟"><a href="#解法2：模拟" class="headerlink" title="解法2：模拟"></a>解法2：模拟</h2><p>暴力模拟逻辑会比较乱，可以做一个简单的分类，这样相对会比较清晰。</p>
<p>有效数字有三种可能的字符串形式：</p>
<ol>
<li>整数</li>
<li>小数</li>
<li>科学计数</li>
</ol>
<p>针对三种形式的数字，分别写一个校验器做判断即可。</p>
<p>在科学计数的校验器中，可以去除科学计数的特征字符，再复用整数校验器和小数校验器的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> validator = Decorator()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validator.validate(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> s.all &#123; it.isDigit() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dotIndex = s.indexOf(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> intPart = s.substring(<span class="number">0</span>, dotIndex)</span><br><span class="line">        <span class="keyword">val</span> decimalPart = s.substring(dotIndex + <span class="number">1</span>, s.length)</span><br><span class="line">        <span class="keyword">return</span> intPart.all &#123; it.isDigit() &#125; &amp;&amp; decimalPart.all &#123; it.isDigit() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScienceFormatValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> floatValidator = FloatValidator()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> intValidator = IntValidator()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> eIndex = s.indexOf(<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (eIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (eIndex == s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> left = s.substring(<span class="number">0</span>, eIndex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> right = s.substring(eIndex + <span class="number">1</span>, s.length)</span><br><span class="line">        <span class="keyword">if</span> (right[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || right[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            right = right.substring(<span class="number">1</span>, right.length)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (intValidator.validate(left) || floatValidator.validate(left)) &amp;&amp; intValidator.validate(right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> validators = listOf(</span><br><span class="line">            IntValidator(),</span><br><span class="line">            FloatValidator(),</span><br><span class="line">            ScienceFormatValidator()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> str = s.trimSpaceAndSign()</span><br><span class="line">        validators.forEach &#123; validator -&gt;</span><br><span class="line">            <span class="keyword">if</span> (validator.validate(str)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">trimSpaceAndSign</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> s = trim()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (s.isNotEmpty() &amp;&amp; (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">        s.substring(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：DFA"><a href="#解法3：DFA" class="headerlink" title="解法3：DFA"></a>解法3：DFA</h2><p>字符匹配规则的过程，可以看作是状态转移的过程，字符作为输入，即状态改变的条件，让一个状态产生转移另一个状态，如果能转换到最终状态，说明字符串是匹配的。</p>
<p>可以用状态机来解决字符串匹配。这里使用DFA，即确定有穷状态机，对每个状态和输入符号可以得到下一个唯一到状态。</p>
<p>那么问题就转变为：</p>
<ol>
<li>有哪些状态？</li>
<li>初始状态是什么？</li>
<li>结束状态是什么？</li>
<li>输入有哪些？</li>
<li>状态转移失败怎么办？</li>
<li>状态转移的所有情况有哪些？</li>
</ol>
<h3 id="有哪些状态？"><a href="#有哪些状态？" class="headerlink" title="有哪些状态？"></a>有哪些状态？</h3><p>我们把所有正确的、互相独立的状态列出来，然后看输入什么字符可以从一个状态转换到另一个状态，就构建出了状态机。</p>
<p>可以把 当前处理到有效数字字符串的哪个部分 当作状态，所有的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.空字符串</span><br><span class="line">1.符号位</span><br><span class="line">2.整数部分数字</span><br><span class="line">3.左侧有整数的小数点</span><br><span class="line">4.左侧无整数的小数点</span><br><span class="line">5.小数部分的数字</span><br><span class="line">6.指数字符e或E</span><br><span class="line">7.指数后面的符号位</span><br><span class="line">8.指数后面的整数部分</span><br></pre></td></tr></table></figure>

<h3 id="初始状态是什么？"><a href="#初始状态是什么？" class="headerlink" title="初始状态是什么？"></a>初始状态是什么？</h3><p>0.空字符串</p>
<h3 id="结束状态是什么？"><a href="#结束状态是什么？" class="headerlink" title="结束状态是什么？"></a>结束状态是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.整数部分数字</span><br><span class="line">3.左侧有整数的小数点</span><br><span class="line">5.小数部分的数字</span><br><span class="line">8.指数后面的整数部分</span><br></pre></td></tr></table></figure>

<h3 id="输入有哪些？"><a href="#输入有哪些？" class="headerlink" title="输入有哪些？"></a>输入有哪些？</h3><ul>
<li>空格</li>
<li>正负号  <code>+</code>  或<code>-</code>  </li>
<li>数字<code>0-9</code></li>
<li>点  <code>.</code>  </li>
<li>英文字母<code>e</code>或<code>E</code></li>
<li>其他字符</li>
</ul>
<h3 id="状态转移失败怎么办？"><a href="#状态转移失败怎么办？" class="headerlink" title="状态转移失败怎么办？"></a>状态转移失败怎么办？</h3><p>如果对于某个输入不能转换到下一个状态，应该提前终止匹配。</p>
<h3 id="状态转移的所有情况有哪些？"><a href="#状态转移的所有情况有哪些？" class="headerlink" title="状态转移的所有情况有哪些？"></a>状态转移的所有情况有哪些？</h3><p>可以用状态表描述所有状态转移的情况，结合规则和示例定义所有状态的转移情况。</p>
<p>如果状态不可转移，用-1表示。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>空格</th>
<th>+/-</th>
<th>0-9</th>
<th>.</th>
<th>e/E</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>0.空字符串</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>1.符号位</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>2.整数部分数字</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>3.左侧有整数的小数点</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>4.左侧无整数的小数点</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>5.小数部分的数字</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>6.指数字符e或E</td>
<td>-1</td>
<td>7</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>7.指数后面的符号位</td>
<td>-1</td>
<td>-1</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>8.指数后面的整数部分</td>
<td>-1</td>
<td>-1</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="状态表怎么存储？"><a href="#状态表怎么存储？" class="headerlink" title="状态表怎么存储？"></a>状态表怎么存储？</h3><ul>
<li>二维数组。</li>
<li>哈希表嵌套，不存储-1的状态，这样还可以节约一点空间。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h4><p>字符串长度为n，需要遍历字符串所有字符。</p>
<p>状态转移查表只需要O(1)时间。</p>
<h4 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O(1)"></a>空间复杂度：O(1)</h4><p>虽然状态表占用一定的空间，但跟字符串长度无关，并且大小固定，所以可以认为是常数空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      |       状态        |空格|+/-|0-9|. |e/E|其他|</span></span><br><span class="line"><span class="comment">     *      | -----------------|----|---|---|--|---|--|</span></span><br><span class="line"><span class="comment">     *      |0.空字符串          |0  |1  |2  |4  |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |1.符号位            |-1 |-1 |2  |4 |-1  |-1|</span></span><br><span class="line"><span class="comment">     *      |2.整数部分数字       |-1 |-1 |2  |3  |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |3.左侧有整数的小数点  |-1 |-1 |5  |-1 |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |4.左侧无整数的小数点  |-1 |-1 |5  |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |5.小数部分的数字     |-1 |-1 |5  |-1 |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |6.指数字符e或E       |-1 |7 |8  |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |7.指数后面的符号位    |-1 |-1 |8 |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |8.指数后面的整数部分  |-1 |-1 |8 |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table = arrayOf(</span><br><span class="line">        intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> finalState = arrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            state = table[state][c.index]</span><br><span class="line">            <span class="keyword">if</span> (state == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state <span class="keyword">in</span> finalState</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="built_in">Char</span>.index: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="string">&#x27; &#x27;</span> -&gt; <span class="number">0</span></span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span> -&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="number">2</span></span><br><span class="line">            <span class="string">&#x27;.&#x27;</span> -&gt; <span class="number">3</span></span><br><span class="line">            <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;E&#x27;</span> -&gt; <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>正则表达式</tag>
        <tag>DFA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.68.文本左右对齐（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.68.%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/text-justification/">LeetCode.68.文本左右对齐（困难）</a></p>
<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<span id="more"></span>

<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<p>说明:</p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 maxWidth。</li>
<li>输入单词数组 words 至少包含一个单词。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>顺着题目说明思考步骤。</p>
<h3 id="怎么知道一行可以放多少个单词？"><a href="#怎么知道一行可以放多少个单词？" class="headerlink" title="怎么知道一行可以放多少个单词？"></a>怎么知道一行可以放多少个单词？</h3><p>依次遍历单词，累加单词长度，跟<code>maxWidth</code>对比，找出一行可以容纳的最多的单词。</p>
<p>如果一行有<code>n</code>个单词，要注意，前<code>n - 1</code>个单词末尾都要至少有一个空格，需要考虑进去。</p>
<h3 id="如何知道每行有多少个空格？"><a href="#如何知道每行有多少个空格？" class="headerlink" title="如何知道每行有多少个空格？"></a>如何知道每行有多少个空格？</h3><p><code>maxWidth - 这一行所有单词长度</code></p>
<h3 id="如何平均分配空格到每个单词的末尾？"><a href="#如何平均分配空格到每个单词的末尾？" class="headerlink" title="如何平均分配空格到每个单词的末尾？"></a>如何平均分配空格到每个单词的末尾？</h3><p>假设一行的空格数有<code>spaceCount</code></p>
<ul>
<li>计算一行额外的空格数量，<code>额外空格数 = maxWidth - 每个单词末尾一个空格数量 - 每个单词的长度</code></li>
<li>平均分配额外空格到每个单词的末尾<ul>
<li>每个单词末尾能分配到多少额外空格，用<code>额外空格数量 / 每行单词数量</code>可得。</li>
<li><code>额外空格数量 / 每行单词数量</code>不能整除时，每个单词末尾额外空格数量就不一样了，按照题目要求，让最右边单词分配少的额外空格，空格数量为<code>额外空格数量 % 每行单词数量</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.70.爬楼梯（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.70.%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/climbing-stairs/">LeetCode.70.爬楼梯（简单）</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑用动态规划，看是否符合动态规划的条件。<br>一般从最终状态做倒推，拆解当前状态问题为上一个状态+有限的步骤。</p>
<h3 id="倒推"><a href="#倒推" class="headerlink" title="倒推"></a>倒推</h3><p>爬到第n阶，最后一步一定是只有两种可能：</p>
<ol>
<li>先爬到第n-1个台阶，再爬1个台阶</li>
<li>先爬到第n-2个台阶，再爬2个台阶</li>
</ol>
<p>把两种可能的方法数累加就是爬到第n阶第方法数。</p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>爬到第1阶，只有1种爬法，即爬1个台阶。<br>爬到第2阶，可以从第0阶爬2个台阶，也可以从第1阶爬1个台阶，共2种爬法。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.714.买卖股票的最佳时机含手续费（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode.714.买卖股票的最佳时机含手续费（中等）</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状态转移方程同<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>卖出时计算利润时把交易费扣除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>, fee: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            noholdProfit = maxOf(noholdProfit, holdProfit + prices[i] - fee)</span><br><span class="line">            holdProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.72.编辑距离（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/">LeetCode.72.编辑距离（困难）</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看着题目就给出了原子化的最小操作步骤了，看着就能拆成子问题的样子。</p>
<p>从两个单词末尾开始看起。</p>
<ul>
<li>如果<code>word1[i1] == word2[i2]</code>，就不用操作；<br>  接着就是去对比<code>word1[0, i1 - 1]</code>和<code>word2[0, i2 - 1]</code>这两个子字符串是不是一样，看子问题。</li>
<li>如果<code>word1[i1] != word2[i2]</code>，那么每个单词都有三种操作可以变成另一个；<br>具体哪种操作后的总操作数最少呢？只能每个都试一下，然后选个操作数最少的。</li>
</ul>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>是<code>word1[0, i]</code>转换为<code>word2[0, j]</code>的操作数。</p>
<ul>
<li><code>word1[i] == word2[j]</code>时，<br><code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>word1[i] != word2[j]</code>时：<ul>
<li><code>word1</code>末尾插入一个与<code>word2[j]</code>相同的字符，插入之前的操作数是<code>dp[i][j - 1]</code>。</li>
<li><code>word1</code>末尾删除一个字符，删除之前的操作数是<code>dp[i - 1][j]</code>。</li>
<li><code>word1</code>末尾字符替换为<code>word2[j]</code>，替换之前的操作数是<code>dp[i - 1][j - 1]</code>。</li>
<li>取插入、删除、替换操作数中最小的一个，<code>dp[i][j] = 1 + minOf(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])</code></li>
</ul>
</li>
</ul>
<p><strong>边界条件</strong></p>
<ul>
<li><code>i == 0</code>时，<ul>
<li><code>dp[i - 1][j]</code>表示空字符串变换到<code>word2[0, j]</code>需要的操作数，很显然要插入<code>j + 1</code>个字符，操作数是<code>j + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>j == 0</code>时，<ul>
<li><code>dp[i][j - 1]</code>表示空字符串变换到<code>word1[0, i]</code>需要的操作数，很显然要插入<code>i + 1</code>个字符，操作数是<code>i + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>i == 0 &amp;&amp; j == 0</code>时，<ul>
<li><code>dp[i - 1][j - 1]</code>（即<code>dp[-1][-1]</code>）表时空字符串转换到空字符串，操作数为0。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(word1.length - <span class="number">1</span>, word2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度</p>
<p>设m为word1长度，n为word2长度，m &lt; n。</p>
<p>画出递归树可以观察到，一个大问题最多可以拆解为3个子问题，也就是一个结点的下一层最多有3个结点，可以一直这样扩张，树高也就是m和n中的较大值。<br>最坏时间复杂度就是递归树的所有结点数，通过等比数列求和公式可得结点总数为 $O(3^n)$。</p>
<p>一次递归占用一个方法栈，空间复杂度就看同一时刻最多会有多少个方法栈存在，因为递归没有发现结果会回溯，所以得到正确答案的时候递归深度最深，也就是方法栈最多的时候。<br>空间复杂度 $O(n)$。</p>
</blockquote>
<p>递归有大量重叠子问题，比如<code>min(i1 - 1, i2 - 1)</code>在依次经历过<code>min(i1 - 1, i2)</code>和<code>min(i1 - 1, i2 - 1)</code>后可以得到，计算了两次，后续递归还有更多重叠子问题，得把中间计算结果保存一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n1) &#123; IntArray(n2) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1 - <span class="number">1</span>, n2 - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong><br>自底向上递推会用到前一项的值，为了避免大量边界判断，把dp数组长度加1。<br><code>dp[i][j]</code>表示<code>word1[0, i - 1]</code>和<code>word2[0, j - 1]</code>的最小编辑距离。</p>
<p><code>dp[i][0]</code>表示<code>word1[0, i - 1]</code>变成空字符串需要多少步操作，很显然是要删除<code>word1[0,i - 1]</code>所有字符，共有<code>i</code>个字符。</p>
<p><code>dp[0][j]</code>表示空字符串要变成<code>word2[0,j - 1]</code>需要多少步操作，很显然是要插入<code>word2[0, j - 1]</code>全部字符，总共<code>j</code>个字符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(len1 + <span class="number">1</span>) &#123; IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len1) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len2) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until len1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until len2) &#123;</span><br><span class="line">	            <span class="comment">// 当前字符相等，不需要操作，操作步数看上一个状态</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前字符不等，可以插入、替换、删除</span></span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + dp[i][j]</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[i + <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[i][j + <span class="number">1</span>]</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(mn)，需要用二维dp数组记录中间计算状态。</p>
</blockquote>
<p><strong>空间优化</strong><br><code>dp[i][j]</code>只跟左、上、左上三项有关，不需要用二维数组记录所有状态，只需要一行数组记录上一行状态即可。</p>
<p>这里有个问题在于，从左到右更新<code>dp</code>数组时会把左上角的值给覆盖掉，所以要在更新左边的值之前，把左上角的值先提前保存一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.len2) dp[j] = j</span><br><span class="line">        <span class="comment">// 表示左上角的值</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len1) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.len2) &#123;</span><br><span class="line">	            <span class="comment">// 更新左边的值之前，把左上角的值先提前保存一下</span></span><br><span class="line">                <span class="keyword">val</span> tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[j] = pre</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + pre</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[j]</span><br><span class="line">                    dp[j] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(n)，只需要用一维dp数组记录中间计算状态。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.740.删除并获得点数（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.740.%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">LeetCode.740.删除并获得点数（中等）</a></p>
<p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于要删除值相邻的元素，可以在脑海里先按元素值对nums数组排序，方便梳理题意，最终求解的东西跟数组顺序也没关系。</p>
<p>删除一个<code>nums[i]</code>获得点数后，所有<code>nums[i] - 1</code>和<code>nums[i] + 1</code>的相邻元素被删除了（不计点数），数组里剩下的所有等于<code>nums[i]</code>的值都还是要逐个主动删除并且计入点数的，因为它们不会因为是某个被删除元素的相邻元素而被删除，因为相邻元素从删除第一个<code>nums[i]</code>就删完了。</p>
<p>所以，假设<code>nums[i]</code>在数组里有<code>c</code>个，删除<code>nums[i]</code>可以获得的点数是<code>nums[i] * c</code>。</p>
<p>可以用一个数组<code>sum</code>记录<code>nums</code>数组中所有相同元素的和，以<code>nums[i]</code>作为<code>sum</code>数组的下标，方便查询点数。即<code>sum[nums[i]] = nums[i] * c</code>。</p>
<p>获取了<code>sum[nums[i]]</code>就不能选取<code>sum[nums[i] - 1]</code>和<code>sum[nums[i] + 1]</code>了，这就转变为打家劫舍的最优化问题。  </p>
<p><code>sum</code>数组的长度为<code>nums数组的最大值 + 1</code>，是一个常数空间，对性能影响可以接受。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteAndEarn</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> maxValue = nums.max()!!</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(maxValue + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            sum[num] += num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until nums.size) &#123;</span><br><span class="line">            cur = maxOf(pre2 + nums[i], pre1)</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.746.使用最小花费爬楼梯（简单）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">LeetCode.746.使用最小花费爬楼梯（简单）</a></p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，往动态规划上考虑，看是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>一般从最终状态做倒推，拆分步骤，列出所有到达最终状态的步骤，看能否拆分为上一个同性质的子问题+有限步骤，拆分步骤的过程得出状态转移方程。</p>
<p>cost数组长度为n，到达楼顶就是到达下标n的地方。<br>设<code>dp[i]</code>表示达到到达下标i所需的最小花费，<code>0 &lt;= i &lt;= n</code>。</p>
<h3 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h3><p>可以从下标为0或1的阶梯开始爬，说明<code>dp[0] = dp[1] = 0</code>。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>达到第i个阶梯，最后一步有两种选择：</p>
<ol>
<li>在第i-1层爬1个阶梯。</li>
<li>在第i-2层爬2个阶梯。</li>
</ol>
<p>到达第i-1层的最小花费是<code>dp[i-1]</code>，爬1个阶梯需要耗费<code>cost[i-1]</code><br>到达第i-2层的最小花费是<code>dp[i-2]</code>，爬2个阶梯需要耗费<code>cost[i-2]</code><br>那么，到达第i层阶梯就是取两者中较小值。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只与前两项值有关，所以不需要数组，用两个变量保存前面两项值即可。</p>
<h3 id="代码（Kotlin）"><a href="#代码（Kotlin）" class="headerlink" title="代码（Kotlin）"></a>代码（Kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">            cur = minOf(pre1 + cost[i - <span class="number">1</span>], pre2 + cost[i - <span class="number">2</span>])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.76.最小覆盖子串（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode.76.最小覆盖子串（困难）</a></p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<span id="more"></span>
<p>注意：</p>
<ul>
<li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li>
<li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在  <code>o(n)</code>  时间内解决此问题的算法吗？</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力朴素法"><a href="#暴力朴素法" class="headerlink" title="暴力朴素法"></a>暴力朴素法</h3><p>设<code>s</code>长度为<code>n</code>，<code>t</code>长度为<code>m</code>。</p>
<p>把<code>t</code>的字符都存在哈希表中，相同字符进行计数。</p>
<p>从<code>s</code>的每一个位置开始，看后面的<code>m</code>个字符是否都在哈希表中，并且相同字符的个数也一样。</p>
<p>这样匹配的时间复杂度是<code>O(mn)</code>，空间复杂度<code>O(m)</code>。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>暴力法有很多重复的判断，所以时间复杂度高，如果能把已经判断过的东西不用再判断了就可以降低时间复杂度。</p>
<p>可以使用滑动窗口，最多也就是滑动窗口的左右边界走完整个字符串，时间复杂度是<code>O(n)</code>的。</p>
<p>算法步骤：</p>
<ol>
<li>不停的扩大窗口，直至窗口中包含了t中所有字符。</li>
<li>不停的缩小窗口，直至窗口中没有包含t中所有字符。</li>
<li>重复上述两步，每一步记录最小的窗口的大小。</li>
</ol>
<p>还是需要把<code>t</code>的字符都存在哈希表中，方便判断窗口中有没有包含t中所有字符，相同字符进行计数。</p>
<p>细节见源码注释。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    滑动窗口两步走:</span></span><br><span class="line"><span class="comment">    1. 不停的扩大窗口，直至窗口中包含了t中所有字符；如果不能再扩大了就不扩大了</span></span><br><span class="line"><span class="comment">    2. 不停的缩小窗口，直至窗口中没有包含t中所有字符，缩小前记录最小的符合答案条件的子串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minWindow</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// S中包含T所有字符的最小子串</span></span><br><span class="line">        <span class="keyword">var</span> minSubstr = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">val</span> window = Window(s, t)</span><br><span class="line">        <span class="keyword">while</span> (window.extend()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (window.match()) &#123;</span><br><span class="line">                <span class="comment">// 有更小的满足答案的窗口，那就要记录下来</span></span><br><span class="line">                <span class="comment">// 但是初始时minSubstr是长度为0，需要特殊对待，因为一旦发现了满足答案的窗口，就要更新记录</span></span><br><span class="line">                <span class="keyword">if</span> (minSubstr.isEmpty() || window.windowSize() &lt; minSubstr.length) &#123;</span><br><span class="line">                    minSubstr = window.windowString()</span><br><span class="line">                &#125;</span><br><span class="line">                window.shorten()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSubstr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>(</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> s: String,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> t: String</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 记录t中所有字符出现的次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> tMap = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口已出现的字符的次数，可以只记录t中存在的字符，t中不存在的字符记录也没啥意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> wMap = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录匹配的字符数量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> matchedCharCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> right = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            t.forEach &#123; c -&gt;</span><br><span class="line">                tMap[c] = <span class="number">1</span> + tMap.getOrDefault(c, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 扩大窗口</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果还能继续扩大返回true，不能再扩大了返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">extend</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 窗口已经滑动到字符串最右侧了</span></span><br><span class="line">            <span class="keyword">if</span> (right == s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            right++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 窗口又增加一个字符</span></span><br><span class="line">            <span class="keyword">val</span> c = s[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">                <span class="comment">// 窗口只记录t中存在的字符，记录t中不存在的字符也没啥意义</span></span><br><span class="line">                wMap[c] = <span class="number">1</span> + wMap.getOrDefault(c, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果窗口内当前字符c的个数已经达到t中c字符的数量，记录匹配的字符数量</span></span><br><span class="line">                <span class="comment">// 字符数量过多不管它，在缩小窗口时一起考虑这个问题</span></span><br><span class="line">                <span class="keyword">if</span> (tMap.containsKey(c) &amp;&amp; tMap[c] == wMap[c]) &#123;</span><br><span class="line">                    matchedCharCount++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口中有字符串t中所有的字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchedCharCount == tMap.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 减少左边界缩短窗口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">shorten</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> c = s[left]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">                wMap[c] = wMap.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 窗口里c字符数量小于t中c的字符数量，匹配字符数量减1</span></span><br><span class="line">                <span class="comment">// 这里感觉有多减的风险，但是其实不会发生，因为一旦不匹配了，就不会再继续缩小窗口了，而是会扩大窗口，所以不用考虑</span></span><br><span class="line">                <span class="keyword">if</span> (wMap[c]!! &lt; tMap[c]!!) &#123;</span><br><span class="line">                    matchedCharCount--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口字符串长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">windowSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">windowString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.84.柱状图中最大的矩形（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a></p>
<p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><p>暴力法虽然时间复杂度往往比较高，但是可以理清思路。</p>
<p><strong>思路</strong></p>
<p>就是枚举以每个柱子高度作为边长的最大矩形面积。</p>
<p>从每个柱子向左和向右检查是否有相同高度或更高的柱子，统计可以形成的矩形的最大宽度，然后计算面积，记录最大的。</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度<code>O(n ^ 2)</code>：</p>
<ul>
<li>枚举所有柱子需要访问数组所有元素。</li>
<li>一次中心扩散最坏情况下要访问数组所有元素，比如所有柱子高度相同。</li>
</ul>
<p>空间复杂度<code>O(1)</code>：</p>
<ul>
<li>没有额外空间开销</li>
</ul>
<h3 id="暴力法多余的时间开销在哪？"><a href="#暴力法多余的时间开销在哪？" class="headerlink" title="暴力法多余的时间开销在哪？"></a>暴力法多余的时间开销在哪？</h3><p>中心扩散时，当前柱子的向右扩散，和后面柱子的向左扩散，这两个是重复的动作，应该优化。</p>
<h3 id="应该怎么优化时间开销？"><a href="#应该怎么优化时间开销？" class="headerlink" title="应该怎么优化时间开销？"></a>应该怎么优化时间开销？</h3><p>由于要查看每一个柱子高度能够形成多大面积的矩形，所以至少要遍历一次数组。</p>
<p>我们是从左到右遍历数组的，可以想办法避免向右扩散，只向左扩散来计算当前矩形面积，因为左边的柱子已经遍历过了。</p>
<p>那么现在问题变为：</p>
<ul>
<li>遇到什么样的柱子才能向左扩散？</li>
<li>向左扩散时，左边的柱子什么时候计算以它们的高度为矩形边长的面积？</li>
</ul>
<h3 id="遇到什么样的柱子才能向左扩散？"><a href="#遇到什么样的柱子才能向左扩散？" class="headerlink" title="遇到什么样的柱子才能向左扩散？"></a>遇到什么样的柱子才能向左扩散？</h3><ul>
<li>看暴力法中向右扩散的条件是，右边的柱子比当前柱子高，才需要扩散。</li>
<li>那么右边柱子如果比当前柱子矮，就无法向右扩散，只能向左扩散。</li>
</ul>
<h3 id="向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？"><a href="#向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？" class="headerlink" title="向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？"></a>向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？</h3><p>在遇到不能向右扩散的柱子之前，所遍历过的柱子的特点是：它们高度是从左到右递增或相等的，否则就应该向左扩散了。</p>
<p>假设在遍历时，发现当前柱子比前一个柱子矮，设当前柱子是第i个。</p>
<h4 id="以第i-1个柱子高度构成的矩形面积怎么求？"><a href="#以第i-1个柱子高度构成的矩形面积怎么求？" class="headerlink" title="以第i - 1个柱子高度构成的矩形面积怎么求？"></a>以第i - 1个柱子高度构成的矩形面积怎么求？</h4><ul>
<li>要寻找左右边界在哪。</li>
<li>右边界是知道的，就是i，因为第i - 1个柱子的高度不能向右扩散了。</li>
<li>左边界是i - 2，因为第i - 2个柱子到第i - 1个柱子的高度是递增的，第i - 1个柱子的高度不能向左扩散。</li>
</ul>
<h4 id="以第i-2个柱子高度构成的矩形面积怎么求？"><a href="#以第i-2个柱子高度构成的矩形面积怎么求？" class="headerlink" title="以第i - 2个柱子高度构成的矩形面积怎么求？"></a>以第i - 2个柱子高度构成的矩形面积怎么求？</h4><ul>
<li>左边界是i - 3，因为左边柱子高度是递增的。</li>
<li>右边界在哪，要取决于第i - 2个柱子和第i个柱子哪个更高。<ul>
<li>如果第i - 2个柱子比第i个柱子高，右边界是i，因为第i - 2个柱子到第i - 1个柱子的高度是递增的，所以第i - 2个柱子可以把矩形扩散到比它高的柱子下面。</li>
<li>如果第i - 2个柱子比第i个柱子矮，右边界不是i了，因为第i - 2个柱子的高度还可以向右扩散。<ul>
<li>什么时候可以计算以第i - 2个柱子高度的矩形面积呢？要在后面遇到比第i - 2个柱子矮的柱子才行，右边界就是后面那个矮柱子的索引，左边界是i - 3。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应该怎么记录左边柱子的信息？"><a href="#应该怎么记录左边柱子的信息？" class="headerlink" title="应该怎么记录左边柱子的信息？"></a>应该怎么记录左边柱子的信息？</h3><ul>
<li>由于在遇到高度递减的柱子时，会求以左边柱子高度构成的矩形面积，而且并且有的柱子会求有的柱子不会求，所以要记录下所有没有求过矩形面积的柱子索引，并要能添加和移除，需要用一个集合保存。</li>
<li>由于要访问左边柱子的高度，而遍历顺序是从左到右的，所以符合这个数据访问顺序的数据结构是栈。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>计算第一个柱子高度的矩形面积时左边界是-1，取做边界的时候要特殊处理一下。</li>
<li>如果末尾的柱子都是递增的，不会触发向左扩散，需要再遍历结束后手动触发一下。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><ul>
<li>遍历一次数组需要访问n个元素。</li>
<li>虽然访问栈需要往回看，但是入栈的元素都是不重复的，并且每个元素只会访问一次，往回看最多访问n个元素。</li>
</ul>
<h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><p>最坏情况下，数组完全递增，栈最多保存n个元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">largestRectangleArea</span><span class="params">(heights: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = heights.size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">                <span class="keyword">val</span> right = i</span><br><span class="line">                <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">                maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发末尾递增柱子的矩形面积计算</span></span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">val</span> right = n</span><br><span class="line">            <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">            maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.85.最大矩形（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">LeetCode.85.最大矩形（困难）</a></p>
<p>给定一个仅包含 <code>0</code>  和  <code>1</code>  、大小为  <code>rows x cols</code>  的二维二进制矩阵，找出只包含  <code>1</code>  的最大矩形，并返回其面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果以某一行为横轴，该行以上的列为纵轴区域，问题就转变为<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a>。</p>
<p>某一行下，每一列下，与行相连的1的个数就是柱子高度。</p>
<h3 id="整个求解过程"><a href="#整个求解过程" class="headerlink" title="整个求解过程"></a>整个求解过程</h3><ul>
<li>统计每一行下柱子的高度</li>
<li>带入<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a>的求解公式里求出柱子可以形成的最大矩形面积</li>
<li>然后在所有行的最大矩形面积里取一个最大值。</li>
</ul>
<h3 id="每行柱子高度统计方法优化"><a href="#每行柱子高度统计方法优化" class="headerlink" title="每行柱子高度统计方法优化"></a>每行柱子高度统计方法优化</h3><ul>
<li>如果到达每一行，再往上遍历遍历每列柱子高度，是有重复计算的。</li>
<li>可以保存之前行的柱子高度的结果，在到下一行的时候，发现这一行某一列是1，就累加高度，是0就清空柱子高度，因为无法形成柱子。这样就不用重复计算了。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalRectangle</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> heights = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (col <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) heights[col]++</span><br><span class="line">                <span class="keyword">else</span> heights[col] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> area = largestRectangleArea(heights)</span><br><span class="line">            maxArea = maxOf(maxArea, area)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">largestRectangleArea</span><span class="params">(heights: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = heights.size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">                <span class="keyword">val</span> right = i</span><br><span class="line">                <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">                maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发末尾递增柱子的矩形面积计算</span></span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">val</span> right = n</span><br><span class="line">            <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">            maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-mn"><a href="#时间复杂度O-mn" class="headerlink" title="时间复杂度O(mn)"></a>时间复杂度O(mn)</h4><p>m为矩阵行数，n为矩阵列数。</p>
<ul>
<li>求柱子高度需要遍历矩阵所有元素，所有元素有m*n个。</li>
<li>求每个柱子高度需要O(n)。</li>
</ul>
<h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><ul>
<li>高度数组占用O(n)。</li>
<li>求柱子最大矩形面积需要O(n)的栈。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.87.扰乱字符串（困难）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.87.%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/scramble-string/">LeetCode.87.扰乱字符串（困难）</a></p>
<p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：</p>
<ul>
<li>如果字符串的长度为 1 ，算法停止</li>
<li>如果字符串的长度 &gt; 1 ，执行下述步骤：<ul>
<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。</li>
<li>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。</li>
<li>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
</ul>
</li>
</ul>
<p>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目描述已经给出了拆解步骤和子问题的划分。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从最后一步开始想：</p>
<ul>
<li>设s1拆解为a1和a2，s2拆解为b1和b2</li>
<li>因拆解后子串顺序有两种，如果s1能扰乱为s2，那么s1和s2对应关系也就有两种：<ul>
<li>a1是否能从b1扰乱来，并且，a2是否能从b2扰乱来；其中<code>a1.length == b1.length &amp;&amp; a2.length == b2.length</code>。</li>
<li>a1是否能从b2扰乱来，并且，a2是否能从b1扰乱来；其中<code>a1.length == b2.length &amp;&amp; a2.length == b1.length</code>。</li>
</ul>
</li>
</ul>
<p>子问题和拆解步骤就出来了。</p>
<h3 id="应该怎么拆解字符串？"><a href="#应该怎么拆解字符串？" class="headerlink" title="应该怎么拆解字符串？"></a>应该怎么拆解字符串？</h3><p>穷举所有可以拆解的位置</p>
<h3 id="有哪些状态？"><a href="#有哪些状态？" class="headerlink" title="有哪些状态？"></a>有哪些状态？</h3><ul>
<li>拆解字符串需要知道起始索引和结束索引。</li>
<li>有两个字符串，也就有4个状态。</li>
<li>但是拆解过后的子串长度是相等的，所以可以不记录两个结束索引，只记录拆解的子串长度，缩减为3个状态。</li>
</ul>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li>如果两个字符串长度不相等，两者无法通过扰乱变为一致。</li>
<li>如果两个字符串长度相等，但每种字符个数不相等，两者无法通过扰乱变为一致。</li>
<li>拆到只有一个字符的时候，直接判断字符是否相同。</li>
</ul>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> s1CharCountMap = s1.groupingBy&#123;it&#125;.eachCount()</span><br><span class="line">        <span class="keyword">val</span> s2CharCountMap = s2.groupingBy&#123;it&#125;.eachCount()</span><br><span class="line">        <span class="keyword">if</span> (s1CharCountMap != s2CharCountMap) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> a1 = s1.substring(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> a2 = s1.substring(i + <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">val</span> b1 = s2.substring(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> b2 = s2.substring(i + <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (isScramble(a1, b1) &amp;&amp; isScramble(a2, b2)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (isScramble(a1, b2) &amp;&amp; isScramble(a2, b1)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度指数级别</p>
</blockquote>
<h3 id="指针递归"><a href="#指针递归" class="headerlink" title="指针递归"></a>指针递归</h3><p>上面的递归解法非常直白，但是不方便存储中间计算结果，子串改成指针形式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1[i1, i1 + length - 1]和s2[i2, i2 + length - 1]是否有一样的字符和字符个数</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hasSameChars</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> counts = IntArray(<span class="number">26</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i1 until i1 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s1[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i2 until i2 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s2[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counts.sum() == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">1</span>) <span class="keyword">return</span> s1[i1] == s2[i2]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 词频不一样，肯定不能转换</span></span><br><span class="line">            <span class="keyword">if</span> (!hasSameChars(i1, i2, length)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k为s1和s2分割出来的左半部分的长度</span></span><br><span class="line">            <span class="comment">// 左子串最短长度为1</span></span><br><span class="line">            <span class="comment">// 左子串最长长度为length - 1，因为要留一个长度给右子串</span></span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2, k) &amp;&amp; test(i1 + k, i2 + k, length - k)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2 + length - k, k) &amp;&amp; test(i1 + k, i2, length - k)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test(<span class="number">0</span>, <span class="number">0</span>, n) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h3><p>暴力递归有重叠子问题，需要记录中间计算状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1[i1, i1 + length - 1]和s2[i2, i2 + length - 1]是否有一样的字符和字符个数</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hasSameChars</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> counts = IntArray(<span class="number">26</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i1 until i1 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s1[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i2 until i2 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s2[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counts.sum() == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; Array(n) &#123; IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2][length] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> matched = s1[i1] == s2[i2]</span><br><span class="line">                memo[i1][i2][length] = <span class="keyword">if</span> (matched) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> matched</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 词频不一样，肯定不能转换</span></span><br><span class="line">            <span class="keyword">if</span> (!hasSameChars(i1, i2, length)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k为s1和s2分割出来的左半部分的长度</span></span><br><span class="line">            <span class="comment">// 左子串最短长度为1</span></span><br><span class="line">            <span class="comment">// 左子串最长长度为length - 1，因为要留一个长度给右子串</span></span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2, k) &amp;&amp; test(i1 + k, i2 + k, length - k)) &#123;</span><br><span class="line">                    memo[i1][i2][length] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2 + length - k, k) &amp;&amp; test(i1 + k, i2, length - k)) &#123;</span><br><span class="line">                    memo[i1][i2][length] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test(<span class="number">0</span>, <span class="number">0</span>, n) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度O-n-4"><a href="#时间复杂度O-n-4" class="headerlink" title="时间复杂度O(n^4)"></a>时间复杂度O(n^4)</h3><ul>
<li>递归会枚举所有length的取值情况，1 &lt;= length &lt;= n。</li>
<li>对于每个length枚举了左子串字符数k的所有取值可能，1 &lt;= k &lt;= length。</li>
<li>递归枚举了所有i1的取值情况，0 &lt;= i1 &lt;= n - 1</li>
<li>递归枚举了所有i2的取值情况，0 &lt;= i2 &lt;= n - 1</li>
</ul>
<h3 id="空间复杂度O-n-3"><a href="#空间复杂度O-n-3" class="headerlink" title="空间复杂度O(n^3)"></a>空间复杂度O(n^3)</h3><p>状态存储是三维数组。</p>
<h3 id="自底向上的动态规划"><a href="#自底向上的动态规划" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h3><p>记忆化递归的备忘录数组的填充过程已经给出了状态转移方程。</p>
<p>设<code>dp[i][j][len]</code>代表  <code>s1</code>  从  <code>i</code>  开始，<code>s2</code>  从  <code>j</code>  开始，后面长度为  <code>len</code>  的字符是否能形成扰乱字符串。</p>
<p><strong>状态转移方程</strong></p>
<p>设<code>s1</code>的左子串的长度为<code>k</code>。</p>
<p><code>dp[i][j][len] = dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k] || dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]</code></p>
<p><strong>边界情况</strong></p>
<p>长度为1时，只需要判断字符是否相同。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = s1[i] == s2[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k] || dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]) &#123;</span><br><span class="line">                            dp[i][j][len] = <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.91.解码方法（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://leetcode-cn.com/problems/decode-ways/">LeetCode.91.解码方法（中等）</a></p>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<blockquote>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
</blockquote>
<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<ul>
<li>“AAJF” ，将消息分组为 (1 1 10 6)</li>
<li>“KJF” ，将消息分组为 (11 10 6)</li>
</ul>
<p>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>思考能否将某个状态下的问题拆分为子问题+有限步骤。</p>
<p>设<code>a[i]</code>为<code>s[0..i]</code>中解码方法总数。</p>
<h3 id="a-i-取值受什么影响？"><a href="#a-i-取值受什么影响？" class="headerlink" title="a[i]取值受什么影响？"></a>a[i]取值受什么影响？</h3><p>受<code>s[i - 1]</code>和<code>s[i - 2]</code>的取值影响，因为要决定是解析一个字符还是两个字符。<br><code>a[i]</code>可以通过<code>a[i - 1]</code>或<code>a[i - 2]</code>递推而来。</p>
<h3 id="s-i-1-和s-i-2-组合的数有哪些情况？"><a href="#s-i-1-和s-i-2-组合的数有哪些情况？" class="headerlink" title="s[i - 1]和s[i - 2]组合的数有哪些情况？"></a><code>s[i - 1]</code>和<code>s[i - 2]</code>组合的数有哪些情况？</h3><p>根据题意，没有直接映射到0的情况，要注意：</p>
<ol>
<li>不能单独映射0，只能作为10或者20整体解析，方案数不变，<code>a[i] = a[i - 1]</code>。一旦出现0的前面不是1或2，整个s无法解析，直接返回0方案数。</li>
<li>06这样的0处在十位数的也不能作为个位数解析，只能一个个解析，方案数不变，<code>a[i] = a[i - 1]</code></li>
</ol>
<p>两个数字剩余的合法取值范围在[11, 19]、[21, 26]，此时可以映射一个字母，也可以映射两个字母。<br><code>a[i] = a[i - 1] + a[i - 2]</code></p>
<p>其他大于26的情况，只能映射一个字母，方案数不变，<code>a[i] = a[i - 1]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>a[i]</code>只与前两个状态有关，只用两个保存状态即可，不需要数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numDecodings</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始的一个字符只有一种映射方案</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始时，前两个字符的解析方案数</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> num = parseInt(s[<span class="number">0</span>], s[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cur = pre</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第3个字符开始解析</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> num = parseInt(s[i - <span class="number">1</span>], s[i])</span><br><span class="line">                <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) pre + prepre <span class="keyword">else</span> pre</span><br><span class="line">            &#125;</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(a: <span class="type">Char</span>, b: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tens = (a.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()) * <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> units = b.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line">        <span class="keyword">return</span> tens + units</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.918.环形子数组的最大和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">LeetCode.918.环形子数组的最大和（中等）</a></p>
<p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p>
<p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，且当 i &gt;= 0 时 C[i+A.length] = C[i]）</p>
<p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="环形数组跟非环形数组的区别是什么？"><a href="#环形数组跟非环形数组的区别是什么？" class="headerlink" title="环形数组跟非环形数组的区别是什么？"></a>环形数组跟非环形数组的区别是什么？</h3><p>环形数组中最终求得的最大和子数组有两种情况</p>
<ol>
<li>数组A的首尾元素不会连接</li>
<li>数组A的首尾元素会连接</li>
</ol>
<h3 id="数组A的首尾元素不会连接的情况如何求解？"><a href="#数组A的首尾元素不会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素不会连接的情况如何求解？"></a>数组A的首尾元素不会连接的情况如何求解？</h3><p>第1种情况就是非环形数组的普通求法，参与计算的区间为<code>[0, n - 1]</code></p>
<h3 id="数组A的首尾元素会连接的情况如何求解？"><a href="#数组A的首尾元素会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素会连接的情况如何求解？"></a>数组A的首尾元素会连接的情况如何求解？</h3><p>第2种情况不好用非环形数组的方法求解，实际观察结果可以得到等价情况：先求出中间部分的子数组的最小和，再用整个数组A的和减去中间的最小和就是两端首尾相连的子数组的最大和。<br>这时只在数组A的<code>[1, n - 2]</code>区间求解，这才能保证首尾不连接。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubarraySumCircular</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMaxSumInLinearCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = maxOf(pre + nums[i], nums[i])</span><br><span class="line">                maxSum = maxOf(maxSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMinSumInCyclicCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minSum = nums[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = minOf(pre + nums[i], nums[i])</span><br><span class="line">                minSum = minOf(minSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            getMaxSumInLinearCase(), </span><br><span class="line">            nums.sum() - getMinSumInCyclicCase()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.931.下降路径最小和（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">LeetCode.931.下降路径最小和（中等）</a></p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，拆分大问题为子问题+有限步骤。</p>
<p>下降路径在第一行任何元素都能开始。</p>
<p>针对第一行某个元素，要选取左下方、正下方、右下方三条向下路径中和最小的路径的和，再加上当前元素的值，就是当前元素开始的下降路径的最小和。<br>第二行每个元素的和最小的下降路径求法一样，直到最后一行。</p>
<p>第一行每个元素的下降路径最小和都逐个求出后，选取一个最小的。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是第r行第c列下降路径最小和。<br><code>dp[r][c] = matrix[r][c] + minOf(dp[r + 1, c - 1], dp[r + 1, c], dp[r + 1, c + 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>最后一行，没有下面一行了<br><code>dp[r][c] = matrix[r][c]</code></li>
<li>第一列，只能读取下方和右下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c], dp[r + 1, c + 1])</code></li>
<li>最后一列，只能读取下方和左下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c - 1], dp[r + 1, c])</code></li>
</ul>
<h3 id="递推顺序"><a href="#递推顺序" class="headerlink" title="递推顺序"></a>递推顺序</h3><p>从下往上</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> dp = Array(rows) &#123; IntArray(columns) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            dp[rows - <span class="number">1</span>][c] = matrix[rows - <span class="number">1</span>][c]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                dp[r][c] = matrix[r][c] + </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, dp[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>因为是逐行递推的，所以可以用原数组存储，不用额外开辟二维数组。</p>
<h3 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                matrix[r][c] += </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, matrix[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.96.不同的二叉搜索树（中等）</title>
    <url>/%E7%AE%97%E6%B3%95/algorithm/LeetCode.96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode.96.不同的二叉搜索树（中等）</a></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<blockquote>
<p>提示：  <code>1 &lt;= n &lt;= 19</code></p>
<span id="more"></span>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树的问题第一反应会想到递归，进而想到能不能划分子问题。</p>
<p>从基本情况开始梳理。<br>构造一棵树，要选一个根节点。<br>如果以某个数字为根节点，左子树有a种，右子树有b种，那么这棵树就有a * b种可能。</p>
<p>左子树和右子树的构建，也要选择根节点，选择逻辑一样，可以递归进行，但是能选的根节点数量少了一个。</p>
<p>递推下去可以发现，如果剩余可选节点数越少，种数就越少。</p>
<p>设<code>sum[i]</code>为节点总数为<code>i</code>的二叉搜索树的种数。<br>除去根节点，假设左子树有<code>j</code>个节点，右子树就有<code>i - 1 - j</code>个节点，其中<code>j</code>的取值范围是<code>0 &lt;= j &lt;= i - 1</code>，得把所有的<code>j</code>可能情况都取一遍值，最后累加结果，就得到<code>sum[i]</code>。</p>
<p><strong>状态转移方程</strong><br><code>sum[i]= ∑ sum[j] * sum[i - 1 - j]</code>，<code>0 &lt;= j &lt;= i - 1</code></p>
<p><strong>边界处理</strong><br>总共只有0个节点，是空树，也算一种树，<code>sum[0] = 1</code>。想象一下如果左子树为空，右子树有n种，那么当前树也应该有n种。<br>总共只有1个节点，只有一种情况，<code>sum[1] = 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        sum[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                sum[i] += sum[j] * sum[i - <span class="number">1</span> - j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ViewDragHelper源码解析</title>
    <url>/Android/ViewDragHelper/2015-05-21-viewdraghelper-source-analysis/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p>在自定义ViewGroup的构造方法里调用<code>ViewDragHelper</code>的静态工厂方法<code>create</code>()创建<code>ViewDragHelper</code>实例</p>
</li>
<li><p>实现<code>ViewDragHelper.Callback</code><br>最重要的几个方法是</p>
<ul>
<li><code>tryCaptureView()</code>里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>clampViewPositionVertical()</code>决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>
<li><code>clampViewPositionHorizontal()</code>与<code>clampViewPositionVertical()</code>同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>
<li><code>getViewVerticalDragRange()</code>要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>
<li><code>getViewHorizontalDragRange()</code>与<code>getViewVerticalDragRange()</code>同理，只不过是发生在水平方向上。</li>
</ul>
</li>
<li><p>在<code>onInterceptTouchEvent()</code>方法里调用并返回<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>方法</p>
</li>
<li><p>在<code>onTouchEvent()</code>方法里调用<code>ViewDragHelper()</code>的<code>processTouchEvent()</code>方法。<code>ACTION_DOWN</code>事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在<code>onTouchEvent()</code>返回<code>true</code>，否则将收不到后续事件，不会产生拖动。</p>
</li>
<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的<code>computeScroll()</code>方法，方法实现如下：</p>
<pre><code> @Override
 public void computeScroll() &#123;
     if (mDragHelper.continueSettling(true)) &#123;
         postInvalidate();
     &#125;
 &#125;
</code></pre>
<p>并在<code>ViewDragHelper.Callback</code>的<code>onViewReleased()</code>方法里调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>，或在任意地方调用<code>smoothSlideViewTo()</code>方法。</p>
</li>
<li><p>如果要实现边缘拖动的效果，需要调用<code>ViewDragHelper</code>的<code>setEdgeTrackingEnabled()</code>方法，注册想要监听的边缘。然后实现<code>ViewDragHelper.Callback</code>里的<code>onEdgeDragStarted()</code>方法，在此手动调用<code>captureChildView()</code>传递要拖动的子View。</p>
</li>
</ol>
<p>具体的使用Demo请见最后面公布的几个案例。</p>
<h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><p>ViewDragHelper的完整源码可在<a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java">GitHub</a>或<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol>
<li>了解View的坐标系统，<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a></li>
<li>了解MotionEvent中关于多点触控的机制，<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a></li>
<li>了解Scroller类原理，<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li>了解Touch事件的分发机制，<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>
</ol>
<h3 id="ViewDragHelper实例的创建"><a href="#ViewDragHelper实例的创建" class="headerlink" title="ViewDragHelper实例的创建"></a>ViewDragHelper实例的创建</h3><p><code>ViewDragHelper</code>重载了两个<code>create()</code>静态方法，先看两个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code>的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。<code>create()</code>直接调用了<code>ViewDragHelper</code>构造方法，我们再来看看这个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apps should use ViewDragHelper.create() to get a new instance.</span></span><br><span class="line"><span class="comment"> * This will allow VDH to use internal compatibility implementations for different</span></span><br><span class="line"><span class="comment"> * platform versions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parent view may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Callback may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mParentView = forParent;</span><br><span class="line">	mCallback = cb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">	mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">	mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">	mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">	mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">	mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过<code>create()</code>工厂方法来创建<code>ViewDragHelper</code>实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li><code>mParentView</code>和<code>mCallback</code>分别保存传递过来的对应参数</li>
<li><code>ViewConfiguration</code>类里定义了<code>View</code>相关的一系列时间、大小、距离等常量</li>
<li><code>mEdgeSize</code>表示边缘触摸的范围。例如<code>mEdgeSize</code>为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于<code>mParentView.getLeft() + mEdgeSize</code>时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见<code>ViewDragHelper</code>的<code>getEdgesTouched()</code>方法。</li>
<li><code>mTouchSlop</code>是一个很小的距离值，只有在前后两次触摸点的距离超过<code>mTouchSlop</code>的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>
<li><code>mMaxVelocity</code>、<code>mMinVelocity</code>是fling时的最大、最小速率，单位是像素每秒。</li>
<li><code>mScroller</code>是<code>View</code>滚动的辅助类，该类的详细解析参见下面几篇文章<ul>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html">Android中Scroller类的分析</a></li>
</ul>
</li>
</ul>
<p>再看三个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span></span><br><span class="line"><span class="comment"> *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">	helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">	<span class="keyword">return</span> helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数<code>sensitivity</code>是用来调节<code>mTouchSlop</code>的值。<code>sensitivity</code>越大，<code>mTouchSlop</code>越小，对滑动的检测就越敏感。例如<code>sensitivity</code>为1时，前后触摸点距离超过20dp才进行滑动处理，现在<code>sensitivity</code>为2的话，前后触摸点距离超过10dp就进行处理了。</p>
<h3 id="对Touch事件的处理"><a href="#对Touch事件的处理" class="headerlink" title="对Touch事件的处理"></a>对Touch事件的处理</h3><p>当<code>mParentView</code>（自定义ViewGroup）被触摸时，首先会调用<code>mParentView</code>的<code>onInterceptTouchEvent(MotionEvent ev)</code>，接着就调用<code>shouldInterceptTouchEvent(MotionEvent ev)</code> ，所以先来看看这个方法的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if this event as provided to the parent view&#x27;s onInterceptTouchEvent should</span></span><br><span class="line"><span class="comment"> * cause the parent to intercept the touch event stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看9~21行，首先是关于多点触控（<code>MotionEvent</code>的<code>actionIndex</code>、<code>ACTION_POINTER_DOWN </code>等概念），不明白的请参阅<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a>。</p>
<p><code>mVelocityTracker</code>记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生<code>ACTION_DOWN</code>事件都会调用<code>cancel()</code>，而在<code>cancel()</code>方法里<code>mVelocityTracker</code>又被清空了，所以<code>mVelocityTracker </code>记录下的是本次<code>ACTION_DOWN</code>事件直至<code>ACTION_UP</code>事件发生后（下次<code>ACTION_DOWN</code>事件发生前）的所有触摸点的信息。</p>
<p>再来看24~42行<code>case MotionEvent.ACTION_DOWN</code>部分，先是调用<code>saveInitialMotion(x, y, pointerId)</code>保存手势的初始信息，即<code>ACTION_DOWN</code>发生时的触摸点坐标（x、y）、触摸手指编号（<code>pointerId</code>），如果触摸到了<code>mParentView</code>的边缘还会记录触摸的是哪个边缘。接着调用<code>findTopChildUnder((int) x, (int) y);</code>来获取当前触摸点下最顶层的子View，看<code>findTopChildUnder </code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the topmost child under the given point within the parent view&#x27;s coordinate system.</span></span><br><span class="line"><span class="comment"> * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x X position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y Y position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">				y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">			<span class="keyword">return</span> child;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现<code>Callback</code>里的<code>getOrderedChildIndex(int index)</code>方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（<code>getOrderedChildIndex()</code>默认直接返回<code>index</code>），会选择到topView，要想让bottomView被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">	<span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">	<span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">		<span class="keyword">return</span> indexBottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32~35行，这里还看到了一个<code>mDragState</code>成员变量，它共有三种取值：</p>
<ol>
<li><code>STATE_IDLE</code>：所有的View处于静止空闲状态</li>
<li><code>STATE_DRAGGING</code>：某个View正在被用户拖动（用户正在与设备交互）</li>
<li><code>STATE_SETTLING</code>：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br><code>mCapturedView</code>默认为<code>null</code>，所以一开始不会执行这里的代码，<code>mDragState</code>处于<code>STATE_SETTLING</code>状态时才会执行<code>tryCaptureViewForDrag()</code>，执行的情况到后面再分析，这里先跳过。</li>
</ol>
<p>37~40行调用了<code>Callback.onEdgeTouched</code>向外部通知<code>mParentView</code>的某些边缘被触摸到了，<code>mInitialEdgesTouched</code>是在刚才调用过的<code>saveInitialMotion</code>方法里进行赋值的。</p>
<p><code>ACTION_DOWN </code>部分处理完了，跳过<code>switch</code>语句块，剩下的代码就只有<code>return mDragState == STATE_DRAGGING;</code>。在<code>ACTION_DOWN</code>部分没有对<code>mDragState</code>进行赋值，其默认值为<code>STATE_IDLE</code>，所以此处返回<code>false</code>。</p>
<p>那么返回<code>false</code>后接下来应该是会调用哪个方法呢，根据<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在<code>mParentView</code>的所有子View中寻找响应这个Touch事件的View（会调用每个子View的<code>dispatchTouchEvent()</code>方法，<code>dispatchTouchEvent</code>里一般又会调用<code>onTouchEvent()</code>）；</p>
<ul>
<li><p>如果没有子View消费这次事件（子View的<code>dispatchTouchEvent()</code>返回都是<code>false</code>），会调用<code>mParentView</code>的<code>super.dispatchTouchEvent(ev)</code>，即<code>View</code>中的<code>dispatchTouchEvent(ev)</code>，然后调用<code>mParentView</code>的<code>onTouchEvent()</code>方法，再调用<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>方法。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动（除了<code>ACTION_DOWN</code>外的其他事件发生时返回<code>true</code>或<code>false</code>都不会影响接下来的事件接受），因为拖动的相关代码是写在<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分的。要注意的是返回<code>true</code>后<code>mParentView</code>的<code>onInterceptTouchEvent()</code>就不会收到后续的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件了。</p>
</li>
<li><p>如果有子View消费了本次<code>ACTION_DOWN</code>事件，<code>mParentView</code>的<code>onTouchEvent()</code>就收不到<code>ACTION_DOWN</code>事件了，也就是<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>收不到<code>ACTION_DOWN</code>事件了。不过只要该View没有调用过<code>requestDisallowInterceptTouchEvent(true)</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分还是会执行的，如果在此时返回了<code>true</code>拦截了<code>ACTION_MOVE</code>事件，<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分也就会正常执行，拖动也就没问题了。<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分具体做了怎样的处理，稍后再来解析。</p>
</li>
</ul>
<p>接下来对这两种情况逐一解析。</p>
<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用<code>processTouchEvent(MotionEvent ev)</code>的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process a touch event received by the parent view. This method will dispatch callback events</span></span><br><span class="line"><span class="comment"> * as needed before returning. The parent view&#x27;s onTouchEvent implementation should call this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev The touch event received by the parent view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">			<span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">			<span class="comment">// Start immediately if possible.</span></span><br><span class="line">			tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跟<code>shouldInterceptTouchEvent()</code>里<code>ACTION_DOWN</code>那部分基本一致，唯一区别就是这里没有约束条件直接调用了<code>tryCaptureViewForDrag()</code>方法，现在来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to capture the view with the given pointer ID. The callback will be involved.</span></span><br><span class="line"><span class="comment"> * This will put us into the &quot;dragging&quot; state. If we&#x27;ve already captured this view with</span></span><br><span class="line"><span class="comment"> * this pointer this method will immediately return true without consulting the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCapture View to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pointerId Pointer to capture with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if capture was successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;</span><br><span class="line">		<span class="comment">// Already done!</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;</span><br><span class="line">		mActivePointerId = pointerId;</span><br><span class="line">		captureChildView(toCapture, pointerId);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>Callback</code>的<code>tryCaptureView(View child, int pointerId)</code>方法，把当前触摸到的View和触摸手指编号传递了过去，在<code>tryCaptureView()</code>中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在<code>tryCaptureView()</code>中返回<code>true</code>，让<code>ViewDragHelper</code>把当前触摸的View捕获下来，接着就调用了<code>captureChildView(toCapture, pointerId)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Capture a specific child view for dragging within the parent. The callback will be notified</span></span><br><span class="line"><span class="comment"> * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span></span><br><span class="line"><span class="comment"> * capture this view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childView Child view to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;captureChildView: parameter must be a descendant &quot;</span> +</span><br><span class="line">				<span class="string">&quot;of the ViewDragHelper&#x27;s tracked parent view (&quot;</span> + mParentView + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCapturedView = childView;</span><br><span class="line">	mActivePointerId = activePointerId;</span><br><span class="line">	mCallback.onViewCaptured(childView, activePointerId);</span><br><span class="line">	setDragState(STATE_DRAGGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，在<code>captureChildView(toCapture, pointerId)</code>中将要拖动的View和触摸的手指编号记录下来，并调用<code>Callback</code>的<code>onViewCaptured(childView, activePointerId)</code>通知外部有子View被捕获到了，再调用<code>setDragState()</code>设置当前的状态为<code>STATE_DRAGGING</code>，看<code>setDragState()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">		mDragState = state;</span><br><span class="line">		mCallback.onViewDragStateChanged(state);</span><br><span class="line">		<span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">			mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态改变后会调用<code>Callback</code>的<code>onViewDragStateChanged()</code>通知状态的变化。</p>
<p>假设<code>ACTION_DOWN</code>发生后在<code>mParentView</code>的<code>onTouchEvent()</code>返回了<code>true</code>，接下来就会执行<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);</span><br><span class="line"></span><br><span class="line">				dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</span><br><span class="line"></span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">					reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">					<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">						<span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">					<span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">							tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断<code>mDragState</code>是否为<code>STATE_DRAGGING</code>，而唯一调用<code>setDragState(STATE_DRAGGING)</code>的地方就是<code>tryCaptureViewForDrag()</code>了，刚才在<code>ACTION_DOWN</code>里调用过<code>tryCaptureViewForDrag()</code>，现在又要分两种情况。<br>如果刚才在<code>ACTION_DOWN</code>里捕获到要拖动的View，那么就执行<code>if</code>部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，<code>mDragState</code>依然是<code>STATE_IDLE</code>，然后会执行<code>else</code>部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让<code>mDragState</code>变为<code>STATE_DRAGGING</code>，之后就会执行<code>if</code>部分的代码了。这里还有两个方法涉及到了<code>Callback</code>里的方法，需要来解析一下，分别是<code>reportNewEdgeDrags()</code>和<code>checkTouchSlop()</code>，先看<code>reportNewEdgeDrags()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_LEFT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_TOP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_RIGHT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">		mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">		mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在<code>mEdgeDragsInProgress</code>中，再调用<code>Callback</code>的<code>onEdgeDragStarted(int edgeFlags, int pointerId)</code>通知某个边缘开始产生拖动了。虽然<code>reportNewEdgeDrags()</code>会被调用很多次（因为<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分会执行很多次），但<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code>只会调用一次，具体的要看<code>checkNewEdgeDrag()</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">			(mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;</span><br><span class="line">		mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>checkNewEdgeDrag()</code>返回<code>true</code>表示在指定的<code>edge</code>（边缘）开始产生拖动了。</li>
<li>方法的两个参数<code>delta</code>和<code>odelta</code>需要解释一下，<code>odelta</code>里的o应该代表opposite，这是什么意思呢，以<code>reportNewEdgeDrags()</code>里调用<code>checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)</code>为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里<code>delta</code>为<code>dx</code>，<code>odelta</code>为<code>dy</code>，也就是说<code>delta</code>是指我们主要监测的方向上的变化，<code>odelta</code>是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>
<li><code>mInitialEdgesTouched</code>是在<code>ACTION_DOWN</code>部分的<code>saveInitialMotion()</code>里生成的，<code>ACTION_DOWN</code>发生时触摸到的边缘会被记录在<code>mInitialEdgesTouched</code>中。如果<code>ACTION_DOWN</code>发生时没有触摸到边缘，或者触摸到的边缘不是指定的<code>edge</code>，就直接返回false了。</li>
<li><code>mTrackingEdges</code>是由<code>setEdgeTrackingEnabled(int edgeFlags)</code>设置的，当我们想要追踪监听边缘触摸时才需要调用<code>setEdgeTrackingEnabled(int edgeFlags)</code>，如果我们没有调用过它，这里就直接返回<code>false</code>了。</li>
<li><code>mEdgeDragsLocked</code>它在这个方法里被引用了多次，它在整个<code>ViewDragHelper</code>里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行<code>mEdgeDragsLocked[pointerId] &amp; edge) == edge</code>执行的结果是<code>false</code>。我们再跳到11到14行看看，<code>absDelta &lt; absODelta * 0.5f</code>的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用<code>Callback</code>的<code>onEdgeLock(edge)</code>检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在<code>mEdgeDragsInProgress</code>里了，也不会收到<code>Callback</code>的<code>onEdgeDragStarted()</code>通知了。并且将锁定的边缘记录在<code>mEdgeDragsLocked</code>变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的<code>edge</code>被锁定，就直接返回<code>false</code>了。</li>
<li>回到第7行的<code>(mEdgeDragsInProgress[pointerId] &amp; edge) == edge</code>，<code>mEdgeDragsInProgress</code>是保存已发生过拖动事件的边缘的，如果给定的<code>edge</code>已经保存过了，那就没必要再检测其他东西了，直接返回<code>false</code>了。</li>
<li>第8行<code>(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)</code>很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>
<li>最后一句返回的时候再次检查给定的<code>edge</code>有没有记录过，确保了每个边缘只会调用一次<code>reportNewEdgeDrags</code>的<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code></li>
</ul>
<p>再来看<code>checkTouchSlop()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if we&#x27;ve crossed a reasonable touch slop for the given child view.</span></span><br><span class="line"><span class="comment"> * If the child cannot be dragged along the horizontal or vertical axis, motion</span></span><br><span class="line"><span class="comment"> * along that axis will not count toward the slop check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx Motion since initial position along X axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the touch slop has been crossed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（<code>mTouchSlop</code>）了，注意<code>dx</code>和<code>dy</code>指的是当前触摸点到<code>ACTION_DOWN</code>触摸到的点的距离。这里先检查<code>Callback</code>的<code>getViewHorizontalDragRange(child)</code>和<code>getViewVerticalDragRange(child)</code>是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分就不会调用<code>tryCaptureViewForDrag()</code>来捕获当前触摸到的View了，拖动也就没办法进行了。</p>
<p>回到<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了<code>Callback</code>中的相关方法，让<code>tryCaptureViewForDrag()</code>正常的捕获到触摸到的View了，下一次<code>ACTION_MOVE</code>时就执行<code>if</code>部分的代码了，也就是开始不停的调用<code>dragTo()</code>对<code>mCaptureView</code>进行真正拖动了，看<code>dragTo()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clampedX = left;</span><br><span class="line">	<span class="keyword">int</span> clampedY = top;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</span><br><span class="line">		mCapturedView.offsetLeftAndRight(clampedX - oldLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</span><br><span class="line">		mCapturedView.offsetTopAndBottom(clampedY - oldTop);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">		mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">				clampedDx, clampedDy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>dx</code>和<code>dy</code>是前后两次<code>ACTION_MOVE</code>移动的距离，<code>left</code>和<code>top</code>分别为<code>mCapturedView.getLeft() + dx</code>, <code>mCapturedView.getTop() + dy</code>，也就是期望的移动后的坐标，对<code>View</code>的<code>getLeft()</code>等方法不理解的请参阅<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>
<p>这里通过调用<code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>来完成对<code>mCapturedView</code>移动，这两个是<code>View</code>中定义的方法，看它们的源码就知道内部是通过改变<code>View</code>的<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>、<code>mBottom</code>，即改变<code>View</code>在父容器中的坐标位置，达到移动<code>View</code>的效果，所以如果调用<code>mCapturedView</code>的<code>layout(int l, int t, int r, int b)</code>方法也可以实现移动<code>View</code>的效果。</p>
<p>具体要移动到哪里，由<code>Callback</code>的<code>clampViewPositionHorizontal()</code>和<code>clampViewPositionVertical()</code>来决定的，如果不想在水平方向上移动，在<code>clampViewPositionHorizontal(View child, int left, int dx)</code>里直接返回<code>child.getLeft()</code>就可以了，这样<code>clampedX - oldLeft</code>的值为0，这里调用<code>mCapturedView.offsetLeftAndRight(clampedX - oldLeft)</code>就不会起作用了。垂直方向上同理。</p>
<p>最后会调用<code>Callback</code>的<code>onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)</code>通知捕获到的View位置改变了，并把最终的坐标（<code>clampedX</code>、<code>clampedY</code>）和最终的移动距离（<code>clampedDx</code>、 <code>clampedDy</code>）传递过去。</p>
<p><code>ACTION_MOVE</code>部分就算告一段落了，接下来应该是用户松手触发<code>ACTION_UP</code>，或者是达到某个条件导致后续的<code>ACTION_MOVE</code>被<code>mParentView</code>的上层View给拦截了而收到<code>ACTION_CANCEL</code>，一起来看这两个部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				releaseViewForPointerUp();</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下<code>releaseViewForPointerUp()</code>和<code>dispatchViewReleased()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releaseViewForPointerUp()</code>里也调用了<code>dispatchViewReleased()</code>，只不过传递了速率给它，这个速率就是由<code>processTouchEvent()</code>的<code>mVelocityTracker</code>追踪算出来的。再看<code>dispatchViewReleased()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like all callback events this must happen on the UI thread, but release</span></span><br><span class="line"><span class="comment"> * involves some extra semantics. During a release (mReleaseInProgress)</span></span><br><span class="line"><span class="comment"> * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">	mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">	mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">	mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">		<span class="comment">// onViewReleased didn&#x27;t call a method that would have changed this. Go idle.</span></span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>Callback</code>的<code>onViewReleased(mCapturedView, xvel, yvel)</code>通知外部捕获到的View被释放了，而在<code>onViewReleased()</code>前后有个<code>mReleaseInProgress</code>值得注意，注释里说唯一可以调用<code>ViewDragHelper</code>的<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方就是在<code>Callback</code>的<code>onViewReleased()</code>里了。</p>
<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（<code>flingCapturedView</code>的四个参数<code>int minLeft, int minTop, int maxLeft, int maxTop</code>可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用<code>settleCapturedViewAt(int finalLeft, int finalTop)</code>。</p>
<p>为什么唯一可以调用<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方是<code>Callback</code>的<code>onViewReleased()</code>呢？看看它们的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * The appropriate velocity from prior motion will be taken into account.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot settleCapturedViewAt outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view based on standard free-moving fling behavior.</span></span><br><span class="line"><span class="comment"> * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span></span><br><span class="line"><span class="comment"> * to continue the motion until it returns false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minLeft Minimum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minTop Minimum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLeft Maximum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxTop Maximum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot flingCapturedView outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法里一开始都会判断<code>mReleaseInProgress</code>为<code>false</code>，如果为<code>false</code>就会抛一个<code>IllegalStateException</code>异常，而<code>mReleaseInProgress</code>唯一为<code>true</code>的时候就是在<code>dispatchViewReleased()</code>里调用<code>onViewReleased()</code>的时候。</p>
<p><code>Scroller</code>的用法请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读<code>Scroller</code>源码，代码量不多。</p>
<p><code>ViewDragHelper</code>还有一个移动View的方法是<code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code>，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span></span><br><span class="line"><span class="comment"> * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child view to capture and animate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Final left position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Final top position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	mCapturedView = child;</span><br><span class="line">	mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If we&#x27;re in an IDLE state to begin with and aren&#x27;t moving anywhere, we</span></span><br><span class="line">		<span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">		mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> continueSliding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它不受<code>mReleaseInProgress</code>的限制，所以可以在任何地方调用，效果和<code>settleCapturedViewAt()</code>类似，因为它们最终都调用了<code>forceSettleCapturedViewAt()</code>来启动自动滚动，区别在于<code>settleCapturedViewAt()</code>会以最后松手前的滑动速率为初速度将View滚动到最终位置，而<code>smoothSlideViewTo()</code>滚动的初速度是0。<code>forceSettleCapturedViewAt()</code>里有地方调用了<code>Callback</code>里的方法，所以再来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Target top position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xvel Horizontal velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> yvel Vertical velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">		mScroller.abortAnimation();</span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">	mScroller.startScroll(startLeft, startTop, dx, dy, duration);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到自动滑动是靠<code>Scroll</code>类完成，在这里生成了调用<code>mScroller.startScroll()</code>需要的参数。再来看看计算滚动时间的方法<code>computeSettleDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">	<span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clampMag()</code>方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过<code>computeAxisDuration()</code>算出来，通过它的参数可以看到最终的滚动时间是由<code>dx</code>、<code>xvel</code>、<code>mCallback.getViewHorizontalDragRange()</code>共同影响的。看<code>computeAxisDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">			distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> duration;</span><br><span class="line">	velocity = Math.abs(velocity);</span><br><span class="line">	<span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">		duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6<del>10行没看明白，直接看14</del>19行，如果给定的速率<code>velocity</code>不为0，就通过距离除以速率来算出时间；如果<code>velocity</code>为0，就通过要滑动的距离（<code>delta</code>）除以总的移动范围（<code>motionRange</code>，就是<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过<code>MAX_SETTLE_DURATION</code>的，源码里的取值是600毫秒，所以不用担心在<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回错误的数而导致自动滚动时间过长了。</p>
<p>在调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>和<code>smoothSlideViewTo()</code>时，还需要实现<code>mParentView</code>的<code>computeScroll()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这属于<code>Scroll</code>类用法的范畴，不明白的请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>
<p>至此，整个触摸流程和<code>ViewDragHelper</code>的重要的方法都过了一遍。之前在讨论<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次<code>ACTION_DOWN</code>事件的情况，现在来看看这种情况。</p>
<p>假设现在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完了，也有子View消费了这次的<code>ACTION_DOWN</code>事件，那么接下来就会调用<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分，不明白为什么的请参阅<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">				<span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">					<span class="comment">// check the callback&#x27;s</span></span><br><span class="line">					<span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">					<span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">					<span class="comment">// would clamp to the same value. If you can&#x27;t move at</span></span><br><span class="line">					<span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">							targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">							(<span class="keyword">int</span>) dy);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">							toCapture);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">					<span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">							&amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">							|| verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">				<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">					<span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			saveLastMotion(ev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用<code>findTopChildUnder(int x, int y)</code>寻找触摸点处的子View，再用<code>checkTouchSlop(View child, float dx, float dy)</code>检查当前触摸点到<code>ACTION_DOWN</code>触摸点的距离是否达到了<code>mTouchSlop</code>，达到了才会去捕获View。<br>接着看19~41行<code>if (pastSlop)&#123;...&#125;</code>部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到<code>getView[Horizontal|Vertical]DragRange</code>和<code>clampViewPosition[Horizontal|Vertical]</code>四个方法。如果<code>getView[Horizontal|Vertical]DragRange</code>返回都是0，就会认作是不会产生拖动。<code>clampViewPosition[Horizontal|Vertical]</code>返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接<code>break</code>，不会执行后续的代码，而后续代码里有调用<code>tryCaptureViewForDrag()</code>，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的<code>tryCaptureViewForDrag()</code>捕获子View，如果捕获成功，<code>mDragState</code>就会变成<code>STATE_DRAGGING</code>，<code>shouldInterceptTouchEvent()</code>返回<code>true</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，后续的移动事件就会在<code>mParentView</code>的<code>onTouchEvent()</code>执行了，最后执行的就是<code>mParentView</code>的<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，拖动正常进行。</p>
<p>回头再看之前在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分留下的坑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他部分...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的<code>tryCaptureViewForDrag()</code>尝试捕获View，如果捕获成功，<code>mDragState</code>就变为<code>STATE_DRAGGING</code>了，<code>shouldInterceptTouchEvent()</code>就返回<code>true</code>了，然后就是<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，接着执行<code>mParentView</code>的<code>onTouchEvent()</code>，再执行<code>processTouchEvent()</code>的<code>ACTION_DOWN</code>部分。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动。</p>
<p>至此整个事件传递流程和<code>ViewDragHelper</code>的重要方法基本都解析完了，<code>shouldInterceptTouchEvent()</code>和<code>processTouchEvent()</code>的<code>ACTION_POINTER_DOWN</code>、<code>ACTION_POINTER_UP</code>部分就留给读者自己解析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>
<ul>
<li><p><a href="http://www.processon.com/view/link/5550a7bae4b09739f465ec64">单点触摸，没有考虑边缘滑动检测的最简流程图</a><br><img src="viewdraghelper-toucheventflow-basic.png"></p>
</li>
<li><p><a href="http://www.processon.com/view/link/5550d3dce4b09739f46789bd">单点触摸，考虑了边缘滑动检测的流程图</a><br><img src="viewdraghelper-toucheventflow-withedgetouch.png"></p>
</li>
</ul>
<p>多点触摸情况我就没研究了，在这里忽略~</p>
<p>三个开启自动滚动的方法：</p>
<ul>
<li><code>settleCapturedViewAt(int finalLeft, int finalTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code><br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>
</ul>
<p><code>Callback</code>的各个方法总结：</p>
<ul>
<li><p><code>void onViewDragStateChanged(int state)</code><br>拖动状态改变时会调用此方法，状态<code>state</code>有<code>STATE_IDLE</code>、<code>STATE_DRAGGING</code>、<code>STATE_SETTLING</code>三种取值。<br>它在<code>setDragState()</code>里被调用，而<code>setDragState()</code>被调用的地方有</p>
<ul>
<li><code>tryCaptureViewForDrag()</code>成功捕获到子View时<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分捕获到</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
</ul>
</li>
<li>调用<code>settleCapturedViewAt()</code>、<code>smoothSlideViewTo()</code>、<code>flingCapturedView()</code>时</li>
<li>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>、<code>ACTION_CANCEL</code>）</li>
<li>自动滚动停止时（<code>continueSettling()</code>里检测到滚动结束时）</li>
<li>外部调用<code>abort()</code>时</li>
</ul>
</li>
<li><p><code>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</code><br>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>
<ul>
<li>在<code>dragTo()</code>里被调用（正在被拖动时）</li>
<li>在<code>continueSettling()</code>里被调用（自动滚动时）</li>
<li>外部调用<code>abort()</code>时被调用</li>
</ul>
</li>
<li><p><code>void onViewCaptured(View capturedChild, int activePointerId)</code><br><code>tryCaptureViewForDrag()</code>成功捕获到子View时会调用此方法。</p>
<ul>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里成功捕获</li>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>手动调用<code>captureChildView()</code></li>
</ul>
</li>
<li><p><code>void onViewReleased(View releasedChild, float xvel, float yvel)</code><br>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>）或被父View拦截事件时（<code>processTouchEvent()</code>的<code>ACTION_CANCEL</code>）会调用此方法。</p>
</li>
<li><p><code>void onEdgeTouched(int edgeFlags, int pointerId)</code><br><code>ACTION_DOWN</code>或<code>ACTION_POINTER_DOWN</code>事件发生时如果触摸到监听的边缘会调用此方法。<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。</p>
</li>
<li><p><code>boolean onEdgeLock(int edgeFlags)</code><br>返回<code>true</code>表示锁定<code>edgeFlags</code>对应的边缘，锁定后的那些边缘就不会在<code>onEdgeDragStarted()</code>被通知了，默认返回<code>false</code>不锁定给定的边缘，<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>其中之一。</p>
</li>
<li><p><code>void onEdgeDragStarted(int edgeFlags, int pointerId)</code><br><code>ACTION_MOVE</code>事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。<code>edgeFlags</code>取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。可在此手动调用<code>captureChildView()</code>触发从边缘拖动子View的效果。</p>
</li>
<li><p><code>int getOrderedChildIndex(int index)</code><br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给<code>tryCaptureViewForDrag()</code>来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>
</li>
<li><p><code>int getViewHorizontalDragRange(View child)</code>、<code>int getViewVerticalDragRange(View child)</code><br>返回给定的<code>child</code>在相应的方向上可以被拖动的最远距离，默认返回0。<code>ACTION_DOWN</code>发生时，若触摸点处的<code>child</code>消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。<br>被调用的地方有三处：</p>
<ul>
<li>在<code>checkTouchSlop()</code>中被调用，返回值大于0才会去检查<code>mTouchSlop</code>。在<code>ACTION_MOVE</code>里调用<code>tryCaptureViewForDrag()</code>之前会调用<code>checkTouchSlop()</code>。如果<code>checkTouchSlop()</code>失败，就不会去捕获View了。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>
<li>在调用<code>smoothSlideViewTo()</code>时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在<code>getView[Horizontal|Vertical]DragRange</code>里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>
</ul>
</li>
<li><p><code>boolean tryCaptureView(View child, int pointerId)</code><br>在<code>tryCaptureViewForDrag()</code>中被调用，返回<code>true</code>表示捕获给定的<code>child</code>。<code>tryCaptureViewForDrag()</code>被调用的地方有</p>
<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
</ul>
</li>
<li><p><code>int clampViewPositionHorizontal(View child, int left, int dx)</code>、<code>int clampViewPositionVertical(View child, int top, int dy)</code><br><code>child</code>在某方向上被拖动时会调用对应方法，返回值是<code>child</code>移动过后的坐标位置，<code>clampViewPositionHorizontal()</code>返回<code>child</code>移动过后的left值，<code>clampViewPositionVertical()</code>返回<code>child</code>移动过后的top值。<br>两个方法被调用的地方有两处：</p>
<ul>
<li>在<code>dragTo()</code>中被调用，<code>dragTo()</code>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里被调用。用来获取被拖动的View要移动到的位置。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>
</ul>
</li>
</ul>
<h2 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h2><p>在这里列举一部分对<code>ViewDragHelper</code>的应用案例，大家自己剖析它们的源码来实践巩固。</p>
<ol>
<li><a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a>，这是最简单的Demo</li>
<li><a href="https://github.com/BlueMor/DragLayout">QQ5.x侧滑菜单</a>、<a href="https://github.com/kyze8439690/ResideLayout">ResideLayout</a></li>
<li><a href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a>、<a href="https://github.com/liuguangqiang/SwipeBack">SwipeBack</a></li>
<li><a href="https://github.com/umano/AndroidSlidingUpPanel">SlidingUpPanel</a></li>
<li><a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java">DrawerLayout</a></li>
</ol>
<h2 id="其他关于ViewDragHelper的分析文章"><a href="#其他关于ViewDragHelper的分析文章" class="headerlink" title="其他关于ViewDragHelper的分析文章"></a>其他关于ViewDragHelper的分析文章</h2><ul>
<li><a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a></li>
<li><a href="http://blog.csdn.net/pi9nc/article/details/39583377">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>
</ul>
<p>转载请注明出处</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>ViewDragHelper</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewDragHelper</tag>
      </tags>
  </entry>
</search>
