<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Activity启动流程</title>
    <url>/Android/Android%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Activity的启动流程是怎样的？"><a href="#Activity的启动流程是怎样的？" class="headerlink" title="Activity的启动流程是怎样的？"></a>Activity的启动流程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828194324.png"></p>
<h1 id="为什么Activity生命周期函数是运行在UI线程的"><a href="#为什么Activity生命周期函数是运行在UI线程的" class="headerlink" title="为什么Activity生命周期函数是运行在UI线程的?"></a>为什么Activity生命周期函数是运行在UI线程的?</h1><p>因为ActivityManagerService通过Binder通信给App进程的IApplicationThread这个Binder对象发送Activity生命周期的事件，而IApplicationThread是执行在Binder线程池中的，Activity生命周期函数需要执行在主线程，所以需要通过App进程的Handler转发一下，以执行在App进程的主线程。</p>
<h1 id="ApplicationThread的作用是什么？"><a href="#ApplicationThread的作用是什么？" class="headerlink" title="ApplicationThread的作用是什么？"></a>ApplicationThread的作用是什么？</h1><p>ApplicationThread是ActivityThread的内部类，继承ApplicationThreadNative,也是一个Binder对象。在此处它是作为IApplicationThread对象的server端等待client端的请求然后进行处理，最大的client就是AMS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    schedulePauseActivity()</span><br><span class="line">    scheduleStopActivity()</span><br><span class="line">    scheduleResumeActivity()</span><br><span class="line">    scheduleSendResult()</span><br><span class="line">    scheduleLaunchActivity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来它继承了ApplicationThreadNative的,并且它内部有非常多的scheduleXXX的方法，这些 schedulexxx的方法会进一步的通过往外发送消息给ActivityThread的mH这个消息队列来做处理。</p>
<h1 id="两个Activity相互跳转的生命周期？"><a href="#两个Activity相互跳转的生命周期？" class="headerlink" title="两个Activity相互跳转的生命周期？"></a>两个Activity相互跳转的生命周期？</h1><p>A Activity跳转到B Activity</p>
<p>A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop()</p>
<p>B Activity返回到A Activity</p>
<p>B.onPause() -&gt; A.onStart() -&gt; A.onResume() -&gt; B.onStop() -&gt; B.onDestroy()</p>
<p>一言以蔽之：</p>
<ol>
<li> 旧页面的onPause调用过后，才会调用新页面的onCreate</li>
<li> 要进入的页面的onResume调用后，才会调用之前页面的onStop</li>
</ol>
<h1 id="什么情况下Activity会重建？"><a href="#什么情况下Activity会重建？" class="headerlink" title="什么情况下Activity会重建？"></a>什么情况下Activity会重建？</h1><p>用户期望 Activity 的界面状态在整个配置变更（例如旋转或切换到多窗口模式）期间保持不变。但是，默认情况下，系统会在发生此类配置更改时销毁 Activity，从而清除存储在 Activity 实例中的任何界面状态。同样，如果用户暂时从您的应用切换到其他应用，并在稍后返回您的应用，他们也希望界面状态保持不变。但是，当用户离开应用且您的 Activity 停止时，系统可能会销毁该应用的进程。</p>
<h1 id="Activity重建的时候怎么保存和恢复参数？"><a href="#Activity重建的时候怎么保存和恢复参数？" class="headerlink" title="Activity重建的时候怎么保存和恢复参数？"></a>Activity重建的时候怎么保存和恢复参数？</h1><ol>
<li> onSaveInstance、onRestoreInstance方法，把对象序列化传递到Bundle对象中</li>
<li> 单例存储。</li>
<li> 数据持久化，重建后再读取。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity启动</tag>
        <tag>ApplicationThread</tag>
      </tags>
  </entry>
  <entry>
    <title>Android App启动流程</title>
    <url>/Android/Android%20App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Android系统启动流程是怎样的？"><a href="#Android系统启动流程是怎样的？" class="headerlink" title="Android系统启动流程是怎样的？"></a>Android系统启动流程是怎样的？</h1><p>当按电源键触发开机，首先会从 ROM 中预定义的地方加载引导程序 BootLoader 到 RAM 中，并执行 BootLoader 程序启动 Linux Kernel， 然后启动用户级别的第一个进程： init 进程。</p>
<p>init 进程会解析 init.rc 脚本做一些初始化工作，包括挂载文件系统、创建工作目录以及启动系统服务进程等，其中系统服务进程包括 Zygote、service manager、media 等。</p>
<p>在 Zygote 中会进一步去启动 system_server 进程，然后在 system_server 进程中会启动 AMS、WMS、PMS 等服务，等这些服务启动之后，AMS 中就会打开 Launcher 应用的 home Activity，最终就看到了手机的 “桌面”。</p>
<p>init.rc中引入了Zygote的启动脚本，Zygote的启动脚本存放在system/core/rootdir目录中，zygote的启动脚本其实也就是用app_process来启动一个java程序。</p>
<h1 id="SystemServer什么时候被启动？"><a href="#SystemServer什么时候被启动？" class="headerlink" title="SystemServer什么时候被启动？"></a>SystemServer什么时候被启动？</h1><p>android 29源码启动SystemServer流程：</p>
<p>init进程解析init.rc脚本</p>
<p>init.rc脚本中有执行app_process程序的代码。</p>
<p>service zygote /system/bin/app_process32 -Xzygote /system/bin –zygote –start-system-server –socket-name=zygote</p>
<p>app_process是启动java程序用的，没有指定要运行的类名，还是会走app_process的main方法，源码如下：</p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp">https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp</a></p>
<p>main方法中识别到–zygote参数会执行com.android.internal.os.ZygoteInit的Java类的main方法。</p>
<p>识别到–start-system-server的参数，会执行forkSystemServer方法启动系统服务进程。</p>
<p>得到系统服务进程的pid后，执行ZygoteInit的handleSystemServerProcess() -&gt;ZygoteInit.zygoteInit() -&gt; RuntimeInit.applicationInit() -&gt; findStaticMain()，最后得到MethodAndArgsCaller，是一个Runnable，返回给ZygoteInit的main()中调用forkSystemServer()的地方执行run()。</p>
<p>MethodAndArgsCaller的run()里通过反射按照给定参数执行给定的方法，方法是main，是哪个类的main方法？类名是在ZygoteInit的forkSystemServer()指定的，类名是com.android.server.SystemServer。</p>
<h1 id="Launcher中点击App图标后，App启动流程是怎样的？"><a href="#Launcher中点击App图标后，App启动流程是怎样的？" class="headerlink" title="Launcher中点击App图标后，App启动流程是怎样的？"></a>Launcher中点击App图标后，App启动流程是怎样的？</h1><p>以下时序图基于Android 9.0源码。</p>
<h2 id="Launcher向AMS发起startActivity请求"><a href="#Launcher向AMS发起startActivity请求" class="headerlink" title="Launcher向AMS发起startActivity请求"></a>Launcher向AMS发起startActivity请求</h2><p>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程的ActivityManagerService发起startActivity请求。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192213.png"></p>
<h2 id="zygote进程创建App进程"><a href="#zygote进程创建App进程" class="headerlink" title="zygote进程创建App进程"></a>zygote进程创建App进程</h2><p>system_server进程的AMS接收到请求后，向zygote进程发送创建进程的请求</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192228.png"></p>
<h2 id="Zygote进程fork出新的子进程"><a href="#Zygote进程fork出新的子进程" class="headerlink" title="Zygote进程fork出新的子进程"></a>Zygote进程fork出新的子进程</h2><p>即App进程。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192241.png"></p>
<h2 id="App进程运行ActivityThread-main"><a href="#App进程运行ActivityThread-main" class="headerlink" title="App进程运行ActivityThread.main()"></a>App进程运行ActivityThread.main()</h2><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192256.png"></p>
<h2 id="App进程跨进程绑定ApplicationThread给系统进程的AMS"><a href="#App进程跨进程绑定ApplicationThread给系统进程的AMS" class="headerlink" title="App进程跨进程绑定ApplicationThread给系统进程的AMS"></a>App进程跨进程绑定ApplicationThread给系统进程的AMS</h2><p>AMS做好准备工作后，让App进程创建Application实例，并调用Application的onCreate()。</p>
<p><strong>为什么要绑定ApplicationThread给AMS？</strong></p>
<p>ActivityThread.attach()里调用IActivityManager.attachApplication()会把当前ActivityThread实例里的ApplicationThread实例对象传递给AMS，AMS把App进程的ApplicationThread存在ProcessRecord的thread属性中</p>
<p><strong>ApplicationThread是什么？</strong></p>
<p>ApplicationThread是一个IBinder对象，是给system_server进程中的AMS要发送数据给App进程时用的，这属于跨进程通信。</p>
<p>AMS保存了App进程的ApplicationThread后，经过一系列准备，最终调用App进程ActivityThread的handleBindApplication()，这里会调用mInstrumentation.callApplicationOnCreate()</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192310.png"></p>
<h2 id="AMS发送启动Activity的请求"><a href="#AMS发送启动Activity的请求" class="headerlink" title="AMS发送启动Activity的请求"></a>AMS发送启动Activity的请求</h2><p>在ActivityManagerService的attachApplication方法中调用了attachApplicationLocked进行绑定，从上面代码可以发现attachApplicationLocked中有两个重要的方法：thread.bindApplication和mStackSupervisor.attachApplicationLocked(app)。thread.bindApplication中的thread其实就是ActivityThread里ApplicationThread对象在AMS的代理对象，故此方法将最终调用ApplicationThread的bindApplication方法。而mStackSupervisor.attachApplicationLocked(app)主要是AMS启动Activity的作用。</p>
<p>在realStartActivityLocked方法中，创建了ClientTransaction对象并将App进程的ApplicationThread传递进去，接着为ClientTransaction对象添加LaunchActivityItem的callback，最终调用ClientLifecycleManager.scheduleTransaction()启动activity。</p>
<p>ClientLifecycleManager.scheduleTransaction()内部调用了App进程的ApplicationThread的scheduleTransaction(ClientTransaction)，该方法实际调用了ActivityThread的scheduleTransaction(ClientTransaction)</p>
<p>ClientTransactionHandler是ActivityThread的父类，所以下面时序图的ClientTransactionHandler代表ActivityThread，H是ActivityThread内部的Handler</p>
<p>ActivityThread的scheduleTransaction(ClientTransaction)向ActivityThread的Handler发送EXECUTE_TRANSACTION的消息，处理Activity的启动。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828192520.png"></p>
<h2 id="ActivityThread的Handler处理启动Activity的请求"><a href="#ActivityThread的Handler处理启动Activity的请求" class="headerlink" title="ActivityThread的Handler处理启动Activity的请求"></a>ActivityThread的Handler处理启动Activity的请求</h2><p>ActivityThread的Handler对EXECUTE_TRANSACTION的消息处理主要是执行TransactionExecutor.execute(ClientTransaction)</p>
<p>TransactionExecutor.execute(ClientTransaction)主要是执行</p>
<p>executeCallbacks(transaction)</p>
<p>executeLifecycleState(transaction)</p>
<p>executeCallbacks()中会取出ClientTransaction的callbacks，对callbacks列表的每一项item执行execute()，callbacks每一项的类型为ClientTransactionItem</p>
<p><strong>ClientTransaction的callbacks在哪添加的？</strong></p>
<p>AMS的ActivityStackSupervisor的realStartActivityLocked()中添加的LaunchActivityItem。</p>
<p>LaunchActivityItem的execute()中会调用ActivityThread的。handleLaunchActivity()，然后调用performLaunchActivity()，在这里通过Instrumentation.newActivity()创建Activity实例，然后调用Activity的onCreate()。</p>
<p><strong>executeLifecycleState()做了什么？</strong></p>
<p>获取ClientTransaction的getLifecycleStateRequest()，做Activity生命周期的回调。</p>
<p>Activity的onStart()、onResume()是在这里触发的。</p>
<p>具体看源码。</p>
<p><strong>ClientTransaction的mLifecycleStateRequest是在哪设置的？</strong></p>
<p>AMS的ActivityStackSupervisor的realStartActivityLocked()中创建了ResumeActivityItem，通过clientTransaction.setLifecycleStateRequest(lifecycleItem)设置添加。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ApplicationThread</tag>
        <tag>App启动</tag>
        <tag>Zygote</tag>
        <tag>AMS</tag>
        <tag>app_process</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Binder机制</title>
    <url>/Android/Android%20Binder%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Binder机制概述"><a href="#Binder机制概述" class="headerlink" title="Binder机制概述"></a>Binder机制概述</h1><p>Android是基于Linux的，Linux的进程之间的内存地址空间是相互隔离的，进程之间无法直接访问对方的数据，这就需要有一个进程之间都可以访问的地方做数据交换，这就是内核空间。</p>
<p>传统的Linux跨进程通信机制下，通常是进程A把数据复制到内核中的一个缓冲区中，进程B从内核的缓冲区中读取数据。</p>
<p>Binder进程间通信机制自然也是要通过内核空间来进行的，但是又不是传统的Linux通信机制，怎么样去在内核中做一些操作呢？Linux有一个动态内核可加载模块，Binder就是加载了 Binder驱动  模块，来在内核中做一些操作，实现跨进程通信。</p>
<h2 id="Binder驱动具体做了什么呢-？"><a href="#Binder驱动具体做了什么呢-？" class="headerlink" title="Binder驱动具体做了什么呢  ？"></a>Binder驱动具体做了什么呢  ？</h2><p>Binder驱动在内核空间中创建一个数据缓冲区，再通过内存映射机制，把缓冲区与数据接受进程用户空间地址做映射，这样数据发送进程的数据把数据拷贝到内核缓冲区过后，数据接受进程就可以直接  获取到数据，避免了一次内核空间的数据拷贝，提高了性能。</p>
<h2 id="Binder机制还保证了进程间通信的安全性。"><a href="#Binder机制还保证了进程间通信的安全性。" class="headerlink" title="Binder机制还保证了进程间通信的安全性。"></a>Binder机制还保证了进程间通信的安全性。</h2><p>传统进程通信机制缺乏足够的安全措施：在传统进程通信中，只能由发送进程在请求中自行填入UID与PID，容易被恶意程序利用，是不可靠的。只有内置在进程通信机制内的可靠的进程身份标记才能提供必要的安全保障，Android的应用程序有自己UID，可用于鉴别进程身份。</p>
<p>Binder机制为每个进程分配了UID/PID来作为鉴别身份的标识，并且在Binder通信时会根据UID/PID进行有效性检测。传统的进程通信方式对于通信双方的身份并没有做出严格的验证，如socket通信ip地址是客户端手动填入，容易出现伪造。</p>
<h2 id="Binder通信整体机制"><a href="#Binder通信整体机制" class="headerlink" title="Binder通信整体机制"></a>Binder通信整体机制</h2><ol>
<li> Server端向ServiceManager注册Binder对象，建立Binder名称和Binder引用的映射关系，这样Client端可以通过Binder名字获取Server中Binder实体的引用。在Android系统启动的时候，会初始化各种系统服务，这些系统服务会注册到ServiceManager。</li>
<li> Client通过名字从ServiceManager获取到Binder实体引用，通常获取到的是一个Proxy代理对象</li>
<li> Client调用代理对象的方法，代理对象会把要调用的方法的方法名称、参数等信息封装成Parcel对象，发送给Binder驱动</li>
<li> Server会读取Binder驱动中的请求数据，解包Parcel对象，并把结果也以Parcel对象的形式返回</li>
<li> 客户端发起Binder调用的时候会阻塞，服务端会有一个Binder线程池来响应处理客户端的请求</li>
<li> 全程使用代理模式屏蔽进程间通信细节</li>
</ol>
<h1 id="Binder的优势是什么？"><a href="#Binder的优势是什么？" class="headerlink" title="Binder的优势是什么？"></a>Binder的优势是什么？</h1><ol>
<li> 数据拷贝仅需一次，性能仅此于共享内存，优于管道、消息队列、套接字等通信方式</li>
<li> C/S架构比共享内存清晰</li>
<li> 传统IPC不做权限校验，由上层使用者自己实现，Binder做了权限控制</li>
</ol>
<h1 id="Binder的原理什么"><a href="#Binder的原理什么" class="headerlink" title="Binder的原理什么?"></a>Binder的原理什么?</h1><p>Binder是基于共享内存的，但是使用了mmap内存映射，只有一次用户空间到内核空间的拷贝，速度快。</p>
<p>在实际的实现中，binder 是作为一个特殊的字符型设备而存在的，设备节点为 /dev/binder, 其实现遵循linux设备驱动模型。</p>
<h1 id="Binder机制的安全性是如何保证的？"><a href="#Binder机制的安全性是如何保证的？" class="headerlink" title="Binder机制的安全性是如何保证的？"></a>Binder机制的安全性是如何保证的？</h1><p>传统进程通信机制缺乏足够的安全措施：</p>
<ul>
<li>传统进程通信的接收进程无法获得发送进程可靠的用户标识/进程标识（UID/PID），因而无法鉴别对方身份。</li>
<li>在传统进程通信中，只能由发送进程在请求中自行填入UID与PID，容易被恶意程序利用，是不可靠的。</li>
<li> 传统进程通信的访问接入点是公开的，如FIFO与unix domain socket的路径名，socket的ip地址与端口号，lSystem V键值等，知道这些接入点的任何程序都可能试图建立连接，很难阻止恶意程序获得连接，如通过猜测地址获得连接等。</li>
</ul>
<p>只有内置在进程通信机制内的可靠的进程身份标记才能提供必要的安全保障。<br>Android的应用程序有自己UID，可用于鉴别进程身份。</p>
<h1 id="Binder的异常传递机制是怎样的？"><a href="#Binder的异常传递机制是怎样的？" class="headerlink" title="Binder的异常传递机制是怎样的？"></a>Binder的异常传递机制是怎样的？</h1><p>可以推断所有Binder实体对象方法中发生的异常都会被处理。无非一种是将异常信息发送给对端进程，另一种是将异常信息在本进程输出。而这些处理都不会使Server进程退出。</p>
<p>仔细思考这样设计也是很合理的。作为Server进程，它在什么时候执行，该执行些什么都不由自己掌控，而是由Client进程控制。因此抛出异常本质上与Client进程相关，让一个Client进程的行为导致Server进程退出显然是不合理的。此外，Server进程可能关联着千百个Client，不能由于一个Client的错误行为而影响本可以正常获取服务的其他Client。</p>
<h1 id="系统服务和context-bindService-的方式有什么区别？"><a href="#系统服务和context-bindService-的方式有什么区别？" class="headerlink" title="系统服务和context.bindService()的方式有什么区别？"></a>系统服务和context.bindService()的方式有什么区别？</h1><p>服务可分为系统服务与普通服务，系统服务一般是在系统启动的时候，由SystemServer进程创建并注册到ServiceManager中的。而普通服务一般是通过ActivityManagerService启动的服务，或者说通过四大组件中的Service组件启动的服务。这两种服务在实现跟使用上是有不同的，主要从以下几个方面：</p>
<ul>
<li>服务的启动方式</li>
<li>服务的注册与管理</li>
<li>服务的请求使用方式</li>
</ul>
<h1 id="Binder缓冲区为什么大小是1MB？为什么不能更大？"><a href="#Binder缓冲区为什么大小是1MB？为什么不能更大？" class="headerlink" title="Binder缓冲区为什么大小是1MB？为什么不能更大？"></a>Binder缓冲区为什么大小是1MB？为什么不能更大？</h1><p>因为缓冲区会他通过mmap映射到用户进程的虚拟地址空间，内存映射的空间不能太大。</p>
<h1 id="Binder应用场景？"><a href="#Binder应用场景？" class="headerlink" title="Binder应用场景？"></a>Binder应用场景？</h1><ol>
<li>跨进程通信</li>
<li>跨进程观察者模式</li>
<li>App提权</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Handler机制</title>
    <url>/Android/Android%20Handler%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Handler消息机制是怎样的过程？"><a href="#Handler消息机制是怎样的过程？" class="headerlink" title="Handler消息机制是怎样的过程？"></a>Handler消息机制是怎样的过程？</h1><p>Looper.loop()流程：</p>
<ol>
<li><p> 通过MessageQueue.next() 取Message，没有消息就阻塞当前线程</p>
</li>
<li><p> 拿到Message返回给Looper.loop的调用处，调用Message绑定的Handler的dispatchMessage处理消息。</p>
</li>
<li><p> 处理结束又回到第1步，无限循环</p>
</li>
</ol>
<p>每个线程都有各自的Looper，每个Looper有一个MessageQueue</p>
<p>消息是链表，按时间when排序。</p>
<h1 id="等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？"><a href="#等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？" class="headerlink" title="等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？"></a>等待新消息阻塞线程和有新消息产生恢复线程的过程是怎样的？</h1><p>调用 MessageQueue.next() 方法的时候会调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。</p>
<p>当我们加入消息的时候，会调用 MessageQueue.enqueueMessage() 方法，添加完 Message 后，如果消息队列被阻塞，则会调用 Native 层的 nativeWake() 方法去唤醒。它通过向管道中写入一个消息，结束上述阻塞，触发上面提到的 nativePollOnce() 方法返回，好让加入的 Message 得到分发处理。</p>
<h1 id="Looper-loop-里面有死循环，为什么没有阻塞主线程？"><a href="#Looper-loop-里面有死循环，为什么没有阻塞主线程？" class="headerlink" title="Looper.loop()里面有死循环，为什么没有阻塞主线程？"></a>Looper.loop()里面有死循环，为什么没有阻塞主线程？</h1><p>loop()里会从消息队列取消息，取不到消息就阻塞当前线程，释放CPU给其他线程使用，有消息时会唤醒阻塞等待的线程。</p>
<h1 id="IdleHandler是干什么的？"><a href="#IdleHandler是干什么的？" class="headerlink" title="IdleHandler是干什么的？"></a>IdleHandler是干什么的？</h1><p>IdleHandler只有一个方法boolean queueIdle()。</p>
<p>此方法在MessageQueue.next()中调用，MessageQueue.next()又在Looper.loop()中调用。</p>
<p>queueIdle()调用时机：</p>
<p>当前消息队列没有可以处理的消息，进入空闲状态，在阻塞等待新的消息前（nativePollOnce方法会阻塞等待新消息），先调用IdleHandler的queueIdle()。</p>
<p>返回true表示下一轮处理完消息后还会回调。</p>
<p>返回false表示这是单次回调，这次回调后不会再回调了。</p>
<p>有新消息时系统会调用MessageQueue的enqueueMessage()，enqueueMessage()调用nativeWake()，唤醒线程。</p>
<p>可以向MessageQueue添加多个IdleHandler。</p>
<h1 id="IdleHandler有什么应用场景？"><a href="#IdleHandler有什么应用场景？" class="headerlink" title="IdleHandler有什么应用场景？"></a>IdleHandler有什么应用场景？</h1><p>可以作为View绘制完成的回调，做启动时间优化。</p>
<p>Activity的onCreate，onStart，onResume中耗时较短但非必要的代码可以放到IdleHandler中执行，减少启动时间。</p>
<p>Activity的onResume是在绘制View之前发生的。</p>
<p>因为在ActivityThread的handleResumeActivity()中，调用performResumeActivity()对应Activity的onResume()，然后调用wm.addView(decor,l)对应绘制。</p>
<h1 id="postDelayed-Runnable-r-long-delayMillis-是如何实现的？"><a href="#postDelayed-Runnable-r-long-delayMillis-是如何实现的？" class="headerlink" title="postDelayed(Runnable r, long delayMillis)是如何实现的？"></a>postDelayed(Runnable r, long delayMillis)是如何实现的？</h1><p>首先从消息池获取一个Message对象，将Runnable对象放入Message的callback属性中；</p>
<p>再通过当前时间和延迟时间计算Runnable执行的时间，调用MessageQueue的enqueueMessage()把消息插入消息链表，执行时间会存入Message对象的when属性中，消息链表是按Message的执行时间升序排序的，插入也会插入到符合顺序的位置。</p>
<h1 id="sendMessage-Message-msg-和post-Runnable-r-有什么区别？"><a href="#sendMessage-Message-msg-和post-Runnable-r-有什么区别？" class="headerlink" title="sendMessage(Message msg)和post(Runnable r)有什么区别？"></a>sendMessage(Message msg)和post(Runnable r)有什么区别？</h1><p>post()会将Runnable放入一个Message对象的callback属性中，还是会转换为Message，本质上没有区别，只不过post要写的参数更少，使用更方便。</p>
<h1 id="使用Handler有什么要注意的？"><a href="#使用Handler有什么要注意的？" class="headerlink" title="使用Handler有什么要注意的？"></a>使用Handler有什么要注意的？</h1><p>要避免内存泄露，自定义Handler要定义静态内部类，并且用弱引用引用外部对象，避免外部对象在消息池中一直被引用而不能垃圾回收进而导致内存泄露。</p>
<h1 id="quit和quitSafely的区别？"><a href="#quit和quitSafely的区别？" class="headerlink" title="quit和quitSafely的区别？"></a>quit和quitSafely的区别？</h1><p>quit() 和 quitSafely() 的本质就是让消息队列的 next() 返回 null，以此来退出Looper.loop()。</p>
<p>quit() 调用后直接终止 Looper，不在处理任何 Message，所有尝试把 Message 放进消息队列的操作都会失败，比如 Handler.sendMessage() 会返回 false，但是存在不安全性，因为有可能有 Message 还在消息队列中没来的及处理就终止 Looper 了。</p>
<p>quitSafely() 调用后会在所有消息都处理后再终止 Looper，所有尝试把 Message 放进消息队列的操作也都会失败。</p>
<h1 id="同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？"><a href="#同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？" class="headerlink" title="同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？"></a>同步消息和异步消息有什么区别？同步屏障（Barrier）是干什么的？</h1><p>Handler创建时可以传递一个async的布尔值参数，带这个参数的构造函数只有系统才能调用，我们创建Handler时async传的是false，通过Handler进行sendMessage或post都是同步消息，如果async传true，则通过Handler发送的都是异步消息。</p>
<p>Handler的sendMessage、post、postDelayed最终都会调用enqueueMessage，这里会判断如果构造Handler时的async传了true，就设置Message.setAsynchronous(true)。</p>
<p>同步消息和异步消息在没有往消息队列插入同步屏障时没有区别，插入同步屏障后，执行的优先级会有变化。</p>
<p>MessageQueue里的消息都是按照时间升序排序的，执行也是按时间由小到大的Message依次执行，如果有一个高优先级的消息需要立即执行，如果把新消息时间设置为当前时间，可能有好几个消息都是这样，原来的按时间顺序执行的机制就没办法保证执行的先后顺序，这就需要另外的机制来保证，即同步屏障机制。</p>
<p>同步屏障也是一个Message对象，但是没有target（没有绑定Handler），通过MessageQueue的postSyncBarrier(long when)方法向消息队列添加。</p>
<p>在MessageQueue的next()方法中，如果从消息队列取出的是同步屏障的Message（target==null），则从消息队列后面找一个异步消息来执行，如果没找到则一直阻塞等待异步消息。</p>
<p>应用场景：</p>
<p>app层无法调用同步屏障，在系统源码里有使用，如ViewRootImpl的schedualeTraversals，向MessageQueue中添加了内存屏障，保证了measure、layout、draw能够优于普通的Message而得到立即执行。</p>
<h1 id="为什么-View-post-里可以拿到-View-的宽高信息呢？"><a href="#为什么-View-post-里可以拿到-View-的宽高信息呢？" class="headerlink" title="为什么 View.post 里可以拿到 View 的宽高信息呢？"></a>为什么 View.post 里可以拿到 View 的宽高信息呢？</h1><p>View.post 和 Handler.post 的区别就是：</p>
<ol>
<li> 如果在 performTraversals 前调用 View.post，则会将消息进行保存，之后在 dispatchAttachedToWindow 的时候通过 ViewRootImpl 中的 Handler 进行调用。</li>
<li> 如果在 performTraversals 以后调用 View.post，则直接通过 ViewRootImpl 中的 Handler 进行调用。</li>
</ol>
<p>因为 View.post 的 Runnable 执行的时候，已经执行过 performTraversals 了，也就是 View 的 measure layout draw 方法都执行过了，自然可以获取到 View 的宽高信息了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
        <tag>Looper</tag>
        <tag>IdleHandler</tag>
        <tag>同步屏障</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Task</title>
    <url>/Android/Android%20Task/</url>
    <content><![CDATA[<p>在日常开发过程中，只要涉及到activity，那么对task相关的东西总会或多或少的接触到，不过对task相关的一些配置的作用理解的还不是很透彻，官方文档在细节上说的也不够清楚，要透彻理解还是得自己写demo实践检验，所以便有了这篇总结。</p>
<span id="more"></span>

<h2 id="task的概念"><a href="#task的概念" class="headerlink" title="task的概念"></a>task的概念</h2><p>参考<a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></p>
<h2 id="查看设备当前task的方法"><a href="#查看设备当前task的方法" class="headerlink" title="查看设备当前task的方法"></a>查看设备当前task的方法</h2><ul>
<li><a href="http://stackoverflow.com/questions/2442713/view-the-tasks-activity-stack">View the Task’s activity stack</a></li>
<li><a href="http://stackoverflow.com/a/22392616/2011291">Show Back Stack of Android</a></li>
</ul>
<h2 id="AndroidManifest中activity标签下和task有关的属性"><a href="#AndroidManifest中activity标签下和task有关的属性" class="headerlink" title="AndroidManifest中activity标签下和task有关的属性"></a>AndroidManifest中activity标签下和task有关的属性</h2><h3 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#aff">taskAffinity</a></h3><ul>
<li>此属性用来标记activity应该属于哪个task。</li>
<li>拥有相同affinity的activity从理论上属于同一个task（在用户的角度看来好像这些activity属于同一个应用），一个task的affinity是由其根activity的taskAffinity取值决定的。</li>
<li>affinity决定了两件事。<ul>
<li>一个是在使用allowTaskReparenting修饰activity时，activity要重新宿主到哪个task。</li>
<li>另一个是使用FLAG_ACTIVITY_NEW_TASK启动activity时，activity要放入哪个task。</li>
</ul>
</li>
<li>如果没有给activity设置taskAffinity，默认都会读取application标签下的taskAffinity属性值，如果application标签下也没有设置taskAffinity，那taskAffinity默认值就是manifest标签下设置的包名。</li>
<li>不仅可以给同一个应用的不同activity设置不同的affinity，也可以给不同应用的activity设置相同的affinity，使它们在用户角度看来好像属于同一个应用。</li>
</ul>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#lmode">launchMode</a></h3><p>launchMode有四种取值，与Intent里以<code>FLAG_ACTIVITY_</code>开头的flag结合，可以对activity的启动达到各种不同的效果。</p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>activity默认的启动模式，每次启动一个standard模式的activity时，都新建一个实例。</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>当前task栈顶存在本activity的实例，直接使用该实例，调用该activity的onNewIntent()，否则新建一个activity的实例入栈。</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>当启动一个singleTask模式的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。 </p>
<ul>
<li>如果存在，那么检查该task栈里是否存在该activity实例。<ul>
<li>如果存在，则将该task调入前台，销毁在该activity以上的activity，并调用该activity的onNewIntent()。</li>
<li>如果不存在，则新建一个该activity实例，并入栈。 </li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他activity，允许其他activity跟自己处于同一个task栈中，也允许其他activity重新宿主到本activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard。</p>
<ul>
<li>从B启动C，C是singleTask，C的affinity和A、B相同，C会进入taskA栈顶。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C相同，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C不同，D会进入新建的taskB中。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskB中，taskB的affinity为D的affinity。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
<li>从B启动C，C是singleTask，C的affinity和A、B不同，C会进入新建的taskB中。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B相同，D会进入taskA栈顶。<ul>
<li>从D启动C，taskB调入前台，放在taskA的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同但与C相同，D会进入新建的taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同且与C也不同，D会进入新建的taskC中。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskC中，taskC的affinity为D的affinity。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>当启动一个singleInstance的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。</p>
<ul>
<li>如果存在，检查这个task中是否存在该activity的实例。<ul>
<li>如果存在，则将该task调入前台，并调用该activity实例的onNewIntent()。</li>
<li>如果不存在，则新建一个task，再新建该activity实例放入新建的task中，系统允许多个相同affinity的task同时存在。</li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他任何activity，都会放到其他task中（新建task或者寻找已存在的task，即使要启动的activity与该activity具有相同的affinity），也不允许其他activity宿主到本task，该activity是task中唯一的activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard</p>
<ul>
<li>从B中启动C，C是singleInstance，C的affinity和A、B相同，C会放入新建的taskB中，taskA和taskB的affinity相同，因为两个task的根activity的affinity相同。<ul>
<li>从C中启动D，D的affinity和A、B、C相同。<ul>
<li>D是standard、singleTop、singleTask时，D会放入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA、taskB的affinity相同，因为三个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B、C不同，不论D是何种launchMode，D都会进入新建的taskC中，taskC的affinity是D的affinity。</li>
</ul>
</li>
<li>从B中启动C，C是singleInstance，C的affinity和A、B不同，C会放入新建的taskB中，taskA和taskB的affinity不同，因为两个task的根activity的affinity不同。<ul>
<li>从C中启动D，D的affinity和A、B相同。<ul>
<li>D是standard、singleTop、singleTask时，D都会进入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA的affinity相同，因为两个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B不同，不论和C是否相同，D都会进入新建的taskC中，因为C所在的task不允许其他activity的存在，taskC的affinity为D的affinity。</li>
</ul>
</li>
</ul>
<p>使用场景：<br>使用singleInstance时，尽量给此activity设置单独的taskAffinity，以保证此activity处于不同名的task中，这样在“最近应用”的列表中可以看到这个task。否则如果有相同task名称的task存在，在“最近应用”的列表中就看不到这个含有singleInstance的activity的task了，只能通过代码启动这个activity来切换回这个task中。<br>而两个不同的task在用户角度来看是两个不同的应用，也就是两种不同的功能，所以使用singleInstance的activity功能上要与其他activity的功能区别较大。并且singleInstance是单例，也就是这个activity是公用的，可以在其他地方启动它来重复使用（可以是被同一个应用的其他地方重复使用，也可以是被其他的应用重复使用）。<br>例如，UC浏览器中有一个可以浏览office文档的activity（launchMode为singleInstance，taskAffinity也是独立的），这显然不是浏览器的主要功能。在文件管理器中点击一个excel文件（或者word、ppt文档）的时候，可以选择使用UC浏览器的这个activity来打开它，并且从用户角度看起来这个activity和UC浏览器是两个不同的应用（在“最近应用”的列表中可以看出来）。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#reparent">allowTaskReparenting</a></h3><p>此属性为true的activity被启动后，若有和此activity相同affinity的task转入前台，则此activity会从启动它的task移动到具有相同affinity的这个task。</p>
<p>例如，现在有两个应用分别为appA和appB，appA中有三个activity分别为activityA1、activityA2、activityA3，其中activityA1、activityA2的taskAffinity为taskA，activityA3的taskAffinity为taskB，appB中有一个activity为activityB1，其taskAffinity为taskB。所有activity都是standard模式。<br>启动appA，默认启动activityA1，再依次启动activityA2、activityA3，此时这三个activity都属于taskA。<br>按home键回到launcher，此时这三个activity扔都属于taskA。</p>
<ul>
<li>此时若点击appA的图标启动appA，看到的是activityA2，activityA3会进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskA、Launcher所在的task、taskB。<ul>
<li>按home键回到launcher，点击appB的图标启动appB，taskB调入前台显示，看到的是activityA3，而不是activityB1。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。</li>
</ul>
</li>
<li>此时若点击appB的图标启动appB，看到的是activityA3，activityA3进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。taskB中还有activityB1在栈底部，在activityA3中按返回键可以回到activityB1。taskA中仅剩activityA1、activityA2。</li>
</ul>
<h3 id="alwaysRetainTaskState"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#always">alwaysRetainTaskState</a></h3><p>如果用户离开一个task已经很久了，系统会在某个时刻清理掉这个task中除了根activity外所有的activity。当用户再次回到这个task，只有根activity被恢复。这样做是因为长期离开一个task，用户很有可能已经放弃了他之前所做的事情，转而要开始做新的事情，所以只保留根activity。<br>若根activity上的alwaysRetainTaskState为true，强制保留本task中的所有activity，即使过了很长时间，也不让系统清理task。<br>例如浏览器打开了很多个tab页，长时间不操作后也要保证再次回来时还是上次浏览的页面。</p>
<h3 id="clearTaskOnLaunch"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#clear">clearTaskOnLaunch</a></h3><p>与alwaysRetainTaskState相反，若根activity上的clearTaskOnLaunch为true，不论何时用户再次从Launcher回到这个task时，除了根activity以外的其他activity都销毁。</p>
<h3 id="finishOnTaskLaunch"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#finish">finishOnTaskLaunch</a></h3><p>此属性为true的activity，不论何时用户再次回到这个activity所属的task时，此activity会被销毁。此属性优先级优于allowTaskReparenting。</p>
<h2 id="Intent中和task有关的部分flag"><a href="#Intent中和task有关的部分flag" class="headerlink" title="Intent中和task有关的部分flag"></a>Intent中和task有关的部分flag</h2><h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_NEW_TASK">FLAG_ACTIVITY_NEW_TASK</a></h3><p>和launchMode的属性值singleTask等效。如果一个Intent中包含此flag，尝试将要启动的activity放在一个新的task中，如果已经有一个task栈里存在目标activity的实例，将此task从后台调到前台来，调用已存在的activity实例的onNewIntent()方法。此flag不能用于startActivityForResult()。</p>
<h3 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_SINGLE_TOP">FLAG_ACTIVITY_SINGLE_TOP</a></h3><p>和launchMode的属性值singleTop等效。如果一个Intent中包含此属性，并且要启动的Activity就是当前的Activity（当前task栈顶activity），直接调用该activity的onNewIntent()，否则新建一个activity实例。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP">FLAG_ACTIVITY_CLEAR_TOP</a></h3><p>如果一个Intent中包含此属性，并且当前task栈存存在目标activity的实例，清除该实例上面的所有的activity。<br>如果目标activity的launcherMode为standard，且Intent没有添加FLAG_ACTIVITY_SINGLE_TOP标记，则会销毁目标activity再重新创建，否则会重用该实例，调用onNewIntent()。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET"><a href="#FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET" class="headerlink" title="FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET">FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</a></h3><p>如果一个Intent中包含此属性，则它转向的那个Activity以及在那个Activity其上的所有Activity都会在task重置时被清除出task，这只发生在task重置的时候，而从Launcher中点击应用图标启动应用的时候会发生task重置（从Launcher启动应用会在Intent中附带一个FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></li>
<li><a href="http://blog.csdn.net/ff20081528/article/details/17219951">Tasks and Back Stack中文翻译</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html">AndroidManifest中activity标签API Doc</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html">Intent API Doc</a></li>
<li><a href="http://blog.csdn.net/liuhe688/article/details/6761337">Activity的task相关</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Task</tag>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View Touch事件分发</title>
    <url>/Android/Android%20View%20Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<h1 id="事件是如何从屏幕点击最终到达-Activity-的？"><a href="#事件是如何从屏幕点击最终到达-Activity-的？" class="headerlink" title="事件是如何从屏幕点击最终到达 Activity 的？"></a>事件是如何从屏幕点击最终到达 Activity 的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828171545.png"></p>
<h1 id="CANCEL-事件什么时候会触发？"><a href="#CANCEL-事件什么时候会触发？" class="headerlink" title="CANCEL 事件什么时候会触发？"></a>CANCEL 事件什么时候会触发？</h1><ol>
<li> View 收到 ACTION_DOWN 事件以后，上一个事件还没有结束（可能因为 APP 的切换、ANR 等导致系统扔掉了后续的事件），这个时候会先执行一次 ACTION_CANCEL。</li>
<li> 子 View 之前拦截了事件，但是后面父 View 重新拦截了事件，这个时候会给子 View 发送 ACTION_CANCEL 事件。</li>
</ol>
<h1 id="如何解决滑动冲突？"><a href="#如何解决滑动冲突？" class="headerlink" title="如何解决滑动冲突？"></a>如何解决滑动冲突？</h1><ul>
<li>  通过重写父类的 onInterceptTouchEvent 来拦截滑动事件。</li>
<li>  通过在子类中调用 parent.requestDisallowInterceptTouchEvent 来通知父类是否要拦截事件。</li>
</ul>
<h1 id="Touch事件分发流程"><a href="#Touch事件分发流程" class="headerlink" title="Touch事件分发流程"></a>Touch事件分发流程</h1><p>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View.dispatchTouchEvent()</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828171640.png"></p>
<p>注意点：</p>
<ul>
<li>如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE、ACTION_UP事件都不会执行。</li>
<li>如果在最上层的View的onTouchEvent在DOWN时间返回true，虽然ViewGroup的onInterceptTouchEvent（）对DOWN事件返回了false，但后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent()</li>
<li>onInterceptTouchEvent（）一旦返回一次true，就再也不会被调用了。</li>
<li>当dispatchTouchEvent（）事件分发时，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP）</li>
<li>dispatchTouchEvent()、 onTouchEvent() 消费事件、终结事件传递（返回true）</li>
<li>onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Touch事件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View 绘制机制</title>
    <url>/Android/Android%20View%20%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="View绘制整个流程"><a href="#View绘制整个流程" class="headerlink" title="View绘制整个流程"></a>View绘制整个流程</h1><p>Activity走到onResume时，会调用ActivityThread的handleResumeActivity。</p>
<p>在这里会创建DecorView，通过WindowManager添加到PhoneWindow中。</p>
<p>这里也会创建ViewRootImpl，把DecorView的parent指定为ViewRootImpl。</p>
<p>再调用DecorView的requestLayout，requestLayout会层层的调用parent的requestLayout，最后走到ViewRootImpl的requestLayout。</p>
<p>然后走到ViewRootImpl.scheduleTraversals()，注册垂直同步监听。</p>
<p>当垂直同步信号来临时，去调用ViewRootImpl.doTraversal() .</p>
<p>再调用ViewRootImpl.performTraversals()，然后依次调用performMeasure()、performLayout()、performDraw()。</p>
<hr>
<p>View.invalidate()也会层层调用parent的invalidateChildInParent，最后调用到ViewRootImpl的invalidateChildInParent，然后调用ViewRootImpl.scheduleTraversals()。</p>
<p>等待垂直同步信号来临时，调用ViewRootImpl.doTraversal()，由于没有给View设置FORCE_LAYOUT的flag，所以不会走measure和layout，只会performDraw()，并且只绘制dirty区域。</p>
<h1 id="首次-View-的绘制流程是在什么时候触发的？"><a href="#首次-View-的绘制流程是在什么时候触发的？" class="headerlink" title="首次 View 的绘制流程是在什么时候触发的？"></a>首次 View 的绘制流程是在什么时候触发的？</h1><p>ActivityThread.handleResumeActivity 里触发的。</p>
<p>ActivityThread.handleResumeActivity 里会调用 wm.addView 来添加 DecorView，wm 是 WindowManagerImpl</p>
<p>最终通过 WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView -&gt; ViewRootImpl.setView -&gt; ViewRootImpl.requestLayout 就触发了第一次 View 的绘制。</p>
<h1 id="ViewRootImpl-创建的时机？"><a href="#ViewRootImpl-创建的时机？" class="headerlink" title="ViewRootImpl 创建的时机？"></a>ViewRootImpl 创建的时机？</h1><p>ActivityThread.handleResumeActivity -&gt; WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView  中创建ViewRootImpl</p>
<h1 id="DecorView的创建时机？"><a href="#DecorView的创建时机？" class="headerlink" title="DecorView的创建时机？"></a>DecorView的创建时机？</h1><p>ActivityThread.handleResumeActivity()中ActivityClientRecord.window.getDecorView();</p>
<p>PhoneWindow.getDecorView()调用installDecor() -&gt; generateDecor()去new DecorView()</p>
<h1 id="ViewRootImpl-和-DecorView-的关系是什么？"><a href="#ViewRootImpl-和-DecorView-的关系是什么？" class="headerlink" title="ViewRootImpl 和 DecorView 的关系是什么？"></a>ViewRootImpl 和 DecorView 的关系是什么？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172333.png"></p>
<p>在 ViewRootImpl.setView 里，通过 DecorView.assignParent 把 ViewRootImpl 设置为 DecorView 的 parent。</p>
<p>所以 ViewRootImpl 和 DecorView 的关系就是 ViewRootImpl 是 DecorView 的 parent。</p>
<p>因为 DecorView 是我们布局的顶层，现在我们就知道层层调用 requestLayout 等方法是怎么调用到 ViewRootImpl 里的了。</p>
<h1 id="Activity、PhoneWindow、DecorView、ViewRootImpl-的关系？"><a href="#Activity、PhoneWindow、DecorView、ViewRootImpl-的关系？" class="headerlink" title="Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？"></a>Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？</h1><ul>
<li>PhoneWindow 其实是 Window 的唯一子类，是 Activity 和 View 交互系统的中间层。</li>
<li>DecorView 是整个 View 层级的最顶层。</li>
<li>ViewRootImpl 是 DecorView 的 parent，但是他并不是一个真正的 View，只是继承了 ViewParent 接口，用来掌管 View 的各种事件，包括 requestLayout、invalidate、dispatchInputEvent 等等。</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172438.png"></p>
<h1 id="如何触发重新绘制？"><a href="#如何触发重新绘制？" class="headerlink" title="如何触发重新绘制？"></a>如何触发重新绘制？</h1><p>View的 requestLayout 和 invalidate</p>
<h1 id="View-requestLayout-流程？"><a href="#View-requestLayout-流程？" class="headerlink" title="View.requestLayout()流程？"></a>View.requestLayout()流程？</h1><p>层层调用 parent 的 requestLayout  ，一直到ViewRootImpl.requestLayout()</p>
<p>ViewRootImpl.requestLayout() 调用 scheduleTraversals() -&gt; doTraversal() -&gt; performTraversals() 开启绘制流程。</p>
<p>在 performTraversals 里，就是熟悉的 performMeasure -&gt; performLayout -&gt; performDraw 三个流程了。</p>
<p>在performDraw View 的绘制过程中，我们可以看到，只有 flag 被设置为 PFLAG_DIRTY_OPAQUE 才会进行绘制（这里划重点）。这也就是大家经常说的 requestLayout 不会引发 draw。</p>
<h1 id="View-invalidate-流程？"><a href="#View-invalidate-流程？" class="headerlink" title="View.invalidate()流程？"></a>View.invalidate()流程？</h1><p>invalidate -&gt; invalidateInternal  -&gt; parent.invalidateChild</p>
<p>invalidateChild的while 循环里，会层层计算 parent 的 dirty 区域，最终会调用到 ViewRootImpl.invalidateChildInParent -&gt; ViewRootImpl.invalidateRectOnScreen -&gt; ViewRootImpl.scheduleTraversals -&gt; ViewRootImpl.performDraw -&gt; ViewRootImpl.draw -&gt; DecorView的draw()</p>
<p>View.draw 方法，根据 PFLAG_DIRTY_OPAQUE flag 去决定是否重新绘制。</p>
<h1 id="requestLayout-和-invalidate-的区别？"><a href="#requestLayout-和-invalidate-的区别？" class="headerlink" title="requestLayout 和 invalidate 的区别？"></a>requestLayout 和 invalidate 的区别？</h1><p>requestLayout 和 invalidate 都会触发整个绘制流程。但是在 measure 和 layout 过程中，只会对 flag 设置为 FORCE_LAYOUT 的情况进行重新测量和布局，而 draw 只会重绘 flag 为 dirty 的区域。</p>
<p>requestLayout 是用来设置 FORCE_LAYOUT 标志，invalidate 用来设置 dirty 标志。所以 requestLayout 只会触发 measure 和 layout，invalidate 只会触发 draw。</p>
<h1 id="requestLayout-一定会触发onMeasure和onLayout吗？"><a href="#requestLayout-一定会触发onMeasure和onLayout吗？" class="headerlink" title="requestLayout 一定会触发onMeasure和onLayout吗？"></a>requestLayout 一定会触发onMeasure和onLayout吗？</h1><p>不一定。</p>
<p>ViewRootImpl.performMeasure，最终调用的是 View.measure。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172624.png"><br>measureSpec 和 oldMeasureSpec 不相符的时候才会onMeasure。</p>
<p>ViewRootImpl.performLayout()：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172646.png"><br>位置有变化才去onLayout。</p>
<h1 id="PFLAG-DIRTY-OPAQUE是什么意思？"><a href="#PFLAG-DIRTY-OPAQUE是什么意思？" class="headerlink" title="PFLAG_DIRTY_OPAQUE是什么意思？"></a>PFLAG_DIRTY_OPAQUE是什么意思？</h1><p>不透明，实心。</p>
<p>实心控件：控件的onDraw方法能够保证此控件的所有区域都会被其所绘制的内容完全覆盖。换句话说，通过此控件所属的区域无法看到此控件之下的内容，也就是既没有半透明也没有空缺的部分。</p>
<h1 id="什么时候View的flag-被设置为-PFLAG-DIRTY-OPAQUE？"><a href="#什么时候View的flag-被设置为-PFLAG-DIRTY-OPAQUE？" class="headerlink" title="什么时候View的flag 被设置为 PFLAG_DIRTY_OPAQUE？"></a>什么时候View的flag 被设置为 PFLAG_DIRTY_OPAQUE？</h1><p>invalidate 会调用 parent.invalidateChild，在这里被赋值的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828172722.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View绘制</tag>
        <tag>ViewRootImpl</tag>
        <tag>DecorView</tag>
        <tag>requestLayout()</tag>
        <tag>invalidate()</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Zygote</title>
    <url>/Android/Android%20Zygote/</url>
    <content><![CDATA[<h1 id="为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？"><a href="#为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？" class="headerlink" title="为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？"></a>为什么要用Zygote孵化一个进程？直接创建一个进程会有什么问题？</h1><p>Zygote 作为一个孵化器，可以提前加载一些资源，这样 fork() 时基于 Copy-On-Write 机制创建的其他进程就能直接使用这些资源，而不用重新加载。</p>
<span id="more"></span>

<p>比如 system_server 就可以直接使用 Zygote 中的 JNI 函数、共享库、常用的类、以及主题资源。</p>
<p>应用在启动的时候需要做很多准备工作，包括启动虚拟机，加载各类系统资源等等，这些都是非常耗时的，如果能在zygote里就给这些必要的初始化工作做好，子进程在fork的时候就能直接共享，那么这样的话效率就会非常高。</p>
<p>这个就是zygote存在的价值，这一点呢SystemServer是替代不了的，主要是因为SystemServer里跑了一堆系统服务，这些是不能继承到应用进程的。</p>
<p>而且我们应用进程在启动的时候，内存空间除了必要的资源外，最好是干干净净的，不要继承一堆乱七八糟的东西。</p>
<p>所以呢，不如给SystemServer和应用进程里都要用到的资源抽出来单独放在一个进程里，也就是这的zygote进程，然后zygote进程再分别孵化出SystemServer进程和应用进程。</p>
<p>孵化出来之后，SystemServer进程和应用进程就可以各干各的事了。</p>
<h1 id="Zygote预加载了那些资源？"><a href="#Zygote预加载了那些资源？" class="headerlink" title="Zygote预加载了那些资源？"></a>Zygote预加载了那些资源？</h1><p>Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：</p>
<ul>
<li>加载ZygoteInit类，注册Zygote Socket服务端套接字</li>
<li>加载虚拟机</li>
<li>提前加载类preloadClasses</li>
<li>提前加载资源preloadResouces</li>
</ul>
<p>ZygoteInit.preload()</p>
<p>preloadClasses()用来预加载类<br>会读取配置文件/system/etc/preloaded-classes，部分内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.android.internal.util.ParseUtils</span><br><span class="line">com.android.internal.util.Preconditions</span><br><span class="line">dalvik.system.CloseGuard</span><br><span class="line">dalvik.system.DalvikLogHandler</span><br><span class="line">java.io.ByteArrayInputStream</span><br><span class="line">java.io.ByteArrayOutputStream</span><br><span class="line">javax.crypto.AEADBadTagException</span><br><span class="line">javax.crypto.BadPaddingException</span><br><span class="line">org.ccil.cowan.tagsoup.ElementType</span><br><span class="line">org.json.JSONArray</span><br><span class="line">org.json.JSONException</span><br><span class="line">org.w3c.dom.Element</span><br><span class="line">org.w3c.dom.Node</span><br><span class="line">sun.misc.LRUCache</span><br><span class="line">sun.misc.Unsafe</span><br></pre></td></tr></table></figure>
<p>都是android sdk的类和java包类。</p>
<p>加载类的方式就是直接Class.forName()<br>// Load and explicitly initialize the given class. Use<br>// Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups<br>// (to derive the caller’s class-loader). Use true to force initialization, and<br>// null for the boot classpath class-loader (could as well cache the<br>// class-loader of this class in a variable).<br>Class.forName(line, true, null); </p>
<p>preloadResources()方法加载资源，加载过程就是调用一些Resources类的obtainTypedArray，然后遍历每项资源，调用Resources.getDrawable()，Resources的内部应该有缓存。</p>
<p>也就是framework.jar和framework-res.jar里的东西。</p>
<p>每一个app进程都应该公用这些东西，不应该重新加载一遍。</p>
<h2 id="system-framework-下的各种jar是什么时候加载的？在哪里指定加载的？"><a href="#system-framework-下的各种jar是什么时候加载的？在哪里指定加载的？" class="headerlink" title="/system/framework/下的各种jar是什么时候加载的？在哪里指定加载的？"></a>/system/framework/下的各种jar是什么时候加载的？在哪里指定加载的？</h2><p>在init.rc中export BOOTCLASSPATH</p>
<h1 id="Zygote进程启动流程"><a href="#Zygote进程启动流程" class="headerlink" title="Zygote进程启动流程"></a>Zygote进程启动流程</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828193745.png"></p>
<h1 id="Zygote-进程和SystemServer进程通信为什么不采用-Binder-而采用Socket？"><a href="#Zygote-进程和SystemServer进程通信为什么不采用-Binder-而采用Socket？" class="headerlink" title="Zygote 进程和SystemServer进程通信为什么不采用 Binder 而采用Socket？"></a>Zygote 进程和SystemServer进程通信为什么不采用 Binder 而采用Socket？</h1><p>原因是因为fork只能拷贝当前线程，不支持多线程的fork。</p>
<p>如果zygote使用binder的多线程模型与system_server进程进行通讯的话，fork()出的App进程的binder通讯没法用，那么只能再使用exec()启动一个新进程。</p>
<p>但是exec()启动的新进程不再包含zygote进程的信息，那这样的就失去了fork的作用了，fork的原理就是copy-on-write机制，zygote进程中已经启动了虚拟机、进行资源和类的预加载以及各种初始化操作，App进程用时拷贝即可。</p>
<p>所以最终zygote采用的方案就是socket + epoll，然后fork出子进程后再在子进程中启动binder线程池。</p>
<h1 id="fork为什么不允许多线程？"><a href="#fork为什么不允许多线程？" class="headerlink" title="fork为什么不允许多线程？"></a>fork为什么不允许多线程？</h1><p>fork() 时只会把调用线程拷贝到子进程、其他线程都会立即停止，那如果一个线程在 fork() 前占用了某个互斥量，fork() 后被立即停止，这个互斥量就得不到释放，再去请求该互斥量就会发生死锁了。</p>
<p>我们知道通过fork创建的一个子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈等。子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着子进程可以读写父进程中任何打开的文件，父进程和子进程之间最大的区别在于它们有着不同的PID。</p>
<p>但是有一点需要注意的是，在Linux中，fork的时候只复制当前线程到子进程，在<a href="http://linux.die.net/man/2/fork">fork(2)-Linux Man Page</a>中有着这样一段相关的描述：</p>
<p>The child process is created with a single thread–the one that called fork(). The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of pthread_atfork(3) may be helpful for dealing with problems that this can cause.</p>
<p>也就是说除了调用fork的线程外，其他线程在子进程中“蒸发”了。</p>
<p>这就是多线程中fork所带来的一切问题的根源所在了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Zygote</tag>
        <tag>fork()</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 动画原理</title>
    <url>/Android/Android%20%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="View-Animation原理"><a href="#View-Animation原理" class="headerlink" title="View Animation原理"></a>View Animation原理</h1><ol>
<li> 首先，当调用了 View.startAnimation() 时动画并没有马上就执行，而是通过 invalidate() 层层通知到 ViewRootImpl 发起一次遍历 View 树的请求，而这次请求会等到接收到最近一帧到了的信号时才去发起遍历 View 树绘制操作。</li>
<li> 从 DecorView 开始遍历，绘制流程在遍历时会调用到 View 的 draw() 方法，当该方法被调用时，如果 View 有绑定动画，那么会去调用applyLegacyAnimation()，这个方法是专门用来处理动画相关逻辑的。</li>
<li> 在 applyLegacyAnimation() 这个方法里，如果动画还没有执行过初始化，先调用动画的初始化方法 initialized()，同时调用 onAnimationStart() 通知动画开始了，然后调用 getTransformation() 来根据当前时间计算动画进度，紧接着调用 applyTransformation() 并传入动画进度来应用动画。</li>
<li> getTransformation() 这个方法有返回值，如果动画还没结束会返回 true，动画已经结束或者被取消了返回 false。所以 applyLegacyAnimation() 会根据 getTransformation() 的返回值来决定是否通知 ViewRootImpl 再发起一次遍历请求，返回值是 true 表示动画没结束，那么就去通知 ViewRootImpl 再次发起一次遍历请求。然后当下一帧到来时，再从 DecorView 开始遍历 View 树绘制，重复上面的步骤，这样直到动画结束。</li>
<li> 有一点需要注意，动画是在每一帧的绘制流程里被执行，所以动画并不是单独执行的，也就是说，如果这一帧里有一些 View 需要重绘，那么这些工作同样是在这一帧里的这次遍历 View 树的过程中完成的。每一帧只会发起一次 perfromTraversals() 操作。</li>
</ol>
<p>View Animation 是在绘制的时候，改变 view 的视觉效果来实现动画的。所以不会对 view 的测量和布局过程有影响。</p>
<p>View 的动画是通过触发绘制过程来执行 draw 的。因为动画是连续的，所以需要不停的触发。</p>
<h1 id="View-Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？"><a href="#View-Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？" class="headerlink" title="View Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？"></a>View Animation为什么移动位置后，点击事件的响应依旧是在原来位置上？</h1><p>因为动画是在 draw 时候形成的，也就是说只是视觉效果。其并没有改变它本身在父类中的位置；</p>
<h1 id="View-Animation中如果对-View-做放大缩小得动画，那么其宽度高度值是否会变化？"><a href="#View-Animation中如果对-View-做放大缩小得动画，那么其宽度高度值是否会变化？" class="headerlink" title="View Animation中如果对 View 做放大缩小得动画，那么其宽度高度值是否会变化？"></a>View Animation中如果对 View 做放大缩小得动画，那么其宽度高度值是否会变化？</h1><p>View Animation 是在绘制的时候，改变 view 的视觉效果来实现动画的。所以不会对 view 的测量和布局过程有影响。</p>
<h1 id="属性动画的原理"><a href="#属性动画的原理" class="headerlink" title="属性动画的原理"></a>属性动画的原理</h1><ol>
<li> ValueAnimator 属性动画调用了 start() 之后，会先去进行一些初始化工作，包括变量的初始化、通知动画开始事件；</li>
<li> 然后通过 AnimationHandler 将其自身 this 添加到 mAnimationCallbacks 队列里，AnimationHandller 是一个单例类，为所有的属性动画服务，列表里存放着所有正在进行或准备开始的属性动画；</li>
<li> 如果当前存在要运行的动画，那么 AnimationHandler 会去通过 Choreographer 向底层注册监听下一个屏幕刷新信号，当接收到信号时，它的 mFrameCallback 会开始进行工作，工作的内容包括遍历列表来分别处理每个属性动画在当前帧的行为，处理完列表中的所有动画后，如果列表还不为 0，那么它又会通过 Choreographer 再去向底层注册监听下一个屏幕刷新信号事件，如此反复，直至所有的动画都结束。</li>
<li> AnimationHandler 遍历列表处理动画是在 doAnimationFrame() 中进行，而具体每个动画的处理逻辑则是在各自，也就是 ValueAnimator 的 doAnimationFrame() 中进行，各个动画如果处理完自身的工作后发现动画已经结束了，那么会将其在列表中的引用赋值为空，AnimationHandler 最后会去将列表中所有为 null 的都移除掉，来清理资源。</li>
<li> 每个动画 ValueAnimator 在处理自身的动画行为时，首先，如果当前是动画的第一帧，那么会根据是否有”跳过片头”（setCurrentPlayTime()）来记录当前动画第一帧的时间 mStartTime 应该是什么。</li>
<li> 第一帧的动画其实也就是记录 mStartTime 的时间以及一些变量的初始化而已，动画进度仍然是 0，所以下一帧才是动画开始的关键，但由于属性动画的处理工作是在绘制界面之前的，那么有可能因为绘制耗时，而导致 mStartTime 记录的第一帧时间与第二帧之间隔得太久，造成丢了开头的多帧，所以如果是这种情况下，会进行 mStartTime 的修正。</li>
<li> 修正的具体做法则是当绘制工作完成后，此时，再根据当前时间与 mStartTime 记录的时间做比较，然后进行修正。</li>
<li> 如果是在动画过程中的某一帧才出现绘制耗时现象，那么，只能表示无能为力了，丢帧是避免不了的了，想要解决就得自己去分析下为什么绘制会耗时；而如果是在第一帧是出现绘制耗时，那么，系统还是可以帮忙补救一下，修正下 mStartTime 来达到避免丢帧。</li>
</ol>
<hr>
<ol>
<li> 当接收到屏幕刷新信号后，AnimationHandler 会去遍历列表，将所有待执行的属性动画都取出来去计算当前帧的动画行为。</li>
<li> 每个动画在处理当前帧的动画逻辑时，首先会先根据当前时间和动画第一帧时间以及动画的持续时长来初步计算出当前帧时动画所处的进度，然后会将这个进度值等价转换到 0-1 区间之内。</li>
<li> 接着，插值器会将这个经过初步计算之后的进度值根据设定的规则计算出实际的动画进度值，取值也是在 0-1 区间内。</li>
<li> 计算出当前帧动画的实际进度之后，会将这个进度值交给关键帧机制，来换算出我们需要的值，比如 ValueAnimator.ofInt(0, 100) 表示我们需要的值变化范围是从 0-100，那么插值器计算出的进度值是 0-1 之间的，接下去就需要借助关键帧机制来映射到 0-100 之间。</li>
<li> 关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。</li>
<li> 当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。</li>
<li> 如果有设置估值器，那么就按估值器的规则来进行映射。</li>
<li> 当关键帧超过两个时，需要先找到当前动画进度是落于哪两个关键帧之间，然后将这个进度值先映射到这两个关键帧之间的取值，接着就可以将这两个关键帧看成是第一帧和最后一帧，那么就可以按照只有两个关键帧的情况下的映射规则来进行计算了。</li>
<li> 而进度值映射到两个关键帧之间的取值，这就需要知道每个关键帧在整个关键帧组中的位置信息，或者说权重。而这个位置信息是在创建每个关键帧时就传进来的。onInt() 的规则是所有关键帧按等比例来分配权重，比如有三个关键帧，第一帧是 0，那么第二帧就是 0.5， 最后一帧 1。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>补间动画</tag>
        <tag>属性动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之Context、ContextImp、ContextWrapper</title>
    <url>/Android/Android%E4%B9%8BContext%E3%80%81ContextImp%E3%80%81ContextWrapper/</url>
    <content><![CDATA[<h1 id="Context、ContextImpl、ContextWrapper关系？"><a href="#Context、ContextImpl、ContextWrapper关系？" class="headerlink" title="Context、ContextImpl、ContextWrapper关系？"></a>Context、ContextImpl、ContextWrapper关系？</h1><ul>
<li>Context是行为的抽象接口。</li>
<li>ContextImpl是Android平台上的具体实现。</li>
<li>ContextWrapper是装饰器可以修改Context的行为而不修改原始的Context对象。<span id="more"></span></li>
</ul>
<h1 id="ContextWrapper装饰Context有什么具体场景？"><a href="#ContextWrapper装饰Context有什么具体场景？" class="headerlink" title="ContextWrapper装饰Context有什么具体场景？"></a>ContextWrapper装饰Context有什么具体场景？</h1><p>比如遇到Receiver的时候，ReceiverRestrictedContext就能够限制Receiver调用startService，让应用程序的Receiver不能够启动Service。通过实现装饰器，能够提供各种各样的装饰，并且也为Android应用程序组件提供了应用环境。</p>
<h1 id="Context类继承关系"><a href="#Context类继承关系" class="headerlink" title="Context类继承关系"></a>Context类继承关系</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828170109.png"></p>
<h1 id="ContextWrapper的mBase是哪个对象？ContextImpl的mOuterContext是哪个对象？"><a href="#ContextWrapper的mBase是哪个对象？ContextImpl的mOuterContext是哪个对象？" class="headerlink" title="ContextWrapper的mBase是哪个对象？ContextImpl的mOuterContext是哪个对象？"></a>ContextWrapper的mBase是哪个对象？ContextImpl的mOuterContext是哪个对象？</h1><ul>
<li>Activity通过ContextWrapper的成员mBase来引用了一个ContextImpl对象，这样，Activity组件以后就可以通过这个ContextImpl对象来执行一些具体的操作（启动Service等）。</li>
<li>同时ContextImpl类又通过自己的成员mOuterContext引用了与它关联的Activity，这样ContextImpl类也可以操作Activity。</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828170210.png"></p>
<h1 id="ContextThemeWrapper使用场景？"><a href="#ContextThemeWrapper使用场景？" class="headerlink" title="ContextThemeWrapper使用场景？"></a>ContextThemeWrapper使用场景？</h1><p>可以传一个主题样式id过来，用style中的各个属性，覆盖原有Context中的属性，在动态替换主题的时候会比较有用。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Context</tag>
        <tag>ContextImp</tag>
        <tag>ContextWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 签名机制</title>
    <url>/Android/Android%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="数字签名解决了什么？"><a href="#数字签名解决了什么？" class="headerlink" title="数字签名解决了什么？"></a>数字签名解决了什么？</h1><p>校验apk文件的完整性，检查是否有损坏或篡改。</p>
<h1 id="数字签名格式"><a href="#数字签名格式" class="headerlink" title="数字签名格式"></a>数字签名格式</h1><p>我们在对Apk签名时并没有直接指定私钥、公钥和数字证书，而是使用keystore文件，这些信息都包含在了keystore文件中。根据编码不同，keystore文件分为很多种，Android使用的是Java标准keystore格式JKS(Java Key Storage)，所以通过Android Studio导出的keystore文件是以.jks结尾的。</p>
<p>keystore使用的证书标准是X.509，X.509标准也有多种编码格式，常用的有两种：pem（Privacy Enhanced Mail）和der（Distinguished Encoding Rules）。jks使用的是der格式，Android也支持直接使用pem格式的证书进行签名。</p>
<h1 id="v1签名"><a href="#v1签名" class="headerlink" title="v1签名"></a>v1签名</h1><p>v1签名也就是jar签名机制</p>
<p>签名过程：</p>
<ol>
<li> 先对apk中每个文件用SHA-1哈希算法求得摘要，再用BASE64编码，将这些信息保存在apk解压后的META-INF目录下的MANIFEST.MF里。</li>
<li> 再对MANIFEST.MF整个文件以及MANIFEST.MF每个条目用SHA-1求得摘要，再用BASE64编码，存入META-INF/CERT.SF。</li>
<li> 对CERT.SF计算摘要，用Android签名文件中的私钥加密这个摘要，作为签名存入CERT.RSA</li>
</ol>
<p>MANIFEST.MF和CERT.SF保证apk数据的完整性，CERT.RSA从整体上保证了数据的完整性和来源可靠。</p>
<p>MANIFEST.MF和CERT.SF可能会被篡改，但最终CERT.RSA中的签名是由私钥加密生成的，没有私钥就不可能生成同样的签名。</p>
<p>CERT.RSA还存储了签名文件（keystore）的公钥，用于解密CERT.RSA中的签名，校验apk时，如果CERT.SF求得摘要后跟签名不一致，说明CERT.SF被篡改过。</p>
<p>v1签名缺点:</p>
<ol>
<li> META-INF不在校验访问，这样可以在这个目录下任意放置文件。</li>
<li> 每一个文件计算摘要，比较耗时。</li>
</ol>
<p>CERT.RSA中存储了什么？</p>
<p>签名文件的公钥、签名、签名算法、签名所有者信息。</p>
<h1 id="v2签名"><a href="#v2签名" class="headerlink" title="v2签名"></a>v2签名</h1><ul>
<li>v1签名验证的是每一个文件的完整性。</li>
<li>v2签名验证的是整个apk的字节流。</li>
</ul>
<p>APK签名信息存储在“APK签名分块”。</p>
<p>ZIP包原本的数据从头到尾分为三块：文件数据区、目录数据区、目录结尾数据区。</p>
<p>APK签名分块是位于文件数据区和目录数据区之间的，目录结尾数据区中记录了目录数据区的地址位置（也就是相当于开头的偏移量），加入APK签名分块后，仅需要修改目录数据区的地址，不影响ZIP其他原来的数据。</p>
<p>APK 签名方案 v2 负责保护第 1、3、4 部分的完整性，以及第 2 部分包含的“APK 签名方案 v2 分块”中的  signed data 分块的完整性。</p>
<p>优势：</p>
<ol>
<li> 对整个zip分块计算哈希摘要，计算量减少，同时可以并行，速度更快。</li>
<li> 验证了整个zip文件，不会漏校验zip中的数据。</li>
</ol>
<h1 id="v3签名"><a href="#v3签名" class="headerlink" title="v3签名"></a>v3签名</h1><p>android系统里不同的keystore签名的apk不能覆盖安装，但是keystore可能因为各种不可控的原因泄露了，按照这样的机制app的发布者就束手无策，别人就可以用恶意的apk覆盖安装发布者发布的正常的apk。如果能用新的keystore签名重新签名app，并能覆盖安装用旧的keystore签名的apk，就可以解决keystore泄露的问题了。</p>
<p>但是也不能让任意的keystore签名的apk可以覆盖安装任意apk，这样keystore签名就失去了校验开发者身份的功能，覆盖安装apk时，android系统得知道新的apk用的新的签名也是同一个发布者签上的，那怎样保证这点？</p>
<p>v3签名使用密钥轮转机制，让apk可以变更签名，在签名数据库新增了一个块，专门存储证书链，建立一个签名信任链，老的证书在前，新的证书在后，新的证书中的签名是由老的数字证书对应的keystore的私钥加密的，所以在覆盖安装apk时，就可以用旧apk中的老的数字证书中的公钥解密新的数字证书中的签名，得到新的数字证书的内容哈希摘要，再根据新证书中指明的哈希算法，计算新证书内容的哈希摘要，对比两个哈希摘要是否一致，一致则说明可信赖，可以覆盖安装。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView缓存机制</title>
    <url>/Android/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="RecyclerView的缓存分为四级"><a href="#RecyclerView的缓存分为四级" class="headerlink" title="RecyclerView的缓存分为四级"></a>RecyclerView的缓存分为四级</h1><ul>
<li>  Scrap</li>
<li>  Cache</li>
<li>  ViewCacheExtension</li>
<li>  RecycledViewPool<span id="more"></span></li>
</ul>
<h2 id="Scrap"><a href="#Scrap" class="headerlink" title="Scrap"></a>Scrap</h2><p>对应ListView 的Active View，就是屏幕内的缓存数据，就是相当于换了个名字，可以直接拿来复用。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>刚刚移出屏幕的缓存数据，默认大小是2个，当其容量被充满同时又有新的数据添加的时候，会根据FIFO原则，把优先进入的缓存数据移出并放到下一级缓存中，然后再把新的数据添加进来。</p>
<p>Cache里面的数据是干净的，也就是携带了原来的ViewHolder的所有数据信息，数据可以直接来拿来复用。</p>
<p>需要注意的是，cache是根据position来寻找数据的，这个postion是根据第一个或者最后一个可见的item的position以及用户操作行为（上拉还是下拉）。</p>
<p>举个栗子：当前屏幕内第一个可见的item的position是1，用户进行了一个下拉操作，那么当前预测的position就相当于（1-1=0），也就是position=0的那个item要被拉回到屏幕，此时RecyclerView就从Cache里面找position=0的数据，如果找到了就直接拿来复用。</p>
<h2 id="ViewCacheExtension"><a href="#ViewCacheExtension" class="headerlink" title="ViewCacheExtension"></a>ViewCacheExtension</h2><p>用户自定义的缓存策略。</p>
<p>用户没有定义的时候，将跳过。</p>
<h2 id="RecycledViewPool"><a href="#RecycledViewPool" class="headerlink" title="RecycledViewPool"></a>RecycledViewPool</h2><p>Cache默认的缓存数量是2个，当Cache缓存满了以后会根据FIFO（先进先出）的规则把Cache先缓存进去的ViewHolder移出并缓存到RecycledViewPool中，RecycledViewPool默认的缓存数量是5个。</p>
<p>RecycledViewPool与Cache相比不同的是，从Cache里面移出的ViewHolder再存入RecycledViewPool之前ViewHolder的数据会被全部重置，相当于一个新的ViewHolder，而且Cache是根据position来获取ViewHolder，而RecycledViewPool是根据itemType获取的，如果没有重写getItemType（）方法，itemType就是默认的。</p>
<p>因为RecycledViewPool缓存的ViewHolder是全新的，所以取出来的时候需要走onBindViewHolder（）方法。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle之Transform</title>
    <url>/Gradle/Gradle%E4%B9%8BTransform/</url>
    <content><![CDATA[<h1 id="AOP两种方式实现"><a href="#AOP两种方式实现" class="headerlink" title="AOP两种方式实现"></a>AOP两种方式实现</h1><ol>
<li> 通过gradle提供的transform api</li>
<li> 通过Java Instrument机制hook dx.jar，拦截gradle编译把class转为dex的过程</li>
</ol>
<p>参考</p>
<ul>
<li><a href="https://www.jianshu.com/p/c202853059b4">Android AOP之字节码插桩</a></li>
</ul>
<h1 id="Transform-API-有什么用？"><a href="#Transform-API-有什么用？" class="headerlink" title="Transform API 有什么用？"></a>Transform API 有什么用？</h1><p>transform拦截jar转为dex的过程。</p>
<p>jar转为dex时先经过transform处理。</p>
<p>jar -&gt; transform -&gt; dex</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825195255.png"></p>
<h1 id="Transform-API如何使用？"><a href="#Transform-API如何使用？" class="headerlink" title="Transform API如何使用？"></a>Transform API如何使用？</h1><p>参考</p>
<ul>
<li><a href="https://juejin.im/post/6844903831646502920">Android Transform + ASM 初探</a></li>
</ul>
<p>不管你修不修改输入，都必须要把类复制到指定的transform输出位置。</p>
<p>步骤：</p>
<ul>
<li>com.android.build.api.transform.Transform是android gradle plugin里的类，引用Transform需要先引入agp的依赖。<br>implementation(“com.android.tools.build:gradle:xxx”)</li>
<li>实现一个自定义的类继承Transform，然后将其注册到agp中即可。</li>
<li>注册到agp，先要获得android的扩展，通过project.extensions.findByType(BaseExtension::class.java)<br>来获取。</li>
<li>再调用BaseExtension中的registerTransform()添加自定义的Transform。</li>
</ul>
<p>一个通过自定义插件添加自定义Transform的示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        project.extensions.findByType(BaseExtension::<span class="keyword">class</span>.java)</span><br><span class="line">            ?.registerTransform(MyTransform())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> : <span class="type">Transform</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyTransform&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInputTypes</span><span class="params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getScopes</span><span class="params">()</span></span>: MutableSet&lt;<span class="keyword">in</span> QualifiedContent.Scope&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isIncremental</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(transformInvocation: <span class="type">TransformInvocation</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.transform(transformInvocation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Transform类中各方法的作用"><a href="#Transform类中各方法的作用" class="headerlink" title="Transform类中各方法的作用"></a>Transform类中各方法的作用</h1><h2 id="getName-String"><a href="#getName-String" class="headerlink" title="getName(): String"></a><code>getName(): String</code></h2><p>本Transform的名称</p>
<h2 id="getInputTypes-Set-lt-ContentType-gt"><a href="#getInputTypes-Set-lt-ContentType-gt" class="headerlink" title="getInputTypes(): Set&lt;ContentType&gt;"></a><code>getInputTypes(): Set&lt;ContentType&gt;</code></h2><ul>
<li>处理的输入类型</li>
<li>分为class文件或者java资源</li>
<li>class文件来自于jar或者文件夹</li>
<li>资源就是标准的java资源，默认约定位于src/main/resources目录下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DefaultContentType</span> <span class="keyword">implements</span> <span class="title">ContentType</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The content is compiled Java code. This can be in a Jar file or in a folder. If</span></span><br><span class="line"><span class="comment">       * in a folder, it is expected to in sub-folders matching package names.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      CLASSES(<span class="number">0x01</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The content is standard Java resources.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      RESOURCES(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getScopes-Set-lt-super-Scope-gt"><a href="#getScopes-Set-lt-super-Scope-gt" class="headerlink" title="getScopes(): Set&lt;? super Scope&gt;"></a><code>getScopes(): Set&lt;? super Scope&gt;</code></h2><p>输入文件所属的范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Scope</span> <span class="keyword">implements</span> <span class="title">ScopeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Only the project content */</span></span><br><span class="line">    PROJECT(<span class="number">0x01</span>), <span class="comment">//只是当前工程的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the project&#x27;s local dependencies (local jars) */</span></span><br><span class="line">    PROJECT_LOCAL_DEPS(<span class="number">0x02</span>), <span class="comment">// 工程的本地jar</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the sub-projects. */</span></span><br><span class="line">    SUB_PROJECTS(<span class="number">0x04</span>),  <span class="comment">// 只包含子工工程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the sub-projects&#x27;s local dependencies (local jars). */</span></span><br><span class="line">    SUB_PROJECTS_LOCAL_DEPS(<span class="number">0x08</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the external libraries */</span></span><br><span class="line">    EXTERNAL_LIBRARIES(<span class="number">0x10</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Code that is being tested by the current variant, including dependencies */</span></span><br><span class="line">    TESTED_CODE(<span class="number">0x20</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local or remote dependencies that are provided-only */</span></span><br><span class="line">    PROVIDED_ONLY(<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransformManager预定了一些SCOPE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_PROJECT =</span><br><span class="line">            ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);</span><br></pre></td></tr></table></figure>

<h2 id="isIncremental-Boolean"><a href="#isIncremental-Boolean" class="headerlink" title="isIncremental(): Boolean"></a><code>isIncremental(): Boolean</code></h2><p>是否是增量编译。</p>
<h2 id="transform-TransformInvocation"><a href="#transform-TransformInvocation" class="headerlink" title="transform(TransformInvocation)"></a>transform(TransformInvocation)</h2><p>input的内容将会打包成一个TransformInvocation对象，交给方法体处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransformInvocation</span> </span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getReferencedInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;SecondaryInput&gt; <span class="title">getSecondaryInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TransformOutputProvider <span class="title">getOutputProvider</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transform方法中如何处理TransformInput的JarInput和DirectoryInput？"><a href="#transform方法中如何处理TransformInput的JarInput和DirectoryInput？" class="headerlink" title="transform方法中如何处理TransformInput的JarInput和DirectoryInput？"></a>transform方法中如何处理TransformInput的JarInput和DirectoryInput？</h2><p>DirectoryInput 进行ASM插桩（参考<a href="https://github.com/lijiankun24/Koala/blob/master/buildSrc/src/main/groovy/com/lijiankun24/koala/plugin/PreClass.groovy">koala - PreClass.groovy</a>）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDirectoryInput</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    directoryInput: <span class="type">DirectoryInput</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    outputProvider: <span class="type">TransformOutputProvider</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directoryInput.file.isDirectory) &#123;</span><br><span class="line">        directoryInput.file.walkTopDown().forEach &#123; file -&gt;</span><br><span class="line">            <span class="keyword">val</span> name = file.name</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; name != <span class="string">&quot;R.class&quot;</span></span><br><span class="line">                &amp;&amp; !name.startsWith(<span class="string">&quot;R\$&quot;</span>) &amp;&amp; name != <span class="string">&quot;BuildConfig.class&quot;</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">val</span> reader = ClassReader(file.readBytes())</span><br><span class="line">                <span class="keyword">val</span> writer = ClassWriter(reader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                <span class="keyword">val</span> visitor = MyClassVisitor(writer)</span><br><span class="line">                reader.accept(visitor, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                <span class="keyword">val</span> code = writer.toByteArray()</span><br><span class="line">                <span class="keyword">val</span> classPath = file.parentFile.absolutePath + File.separator + name</span><br><span class="line">                <span class="keyword">val</span> fos = FileOutputStream(classPath)</span><br><span class="line">                fos.write(code)</span><br><span class="line">                fos.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完输入文件之后，要把输出给下一个任务</span></span><br><span class="line">    <span class="keyword">val</span> dest = outputProvider.getContentLocation(</span><br><span class="line">        directoryInput.name,</span><br><span class="line">        directoryInput.contentTypes, directoryInput.scopes,</span><br><span class="line">        Format.DIRECTORY</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JarInput 不处理（参考<a href="https://github.com/lijiankun24/Koala/blob/master/buildSrc/src/main/groovy/com/lijiankun24/koala/plugin/PreClass.groovy">koala - PreClass.groovy</a>）：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">    <span class="keyword">def</span> jarName = jarInput.name</span><br><span class="line">    <span class="keyword">def</span> md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">    <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">        jarName = jarName.substring(<span class="number">0</span>, jarName.length() - <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> dest = transformInvocation.outputProvider.getContentLocation(jarName + md5Name,</span><br><span class="line">            jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line"></span><br><span class="line">    FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>JarInput 处理ASM：<br>参考:</p>
<ul>
<li><a href="https://github.com/chenenyu/Router/blob/master/gradle-plugin/src/main/groovy/com/chenenyu/router/RouterTransform.groovy">Router - RouterTransform.groovy</a></li>
<li><a href="https://github.com/chenenyu/Router/blob/master/gradle-plugin/src/main/groovy/com/chenenyu/router/Scanner.groovy">Router - Scanner.groovy</a><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleJarInput</span><span class="params">(jarInput: <span class="type">JarInput</span>, outputProvider: <span class="type">TransformOutputProvider</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//重名名输出文件,因为可能同名,会覆盖</span></span><br><span class="line">    <span class="keyword">var</span> jarName = jarInput.name</span><br><span class="line">    <span class="keyword">val</span> md5Name = DigestUtils.md5Hex(jarInput.file.absolutePath)</span><br><span class="line">    <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">        jarName = jarName.substring(<span class="number">0</span>, jarName.length - <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt; 处理输入的jar文件中的class，输出到一个临时的jar文件</span></span><br><span class="line">    <span class="keyword">val</span> jarFile = JarFile(jarInput.file)</span><br><span class="line">    <span class="keyword">val</span> enumeration = jarFile.entries()</span><br><span class="line">    <span class="keyword">val</span> tmpFile = File(jarInput.file.parent + File.separator + <span class="string">&quot;classes_temp.jar&quot;</span>)</span><br><span class="line">    <span class="comment">// 避免上次的缓存被重复插入</span></span><br><span class="line">    <span class="keyword">if</span> (tmpFile.exists()) &#123;</span><br><span class="line">        tmpFile.delete()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jarOutputStream = JarOutputStream(FileOutputStream(tmpFile))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存</span></span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">        <span class="keyword">val</span> jarEntry = enumeration?.nextElement() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> entryName = jarEntry.name</span><br><span class="line">        <span class="keyword">val</span> zipEntry = ZipEntry(entryName)</span><br><span class="line">        <span class="keyword">val</span> inputStream = jarFile.getInputStream(jarEntry)</span><br><span class="line">        <span class="comment">// 插桩class</span></span><br><span class="line">        <span class="keyword">if</span> (entryName.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; !entryName.startsWith(<span class="string">&quot;R\$&quot;</span>)</span><br><span class="line">            &amp;&amp; <span class="string">&quot;R.class&quot;</span> != entryName &amp;&amp; <span class="string">&quot;BuildConfig.class&quot;</span> != entryName</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">//class文件处理</span></span><br><span class="line">            println(<span class="string">&quot;----------- deal with jar class file &lt;&#x27; + <span class="variable">$entryName</span> + &#x27;&gt; -----------&quot;</span>)</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            <span class="keyword">val</span> classReader = ClassReader(inputStream)</span><br><span class="line">            <span class="keyword">val</span> classWriter = ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">            <span class="keyword">val</span> cv = MyClassVisitor(classWriter)</span><br><span class="line">            classReader.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">            <span class="keyword">val</span> code = classWriter.toByteArray()</span><br><span class="line">            jarOutputStream.write(code)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            jarOutputStream.write(inputStream.readBytes())</span><br><span class="line">        &#125;</span><br><span class="line">        jarOutputStream.closeEntry()</span><br><span class="line">    &#125;</span><br><span class="line">    jarOutputStream.close()</span><br><span class="line">    jarFile.close()</span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt; 处理输入的jar文件中的class，输出到一个临时的jar文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt; 处理过class的临时jar文件输出到目标位置</span></span><br><span class="line">    <span class="keyword">val</span> dest = outputProvider.getContentLocation(</span><br><span class="line">        jarName + md5Name,</span><br><span class="line">        jarInput.contentTypes, jarInput.scopes, Format.JAR</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyFile(tmpFile, dest)</span><br><span class="line">    tmpFile.delete()</span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt; 处理过class的临时jar文件输出到目标位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Java-Agent和Instrument机制是什么？有什么用？大概如何使用？"><a href="#Java-Agent和Instrument机制是什么？有什么用？大概如何使用？" class="headerlink" title="Java Agent和Instrument机制是什么？有什么用？大概如何使用？"></a>Java Agent和Instrument机制是什么？有什么用？大概如何使用？</h1><p>JavaAgent使用指南</p>
<p><a href="https://www.cnblogs.com/rickiyang/p/11368932.html">https://www.cnblogs.com/rickiyang/p/11368932.html</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.im/post/6844903780916396039">【Android】函数插桩（Gradle + ASM）</a></li>
</ul>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Transform</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化：Serializable与Parceable</title>
    <url>/Java/Java%20Serializable%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="序列化的意义和价值是什么？"><a href="#序列化的意义和价值是什么？" class="headerlink" title="序列化的意义和价值是什么？"></a>序列化的意义和价值是什么？</h1><p>序列化就是把对象转换为字节序列。</p>
<p>反序列化就是把字节序列还原为对象。</p>
<p>对象是程序运行时的信息载体，序列化机制使得对象信息可以脱离程序的运行而独立存在，这样便于进行网络传输或持久性存储到磁盘。</p>
<h1 id="序列化考量的重点是什么？"><a href="#序列化考量的重点是什么？" class="headerlink" title="序列化考量的重点是什么？"></a>序列化考量的重点是什么？</h1><ol>
<li> 协议是否跨平台</li>
<li> 序列化速度</li>
<li> 字节序列大小</li>
</ol>
<h1 id="Serializable底层运作机制是怎样的？"><a href="#Serializable底层运作机制是怎样的？" class="headerlink" title="Serializable底层运作机制是怎样的？"></a>Serializable底层运作机制是怎样的？</h1><p>查看ObjectInputStream的readObject方法  和 ObjectOutputStream的writeObject的代码。</p>
<p>主要运用了反射。</p>
<h1 id="Serializable如何自定义决定哪些字段写入和读取？"><a href="#Serializable如何自定义决定哪些字段写入和读取？" class="headerlink" title="Serializable如何自定义决定哪些字段写入和读取？"></a>Serializable如何自定义决定哪些字段写入和读取？</h1><ol>
<li> 通过transient关键字修饰属性，排除在序列化之外</li>
<li> 在类中增加writeObejct和readObject方法，JDK中的ArrayList、HashMap等都复写了writeObject</li>
<li> 在类中增加writeReplace和readResolve方法，提供了writeReplace就不会执行writeObject，提供了readResolve就不会执行readObject</li>
<li> 实现Externalizable接口，显式实现readExternal和writeExternal</li>
</ol>
<p>Java为用户定义了默认的序列化、反序列化方法，其实就是ObjectOutputStream的defaultWriteObject方法和ObjectInputStream的defaultReadObject方法。</p>
<p>为什么HashMap要自定义序列化逻辑呢？<br>可能的原因是，存储数据的数组table，一般都是不满的（因为HashMap的负载因子默认0.75，超过就会扩容），里面肯定会有很多null，如果是默认的序列化，这些null也会被被序列化，显然这些null是没有必要的做序列化的。</p>
<p>ArrayList自定义序列化方法，也是因为elementData数组可能没存满。</p>
<h1 id="serialVersionUID是干什么的？"><a href="#serialVersionUID是干什么的？" class="headerlink" title="serialVersionUID是干什么的？"></a>serialVersionUID是干什么的？</h1><p>反序列化需要指定一个类，但是类的结构会变更，如何保证已经序列化的字节序列与当前的类结构是对应上的，可以在字节序列和类中分别存储一个版本号，只有版本号相同，就当做是可转行的，版本号不同反序列化就报错。</p>
<p>类中指定版本号是使用private static final long serialVersionUID属性，值为任意。如果不声明这个属性，虚拟机会根据类信息自动生成一个版本号。</p>
<p>这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</p>
<h1 id="什么情况下需要修改serialVersionUID呢？"><a href="#什么情况下需要修改serialVersionUID呢？" class="headerlink" title="什么情况下需要修改serialVersionUID呢？"></a>什么情况下需要修改serialVersionUID呢？</h1><p>分三种情况：</p>
<ol>
<li> 如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li>
<li> 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li>
<li> 如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li>
</ol>
<h1 id="Serializable序列化会有什么问题？"><a href="#Serializable序列化会有什么问题？" class="headerlink" title="Serializable序列化会有什么问题？"></a>Serializable序列化会有什么问题？</h1><p>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</p>
<p>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</p>
<h1 id="Serializable反序列化会有什么问题？"><a href="#Serializable反序列化会有什么问题？" class="headerlink" title="Serializable反序列化会有什么问题？"></a>Serializable反序列化会有什么问题？</h1><p>反序列化不会调用类的构造函数，会调用第一个非序列化父类的无参构造函数</p>
<p>这点可以通过 ObjectInputSteam -&gt; readObject -&gt; readObject0 -&gt; readOrdinaryObject -&gt; desc.newInstance() 得知，desc是ObjectStreamClass的实例，ObjectStreamClass.newInstance()的注释是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new instance of the represented class.  If the class is</span><br><span class="line"> * externalizable, invokes its public no-arg constructor; otherwise, if the</span><br><span class="line"> * class is serializable, invokes the no-arg constructor of the first</span><br><span class="line"> * non-serializable superclass.  Throws UnsupportedOperationException if</span><br><span class="line"> * this class descriptor is not associated with a class, if the associated</span><br><span class="line"> * class is non-serializable or if the appropriate no-arg constructor is</span><br><span class="line"> * inaccessible/unavailable.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>这样设计的目的是什么？</p>
<p>推测是因为如果调用了类的构造函数，如果构造函数中有改变类属性状态的代码，反序列化后就得不到序列化时的状态了，所以不能调用。</p>
<h1 id="Serializable的具体序列化执行过程中哪些地方用到了大量的反射？"><a href="#Serializable的具体序列化执行过程中哪些地方用到了大量的反射？" class="headerlink" title="Serializable的具体序列化执行过程中哪些地方用到了大量的反射？"></a>Serializable的具体序列化执行过程中哪些地方用到了大量的反射？</h1><p>因为没有在代码层面手动写入特定字段，序列化都是全自动化的，在ObjectOutputStream底层都是通过反射获取类的字段信息，defaultWriteFields()读取类的属性字段是通过Field，Field从ObjectStreamClass的getFields()得来，getFields()内部还是反射。</p>
<p>ObjectInputStream也通过反射创建类。</p>
<h1 id="Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？"><a href="#Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？" class="headerlink" title="Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？"></a>Serializable的具体序列化执行过程中哪些地方创建了大量的临时对象？会有什么问题？</h1><p>创建大量的临时对象会引发频繁的垃圾回收，垃圾回收会stop the world，进而引起进程的卡顿。</p>
<p>Serializable的序列化过程比较复杂，有很多对象参与工作，例如ObjectStreamClass。</p>
<h1 id="Parceable底层运作机制是怎样的？"><a href="#Parceable底层运作机制是怎样的？" class="headerlink" title="Parceable底层运作机制是怎样的？"></a>Parceable底层运作机制是怎样的？</h1><p>Interface for classes whose instances can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field called CREATOR of a type that implements the Parcelable.Creator interface.<br>A typical implementation of Parcelable is:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mData;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(mData);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;MyParcelable&gt; CREATOR</span><br><span class="line">            = <span class="keyword">new</span> Parcelable.Creator&lt;MyParcelable&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyParcelable <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable(in);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> MyParcelable[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        mData = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parcelable通过Parcel的一系列read和write方法实现序列化，Parcel的read和write方法都是在native层实现。</p>
<p>Parcel把对象数据直接序列化输出在内存，并且数据结构很紧凑，几乎只存储数据值，不存储额外的信息，而Serializable会存储很多额外的信息，所以Parcel序列化的输出的信息量就比Serializable少，同时没有用反射，而是直接操作内存指针，因此速度更快。<br>缺点：<br>    1. 由于数据紧凑，没有存储必要的判断信息，不能用于持久化存储，因为反序列化时，缺乏足够的信息来保证数据恢复的正确性。<br>    2. 需要手动指定哪些字段写入，并且写入顺序和读入顺序要一致</p>
<h1 id="Parceable与Serializable有什么区别？"><a href="#Parceable与Serializable有什么区别？" class="headerlink" title="Parceable与Serializable有什么区别？"></a>Parceable与Serializable有什么区别？</h1><p>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作。</p>
<p>Parcelable  自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828174331.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Serializable</tag>
        <tag>Parceable</tag>
        <tag>序列化</tag>
        <tag>serialVersionUID</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自动装箱、Integer缓存</title>
    <url>/Java/Java%20%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81Integer%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="自动装箱和自动拆箱是怎么回事？实际发生了什么？"><a href="#自动装箱和自动拆箱是怎么回事？实际发生了什么？" class="headerlink" title="自动装箱和自动拆箱是怎么回事？实际发生了什么？"></a>自动装箱和自动拆箱是怎么回事？实际发生了什么？</h1><p>如下的Java代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer a = 10;</span><br><span class="line">int b = a;</span><br></pre></td></tr></table></figure>
<p>在Intellij idea里通过View - Show Bytecode查看字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L0</span><br><span class="line"> LINENUMBER 3 L0</span><br><span class="line"> BIPUSH 10</span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"> ASTORE 1</span><br><span class="line">L1</span><br><span class="line"> LINENUMBER 4 L1</span><br><span class="line"> ALOAD 1</span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"> ISTORE 2</span><br></pre></td></tr></table></figure>
<p>可以看到int对象的自动装箱，是调用了Integer.valueOf()方法，自动拆卸是调用了Integer.intValue()。</p>
<h1 id="触发自动装箱和自动拆箱的场景有哪些？"><a href="#触发自动装箱和自动拆箱的场景有哪些？" class="headerlink" title="触发自动装箱和自动拆箱的场景有哪些？"></a>触发自动装箱和自动拆箱的场景有哪些？</h1><p>自动装箱的场景：<br>    1. 基本类型赋值给包装类型，如 Integer a = 10;</p>
<p>自动拆箱的场景：<br>    1. 包装类型赋值给基本类型<br>    2. 参与表达式运算或算数运算</p>
<p>进行 <code>=</code> 赋值操作（装箱或拆箱）<br>进行<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>混合运算 （拆箱）<br>进行<code>&gt;</code>, <code>&lt;</code>, <code>==</code>比较运算（拆箱） </p>
<p>当 <code>==</code>运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象。</p>
<p>而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）调用equals进行比较（装箱）。</p>
<p>ArrayList,HashMap等集合类 添加基础类型数据时，因为集合只能添加引用类型（装箱）。</p>
<h1 id="自动装箱解决了什么问题？有哪些场景不得不使用包装类？"><a href="#自动装箱解决了什么问题？有哪些场景不得不使用包装类？" class="headerlink" title="自动装箱解决了什么问题？有哪些场景不得不使用包装类？"></a>自动装箱解决了什么问题？有哪些场景不得不使用包装类？</h1><ol>
<li> 集合类只能使用包装类型，不允许使用基本类型，所以需要有包装类</li>
<li> 由于基本类型没有null的状态，所以需要有包装类对象能够表示null</li>
<li> 泛型只针对类，不能使用基本类型</li>
<li> 反射也只能反射类，不能反射基本类型</li>
<li> 包装类一旦创建，是值不可变的对象，不容易赋值出错</li>
</ol>
<h1 id="为什么Java还要定义基本数据类型，直接使用包装类完全面向对象不就行了吗？"><a href="#为什么Java还要定义基本数据类型，直接使用包装类完全面向对象不就行了吗？" class="headerlink" title="为什么Java还要定义基本数据类型，直接使用包装类完全面向对象不就行了吗？"></a>为什么Java还要定义基本数据类型，直接使用包装类完全面向对象不就行了吗？</h1><p>这需要从Java虚拟机的角度解释性能问题，当执行一个方法中的算术运算时，虚拟机是基于栈帧中的操作数栈进行数据的读取和运算。</p>
<p>如果参与运算的是基本数据类型，由于基本类型大小是固定的，一来本身占用空间小，二来基本类型的变量值可以直接存入局部变量表，直接从局部变量表中读取数据速度很快（跟访问对象的方式相比而言）；基本也不需要垃圾回收，局部变量表是位于栈帧中的，方法执行完毕，栈帧出栈，基本数据类型的变量都会自动释放内存。</p>
<p>如果参与运算的是包装类对象，对象创建后是位于堆中，对象在局部变量表中存储的只是对象指针，指向其在堆中的位置，运算时先访问局部变量表，再访问堆中的对象内部的值，比直接访问局部变量表要多一次额外的访问；其次创建对象占用了额外的空间，因为对象比基本类型要多耗费额外的空间，如对象头等；再次对象创建后还需要垃圾回收，增加了垃圾回收的负担。</p>
<p>基本类型在方法传参时是值的拷贝传递，对象类型在方法传参是引用传递。</p>
<h1 id="Kotlin已经废弃了基本数据类型，已经全是面向对象了，Kotlin这样做没有性能问题吗？"><a href="#Kotlin已经废弃了基本数据类型，已经全是面向对象了，Kotlin这样做没有性能问题吗？" class="headerlink" title="Kotlin已经废弃了基本数据类型，已经全是面向对象了，Kotlin这样做没有性能问题吗？"></a>Kotlin已经废弃了基本数据类型，已经全是面向对象了，Kotlin这样做没有性能问题吗？</h1><p>Kotlin只是在语法层面屏蔽了内部的实现细节，在编译时，还是会把Kotlin的基本数据类型对应的对象类型还是换转为Java基本数据类型，这可以通过反编译Kotlin为Java后看出，这样Kotlin更加彻底面向对象，更加的函数式</p>
<h1 id="Kotiln中整数数组为什么不直接使用-Array-而是-IntArray-？"><a href="#Kotiln中整数数组为什么不直接使用-Array-而是-IntArray-？" class="headerlink" title="Kotiln中整数数组为什么不直接使用 Array 而是 IntArray ？"></a>Kotiln中整数数组为什么不直接使用 Array<Int> 而是 IntArray ？</h1><p>IntArray最终会编译成int[]。</p>
<p>Array<Int>最终会编译成Integer[]。</p>
<p>可以通过查看字节码来验证这一点。</p>
<p>包装类型遍历时会有自动装箱和拆箱的过程，会创建大量的临时对象，加重了垃圾回收的负担，垃圾回收多了会引发stop the world，进而会增加卡顿的几率。</p>
<h1 id="自动装箱和拆箱会产生什么问题？"><a href="#自动装箱和拆箱会产生什么问题？" class="headerlink" title="自动装箱和拆箱会产生什么问题？"></a>自动装箱和拆箱会产生什么问题？</h1><p>在自动拆卸时，当包装类变量为null时，会发生空指针异常，例如</p>
<p>Integer a  = null;</p>
<p>int b = a;</p>
<p>第二句赋值时会调用a.intValue()，然而a是null，会抛出空指针异常。</p>
<p>自动装箱会创建包装类对象，如果在大的循环中有自动装箱的发生，会创建很多临时的无用的包装类对象，增加了垃圾回收的负担，垃圾回收会引发stop the world停止所有的线程工作，导致系统的吞吐量降低。</p>
<h1 id="Integer的缓存机制是怎么回事？"><a href="#Integer的缓存机制是怎么回事？" class="headerlink" title="Integer的缓存机制是怎么回事？"></a>Integer的缓存机制是怎么回事？</h1><p>学会看字节码就知道自动装箱拆箱实际调用的是什么。</p>
<p>Intellij idea里通过View - Show Bytecode</p>
<p>以Integer为例</p>
<p>Integer a = 3;</p>
<p>字节码指令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ICONST_3</span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line">ASTORE 3</span><br></pre></td></tr></table></figure>

<p>看到调用的是Integer.valueOf()方法</p>
<p>Integer.valueOf()内部会用到IntegerCache，默认-128到127的Integer对象都会被缓存，通过valueOf()返回这个范围内的Integer对象都是同一个</p>
<h1 id="两个值相等的Integer对象，-比较，是否相等？"><a href="#两个值相等的Integer对象，-比较，是否相等？" class="headerlink" title="两个值相等的Integer对象，==比较，是否相等？"></a>两个值相等的Integer对象，==比较，是否相等？</h1><p>要看Integer对象是如何从创建出来的。</p>
<p>如果Integer是new出来的，==比较对象的内存地址，肯定不相等。</p>
<p>如果Integer是通过Integer.valueOf()创建出来的，如果值是[-128,127]之间的数，会用缓存的Integer对象，即是同一个Integer对象。</p>
<p>其中自动装修也会调用Integer.valueOf()方法生成Integer对象，触发自动装箱的代码如 Integer a = 3。</p>
<h1 id="其他基本类型的包装类是否跟Integer一样都有Cache？"><a href="#其他基本类型的包装类是否跟Integer一样都有Cache？" class="headerlink" title="其他基本类型的包装类是否跟Integer一样都有Cache？"></a>其他基本类型的包装类是否跟Integer一样都有Cache？</h1><p>Java的基本类型有八种：</p>
<ol>
<li> 字符类型：char</li>
<li> 布尔类型：boolean</li>
<li>数值类型：<ol>
<li> 整数类型：byte、short、int、long</li>
<li> 浮点数类型：float、double</li>
</ol>
</li>
</ol>
<p>整数类型Byte、Short、Integer、Long都有Cache机制，缓存的数值范围都是[-128,127]。</p>
<p>字符类型Character有Cache机制，缓存范围[0,127]的ASCII字符。</p>
<p>布尔类型Boolean有Cache机制，定了两个TRUE和FALSE的常量，通过Boolean.valueOf(boolean b)返回的都是这两个常量的其中之一。</p>
<p>浮点数类型没有Cache机制，valueOf方法都是直接new一个Float或Double对象；某个范围内整数数值是有限个的，所以缓存有意义，命中率也高，而浮点数某个范围内的数值个数是无穷多个，即使做缓存，缓存命中率低，没有起到缓存的作用，反而占用了存储空间，故而浮点数不需要缓存。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>自动装箱</tag>
        <tag>Integer缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.10.正则表达式匹配（困难）</title>
    <url>/LeetCode/LeetCode.10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode.10.正则表达式匹配（困难）</a></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>题目已经给出了匹配规则。</p>
<h3 id="怎么做匹配？"><a href="#怎么做匹配？" class="headerlink" title="怎么做匹配？"></a>怎么做匹配？</h3><p>用两个指针<code>i</code>和<code>j</code>分别指向<code>s</code>和<code>p</code>的开头，一直匹配，如果两个指针都能到达<code>s</code>和<code>p</code>的末尾，说明匹配成功。</p>
<h3 id="的注意事项"><a href="#的注意事项" class="headerlink" title="*的注意事项"></a><code>*</code>的注意事项</h3><p><code>p</code>中遇到<code>*</code>时要考虑它前面一个字符是什么。</p>
<p>但我们是从左向右匹配的，所以在当前位置匹配字符时，要考虑<code>p</code>的下一个位置是不是<code>*</code>。</p>
<h3 id="如何用-匹配多个字符？"><a href="#如何用-匹配多个字符？" class="headerlink" title="如何用*匹配多个字符？"></a>如何用<code>*</code>匹配多个字符？</h3><p>可以匹配0个字符、1个字符，多个字符递归去解决。</p>
<ul>
<li>匹配0个字符时，指针<code>i</code>不动，<code>j</code>跳到<code>j + 2</code></li>
<li>匹配1个字符时，先要看<code>s[i]</code>是不是跟<code>p[j]</code>匹配，匹配的话<code>j</code>是不动的，因为可以匹配多个。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>按道理<code>j == p.length &amp;&amp; i == s.length</code>时，说明匹配完成，否则没有完成匹配。<br>但是因为有<code>*</code>的存在，可能<code>j</code>还指向<code>*</code>前面一个字符，<code>i</code>会先到末尾，即此时<code>j != p.length &amp;&amp; i == s.length</code>，也可能是匹配成功的，<code>i</code>发现<code>s</code>后面没有字符可匹配时，可以走<code>*</code>匹配0个字符的逻辑，这样<code>j</code>就到达末尾了。</p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">val</span> isStarPattern = j &lt;= n - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (isStarPattern) &#123;</span><br><span class="line">                <span class="keyword">val</span> isZeroMatched = match(i, j + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">val</span> isOneMatched = isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j)</span><br><span class="line">                isZeroMatched || isOneMatched</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：平均O(n * 2 ^ 星号数)，最差O(2^n)，</p>
</blockquote>
<h2 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h2><p>普通递归存在很多重叠子问题。</p>
<p>比如执行两次<code>match(i +  1, j)</code>再执行两次<code>match(i, j +  2)</code>的结果跟执行两次<code>match(i +  1, j +  1)</code>的结果是一样的。</p>
<p>所以需要记录中间结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;String, <span class="built_in">Boolean</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">val</span> key = <span class="string">&quot;<span class="variable">$i</span>,<span class="variable">$j</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (memo.contains(key)) <span class="keyword">return</span> memo[key]!!</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">val</span> isStarPattern = j &lt;= n - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">val</span> matched = <span class="keyword">if</span> (isStarPattern) &#123;</span><br><span class="line">                <span class="keyword">val</span> isZeroMatched = match(i, j + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">val</span> isOneMatched = isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j)</span><br><span class="line">                isZeroMatched || isOneMatched</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            memo[key] = matched</span><br><span class="line">            <span class="keyword">return</span> matched</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：平均O(n*(星号数+1))，最差O(n²)</p>
</blockquote>
<h2 id="解法3：自底向上动态规划"><a href="#解法3：自底向上动态规划" class="headerlink" title="解法3：自底向上动态规划"></a>解法3：自底向上动态规划</h2><p>由递归解法分析可知，大问题可以划分为子问题+有限步骤解决，并且符合最优子结构、无后效性、重叠子问题。<br>这里的关键是梳理出子问题是经过怎样的步骤得到大问题，即可得到状态转移方程。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[i][j]</code>为 <code>s</code> 的前<code>i</code>个字符是否能被 <code>p</code> 的前<code>j</code>个字符匹配。</p>
<ul>
<li><code>s[i - 1] == p[j - 1]</code>时，<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>s[i - 1] != p[j - 1]</code>时：<ul>
<li><code>p[j - 1] != &#39;.&#39; &amp;&amp; p[j - 1] != &#39;*&#39;</code>时，<code>dp[i][j] = false</code>。</li>
<li><code>p[j - 1] == &#39;.&#39;</code>时：<br><code>.</code>可以匹配任意字符，跟<code>s[i - 1] == p[j - 1]</code>的处理情况一样，即：<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>p[j - 1] == &#39;*&#39;</code>时：<br><code>*</code>可以匹配前面字符的0个或多个；<ul>
<li>匹配0次：<code>dp[i][j] = dp[i][j - 2]</code></li>
<li>匹配1次：<code>dp[i][j] = dp[i - 1][j] &amp;&amp; (p[j - 2] == s[i - 1] || p[j - 2] == &#39;.&#39;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> ls = s.length</span><br><span class="line">        <span class="keyword">val</span> lp = p.length</span><br><span class="line">        <span class="comment">// dp[i][j]表示s的前i个字符否能与p的前j个字符匹配，i和j分别从0开始取值</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(ls + <span class="number">1</span>) &#123; BooleanArray(lp + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">		<span class="comment">// 0个字符跟0个字符是匹配的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// p中有*是可以匹配0个字符的，所以做一下初始化</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">2</span> until dp[<span class="number">0</span>].size) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until dp.size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until dp[i].size) &#123;</span><br><span class="line">                <span class="keyword">val</span> si = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> pi = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (p[pi] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 匹配0次，字符可以不相等</span></span><br><span class="line">                    <span class="comment">// 匹配1次，字符要相同</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                            || dp[i - <span class="number">1</span>][j] &amp;&amp; (s[si] == p[pi - <span class="number">1</span>] || p[pi - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[si] == p[pi] || p[pi] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ls][lp]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 O(mn)：m、n分别为s、p长度，填充二维dp数组所需的时间。</p>
<p>空间复杂度 O(mn)：二维dp数组占用的空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1014.最佳观光组合（中等）</title>
    <url>/LeetCode/LeetCode.1014.%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">LeetCode.1014.最佳观光组合（中等）</a></p>
<p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。<br>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。<br>返回一对观光景点能取得的最高分。、</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h2><ol>
<li>对一个确定的<code>j</code>，需要在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得观光组合得分最高。</li>
<li>不知道选哪个<code>j</code>能让得分最高，就需要穷举所有<code>j</code>的取值可能性。</li>
</ol>
<h2 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h2><p>目标是求最大的观察观光组合得分，那么就得思考得分与什么相关，能否分解为独立的几个部分，再穷举每个部分所有的可能性，看这些可能性是怎么操作得到的，就可以知道得分是怎么来的了。</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>得分公式<code>values[i] + values[j] + i - j</code>里会变的东西就是<code>i</code>和<code>j</code>，这两个是独立变化的，那么就可以把公式拆成两部分：</p>
<ol>
<li>仅跟<code>i</code>相关的，即 <code>values[i] + i</code>，可以称为<code>scoreI</code></li>
<li>仅跟<code>j</code>相关的，即 <code>values[j] - j</code>，可以称为<code>scoreJ</code></li>
</ol>
<p>总分<code>score = scoreI + scoreJ</code></p>
<h2 id="对于一个确定的j，怎么使得得分最高呢？"><a href="#对于一个确定的j，怎么使得得分最高呢？" class="headerlink" title="对于一个确定的j，怎么使得得分最高呢？"></a>对于一个确定的j，怎么使得得分最高呢？</h2><ol>
<li><code>j</code>确定了， <code>scoreJ</code> 是确定的，不会变动。</li>
<li>然后在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得<code>scoreI</code> 最大，得分就是最高了。</li>
</ol>
<p>不确定选哪个<code>j</code>可以得分最高，那就遍历数组，穷举<code>j</code>所有的取值可能。</p>
<p>但是按照这个思路，先穷举<code>j</code>，再在每个<code>j</code>处往回穷举<code>i</code>，时间复杂度是O($n^2$)，是否存在不必要的操作？</p>
<h2 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h2><p>仔细分析两个步骤可以发现，没有必要往回穷举<code>i</code>，因为<code>i &lt; j</code>，在数组中遍历到<code>j</code>，<code>j</code>前面的位置肯定都遍历过了，<code>i</code>已经可以确定了；简单点说，<code>j</code>确定了，<code>i</code>就确定了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(values: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = values.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxScoreI = values[<span class="number">0</span>] + <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxScore = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 穷举所有的j</span></span><br><span class="line">        <span class="comment">// 只有1个景点无法形成观光组合，所以从1开始遍历，这样至少2个有两个景点能形成观光组合</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> scoreJ = values[j] - j</span><br><span class="line">            <span class="keyword">val</span> score = maxScoreI + scoreJ</span><br><span class="line">            maxScore = maxOf(maxScore, score)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 上面已经处理过j，对于下一个j而言，需要知道下一个j前面最大的scoreI是多少</span></span><br><span class="line">            <span class="keyword">val</span> scoreI = values[j] + j</span><br><span class="line">            maxScoreI = maxOf(maxScoreI, scoreI)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxScore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1143.最长公共子序列（中等）</title>
    <url>/LeetCode/LeetCode.1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode.1143.最长公共子序列（中等）</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h2><p>尝试划分子问题。</p>
<p><strong>如果text1和text2存在公共子序列，那是怎么得来的？</strong><br>肯定是之前没有公共子序列或者存在公共子序列，然后又发现了两者相同的字符，得到了更长的公共子序列。</p>
<p><strong>如果末尾字符不相同怎么办？</strong></p>
<ol>
<li>删除text1的末尾字符，剩余字符串去跟text2比较。</li>
<li>删除text2的末尾字符，剩余字符串去跟text1比较。</li>
</ol>
<p>取两种情况中可以得到的最长公共子序列的情况。</p>
<p>同时删除text1和text2的末尾字符要不要考虑？</p>
<p>这里划分出了子问题和所有的递推步骤。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span> || i2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (text1[i1] == text2[i2]) <span class="number">1</span> + solve(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> maxOf(solve(i1 - <span class="number">1</span>, i2), solve(i1, i2 - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(text1.length - <span class="number">1</span>, text2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在重叠子问题，有大量重复计算，用数组记录中间计算结果。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun longestCommonSubsequence(text1: String, text2: String): Int &#123;</span><br><span class="line">        val memo = Array(text1.length) &#123; IntArray(text2.length) &#123; 0 &#125; &#125;</span><br><span class="line">        fun solve(i1: Int, i2: Int): Int &#123;</span><br><span class="line">            if (i1 == -1 || i2 == -1) return 0 </span><br><span class="line">            if (memo[i1][i2] &gt; 0) return memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = if (text1[i1] == text2[i2]) 1 + solve(i1 - 1, i2 - 1)</span><br><span class="line">            else maxOf(solve(i1 - 1, i2), solve(i1, i2 - 1))</span><br><span class="line">            return memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(text1.length - 1, text2.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：自底向上动态规划"><a href="#解法2：自底向上动态规划" class="headerlink" title="解法2：自底向上动态规划"></a>解法2：自底向上动态规划</h2><p>设<code>dp[i][j]</code>为<code>text1</code>的前<code>i + 1</code>个字符与<code>text2</code>的前<code>j + 1</code>个字符最长公共子序列的长度。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>text1[i] == text2[j]</code>时，<code>dp[i][j] = 1 + dp[i - 1][j - 1]</code></li>
<li><code>text1[i] != text2[j]</code>时，<code>dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
<p><strong>边界处理</strong><br>设<code>s1</code>是<code>text1</code>子字符串，<code>s2</code>是<code>text2</code>子字符串。</p>
<ul>
<li><code>s1</code>和<code>s2</code>为一个字符时，只需要判断字符是否相同，可以计算<code>dp[0][0]</code>。</li>
<li><code>s1</code>只有一个字符时，如果跟<code>s2</code>的字符不相同，<code>s1</code>没办法再删减，直接取<code>s2</code>删减后的结果。</li>
<li><code>s2</code>只有一个字符时，如果跟<code>s1</code>的字符不相同，<code>s2</code>没办法再删减，直接取<code>s1</code>删减后的结果。</li>
</ul>
<p><strong>复杂度</strong><br>设<code>text1</code>长度为<code>m</code>，<code>text2</code>长度为<code>n</code>。<br>时间复杂度O(mn)：双循环无法省略。<br>空间复杂度O(mn)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = text1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = text2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n1) &#123; IntArray(n2) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) dp[i][<span class="number">0</span>] = <span class="keyword">if</span> (text1[i] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) dp[<span class="number">0</span>][j] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[j]) <span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (text1[i] == text2[j]) <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1 - <span class="number">1</span>][n2 - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.118.杨辉三角（简单）</title>
    <url>/LeetCode/LeetCode.118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">LeetCode.118.杨辉三角（简单）</a></p>
<p>给定一个非负整数 _<code>numRows</code>，_生成「杨辉三角」的前 <em><code>numRows</code></em> 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递推公式题目已经给出，讨论一下边界情况，把问题具体定义就好了。</p>
<h3 id="问题公式化"><a href="#问题公式化" class="headerlink" title="问题公式化"></a>问题公式化</h3><p>三角形每行用List存储，所有行也用List存储。<br>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>把三角形左侧对齐可以观察到：<br>左上方的数就是<code>dp[r - 1][c - 1]</code>；<br>右上方的数就是<code>dp[r - 1][c]</code>；</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h2 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h2><p>r = 0时，没有上方，但其实知道第一行是1，只有1个元素，直接添加到结果集就行了。<br>r &gt; 0后：<br>c = 0 处于第一列时，没有左上方，左上方当作0，只累加右上方，<code>dp[r][0] = dp[r - 1][c]</code>。<br>c = r 处于最后一列时，没有右上方，右上方当作0，只累加左上方，<code>dp[r][r] = dp[r - 1][r - 1]</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(numRows: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> triangle = mutableListOf&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">        triangle.add(listOf(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until numRows) &#123;</span><br><span class="line">            <span class="keyword">val</span> rows = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0.</span>.r) &#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 第一列，只能加右上方</span></span><br><span class="line">                    c == <span class="number">0</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                    <span class="comment">// 最后一列，只能加左上方</span></span><br><span class="line">                    c == r -&gt; rows.add(triangle[r - <span class="number">1</span>][r - <span class="number">1</span>])</span><br><span class="line">                    <span class="comment">// 中间列，左上方+右上方</span></span><br><span class="line">                    <span class="keyword">else</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][c - <span class="number">1</span>] + triangle[r - <span class="number">1</span>][c])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            triangle.add(rows)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.119.杨辉三角II（简单）</title>
    <url>/LeetCode/LeetCode.119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">LeetCode.119.杨辉三角II（简单）</a></p>
<p>给定一个非负索引  <code>rowIndex</code>，返回「杨辉三角」的第  <code>rowIndex</code>  行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最直观就是求出杨辉三角所有行，取第<code>rowIndex</code>行。<br>实际每一行由上一行推导而来，不需要存储所有行，只需要保存上一行，递推来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>左上方的数：<code>dp[r - 1][c - 1]</code>；<br>右上方的数：<code>dp[r - 1][c]</code>；<br><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>用一个数组就可以完成每行迭代。<br><code>dp[c] = dp[c - 1] + dp[c]</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>更新第c列时，会读取c - 1列的旧值；<br>但是c - 1列在更新数组的时候已经被新值覆盖了。<br>解决方案：</p>
<ol>
<li>从左向右遍历数组时，临时存储一下旧值。</li>
<li>从右向左遍历数组。</li>
</ol>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRow</span><span class="params">(rowIndex: <span class="type">Int</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = IntArray(rowIndex + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        rows[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1.</span>.rowIndex) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> r - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">                rows[c] = rows[c - <span class="number">1</span>] + rows[c]</span><br><span class="line">            &#125;</span><br><span class="line">            rows[r] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows.toList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.120.三角形最小路径和（中等）</title>
    <url>/LeetCode/LeetCode.120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/triangle/">LeetCode.120.三角形最小路径和（中等）</a></p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目已经给出了递推公式，是从上往下取值的，所以要从最后一行往上递推，最后得到结果。<br>如果用递归写，这个顺序就会比较明白，递归划分为子问题后，实际是自底向上传递计算结果的。</p>
<p>设<code>dp[i][j]</code>为第i行第j列向下的最小路径和。<br>总共<code>n</code>行。</p>
<p>最后一行没有下一行了，所以<br><code>dp[n - 1][j] = triangle[n - 1][j]</code></p>
<p>上面的行，状态转移方程为：<br><code>dp[i][j] = triangle[i][j] + minOf(dp[i + 1][j], dp[i + 1][j + 1]</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minimumTotal</span><span class="params">(triangle: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Int</span>&gt;&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = triangle.size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[n - <span class="number">1</span>][j] = triangle[n - <span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.i) &#123;</span><br><span class="line">                dp[i][j] = triangle[i][j] + minOf(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.120.三角形最小路径和（中等）</title>
    <url>/LeetCode/LeetCode.121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode.121.买卖股票的最佳时机（简单）</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>设dp[i]为第0天到第i天获取最大利润。</p>
<p>在第i天，可以选择不卖股票或卖出股票。</p>
<ol>
<li>不卖股票，dp[i] = dp[i - 1]</li>
<li>卖出股票，由于只能买入一次和卖出一次，那要获得最大利润，肯定要在第0天到第i -1中股票最低的时候买入，dp[i] = prices[i] - minPrice</li>
</ol>
<p>dp[i]只与上一个状态有关，所以可以用变量存储状态，不需要数组记录。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxProfit = maxOf(maxProfit, prices[i] - minPrice)</span><br><span class="line">            minPrice = minOf(minPrice, prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="comment">// dp[i][k]表示前i天持有和未持有第i天的股票的最大收益</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 第i天未持有，可能是前i-1天就未持有然后今天不操作，或者以前持有了今天卖出了</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            <span class="comment">// 第i天持有，可能是前i-1天就持有了然后今天不操作，或者以前就未持有今天买入了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.124.二叉树中的最大路径和（困难）</title>
    <url>/LeetCode/LeetCode.124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">LeetCode.124.二叉树中的最大路径和（困难）</a></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设找到了最大路径和的路径，观察这个路径的特点，可以发现路径必然会经过一个根节点，也就是从一个根节点向左和向右延伸可以到达整个路径。</p>
<h3 id="路径和怎么计算？"><a href="#路径和怎么计算？" class="headerlink" title="路径和怎么计算？"></a>路径和怎么计算？</h3><p>可以遍历每一个节点，计算当前节点左、右子树上的最大路径和，再与当前节点的值相加即可。</p>
<h3 id="计算路径和的注意事项"><a href="#计算路径和的注意事项" class="headerlink" title="计算路径和的注意事项"></a>计算路径和的注意事项</h3><p>这里要注意节点值可能是负数，所以左右子树的路径和可能是负的，越加越小，如果是负的肯定就不加了。</p>
<h3 id="左右子树最大路径和怎么求？"><a href="#左右子树最大路径和怎么求？" class="headerlink" title="左右子树最大路径和怎么求？"></a>左右子树最大路径和怎么求？</h3><p>对于某个节点x来说，若其左子树路径和为leftSum，右子树路径和为rightSum，对于x的父节点来说，只能选用leftSum和rightSum种较大的那个，再加上x的值，作为x的父节点的子树路径和。否则就路径就有分叉了，不满足题意。</p>
<h3 id="怎么求最大路径和？"><a href="#怎么求最大路径和？" class="headerlink" title="怎么求最大路径和？"></a>怎么求最大路径和？</h3><p>计算每个节点路径和时，记录最大的那个路径和的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var ti = TreeNode(5)</span></span><br><span class="line"><span class="comment"> * var v = ti.`val`</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var left: TreeNode? = null</span></span><br><span class="line"><span class="comment"> *     var right: TreeNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxSum = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">maxGain</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> leftSum = maxOf(<span class="number">0</span>, maxGain(root.left))</span><br><span class="line">            <span class="keyword">val</span> rightSum = maxOf(<span class="number">0</span>, maxGain(root.right))</span><br><span class="line">            <span class="keyword">val</span> currentPathSum = root.`<span class="keyword">val</span>` + leftSum + rightSum</span><br><span class="line">            maxSum = maxOf(maxSum, currentPathSum)</span><br><span class="line">            <span class="keyword">return</span> root.`<span class="keyword">val</span>` + maxOf(leftSum, rightSum)</span><br><span class="line">        &#125;</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.126.单词接龙 II（困难）</title>
    <url>/LeetCode/LeetCode.126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-ladder-ii/">LeetCode.126.单词接龙 II（困难）</a></p>
<p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</li>
<li>sk == endWord</li>
</ul>
<p>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>通过广度优先搜索建立图的邻接表。<ul>
<li>在发现最短转换路径时停止构建图。</li>
<li>有可能有多条最短路径，所以发现了一条最短路径时不要立刻终止，等这一层都遍历完。</li>
</ul>
</li>
<li>通过深度优先搜索，求得最短路径。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findLadders</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 单词列表转为哈希集合，便于快速查找</span></span><br><span class="line">        <span class="keyword">val</span> wordSet = wordList.toSet()</span><br><span class="line">        <span class="comment">// 单词列表中没有endWord直接返回，不用搜索了</span></span><br><span class="line">        <span class="keyword">if</span> (!wordSet.contains(endWord)) <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs建立图的邻接表</span></span><br><span class="line">        <span class="keyword">val</span> graph = mutableMapOf&lt;String, MutableSet&lt;String&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> found = bfs(beginWord, endWord, wordSet, graph)</span><br><span class="line">        <span class="keyword">if</span> (!found) <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs搜索</span></span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;List&lt;String&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> path = mutableListOf(beginWord)</span><br><span class="line">        dfs(beginWord, endWord, graph, path, result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;, graph: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, MutableSet&lt;String&gt;&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = java.util.ArrayDeque&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        queue.add(beginWord)</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> levelVisited = mutableSetOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> levelCount = queue.size</span><br><span class="line">            repeat(levelCount) &#123;</span><br><span class="line">                <span class="keyword">val</span> currentWord = queue.poll()</span><br><span class="line">                <span class="keyword">val</span> nextNodes = getNextLevelNodes(currentWord, wordSet)</span><br><span class="line">                <span class="keyword">for</span> (nextWord <span class="keyword">in</span> nextNodes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited.contains(nextWord)) <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> (nextWord == endWord) &#123;</span><br><span class="line">                        found = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(nextWord)</span><br><span class="line">                    levelVisited.add(nextWord)</span><br><span class="line"></span><br><span class="line">                    graph.getOrPut(currentWord, &#123; mutableSetOf() &#125;)</span><br><span class="line">                            .add(nextWord)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在某一层发现了路径终点，就直接不继续了，这样保证路径是最短的</span></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            visited.addAll(levelVisited)</span><br><span class="line">            levelVisited.clear()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, graph: <span class="type">Map</span>&lt;<span class="type">String</span>, Set&lt;String&gt;&gt;, path: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;, result: <span class="type">MutableList</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginWord == endWord) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(beginWord)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        graph[beginWord]?.forEach &#123; nextWord -&gt;</span><br><span class="line">            path.add(nextWord)</span><br><span class="line">            dfs(nextWord, endWord, graph, path, result)</span><br><span class="line">            path.removeAt(path.lastIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变化[word]每一个位置的字符，看是否存在于单词列表中，存在的话，记录为下一层的顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextLevelNodes</span><span class="params">(word: <span class="type">String</span>, wordSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>: Set&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> nodes = mutableSetOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> chars = word.toCharArray()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> chars.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> oldChar = chars[i]</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = <span class="string">&#x27;a&#x27;</span> + j</span><br><span class="line">                <span class="keyword">if</span> (c == oldChar) <span class="keyword">continue</span></span><br><span class="line">                chars[i] = c</span><br><span class="line">                <span class="keyword">val</span> next = String(chars)</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(next)) &#123;</span><br><span class="line">                    nodes.add(next)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[i] = oldChar</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>图</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.127.单词接龙（困难）</title>
    <url>/LeetCode/LeetCode.127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-ladder/">LeetCode.127.单词接龙（困难）</a></p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code>  和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p>
<ul>
<li>序列中第一个单词是 beginWord 。</li>
<li>序列中最后一个单词是 endWord 。</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典 wordList 中的单词。</li>
</ul>
<p>你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p>
<span id="more"></span>
<p>提示：</p>
<ul>
<li>1 &lt;= beginWord.length &lt;= 10</li>
<li>endWord.length == beginWord.length</li>
<li>1 &lt;= wordList.length &lt;= 5000</li>
<li>wordList[i].length == beginWord.length</li>
<li>beginWord、endWord 和 wordList[i] 由小写英文字母组成</li>
<li>beginWord != endWord</li>
<li>wordList 中的所有字符串 互不相同</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>有一个起点、一个终点，加上一系列路径的选择，就是搜索问题。</li>
<li>可以用深度优先搜索或广度优先搜索，每个单词就是图中一个结点。</li>
</ul>
<h3 id="用DFS还是BFS？为什么？"><a href="#用DFS还是BFS？为什么？" class="headerlink" title="用DFS还是BFS？为什么？"></a>用DFS还是BFS？为什么？</h3><ul>
<li>题目要求最短转换序列，也就是求最短路径，用广度优先搜索用时最短，发现到达终点就直接返回。</li>
<li>如果用深度有限搜索，遍历完所有路径还得回溯，会比较耗时。</li>
</ul>
<p>但是搜索需要有路径选择，这就引出了下一个问题。</p>
<h3 id="对于每一个单词，它的邻接单词有哪些？"><a href="#对于每一个单词，它的邻接单词有哪些？" class="headerlink" title="对于每一个单词，它的邻接单词有哪些？"></a>对于每一个单词，它的邻接单词有哪些？</h3><ul>
<li>每次转换单词只能改变一个字母，但是单词有n个字母，不知道转换哪个，那就所有的都尝试转换一遍，看能得到哪些单词。</li>
<li>可以提前存储好每个单词能转换到的单词，直接O(1)时间查询，可以用哈希表存储。</li>
<li>对于转换到的单词而言，他跟转换前的单词的区别也就是那一个字符不同，其他字符都相同，并且可能有多个能转换到的单词。<ul>
<li>我们可以用对要变化的位置上加上*再加上剩余字母作为哈希表的键，单词列表作为哈希表的值。</li>
<li>提前读取所有单词，做预处理。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ladderLength</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 所有单词长度一致</span></span><br><span class="line">        <span class="keyword">val</span> wordLength = beginWord.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key是通配词，value是这个通配词对应的所有词</span></span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()</span><br><span class="line">        wordList.forEach &#123; word -&gt;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until wordLength) &#123;</span><br><span class="line">                <span class="keyword">val</span> key = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, wordLength)</span><br><span class="line">                <span class="keyword">val</span> list = map.getOrDefault(key, mutableListOf())</span><br><span class="line">                list.add(word)</span><br><span class="line">                map[key] = list</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问数组，防止绕环</span></span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">val</span> queue = ArrayDeque&lt;String&gt;()</span><br><span class="line">        queue.add(beginWord)</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> emptyList = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> count = queue.size</span><br><span class="line">            repeat(count) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = queue.poll()</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until wordLength) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, wordLength)</span><br><span class="line">                    <span class="keyword">val</span> adjacentWords = map.getOrDefault(key, emptyList)</span><br><span class="line">                    adjacentWords.forEach &#123; adjacentWord -&gt;</span><br><span class="line">                        <span class="comment">// 加1是因为endWord也算一个步骤，要加上</span></span><br><span class="line">                        <span class="keyword">if</span> (adjacentWord == endWord) <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(adjacentWord)) &#123;</span><br><span class="line">                            visited.add(adjacentWord)</span><br><span class="line">                            queue.add(adjacentWord)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>图</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1277.统计全为 1 的正方形子矩阵（中等）</title>
    <url>/LeetCode/LeetCode.1277.%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">LeetCode.1277.统计全为 1 的正方形子矩阵（中等）</a></p>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是  <code>0</code>  就是  <code>1</code>，请你统计并返回其中完全由  <code>1</code>  组成的  <strong>正方形</strong>  子矩阵的个数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p><code>side</code>数组每一项累加，就是所有能用1组成的正方形的个数。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countSquares</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        count += side[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    count += side[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化后代码（kotlin）"><a href="#优化后代码（kotlin）" class="headerlink" title="优化后代码（kotlin）"></a>优化后代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countSquares</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[j]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储上一行状态，以便接下来读取左上方状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                side[j] = <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// side[j]: 上方状态</span></span><br><span class="line">                    <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">                    <span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> </span><br><span class="line">                    <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j], side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>])</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                count += side[j]</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1314.矩阵区域和（中等）</title>
    <url>/LeetCode/LeetCode.1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a></p>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p>
<ul>
<li>i - k &lt;= r &lt;= i + k,</li>
<li>j - k &lt;= c &lt;= j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
<span id="more"></span>

<p>提示：</p>
<blockquote>
<p>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, k &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力解法需要O($n^4$)时间复杂度，考虑时间更优化的算法。</p>
<h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>题目要求解区域和是二维的，可以简化问题，先看看一维数组某一区间的元素和怎么求，因为二维的区域相当于一维的叠加。</p>
<h3 id="一维数组某区间内元素和怎么快速求解？"><a href="#一维数组某区间内元素和怎么快速求解？" class="headerlink" title="一维数组某区间内元素和怎么快速求解？"></a>一维数组某区间内元素和怎么快速求解？</h3><p>可以预先计算和存储每个位置的前缀和（第0个到第i个元素之间所有元素的和），要计算某个区间的和，用区间端点的前缀和相减就可以在O(1)时间复杂度内求解，但需要占用O(n)空间。</p>
<p>考虑用二维前缀和快速求解面积问题。</p>
<h3 id="二维前缀和定义"><a href="#二维前缀和定义" class="headerlink" title="二维前缀和定义"></a>二维前缀和定义</h3><p>第0行第0列到第r行第c列形成的矩形区域内所有元素的和。<br>记为<code>preSum[r][c]</code>。</p>
<h3 id="怎么利用二维前缀和求解区域面积？"><a href="#怎么利用二维前缀和求解区域面积？" class="headerlink" title="怎么利用二维前缀和求解区域面积？"></a>怎么利用二维前缀和求解区域面积？</h3><p>比如要求区域d的元素和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列：                  </span><br><span class="line">0   a a a b b b b b   </span><br><span class="line">1   a a a b b b b b</span><br><span class="line">2   c c c d d d d d</span><br><span class="line">3   c c c d d d d d</span><br><span class="line">4   c c c d d d d d</span><br><span class="line">行： 0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>公式表达：<br><code>区域d所有元素和 = preSum[7,4] - preSum[2, 4] - preSum[7, 1] + preSum[2, 1]</code><br><code>preSum[7,4]</code>：整个区域所有元素和<br><code>preSum[2, 4]</code>：区域a + 区域c<br><code>preSum[7, 1]</code>：区域a + 区域b<br><code>preSum[2, 1]</code>：区域a</p>
<h3 id="二维前缀和怎么推导？"><a href="#二维前缀和怎么推导？" class="headerlink" title="二维前缀和怎么推导？"></a>二维前缀和怎么推导？</h3><ul>
<li>第一行和第一列前缀和不用推导，左边和上边都没有元素，直接等于元素本身。</li>
<li>第一行上方没有元素，当作一维前缀和求解。</li>
<li>第一列和第一行情况相同，方向变了一下，还是当作一维前缀和求解。</li>
<li>非第一行和非第一列位置的前缀和，跟求解区域和类似，前缀和 = 上方二维前缀和 + 左方二维前缀和 - 左上方二维前缀和 + 本元素值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">matrixBlockSum</span><span class="params">(mat: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, k: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> m = mat.size</span><br><span class="line">        <span class="keyword">val</span> n = mat[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> answer = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) preSum[r][<span class="number">0</span>] = mat[r][<span class="number">0</span>] + preSum[r - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) preSum[<span class="number">0</span>][c] = mat[<span class="number">0</span>][c] + preSum[<span class="number">0</span>][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                preSum[r][c] = mat[r][c] + preSum[r - <span class="number">1</span>][c] + preSum[r][c - <span class="number">1</span>] - preSum[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解区域和</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> leftTopX = maxOf(r - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> leftTopY = maxOf(c - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomX = minOf(r + k, m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomY = minOf(c + k, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> wholeArea = preSum[rightBottomX][rightBottomY]</span><br><span class="line">                <span class="keyword">val</span> leftArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][rightBottomY] </span><br><span class="line">                <span class="keyword">val</span> topArea = <span class="keyword">if</span> (leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[rightBottomX][leftTopY - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> leftTopArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span> || leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][leftTopY - <span class="number">1</span>]</span><br><span class="line">                answer[r][c] = wholeArea - leftArea - topArea + leftTopArea</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1314.矩阵区域和（中等）</title>
    <url>/LeetCode/LeetCode.1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a></p>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p>
<ul>
<li>i - k &lt;= r &lt;= i + k,</li>
<li>j - k &lt;= c &lt;= j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
<span id="more"></span>

<p>提示：</p>
<blockquote>
<p>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, k &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100</p>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力解法需要O($n^4$)时间复杂度，考虑时间更优化的算法。</p>
<h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>题目要求解区域和是二维的，可以简化问题，先看看一维数组某一区间的元素和怎么求，因为二维的区域相当于一维的叠加。</p>
<h2 id="一维数组某区间内元素和怎么快速求解？"><a href="#一维数组某区间内元素和怎么快速求解？" class="headerlink" title="一维数组某区间内元素和怎么快速求解？"></a>一维数组某区间内元素和怎么快速求解？</h2><p>可以预先计算和存储每个位置的前缀和（第0个到第i个元素之间所有元素的和），要计算某个区间的和，用区间端点的前缀和相减就可以在O(1)时间复杂度内求解，但需要占用O(n)空间。</p>
<p>考虑用二维前缀和快速求解面积问题。</p>
<h2 id="二维前缀和定义"><a href="#二维前缀和定义" class="headerlink" title="二维前缀和定义"></a>二维前缀和定义</h2><p>第0行第0列到第r行第c列形成的矩形区域内所有元素的和。<br>记为<code>preSum[r][c]</code>。</p>
<h2 id="怎么利用二维前缀和求解区域面积？"><a href="#怎么利用二维前缀和求解区域面积？" class="headerlink" title="怎么利用二维前缀和求解区域面积？"></a>怎么利用二维前缀和求解区域面积？</h2><p>比如要求区域d的元素和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列：                  </span><br><span class="line">0   a a a b b b b b   </span><br><span class="line">1   a a a b b b b b</span><br><span class="line">2   c c c d d d d d</span><br><span class="line">3   c c c d d d d d</span><br><span class="line">4   c c c d d d d d</span><br><span class="line">行： 0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>公式表达：<br><code>区域d所有元素和 = preSum[7,4] - preSum[2, 4] - preSum[7, 1] + preSum[2, 1]</code><br><code>preSum[7,4]</code>：整个区域所有元素和<br><code>preSum[2, 4]</code>：区域a + 区域c<br><code>preSum[7, 1]</code>：区域a + 区域b<br><code>preSum[2, 1]</code>：区域a</p>
<h2 id="二维前缀和怎么推导？"><a href="#二维前缀和怎么推导？" class="headerlink" title="二维前缀和怎么推导？"></a>二维前缀和怎么推导？</h2><ul>
<li>第一行和第一列前缀和不用推导，左边和上边都没有元素，直接等于元素本身。</li>
<li>第一行上方没有元素，当作一维前缀和求解。</li>
<li>第一列和第一行情况相同，方向变了一下，还是当作一维前缀和求解。</li>
<li>非第一行和非第一列位置的前缀和，跟求解区域和类似，前缀和 = 上方二维前缀和 + 左方二维前缀和 - 左上方二维前缀和 + 本元素值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">matrixBlockSum</span><span class="params">(mat: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, k: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> m = mat.size</span><br><span class="line">        <span class="keyword">val</span> n = mat[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> answer = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) preSum[r][<span class="number">0</span>] = mat[r][<span class="number">0</span>] + preSum[r - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) preSum[<span class="number">0</span>][c] = mat[<span class="number">0</span>][c] + preSum[<span class="number">0</span>][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                preSum[r][c] = mat[r][c] + preSum[r - <span class="number">1</span>][c] + preSum[r][c - <span class="number">1</span>] - preSum[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解区域和</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> leftTopX = maxOf(r - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> leftTopY = maxOf(c - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomX = minOf(r + k, m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomY = minOf(c + k, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> wholeArea = preSum[rightBottomX][rightBottomY]</span><br><span class="line">                <span class="keyword">val</span> leftArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][rightBottomY] </span><br><span class="line">                <span class="keyword">val</span> topArea = <span class="keyword">if</span> (leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[rightBottomX][leftTopY - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> leftTopArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span> || leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][leftTopY - <span class="number">1</span>]</span><br><span class="line">                answer[r][c] = wholeArea - leftArea - topArea + leftTopArea</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.132.分割回文串 II（困难）</title>
    <url>/LeetCode/LeetCode.132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">LeetCode.132.分割回文串 II（困难）</a></p>
<p>给你一个字符串  <code>s</code>，请你将  <code>s</code>  分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的  <strong>最少分割次数</strong>  。</p>
<span id="more"></span>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 2000</code></li>
<li>  <code>s</code>  仅由小写英文字母组成</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="拆解问题"><a href="#拆解问题" class="headerlink" title="拆解问题"></a>拆解问题</h3><p>如果已经求得一个子串的最少分割次数，是可以推导出整个串的最少分割次数。</p>
<ul>
<li>要保证分割次数最少，先检查整个串s是不是回文。<ul>
<li>如果是，就不用分割了，分割次数是0。</li>
<li>如果s不是回文，需要在0到<code>n - 1</code>（n为s长度）中找一个分割位置<code>i</code>。<ul>
<li>如果<code>s[0: i]</code>的最少分割次数已经知道<code>（0 &lt;= i &lt; n）</code>，同时<code>s[i + 1:]</code>是回文，说明在<code>s[0: i]</code>的最少分割次数基础上还要再多分割一次才能完成整个串的分割，那么整个字符串s的最少分割次数就是<code>s[0: i]</code>的最少分割次数 + 1。</li>
<li>而<code>s[0: i]</code>的最少分割次数其实是需要把<code>i</code>从0到<code>n - 2</code>全部遍历一遍才知道哪一种分割的次数是最小的，那么<code>s[0: i]</code>的最少分割次数的求法，跟上述过程一样，可以递推。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：s[0: i]是python中截取子串的表示方法，表示截取第0位到第i位的字符)</p>
</blockquote>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>令<code>dp[i]</code>表示<code>s[0: i]</code>的最少分割次数。</p>
<p>如果<code>s[0: i]</code>就是回文，那么<code>dp[i]</code>就是0。<br>如果<code>s[0: i]</code>不是回文，但是它的一个子串<code>s[0: j]</code>的最少分割次数已知(<code>0 &lt;= j &lt; i</code>)，并且<code>s[j + 1: i]</code>是回文，则 <code>dp[i] = dp[j] + 1</code> </p>
<p>最终结果就是求<code>dp[n - 1]</code>，从0开始递推就好了。</p>
<p>递推方程： <code>dp[i] = min(dp[j]) + 1</code>，其中<code>0 &lt;= j &lt; i</code>。</p>
<h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><ul>
<li>初始状态<code>dp[0]</code>就是<code>s[0: 0]</code>的最少分割次数，<code>s[0: 0]</code>就是首字符，单个字符是回文串，所以不用分割，<code>dp[0] = 0</code>。</li>
<li>最坏的情况就是每个字符都分割，因为每个单字符都是回文，最大的分割次数就是<code>n - 1</code>，可以给<code>dp</code>数组初始化。</li>
</ul>
<h3 id="怎么快速判断s-i-j-是回文？"><a href="#怎么快速判断s-i-j-是回文？" class="headerlink" title="怎么快速判断s[i, j]是回文？"></a>怎么快速判断s[i, j]是回文？</h3><p>最好预处理整个s，把s的所有子串都判断一下是不是回文串，这样就可以做到O(1)的查表操作来快速判断了。</p>
<p>这里跟 <a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a> 处理方式一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCut</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n)</span><br><span class="line">        <span class="comment">// s[0: i]的子串最大分割次数，就是每个字符都分割一下，分割i次（1 &lt;= i &lt; n）</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 判断s[0:i]是不是回文</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, i)) &#123;</span><br><span class="line">                <span class="comment">// s[0:i]是回文，不用分割，最少分割次数是0</span></span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s[0:i]不是回文，需要在[0,i)之间找到一个分割位置j，使得s[j+1:i]是回文，同时dp[j]最小</span></span><br><span class="line">            <span class="comment">// 需要从0开始遍历到i-1去寻找出最小的分割位置j</span></span><br><span class="line">            <span class="comment">// 这样也才能利用递推，利用之前存储过的状态，因为是从索引0开始递推的</span></span><br><span class="line">            <span class="keyword">var</span> minCut = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(s, j + <span class="number">1</span>, i)) &#123;</span><br><span class="line">                    <span class="comment">// s[j+1:i]是回文，dp[j]+1是dp[i]可能的一个取值，需要找一个最小的</span></span><br><span class="line">                    minCut = minOf(minCut, dp[j] + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// s[j+1:i]不是回文，当前的分割是无效的，就看下一个分割了，忽略当前的分割</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s[0:i]最大的分割次数，就是i次了，在前面已经初始化过了</span></span><br><span class="line">            <span class="comment">// 如果s[0:i]存在更少的分割，更新dp[i]的值</span></span><br><span class="line">            <span class="keyword">if</span> (minCut != <span class="built_in">Int</span>.MAX_VALUE) &#123;</span><br><span class="line">                dp[i] = minCut</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dpStates: Array&lt;Array&lt;<span class="built_in">Boolean</span>&gt;&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串[s]索引从[start]到[end]的子串是否是回文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isPalindrome</span><span class="params">(s: <span class="type">String</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> states = dpStates ?: getPalindromeStates(s)</span><br><span class="line">        dpStates = states</span><br><span class="line">        <span class="keyword">return</span> states[start][end]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPalindromeStates</span><span class="params">(s: <span class="type">String</span>)</span></span>: Array&lt;Array&lt;<span class="built_in">Boolean</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(n) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="comment">// 遍历所有长度的子串，length代表子串的长度，可以从1一直取值到n</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 把所有是长度为length的子串都检查一遍，看是不是回文，start就要从0开始取值，一直取到n-length</span></span><br><span class="line">            <span class="comment">// start 是应该小于 n-length 还是小于等于?</span></span><br><span class="line">            <span class="comment">// 可以举例n为5，length为2，直观上看最后一个length为2的子串应该是s[3:4]，start为3，是n-length的结果</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.(n - length)) &#123;</span><br><span class="line">                <span class="comment">// end和start之间保持相距length</span></span><br><span class="line">                <span class="keyword">val</span> end = start + length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (start + <span class="number">1</span> &lt;= end - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>] &amp;&amp; s[start] == s[end]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = s[start] == s[end]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n^2)</p>
<p>n 是字符串 s 的长度。<br>预处理计算s所有子串是否是回文和动态规划计算s最小分割次数的时间复杂度均为 O(n^2)。</p>
<p>空间复杂度：O(n^2)</p>
<p>预处理计算s所有子串是否是回文需要O(n^2)的空间占用。<br>动态规划计算s最小分割次数需要O(n)的空间占用。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.135.分发糖果（困难）</title>
    <url>/LeetCode/LeetCode.135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/candy/">LeetCode.135.分发糖果（困难）</a></p>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>难点在于<code>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</code></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>化繁为简，这里可以拆解为两个规则：</p>
<ul>
<li>左规则：当 <code>ratings[i − 1] &lt; ratings[i]</code> 时，第<code>i</code> 个学生的糖果数量比第<code>i − 1</code>个孩子的糖果数量多。</li>
<li>右规则：当 <code>ratings[i] &gt; ratings[i + 1]</code> 时，第<code>i</code> 个学生的糖果数量比第<code>i + 1</code>个孩子的糖果数量多。</li>
</ul>
<h3 id="如何求解？"><a href="#如何求解？" class="headerlink" title="如何求解？"></a>如何求解？</h3><ul>
<li>先从左到右遍历评分数组，按左规则分配糖果。</li>
<li>再从右到左遍历评分数组，按右规则分配糖果。</li>
<li>最后同时满足左右规则的糖果数量就是最终结果，也就是取两者较大值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> left = IntArray(ratings.size) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> right = IntArray(ratings.size) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                right[i - <span class="number">1</span>] = right[i] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.indices) &#123;</span><br><span class="line">            sum += maxOf(left[i], right[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n)，n 是孩子的数量，要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。</li>
<li>空间复杂度：O(n)，要保存所有的左、右规则对应的糖果数量。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>之前的解法已经把思路打开了，可以从左到右遍历分析看看能不能不占用额外空间就可以求解。</p>
<p>孩子的分数的排列无非是递增、递减、相等三种情况。</p>
<p>从左向右看：</p>
<ul>
<li><strong>如果孩子分数相等</strong>，就分配1个糖果。</li>
<li><strong>如果孩子处于分数递增的序列中</strong>，可以发现糖果数量从左到右看是会从1开始递增，这样糖果分配数量才最少。</li>
<li><strong>如果孩子处于分数递减的序列中</strong>，可以发现糖果数量从左到右看是会递减到1，这样糖果分配数量才最少。<ul>
<li>如果从分配到1个糖果的孩子从右到左看，糖果数量是会递增到递减序列的开始位置。</li>
<li>所以统计递减序列应该分配多少糖果，只要统计递减序列有多长，看做跟递增情况分配形式一样就行了。</li>
</ul>
</li>
</ul>
<p><strong>递减序列的起点在哪？</strong><br><code>rating[i] &lt; rating[i - 1] &amp;&amp; rating[i - 1] &gt; rating[i - 2]</code>时，<code>i</code>就是递减序列的起点。</p>
<p><strong>边界情况</strong></p>
<p>由于递增序列最后一个元素也可以算是递减序列的一个元素，所以它是受右规则约束的。</p>
<p>比如递增序列有3个元素，递减序列有8个元素，那么递增序列的第3个元素在递增遍历时分配了3个糖果，但最后实际应当分配9个糖果。这多的6个糖果应该怎么算进去？</p>
<p>可以发现如果递增序列和递减序列一样长：</p>
<ul>
<li>递增序列最后一个孩子和递减序列第一个孩子分配的糖果数量是一样的。</li>
<li>这两个孩子的分数可能不一样。</li>
</ul>
<p>这样的话要给递增序列最后一个孩子或递减序列第一个孩子多分配1个糖果的，才能满足左规则和右规则。</p>
<ul>
<li>如果递减序列比递增序列长1，就只能给递增序列最后一个孩子多分配2个糖果。</li>
<li>如果递减序列比递增序列长2，就只能给递增序列最后一个孩子多分配3个糖果。</li>
<li>如果递减序列比递增序列长3，就只能给递增序列最后一个孩子多分配4个糖果。</li>
</ul>
<p>所以：如果递减序列比递增序列长x，就只能给递增序列最后一个孩子多分配x + 1个糖果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = ratings.size</span><br><span class="line">        <span class="comment">// 上一个孩子的糖果数，第一个孩子默认分配1个糖果</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 糖果数量，第一个孩子默认分配1个糖果</span></span><br><span class="line">        <span class="keyword">var</span> candies = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 递增序列长度，已经有一个孩子分配了糖果</span></span><br><span class="line">        <span class="keyword">var</span> inc = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 递减序列长度</span></span><br><span class="line">        <span class="keyword">var</span> dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                ratings[i] == ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 分数持平，分配最少的糖果</span></span><br><span class="line">                    candies += <span class="number">1</span></span><br><span class="line">                    pre = <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 递增序列的开始，算递增序列第1个元素</span></span><br><span class="line">                    inc = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 糖果数为1时，递减序列还没开始或者刚结束</span></span><br><span class="line">                    dec = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                ratings[i] &gt; ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 分数递增，比前一个孩子多分配一个糖果</span></span><br><span class="line">                    <span class="keyword">val</span> cur = pre + <span class="number">1</span></span><br><span class="line">                    candies += cur</span><br><span class="line">                    pre = cur</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 递增序列长度在增加</span></span><br><span class="line">                    inc = cur</span><br><span class="line">                    <span class="comment">// 递减序列还没开始</span></span><br><span class="line">                    dec = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                ratings[i] &lt; ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 递减序列长度累加</span></span><br><span class="line">                    dec++</span><br><span class="line">                    <span class="comment">// 给递增序列最后一个孩子多分配 `递减序列长度 - 递增序列长度` 个糖果</span></span><br><span class="line">                    <span class="keyword">if</span> (inc == dec) dec++</span><br><span class="line">                    <span class="comment">// 把递减序列当做递增序列看，最终分配形式是一样的</span></span><br><span class="line">                    candies += dec</span><br><span class="line">                    <span class="comment">// 糖果数量递减到1时，要记录下来</span></span><br><span class="line">                    pre = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n)，遍历一次数组。</li>
<li>空间复杂度：O(1)，仅适用常数个变量。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.139.单词拆分（中等）</title>
    <url>/LeetCode/LeetCode.139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h3><p>提到拆分，我们可以考虑能不能把大问题拆分为子问题+有限步骤，给问题建模，简化讨论。</p>
<ol>
<li>如果s可以被拆分，那么至少s的末尾字符组成的单词肯定是在wordDict中的。<ul>
<li>s的末尾字符组成的单词，可以从s的末尾位置开始，依次穷举取长度为1、2、3……n的子字符串，看子字符串是否在wordDict中。</li>
<li>接下来再去看剩下的前半部分的子字符串能不能继续拆分成功。</li>
</ul>
</li>
<li>如果s不能被拆分，有两种情况:<ol>
<li>穷举s所有末尾子字符串，是没有一个子字符串是在wordDict中的。</li>
<li>末尾有一部分子字符串组成的单词在wordDict中，最后s剩下前半段的子字符串不能被wordDict拆分。</li>
</ol>
</li>
</ol>
<p>这里已经划分出了子问题+有限步骤，可以用递归来解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 如果字符串能拆完，最后索引肯定为-1</span></span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 在字符串s[0,end]中，从末尾依次取长度为1、2、3……end+1的子字符串，检查子字符串是否在wordDict里</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 截取末尾字符串</span></span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 末尾字符串在wordDict里</span></span><br><span class="line">                <span class="comment">// 剩下的前半段子字符串s[0,start - 1]有可能可以被继续拆分，也有可能不可以被拆分，不知道能不能就只能每个情况都试一下</span></span><br><span class="line">                <span class="comment">// 所以这里不是直接return，而是要试一下每一种的单词拆分，看哪一种行的通</span></span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    <span class="comment">// end指向剩下的前半部分子字符串末尾</span></span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试拆分s[0, n - 1]</span></span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h4><p>递归的问题在于有重叠子问题，有很多重复计算耗时，保存一下中间计算结果就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(s.length) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (memo[end] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">if</span> (memo[end] == <span class="number">1</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[end] = <span class="keyword">if</span> (result) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法3：自下而上递推式动态规划"><a href="#解法3：自下而上递推式动态规划" class="headerlink" title="解法3：自下而上递推式动态规划"></a>解法3：自下而上递推式动态规划</h4><p>能用记忆化递归的，也可以用自下而上递推的方式做。</p>
<p>设<code>dp[end]</code>为第0个到第end个字符组成的字符串是否可以被wordDict中的单词拆分。<br>穷举所有<code>s[0, end]</code>的末尾字符串，判断能否拆分。<br>设<code>s[0, end]</code>的末尾字符串的开始索引为<code>start</code>，<code>0 &lt;= start &lt;= end</code>。</p>
<p><strong>状态转移方程</strong><br><code>dp[end] = dp[start - 1] &amp;&amp; s[start, end] in wordDict</code></p>
<p><code>start==0</code> 时，截取的是整个字符串，直接判断整个字符串是否在wordDict里就行了，<code>dp[0] = s[start, end] in wordDict</code>。</p>
<p>由于计算新的状态需要读取之前的每个最优化的状态，所以空间无法优化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> dp = BooleanArray(n) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (end <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.end) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[start - <span class="number">1</span>] &amp;&amp; word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.140.单词拆分 II（困难）</title>
    <url>/LeetCode/LeetCode.140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-break-ii/">LeetCode.140.单词拆分 II（困难）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<span id="more"></span>

<p>说明：</p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果知道<code>s</code>的末尾的字符组成的单词处在wordDict中，并且前面的子串也是可以被wordDict拆分，就可以把末尾的单词添加到句子中。</p>
<ul>
<li><code>s</code>的末尾字符能不能组成wordDict中的单词，可以从末尾索引开始往前遍历一个个的试。</li>
<li>前面的子串是否可以被wordDict拆分，需要提前计算好，这里就借用 <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a>中的状态表，即<code>dp[i]</code>：<code>s</code>的前<code>i</code>个字符组成的子串能否拆分成<code>wordDict</code>中的若干个单词。</li>
</ul>
<p>用深度优先搜索递归试一遍就行，直到把<code>s</code>拆分完，结束搜索。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = wordDict.toHashSet()</span><br><span class="line">        <span class="keyword">val</span> dp = getDpState(s, <span class="keyword">set</span>)</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        dfs(s, <span class="keyword">set</span>, s.length, result, dp, Stack())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个一维数组，第i位表示，[s]的前i个字符组成的子串拆分成[wordDict]中的若干个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDpState</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>: Array&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> state = Array(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        state[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">val</span> s2 = s.substring(j, i)</span><br><span class="line">                <span class="keyword">if</span> (state[j] &amp;&amp; wordDict.contains(s2)) &#123;</span><br><span class="line">                    state[i] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;, end: <span class="type">Int</span>, result: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;, dp: <span class="type">Array</span>&lt;<span class="type">Boolean</span>&gt;, path: <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// s[0:end-1]是否是单词，是的话，应当添加到路径中，同时是也是路径的终点，即递归树的叶子节点</span></span><br><span class="line">        <span class="keyword">val</span> prefix = s.substring(<span class="number">0</span>, end)</span><br><span class="line">        <span class="keyword">if</span> (wordDict.contains(prefix)) &#123;</span><br><span class="line">            path.push(prefix)</span><br><span class="line">            result.add(path.reversed().joinToString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            path.pop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检索所有子串的拆分的可能组合</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.end) &#123;</span><br><span class="line">            <span class="comment">// 前i个字符组成的左子串是可以被拆分为若干个单词的</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i]) &#123;</span><br><span class="line">                <span class="comment">// 就看右子串是否是单词</span></span><br><span class="line">                <span class="keyword">val</span> substring = s.substring(i, end)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(substring)) &#123;</span><br><span class="line">                    <span class="comment">// 右子串是一个单词，应当添加到路径中</span></span><br><span class="line">                    path.push(substring)</span><br><span class="line">                    <span class="comment">// 继续探寻左子串s[0:i-1]</span></span><br><span class="line">                    dfs(s, wordDict, i, result, dp, path)</span><br><span class="line">                    <span class="comment">// 左子串探寻完了，从路径中移除当前单词，以不影响寻找下一个组合的单词路径</span></span><br><span class="line">                    path.pop()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1483.树节点的第 K 个祖（困难）</title>
    <url>/LeetCode/LeetCode.1483.%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC%20K%20%E4%B8%AA%E7%A5%96%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/">LeetCode.1483.树节点的第 K 个祖（困难）</a></p>
<p>给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。</p>
<p>请你设计并实现 getKthAncestor(int node, int k) 函数，函数返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。</p>
<p>树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul>
<li>go[i][x]表示结点x的第 2的i次幂 个祖先结点，即x往上跳 2的i次幂 后达到的结点。</li>
<li>x跳<code>2的i次幂</code>步可以分解为先跳了<code>2的i-1次幂</code>步，再跳<code>2的i-1次幂</code>步。</li>
<li>从x跳<code>2的i-1次幂</code>步后的到达的结点为go[i-1][x]，令其为y。</li>
<li>再跳<code>2的i-1次幂</code>步后到达的结点为go[i-1][y]。</li>
<li>则go[i][x] = go[i-1][y] = go[i-1][go[i-1][x]]。</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>把i放在二维数组的第一维，x放在二维数组的第二维。</li>
<li>因为i的取值范围很小，n可能很大。</li>
<li>将小维度的循环放在外层，可以提高缓存的命中率，进而提高程序运行速度。</li>
</ul>
<h2 id="i的取值范围是多少？"><a href="#i的取值范围是多少？" class="headerlink" title="i的取值范围是多少？"></a>i的取值范围是多少？</h2><p>二叉树有n个结点，树高最多n层，退化为一个长度为n链表，最坏情况下就是求叶结点的第n-1个祖先。</p>
<p>用1 + $log_2{(n-1)}$（向下取整）个二进制位足以表示n-1。</p>
<p>例如8的二进制是1000，16的二进制位10000，8是2的3次幂，16是2的4次幂。</p>
<p>大于等于8小于16的数用4位二进制就可以表示：1000、1001、1010、1011、1100、1101、1110、1111。</p>
<p>所以n-1可以用多少位二进制表示，求$log_2{(n-1)}$后向下取整再加1即可</p>
<h2 id="怎么求第k个祖先？"><a href="#怎么求第k个祖先？" class="headerlink" title="怎么求第k个祖先？"></a>怎么求第k个祖先？</h2><p>把k拆解为2的幂的和，即检查k的二进制的每一位是否是1，第i位是1就往上跳<code>2的i次幂</code>步，这样最多检查（跳）1 + $log_2{(n-1)}$次，因为有效的k最大也就是n-1，n-1用1 + $log_2{(n-1)}$个二进制位可以表示，所以可在O($log_2{n}$)时间内找到第k个祖先</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.log2</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倍增法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeAncestor</span></span>(n: <span class="built_in">Int</span>, parent: IntArray) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树有n个结点，树高最多n层，退化为一个长度为n链表，最坏情况下就是求叶结点的第n-1个祖先</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用1 + log_2&#123;n&#125;（向下取整）个二进制位足以表示n</span></span><br><span class="line"><span class="comment">     * 例如8的二进制是1000，16的二进制位10000，8是2的3次幂，16是2的4次幂</span></span><br><span class="line"><span class="comment">     * 大于等于8小于16的数用4位二进制就可以表示：1000、1001、1010、1011、1100、1101、1110、1111</span></span><br><span class="line"><span class="comment">     * 所以n可以用多少位二进制表示，对n向下取整再加1即可求得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bits = log2((n - <span class="number">1</span>).toDouble()).toInt() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * go[i][x]表示结点x的第 2的i次幂 个祖先结点，即x往上跳 2的i次幂 后达到的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * x跳 2的i次幂 步可以分解为先跳了 2的i-1次幂 步，再跳 2的i-1次幂 步</span></span><br><span class="line"><span class="comment">     * 从x跳 2的i-1次幂 步后的到达的结点为go[i-1][x]，令其为y</span></span><br><span class="line"><span class="comment">     * 再跳 2的i-1次幂 步后到达的结点为go[i-1][y]</span></span><br><span class="line"><span class="comment">     * 则go[i][x] = go[i-1][go[i-1][x]]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么要把i放在二维数组的第一维，x放在二维数组的第二维？</span></span><br><span class="line"><span class="comment">     * 因为i的取值范围很小，n可能很大</span></span><br><span class="line"><span class="comment">     * 将小维度的循环放在外层，可以提高缓存的命中率，进而提高程序运行速度</span></span><br><span class="line"><span class="comment">     * 因为内存从外存读取数据是按块读取的，CPU从内存读取数据到CPU缓存也是按块的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> go = Array(bits) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理时间复杂度O(n * log n)</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// go[i][x] = go[i-1][go[i-1][x]]</span></span><br><span class="line">        <span class="comment">// 求go[i][x]是依赖于前一步的，需要初始化最一开始的情景</span></span><br><span class="line">        <span class="comment">// i最小取0，go[0][x]为x的第1个（第2的0次幂个）祖先结点，即x的父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个结点的第 2的0次幂 个祖先，即第1个祖先，就是它们的直接父结点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            go[<span class="number">0</span>][i] = parent[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次求出每个结点x往上跳 2的1次幂、2的2次幂...2的bits-1次幂 步后到达的结点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until bits) &#123;</span><br><span class="line">            <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (go[i - <span class="number">1</span>][x] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// x往上跳 2的i次幂 步，可以看作是先跳了 2的i-1次幂 步，再跳 2的i-1次幂 步</span></span><br><span class="line">                    <span class="comment">// 从结点x往上先跳 2的i-1次幂 步后到达的结点是go[i - 1][x]，设其为y，y在前一轮循环已经求过了</span></span><br><span class="line">                    <span class="comment">// 从结点y往上再跳 2的i-1次幂 步后达到的结点，在上一轮循环也求过了</span></span><br><span class="line">                    <span class="comment">// 所以这个递推关系就可以顺利进行</span></span><br><span class="line">                    go[i][x] = go[i - <span class="number">1</span>][go[i - <span class="number">1</span>][x]]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 之前已经往上跳到根结点了，后面也没必要再跳了</span></span><br><span class="line">                    go[i][x] = -<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把k拆分为2的幂的和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 查询时间复杂度O(log n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getKthAncestor</span><span class="params">(node: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ancestor = node</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> bits - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// k的二进制在第i位为0，不往上跳</span></span><br><span class="line">            <span class="keyword">val</span> mask = <span class="number">1</span> shl i</span><br><span class="line">            <span class="keyword">if</span> (k and mask == <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// k的二进制在第i位为1，可以往上跳 2的i次幂 步</span></span><br><span class="line">            ancestor = go[i][ancestor]</span><br><span class="line">            <span class="comment">// 不存在node的第k个祖先</span></span><br><span class="line">            <span class="keyword">if</span> (ancestor == -<span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>倍增法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.149.直线上最多的点数（困难）</title>
    <url>/LeetCode/LeetCode.149.%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">LeetCode.149.直线上最多的点数（困难）</a></p>
<p>给你一个数组  <code>points</code>  ，其中  <code>points[i] = [xi, yi]</code>  表示  <strong>X-Y</strong>  平面上的一个点。求最多有多少个点在同一条直线上。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力法梳理出整体框架，剩下细节问题和边界问题再填充。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>穷举所有可能形成的直线。</li>
<li>统计有多少点在这一条直线上。</li>
<li>记录最大的点数。</li>
</ul>
<h3 id="如何确定一个点是否在一条直线上？"><a href="#如何确定一个点是否在一条直线上？" class="headerlink" title="如何确定一个点是否在一条直线上？"></a>如何确定一个点是否在一条直线上？</h3><p>已知点<code>(x1, y1)</code>和<code>(x2, y2)</code>确定的一条直线L。</p>
<p>判断点<code>(x, y)</code>是否在直线L上，可以判断点<code>(x1, y1)</code>和点<code>(x, y)</code>组成的直线的斜率是否与直线L的斜率相等。</p>
<p>换成数学表达式即判断 <code>(y2 - y1) / (x2 - x1) == (y - y1) / (x - x1)</code>。<br>其中两点不能是同一个点，<code>x1</code>不等于<code>x</code>。</p>
<h3 id="斜率计算是浮点数，比较判断不准确怎么办？"><a href="#斜率计算是浮点数，比较判断不准确怎么办？" class="headerlink" title="斜率计算是浮点数，比较判断不准确怎么办？"></a>斜率计算是浮点数，比较判断不准确怎么办？</h3><ul>
<li>由于计算机除法存在数学精度问题，需要把上述表达式的比较，转换为对分子和分母分别比较。</li>
<li>比较之前需要将分子分母约分到最简，进而就要求分子和父母的最大公约数。</li>
<li>可使用辗转相除法来求最大公约数，约分分子、分母到最简。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxPoints</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">// 一个点和两个点都是在同一个直线上</span></span><br><span class="line">        <span class="keyword">if</span> (points.size &lt; <span class="number">3</span>) <span class="keyword">return</span> points.size</span><br><span class="line">        <span class="comment">// 所有的点都是同一个点，表示所有的点都在同一条直线上</span></span><br><span class="line">        <span class="keyword">if</span> (points.distinctBy &#123; <span class="string">&quot;<span class="subst">$&#123;it[<span class="number">0</span>]&#125;</span>,<span class="subst">$&#123;it[<span class="number">1</span>]&#125;</span>&quot;</span> &#125;.size == <span class="number">1</span>) <span class="keyword">return</span> points.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = points.size</span><br><span class="line">        <span class="keyword">var</span> maxPoints = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> x1 = points[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> y1 = points[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> x2 = points[j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">val</span> y2 = points[j][<span class="number">1</span>]</span><br><span class="line">                <span class="comment">// 同一个点确立不了直线，直接跳过，之后再确立了直线的情况，会考察到跳过的这个点</span></span><br><span class="line">                <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">// (x1,y1)和(x2,y2)确立一条直线</span></span><br><span class="line">                <span class="keyword">val</span> line = Line(x1, y1, x2, y2)</span><br><span class="line">                <span class="comment">// 统计所有其他的点，是否在这条线上</span></span><br><span class="line">                <span class="keyword">var</span> tmpMax = <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == i || k == j) <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">val</span> x3 = points[k][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">val</span> y3 = points[k][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> (line.isOnTheLine(x3, y3)) &#123;</span><br><span class="line">                        <span class="comment">// 发现有一个点在线上，计数</span></span><br><span class="line">                        tmpMax++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpMax &gt; maxPoints) &#123;</span><br><span class="line">                    maxPoints = tmpMax</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPoints</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点([x1],[y1])和点([x2],[y2])确定一条直线</span></span><br><span class="line"><span class="comment">     * 直线的斜率为(y2-y1)/(x2-x1)</span></span><br><span class="line"><span class="comment">     * 限制条件：两点不能是同一个点，同时x1不等于x2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>(</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> x1: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> y1: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> x2: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> y2: <span class="built_in">Int</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 点([x],[y])是否在同一直线上</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 可判断点([x1],[y1])和点([x],[y])组成的直线斜率是否之前的直线相等</span></span><br><span class="line"><span class="comment">         * 换成数学表达式即 (y2-y1)/(x2-x1) == (y-y1)/(x-x1)</span></span><br><span class="line"><span class="comment">         * 其中两点不能是同一个点，x1不等于x</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 由于存在数学精度问题，需要把上述表达式的比较，转换为对分子和分母分别比较，比较之前需要将分子分母约分到最简</span></span><br><span class="line"><span class="comment">         * 进而就要求分子和父母的最大公约数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">isOnTheLine</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == x1 &amp;&amp; y == y1 || x == x2 &amp;&amp; y == y2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> d1 = greatestCommonDivisor(y2 - y1, x2 - x1)</span><br><span class="line">            <span class="keyword">val</span> d2 = greatestCommonDivisor(y - y1, x - x1)</span><br><span class="line">            <span class="keyword">val</span> isSameNumerator = (y2 - y1) / d1 == (y - y1) / d2</span><br><span class="line">            <span class="keyword">val</span> isSameDenominator = (x2 - x1) / d1 == (x - x1) / d2</span><br><span class="line">            <span class="keyword">return</span> isSameNumerator &amp;&amp; isSameDenominator</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 求[a]和[b]的最大公约数</span></span><br><span class="line"><span class="comment">         * 使用辗转相除法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">greatestCommonDivisor</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a</span><br><span class="line">            <span class="keyword">var</span> big = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">var</span> small = <span class="keyword">if</span> (a &lt; b) a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">while</span> (small != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> remainder = big % small</span><br><span class="line">                big = small</span><br><span class="line">                small = remainder</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> big</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n^3)</code></li>
<li>空间复杂度<code>O(1)</code></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.152.乘积最大子数组（中等）</title>
    <url>/LeetCode/LeetCode.152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode.152.乘积最大子数组（中等）</a></p>
<p>给你一个整数数组  <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最值问题考虑用动态规划。</p>
<p>为了方便描述，设<code>maxProduct[i]</code>为以<code>nums[i]</code>结尾的子数组的最大乘积。</p>
<p>求<code>maxProduct[i]</code>，<code>nums[i]</code>肯定少不了，因为子数组最少需要一个元素。</p>
<h2 id="求maxProduct-i-有哪些可能的组合情况？"><a href="#求maxProduct-i-有哪些可能的组合情况？" class="headerlink" title="求maxProduct[i]有哪些可能的组合情况？"></a>求maxProduct[i]有哪些可能的组合情况？</h2><ol>
<li><code>nums[i]</code>自己单独成为一个子数组。<br>比如前面子数组乘积是0，<code>nums[i]</code>为正数，就没必要跟前面相乘了。但是<code>nums[i]</code>可能会比前面子数组乘积要小，所以要看看其他情况。</li>
<li><code>nums[i]</code>跟前面的子数组的乘积相乘。<br>接下来就是看怎么跟<code>nums[i]</code>相乘可以得到尽可能大的乘积。</li>
</ol>
<h2 id="有哪些乘法情况可以使乘积变大？"><a href="#有哪些乘法情况可以使乘积变大？" class="headerlink" title="有哪些乘法情况可以使乘积变大？"></a>有哪些乘法情况可以使乘积变大？</h2><ol>
<li>正数 * 正数</li>
<li>负数 * 负数</li>
</ol>
<p>也就是说求<code>maxProduct[i]</code>要记录<code>nums[i]</code>前面的子数组的最大乘积和最小乘积。</p>
<h2 id="穷举求maxProduct-i-要考虑的情况"><a href="#穷举求maxProduct-i-要考虑的情况" class="headerlink" title="穷举求maxProduct[i]要考虑的情况"></a>穷举求maxProduct[i]要考虑的情况</h2><ol>
<li><code>nums[i]</code>单独成为一个子数组</li>
<li><code>nums[i]</code>乘以i前面的子数组最大的乘积</li>
<li><code>nums[i]</code>乘以i前面的子数组最小的乘积</li>
</ol>
<p>求<code>maxProduct[i]</code>就是取三者最大值</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p><code>maxProduct[i] = max(nums[i],  nums[i] * maxProduct[i - 1], nums[i] * minProduct[i - 1])</code></p>
<h2 id="怎么求以nums-i-结尾的连续子数组的最小乘积？"><a href="#怎么求以nums-i-结尾的连续子数组的最小乘积？" class="headerlink" title="怎么求以nums[i]结尾的连续子数组的最小乘积？"></a>怎么求以nums[i]结尾的连续子数组的最小乘积？</h2><p>跟考虑求最大乘积思路一样。<br>使乘积变得更小的方式就是正数和负数相乘。<br><code>nums[i]</code>可能为正也可能为负，所以<code>minProduct[i]</code>的求解也是有<code>maxProduct[i]</code>的那三种情况，只不过是求最小值。</p>
<h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><p><code>maxProduct[0]</code>就是<code>nums[i]</code>本身，因为以<code>nums[0]</code>为结尾的子数组就是<code>nums[0]</code>本身构成的一个元素的子数组。<br>同理，<code>minProduct[0]</code>也是<code>nums[i]</code>。</p>
<p>递推要从<code>i = 1</code>开始。</p>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p>当前状态只跟上一步状态有关，所以不需要用数组存储所有状态，用几个变量记录上一步状态即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProduct</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> minProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> maxProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> result = maxProduct</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> num = nums[i]</span><br><span class="line">            <span class="keyword">val</span> newMaxProduct = maxOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            minProduct = minOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            maxProduct = newMaxProduct</span><br><span class="line">            result = maxOf(result, maxProduct)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.154.寻找旋转排序数组中的最小值 II（困难）</title>
    <url>/LeetCode/LeetCode.154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode.154.寻找旋转排序数组中的最小值 II（困难）</a></p>
<span id="more"></span>

<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</li>
<li>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]</li>
</ul>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>提示：</p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p>进阶：</p>
<ul>
<li>这道题是 寻找旋转排序数组中的最小值 的延伸题目。</li>
<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过模拟可知，多次旋转后得到还是跟一次旋转一样的效果。</p>
<p>旋转一次后，数组可以分为左右两个子数组<code>nums1</code>和<code>nums2</code>，其中：</p>
<ul>
<li><code>nums1</code>和<code>nums2</code>本身都有序。</li>
<li><code>nums1中所有元素 &gt;= nums2中所有元素</code>。<ul>
<li><code>nums1</code>的首元素可能与<code>nums2</code>尾元素相等。</li>
</ul>
</li>
</ul>
<p><strong>最小的数字</strong>是<code>nums2</code>的第一个元素。</p>
<p>二分查找的时候，只要知道<code>nums[mid]</code>是位于<code>nums1</code>还是<code>nums2</code>中，就知道下一步应该往哪去缩减寻找范围。</p>
<h3 id="怎么知道nums-mid-是不是位于nums1？"><a href="#怎么知道nums-mid-是不是位于nums1？" class="headerlink" title="怎么知道nums[mid]是不是位于nums1？"></a>怎么知道nums[mid]是不是位于<code>nums1</code>？</h3><p><code>nums[mid] &gt; nums[0]</code>时，<code>nums[mid]</code>一定位于<code>nums1</code>。</p>
<h3 id="nums-mid-位于nums1，接下来往哪找最小的数？"><a href="#nums-mid-位于nums1，接下来往哪找最小的数？" class="headerlink" title="nums[mid]位于nums1，接下来往哪找最小的数？"></a>nums[mid]位于nums1，接下来往哪找最小的数？</h3><p>最小的数字是<code>nums2</code>的第一个元素，接下来要往右找。</p>
<h3 id="怎么知道nums-mid-是不是位于nums2？"><a href="#怎么知道nums-mid-是不是位于nums2？" class="headerlink" title="怎么知道nums[mid]是不是位于nums2？"></a>怎么知道nums[mid]是不是位于nums2？</h3><p><code>nums[mid] &lt; nums[0]</code>时，<code>nums[mid]</code>一定位于<code>nums2</code>。</p>
<h3 id="nums-mid-位于nums2，接下来往哪找最小的数？"><a href="#nums-mid-位于nums2，接下来往哪找最小的数？" class="headerlink" title="nums[mid]位于nums2，接下来往哪找最小的数？"></a>nums[mid]位于nums2，接下来往哪找最小的数？</h3><p>最小的数字是<code>nums2</code>的第一个元素，接下来要往左找。</p>
<h3 id="nums-mid-位于nums2，怎么知道nums-mid-是不是最小的数？"><a href="#nums-mid-位于nums2，怎么知道nums-mid-是不是最小的数？" class="headerlink" title="nums[mid]位于nums2，怎么知道nums[mid]是不是最小的数？"></a>nums[mid]位于nums2，怎么知道nums[mid]是不是最小的数？</h3><p>如果<code>nums[mid]</code>就是最小的数字，<code>mid</code>处于两个升序序列的分割位置，那么<code>nums[mid]</code>一定是比前一个数字要小的，判断<code>nums[mid] &lt; nums[mid - 1]</code>即可。</p>
<h3 id="nums-mid-nums-0-时，接下来应该往哪找？"><a href="#nums-mid-nums-0-时，接下来应该往哪找？" class="headerlink" title="nums[mid] == nums[0]时，接下来应该往哪找？"></a>nums[mid] == nums[0]时，接下来应该往哪找？</h3><p>由于数组允许有重复数字，<code>nums1</code>的首元素可能与<code>nums2</code>尾元素相等，这里就有两种情况：</p>
<ul>
<li>如果<code>nums1</code>的首元素与<code>nums2</code>尾元素相等，不确定<code>nums[mid]</code>是在<code>nums1</code>还是<code>nums2</code>中，只能线性缩减边界。</li>
<li>如果<code>nums1</code>的首元素与<code>nums2</code>尾元素不相等，说明<code>nums[mid]</code>在<code>nums1</code>中，最小元素在<code>nums2</code>中，要向右找。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>只有一个元素，最小的数就是元素本身</li>
<li>如果最后一个数字比第一个数字大，说明没有旋转，第一数字就是最小的了</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMin</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素，最小的数就是元素本身</span></span><br><span class="line">        <span class="comment">// 如果最后一个数字比第一个数字大，说明没有旋转，第一数字就是最小的了</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.size - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> high = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果mid大于第一个数，从第一个数字到mid都是升序的，旋转的部分在右边，最小的数也就在右边，接下来要往右找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) &#123; <span class="comment">// mid比第一个数小，说明mid已处于旋转的部分，最小的数在左边</span></span><br><span class="line">                <span class="comment">// 如果mid就是最小的数字，mid处于两个升序序列的分割位置，那么mid一定是比前一个数字要小的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[mid]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 还没找到最小的，所以要往左边找</span></span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[<span class="number">0</span>]) &#123; <span class="comment">// mid与第一个数相等</span></span><br><span class="line">                <span class="comment">// 如果mid在前面的升序序列接下来就要往右找，在后面的序列就要往左找</span></span><br><span class="line">                <span class="comment">// 但是无法判断这一点，只能从一侧依次递减</span></span><br><span class="line">                <span class="comment">// 如 [1, 0, 1, 1, 1] 和 [1, 1, 1, 0, 1]</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] != nums[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没找到，说明数组元素全部相等</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>平均时间复杂度O(log n)，最坏情况下数组元素全部相同，需要线性扫描整个数组，时间复杂度O(n)。</p>
<p>空间复杂度O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1567.乘积为正数的最长子数组长度（中等）</title>
    <url>/LeetCode/LeetCode.1567.%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">LeetCode.1567.乘积为正数的最长子数组长度（中等）</a></p>
<p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。<br>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。<br>请你返回乘积为正数的最长子数组长度。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最优化问题考虑用动态规划，先从某个状态倒推拆解问题。</p>
<h2 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h2><p>设<code>positive[i]</code>是以<code>nums[i]</code>结尾的子数组中，乘积为正数的最长连续子数组的长度。</p>
<h2 id="如何保证乘积为正数？"><a href="#如何保证乘积为正数？" class="headerlink" title="如何保证乘积为正数？"></a>如何保证乘积为正数？</h2><p>正数 * 正数<br>负数 * 负数</p>
<h2 id="以nums-i-结尾的子数组有哪些组合情况？"><a href="#以nums-i-结尾的子数组有哪些组合情况？" class="headerlink" title="以nums[i]结尾的子数组有哪些组合情况？"></a>以nums[i]结尾的子数组有哪些组合情况？</h2><p>按照<code>nums[i]</code>要不要拿去做乘法，分为：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>跟前面的子数组连接</li>
</ol>
<p>实际去求<code>positive[i]</code>，肯定是尽量与前面的子数组的乘积去相乘，这样会得到尽可能大的结果长度。<br>如果<code>nums[i]</code>没法跟前面的子数组乘积相乘，再单独把<code>nums[i]</code>作为子数组。</p>
<h2 id="如何保证以nums-i-结尾的子数组乘积为正数？"><a href="#如何保证以nums-i-结尾的子数组乘积为正数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为正数？"></a>如何保证以nums[i]结尾的子数组乘积为正数？</h2><ol>
<li><code>nums[i]</code>单独为一个子数组时，<code>nums[i]</code>要为正数</li>
<li><code>nums[i]</code>跟前面的子数组连接时<ol>
<li><code>nums[i]</code>为正，前面子数组乘积为正</li>
<li><code>nums[i]</code>为负，前面子数组乘积为负</li>
</ol>
</li>
</ol>
<p>这里还要记录前面子数组乘积为负数的最长长度，可以定义<code>negative[i]</code>是以<code>nums[i]</code>结尾的子数组中乘积为负数的最长连续子数组的长度。</p>
<h2 id="考虑边界情况"><a href="#考虑边界情况" class="headerlink" title="考虑边界情况"></a>考虑边界情况</h2><ol>
<li>在<code>nums[i]</code>要跟前面的子数组连接时，如果：<ol>
<li><code>nums[i]</code>为正数，前面没有乘积是正数的子数组（比如乘积是0或者负数或者没有任何数），这个时候<code>nums[i]</code>可以单独做一个子数组，<code>positive[i] = 1</code>。</li>
<li><code>nums[i]</code>为负数，前面没有乘积是负数的子数组，这个时候<code>nums[i]</code>单独作为子数组也不是正的，<code>positive[i]</code>是0。</li>
</ol>
</li>
<li><code>nums[i]</code>为0时，<code>positive[0]</code>只能为0，因为单独让<code>nums[i]</code>成为子数组乘积是0，<code>nums[i]</code>跟前面子数组乘积相乘也是0。</li>
</ol>
<h2 id="positive-i-的状态转移方程"><a href="#positive-i-的状态转移方程" class="headerlink" title="positive[i]的状态转移方程"></a>positive[i]的状态转移方程</h2><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1. `positive[i] = positive[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0`，前面有乘积为正数的子数组，正数*正数乘积是正数
 2. `positive[i] = 1`，当`i &gt; 0 &amp;&amp; positive[i - 1] == 0`，前面没有乘积为正数的子数组，`nums[i]`单独作为一个子数组
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `positive[i] = negative[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0`，前面有乘积为负数的子数组，负数*负数乘积是正数
 2. `positive[i] = 0`，当 `i &gt; 0 &amp;&amp; negative[i - 1] == 0`，前面没有乘积为负数的子数组，`nums[i]`没的乘，以`nums[i]`结尾的子数组的乘积没办法变为正数
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>positive[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>positive[0] = if (nums[0] &gt; 0) 1 else 0</code></li>
</ol>
<h2 id="如何保证以nums-i-结尾的子数组乘积为负数？"><a href="#如何保证以nums-i-结尾的子数组乘积为负数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为负数？"></a>如何保证以nums[i]结尾的子数组乘积为负数？</h2><p>跟<code>positive[i]</code>正好相反。<br><code>nums[i]</code>跟前面的子数组连接时：<br>    1. <code>nums[i]</code>为正，前面子数组乘积为负<br>    2. <code>nums[i]</code>为负，前面子数组乘积为正</p>
<h2 id="negative-i-的状态转移方程"><a href="#negative-i-的状态转移方程" class="headerlink" title="negative[i]的状态转移方程"></a>negative[i]的状态转移方程</h2><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1.` i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0` 时，`negative[i] = negative[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; negative[i - 1] == 0` 时，`negative[i] = 0`
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0` 时，`negative[i] = positive[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; positive[i - 1] == 0` 时，`negative[i] = 1`
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>negative[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>negative[0] = if (nums[0] &lt; 0) 1 else 0</code></li>
</ol>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>positive[i]</code>和<code>negative[i]</code>只与上一个状态有关，不需要数据存储所有状态，用变量记录上一个状态即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMaxLen</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> positive = <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> negative = <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxLength = positive</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                nums[i] &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (positive == 0)*/</span> <span class="number">1</span> </span><br><span class="line">                    negative = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (negative[i - 1] == 0)*/</span> <span class="number">0</span> </span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] &lt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newPositive = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (negative == 0) */</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">val</span> newNegative = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (positive == 0) */</span> <span class="number">1</span></span><br><span class="line">                    positive = newPositive</span><br><span class="line">                    negative = newNegative</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] == <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="number">0</span></span><br><span class="line">                    negative = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, positive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.174.地下城游戏（困难）</title>
    <url>/LeetCode/LeetCode.174.%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/dungeon-game/">LeetCode.174.地下城游戏（困难）</a></p>
<span id="more"></span>

<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<p><strong>说明:</strong></p>
<ul>
<li>  骑士的健康点数没有上限。</li>
<li>  任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设<code>dungeon[i][j]</code>为地牢的第<code>i</code>行第<code>j</code>列的点数，可正、可负、可零。</p>
<p>这题跟最小路径和不一样的点在于：<code>在任意格子，都要求骑士的 生命值x &gt;= 1</code>。</p>
<p>如果骑士位于某行某列，则要求<code>x &gt;= 1 &amp;&amp; x + dungeon[i][j] &gt;= 1</code>，不等式两侧的项换个位置也就是：<code>x &gt;= 1 &amp;&amp; x &gt;= 1 - dungeon[i][j]</code>，我们要求最低的生命值，可得<code>x = maxOf(1, 1 - dungeon[i][j])</code>。</p>
<p>但是骑士是要在走动的，光看当前位置的点数，是不知道当前生命值够不够用，需要知道后面的路径需要的最少生命值是多少，假设是<code>y</code>，那么当前位置就要满足<code>x &gt;= 1 &amp;&amp; x + dungeon[i][j] &gt;= y</code>，我们要求最低的生命值，可得<code>x = maxOf(1, y - dungeon[i][j])</code>。</p>
<p>状态转移的过程就出来了，是要从末尾往开头递推，才能得出结果。</p>
<p>从左上到右下的路径，有两种选择，往右走、往下走。不知道往哪走所需的最低初始健康点数最少，就两个都试一遍，取最小的。</p>
<p><strong>边界条件</strong></p>
<ul>
<li>在最后一行，只能向右走，无法向下走。</li>
<li>在最后一列，只能向下走，无法向右走。</li>
</ul>
<p><strong>回溯递归解法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">findMinHp</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                r == m - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r, c + <span class="number">1</span>) - dungeon[r][c])</span><br><span class="line">                c == n - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r + <span class="number">1</span>, c) - dungeon[r][c])</span><br><span class="line">                <span class="keyword">else</span> -&gt; maxOf(<span class="number">1</span>, minOf(findMinHp(r, c + <span class="number">1</span>), findMinHp(r + <span class="number">1</span>, c)) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findMinHp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归存在重叠子问题，例如<code>findMinHp(r + 1, c)</code>会执行多次，需要记录中间状态。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> memo = Array(m) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">findMinHp</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[r][c] != -<span class="number">1</span>) <span class="keyword">return</span> memo[r][c]</span><br><span class="line">            <span class="keyword">val</span> result =  <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[r][c])</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                r == m - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r, c + <span class="number">1</span>) - dungeon[r][c])</span><br><span class="line">                c == n - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r + <span class="number">1</span>, c) - dungeon[r][c])</span><br><span class="line">                <span class="keyword">else</span> -&gt; maxOf(<span class="number">1</span>, minOf(findMinHp(r, c + <span class="number">1</span>), findMinHp(r + <span class="number">1</span>, c)) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">            memo[r][c] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findMinHp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上的动态规划</strong></p>
<p>记忆化递归已经给出了状态转移方程，需要注意的是要从最右下角开始往左上角递推，才能得到结果。</p>
<p>设<code>dp[i][j]</code>表示骑士位于第<code>i</code>行第<code>j</code>列格子时要达到公主处所需要的最小生命值。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li>最右下角：<code>dp[i][j] = maxOf(1, 1 - dungeon[m - 1][n - 1])</code>。</li>
<li>最后一列：<code>dp[i][j] = maxOf(1, dp[r + 1][c] - dungeon[r][c])</code>。</li>
<li>最后一行：<code>dp[i][j] = maxOf(1, dp[r][c + 1] - dungeon[r][c])</code>。</li>
<li>其他行和列：<code>dp[i][j] = maxOf(1, minOf(dp[r][c + 1], dp[r + 1][c]) - dungeon[r][c])</code>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> m - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = maxOf(<span class="number">1</span>, dp[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i][n - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            dp[m - <span class="number">1</span>][i] = maxOf(<span class="number">1</span>, dp[m - <span class="number">1</span>][i + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][i])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> m - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">                dp[r][c] = maxOf(<span class="number">1</span>, minOf(dp[r][c + <span class="number">1</span>], dp[r + <span class="number">1</span>][c]) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.188.买卖股票的最佳时机 IV（困难）</title>
    <url>/LeetCode/LeetCode.188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode.188.买卖股票的最佳时机 IV（困难）</a></p>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最优化问题考虑用动态规划。</p>
<p>看最终结果受哪些因素影响，穷举不同因素的所有状态值，就可以推导出最终结果。</p>
<h3 id="最终收益受哪些维度的状态变化影响？"><a href="#最终收益受哪些维度的状态变化影响？" class="headerlink" title="最终收益受哪些维度的状态变化影响？"></a>最终收益受哪些维度的状态变化影响？</h3><ul>
<li>在第几天买入或卖出肯定是会影响最终收益，可能某一天突然暴涨。</li>
<li>交易次数越多，可能赚取的收益越大。</li>
<li>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。归纳合并一下，这些操作会产生的结果状态是：第<code>i</code>天持有或不持有股票。股票持有状态也会影响最终收益。</li>
</ul>
<p>所以从结果上看，一共有三种纬度的状态变化：</p>
<ul>
<li>第几天做出选择</li>
<li>已经交易了多少次</li>
<li>当前是否持有股票</li>
</ul>
<h3 id="买入的时候算一次交易，还是卖出的时候算一次交易？"><a href="#买入的时候算一次交易，还是卖出的时候算一次交易？" class="headerlink" title="买入的时候算一次交易，还是卖出的时候算一次交易？"></a>买入的时候算一次交易，还是卖出的时候算一次交易？</h3><p>其实都可以，不影响最终结果，只是状态转移过程会有所变化。<br>这里定义买入的时候算一次交易。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i][j][k]</code>表示，前<code>i</code>天，交易了<code>j</code>次，在第<code>i</code>天持有或不持有股票，所获得最大的收益。其中<code>k == 0</code>表示不持有，<code>k == 1</code>表示持有。</p>
<ul>
<li><code>dp[i][j][0]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][0]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天卖出。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][] + prices[i]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>dp[i][j][1]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j][1]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天买入。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j - 1][0] - prices[i]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>第0天<ul>
<li>持有股票的话，不多少次交易，只能直接买入一次。</li>
<li>不持有股票的话，收益就是0。</li>
</ul>
</li>
<li>第<code>i</code>天之前都没有交易即<code>j == 0</code>），第<code>i</code>天要交易操作就买入。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>如果给定的最多交易次数<code>k</code>非常大，状态数组开辟空间也会非常大，的。</p>
<p><strong>交易上限是多少？</strong></p>
<p>一次交易要买入和卖出，总共n天，交易次数不应该超过n / 2。</p>
<p><strong>交易次数超过n / 2要怎么办？</strong></p>
<p>这就等于不限交易次数，与<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a>解法相同，可以复用这种情况下最优化空间的解答。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(k: <span class="type">Int</span>, prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty() || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfitNonLimitCount(prices)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三种状态：第几天买入或卖出、已经交易了多少次、当前是否持有股票</span></span><br><span class="line">        <span class="comment">// dp[i][j][0或1]表示，前i天，交易了j次，在第i天持有或不持有股票，所获得最大的收益</span></span><br><span class="line">        <span class="comment">// 这里定义买入的时候算一次交易</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(k) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 第0天持有股票的话，最多k次交易，只能直接买入</span></span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第i天，交易了j次，持有股票</span></span><br><span class="line">                    <span class="comment">// 可能是前i-1天就交易了j次并持有股票，也可能前i-1天交易了j-1次在今天买入了</span></span><br><span class="line">                    <span class="comment">// 如果之前没有交易，今天就直接买入就好了</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], -prices[i])</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">maxProfitNonLimitCount</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n * k)</code>。</li>
<li><code>k &gt;= n / 2</code>时，空间复杂度<code>O(1)</code>；<code>k &lt; n / 2</code>时，空间复杂度<code>O(n * k)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.198.打家劫舍（中等）</title>
    <url>/LeetCode/LeetCode.198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/house-robber/">LeetCode.198.打家劫舍（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最优化问题，考虑是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>从最终状态做倒推，穷举列出到达最终状态所需要的最小步骤，看是否能从上一个状态加上有限步骤得到最终状态，检查上一个状态的最优解是否也能通过不停的倒推拆解得到，拆分步骤的过程可得出状态转移方程。拆分到最开始，做边界条件处理。</p>
<h2 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h2><p>设<code>nums[i]</code>为第i间房屋金额。<br>设<code>dp[i]</code>为达到第i个房屋时能偷到的最高金额。</p>
<ol>
<li>偷第i间房，就不能偷第i - 1房，<code>dp[i] = dp[i - 2] + nums[i]</code></li>
<li>不偷第i间房，<code>dp[i] = dp[i - 1]</code></li>
</ol>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><ol>
<li>只有1间房，直接偷</li>
<li>只有2间房，由于不能偷相邻的房间，就偷钱多的。 </li>
</ol>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>dp[i]</code>只从前两项递推得来，所以不需要数组记录所有状态，只需要两个变量记录递推的状态。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1 </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.212.单词搜索 II（困难）</title>
    <url>/LeetCode/LeetCode.212.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-search-ii/">LeetCode.212.单词搜索 II（困难）</a></p>
<p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>网格中找字典单词，而且还是往相邻单元格找，用深度优先搜索。</li>
<li>单词必须按照字母顺序，所以必须尝试从每个单元格开始搜索。</li>
<li>只要在网格中找到了一个单词，接下来就不用再找这个单词了。</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>遍历所有单词。</li>
<li>遍历网格所有的单元格，在每个单元格用回溯找指定单词，找到一个就停止。</li>
</ul>
<h3 id="回溯怎么写？"><a href="#回溯怎么写？" class="headerlink" title="回溯怎么写？"></a>回溯怎么写？</h3><p>标准的回溯模板写法。</p>
<ul>
<li>用一个访问数组记录已访问过的元素，避免循环搜索。</li>
<li>用方向数组简化代码，做好边界检查。</li>
<li>回溯结束条件就是单词所有字符遍历完了。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各索引从小到大依次代表 上、右、下、左</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaRow = intArrayOf(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaColumn = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findWords</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">for</span> (word <span class="keyword">in</span> words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word)) &#123;</span><br><span class="line">                result.add(word)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findWord</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, word: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = board.size</span><br><span class="line">        <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> visited = Array(rows) &#123; BooleanArray(columns) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                <span class="keyword">val</span> found = backtrack(board, row, column, visited, word, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (found) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, row: <span class="type">Int</span>, column: <span class="type">Int</span>, visited: <span class="type">Array</span>&lt;<span class="type">BooleanArray</span>&gt;, word: <span class="type">String</span>, wordIndex: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[row][column] == word[wordIndex]) &#123;</span><br><span class="line">            <span class="comment">// 期待的正确情况的边界条件</span></span><br><span class="line">            <span class="keyword">if</span> (wordIndex == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 单词还没搜完，就继续尝试下一个位置</span></span><br><span class="line">            visited[row][column] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> (direction <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newRow = row + deltaRow[direction]</span><br><span class="line">                <span class="keyword">val</span> newColumn = column + deltaColumn[direction]</span><br><span class="line">                <span class="keyword">val</span> rows = board.size</span><br><span class="line">                <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">val</span> isInBound = newRow <span class="keyword">in</span> <span class="number">0</span> until rows &amp;&amp; newColumn <span class="keyword">in</span> <span class="number">0</span> until columns</span><br><span class="line">                <span class="keyword">if</span> (isInBound &amp;&amp; !visited[newRow][newColumn]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(board, newRow, newColumn, visited, word, wordIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[row][column] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：字典树-回溯"><a href="#解法2：字典树-回溯" class="headerlink" title="解法2：字典树 + 回溯"></a>解法2：字典树 + 回溯</h2><p>解法1 的步骤是</p>
<ul>
<li>遍历单词列表选一个单词。</li>
<li>从网格中的每个位置开始回溯，看能否找到这个单词。</li>
</ul>
<p>如果能在网格中的每个位置开始回溯时：</p>
<ul>
<li>发现找到了单词，就能直接记录下来。</li>
<li>所走的字符不能构成单词就不要继续做没有意义的搜索了。</li>
</ul>
<p>这样就是最省时间的。</p>
<p>符合这个访问特点的就是字典树，所以得吧words所有单词先构建出一个字典树。</p>
<p>在网格中的每个位置开始回溯时，用字典树匹配回溯发现的字符，如果能组成单词，就记录下来。</p>
<p><strong>字典树匹配的问题</strong></p>
<p>如果在每个递归层都从字典数的根节点开始匹配，那么会有很多重复判断，可以在回溯递归时，传递字典树的节点给每个递归层，就不会重复判断了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>(</span><br><span class="line">        <span class="keyword">var</span> isEnd: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">val</span> next: Array&lt;Node?&gt; = Array(<span class="number">26</span>) &#123; <span class="literal">null</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">val</span> i = c - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (p.next[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next[i] = Node()</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next[i]!!</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEnd = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各索引从小到大依次代表 上、右、下、左</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaRow = intArrayOf(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaColumn = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findWords</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 所有单词构建字典树</span></span><br><span class="line">        <span class="keyword">val</span> trie = Trie()</span><br><span class="line">        <span class="keyword">for</span> (word <span class="keyword">in</span> words) &#123;</span><br><span class="line">            trie.insert(word)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">val</span> result = HashSet&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> rows = board.size</span><br><span class="line">        <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> visited = Array(rows) &#123; BooleanArray(columns) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> path = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                backtrack(board, row, column, visited, trie.root, path, result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            row: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            column: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            visited: <span class="type">Array</span>&lt;<span class="type">BooleanArray</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            node: <span class="type">Node</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">Stack</span>&lt;<span class="type">Char</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            result: <span class="type">HashSet</span>&lt;<span class="type">String</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> c = board[row][column]</span><br><span class="line">        <span class="keyword">val</span> currentNode = node.next[c - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.push(c)</span><br><span class="line">            visited[row][column] = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 找到一个单词</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.isEnd) &#123;</span><br><span class="line">                <span class="comment">// 添加结果</span></span><br><span class="line">                <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> path.indices) &#123;</span><br><span class="line">                    sb.append(path[i])</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(sb.toString())</span><br><span class="line">                <span class="comment">// 不能中断搜索，因为字典树当前结点可能还有子树，所以这里找到了一个单词不做return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单词还没搜完，就继续尝试下一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (direction <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newRow = row + deltaRow[direction]</span><br><span class="line">                <span class="keyword">val</span> newColumn = column + deltaColumn[direction]</span><br><span class="line">                <span class="keyword">val</span> rows = board.size</span><br><span class="line">                <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">val</span> isInBound = newRow <span class="keyword">in</span> <span class="number">0</span> until rows &amp;&amp; newColumn <span class="keyword">in</span> <span class="number">0</span> until columns</span><br><span class="line">                <span class="keyword">if</span> (isInBound &amp;&amp; !visited[newRow][newColumn]) &#123;</span><br><span class="line">                    backtrack(board, newRow, newColumn, visited, currentNode, path, result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            path.pop()</span><br><span class="line">            visited[row][column] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>深度优先搜索</tag>
        <tag>回溯</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.213.打家劫舍 II（中等）</title>
    <url>/LeetCode/LeetCode.213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">LeetCode.213.打家劫舍 II（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="环形排列影响了什么？"><a href="#环形排列影响了什么？" class="headerlink" title="环形排列影响了什么？"></a>环形排列影响了什么？</h2><p>第1间房子和最后一间房子只能偷一个，不知道偷哪个金额最高。</p>
<h2 id="不知道偷第一间还是最后一间，怎么办？"><a href="#不知道偷第一间还是最后一间，怎么办？" class="headerlink" title="不知道偷第一间还是最后一间，怎么办？"></a>不知道偷第一间还是最后一间，怎么办？</h2><p>两种情况都偷一下，取金额大的那个方案。即：</p>
<ol>
<li>偷第1间房子，不偷最后一间房子</li>
<li>不偷第1间房子，偷最后一间房子</li>
</ol>
<p>转换为两个非环问题取较大值的问题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">0</span>, n - <span class="number">1</span>)),</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">1</span>, n))</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">linearRob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> n = nums.size</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">var</span> cur = pre1</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">                cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">                pre2 = pre1</span><br><span class="line">                pre1 = cur</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.214.最短回文串（困难）</title>
    <url>/LeetCode/LeetCode.214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/shortest-palindrome/">LeetCode.214.最短回文串（困难）</a></p>
<p>给定一个字符串  _<strong>s</strong>_，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串的特点是左右两端字符相同，要在<code>s</code>前面添加字符串使得新字符串是回文串，那就把<code>s</code>的倒置字符串放在前面就可以形成回文了。</p>
<h3 id="s的倒置字符串添加在s前面会有什么问题？"><a href="#s的倒置字符串添加在s前面会有什么问题？" class="headerlink" title="s的倒置字符串添加在s前面会有什么问题？"></a>s的倒置字符串添加在s前面会有什么问题？</h3><p>这样添加还不是最短的回文。</p>
<p>比如s是abbacd，添加dcabba到开头，形成dcabbaabbacd，可以发现abba是多余的，不用添加，dcabbacd是更短的回文串，只要添加dc就行了。</p>
<h3 id="应该添加什么样的字符串才能获得最短回文？"><a href="#应该添加什么样的字符串才能获得最短回文？" class="headerlink" title="应该添加什么样的字符串才能获得最短回文？"></a>应该添加什么样的字符串才能获得最短回文？</h3><p>得找到abbacd的前缀和dcabba的后缀最长的重合的部分的长度，然后找到不重复的部分，添加到字符串前面。</p>
<p>标准化描述：</p>
<ul>
<li>设<code>s&#39;</code>是<code>s</code>的倒置字符串。</li>
<li>求<code>s</code>的前缀和<code>s&#39;</code>的后缀中相同部分最长的长度<code>x</code>。</li>
<li>取<code>s</code>的子串<code>s[x, n - 1]</code>，倒置后添加到<code>s</code>前面，形成最短回文。</li>
</ul>
<h3 id="怎么寻找s和s的倒置字符串最长前后缀？"><a href="#怎么寻找s和s的倒置字符串最长前后缀？" class="headerlink" title="怎么寻找s和s的倒置字符串最长前后缀？"></a>怎么寻找s和s的倒置字符串最长前后缀？</h3><p>联想到kmp做字符串匹配时，要先求一个前缀函数，前缀函数<code>prefix[i]</code>表示<code>s[0, i]</code>中最长的公共前后缀的长度，只要求出前缀函数就可以求解题目。</p>
<h3 id="前缀函数怎么求？"><a href="#前缀函数怎么求？" class="headerlink" title="前缀函数怎么求？"></a>前缀函数怎么求？</h3><p>一句话：让<code>s[0, n - 1]</code>匹配<code>s[1, n - 1]</code>。</p>
<p>算法步骤：</p>
<ul>
<li>双指针<code>i</code>和<code>j</code>遍历<code>s</code>。</li>
<li><code>i</code>从1开始，<code>j</code>从0开始。</li>
<li>s匹配自己，字符能匹配上，双指针都前进。</li>
<li>当前<code>s[i]</code>和<code>s[j]</code>不匹配，要把<code>j</code>往回退。<ul>
<li><code>j</code>退到前一个位置（<code>j - 1</code>）的最长公共前后缀的前缀的下一个字符的位置。继续拿<code>s[j]</code>跟<code>s[i]</code>尝试匹配，如果能匹配的上，<code>prefix[i]</code>就求出来了。</li>
<li>如果<code>j</code>一直回退，最坏也就是回退到0，因为<code>prefix[0] = 0</code>（一个字符不存在前后缀），没的退了，只能比较<code>s[i]</code>和<code>s[0]</code>，没匹配的话公共前后缀长度就是0。</li>
</ul>
</li>
</ul>
<h3 id="前缀函数应该针对哪个字符串求？"><a href="#前缀函数应该针对哪个字符串求？" class="headerlink" title="前缀函数应该针对哪个字符串求？"></a>前缀函数应该针对哪个字符串求？</h3><p>我们要求<code>s</code>的前缀和<code>s</code>的倒置字符串的后缀最长的公共部分。<br>所以弄一个新字符串 <code>s&#39; + s</code>。</p>
<p><strong>这样存在一个问题</strong>，如果所有字符都相同，此时最长公共前后缀就是整个字符串<code>s&#39; + s</code>本身，这不是期望的结果，所以连接<code>s&#39;</code>和<code>s</code>时，中间隔一个用不到的字符，比如<code>#</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shortestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 加#是为了防止出现全部重复的字符，这样最长公共前后缀的长度就不是期望的了</span></span><br><span class="line">        <span class="keyword">val</span> maxLength = (s + <span class="string">&quot;#&quot;</span> + s.reversed()).prefixArray().last()</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLength).reversed() + s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">prefixArray</span><span class="params">()</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> s = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> n = length</span><br><span class="line">        <span class="keyword">val</span> prefix = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = prefix[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = prefix[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) j++</span><br><span class="line">            prefix[i] = j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>设字符串<code>s</code>长度为n。</p>
<ul>
<li>时间复杂度O(n)：求前缀函数最坏情况需要O(n + n) = O(n)时间；还要遍历整个<code>s&#39; + s</code>，有2n的长度，需要O(n)时间。</li>
<li>空间复杂度O(n)：前缀函数占用O(n)空间。</li>
</ul>
<p>kmp时间复杂度推导可参考：</p>
<ul>
<li><a href="https://blog.csdn.net/niukai1768/article/details/79579709">KMP时间复杂度分析</a></li>
<li><a href="https://segmentfault.com/q/1010000014560162">KMP算法的时间复杂度是如何计算的？</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.218.天际线问题（困难）</title>
    <url>/LeetCode/LeetCode.218.%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/the-skyline-problem/">LeetCode.218.天际线问题（困难）</a></p>
<span id="more"></span>

<p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p>
<p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p>
<p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>模拟一遍天际线形成的过程。</li>
<li>从简单的情况出发，逐步添加条件讨论复杂的情况。</li>
<li>穷举所有可能性，发现和总结重复的规律。</li>
</ul>
<h2 id="天际线受哪几个因素影响？"><a href="#天际线受哪几个因素影响？" class="headerlink" title="天际线受哪几个因素影响？"></a>天际线受哪几个因素影响？</h2><ul>
<li>建筑物左边界和右边界</li>
<li>建筑物高度</li>
<li>建筑物个数</li>
</ul>
<h2 id="只有一个建筑时，天际线的关键点是哪些？"><a href="#只有一个建筑时，天际线的关键点是哪些？" class="headerlink" title="只有一个建筑时，天际线的关键点是哪些？"></a>只有一个建筑时，天际线的关键点是哪些？</h2><p>天际线的形成就是从左到右扫描建筑边界。</p>
<ul>
<li>发现第一个建筑后，边际线的第一个关键点是第一个建筑左上角点。</li>
<li>后面没有其他建筑，边际线的第二个关键点是第一个建筑右下角点。</li>
</ul>
<p>此时看不出来什么规律。</p>
<h2 id="有两个建筑时，天际线的关键点受到怎样的影响？"><a href="#有两个建筑时，天际线的关键点受到怎样的影响？" class="headerlink" title="有两个建筑时，天际线的关键点受到怎样的影响？"></a>有两个建筑时，天际线的关键点受到怎样的影响？</h2><p>为方便描述，先假设：<br>第一个建筑为A，下一个建筑为B，leftB &gt; leftA。</p>
<p>leftB、rightB、heightB的变化都会影响天际线的变化，所以就分类讨论。</p>
<p>先看建筑B在横轴变化，再看高度变化：</p>
<h3 id="B和A没有重叠（leftB-gt-rightA）"><a href="#B和A没有重叠（leftB-gt-rightA）" class="headerlink" title="B和A没有重叠（leftB &gt; rightA）"></a>B和A没有重叠（leftB &gt; rightA）</h3><p>此时B跟A的情况是一样的。</p>
<h3 id="B和A有一部分重叠（leftB-lt-rightA）"><a href="#B和A有一部分重叠（leftB-lt-rightA）" class="headerlink" title="B和A有一部分重叠（leftB &lt; rightA）"></a>B和A有一部分重叠（leftB &lt; rightA）</h3><h4 id="B的高度-gt-A的高度"><a href="#B的高度-gt-A的高度" class="headerlink" title="B的高度 &gt; A的高度"></a>B的高度 &gt; A的高度</h4><p>B的左边界会影响天际线，天际线第2个关键点是B的左上角点（leftB, heightB）。</p>
<p><strong>扩展：建筑横轴坐标不变，高度和个数变化</strong></p>
<p>如果有很多不同高的建筑，边界横轴坐标都是leftB，应该选哪个建筑的边界为天际线？选最高的。</p>
<h4 id="B的高度-lt-A的高度"><a href="#B的高度-lt-A的高度" class="headerlink" title="B的高度 &lt; A的高度"></a>B的高度 &lt; A的高度</h4><p>B的左边界不会影响天际线。</p>
<ul>
<li>如果rightB &lt; rightA，B的右边界对天际线也没有影响。</li>
<li>如果rightB &gt; rightA，天际线第2个关键点坐标是（rightA, heightB）。</li>
</ul>
<p><strong>扩展：建筑横轴坐标不变，高度和个数变化</strong></p>
<p>如果有很多不同高的建筑，左右边界都在rightB两侧，应该选哪个建筑的边界为天际线？<br>选第二高的，因为最高的建筑到头了，只能选次高的做边际线。</p>
<h2 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h2><p>从左到右扫描</p>
<ul>
<li>边际线增高的时候，关键点都是建筑左上角点，并且是相同左边界中最高的。</li>
<li>边际线降低的时候，关键点需要知道建筑右上角点横坐标，以及此横坐标下次高的建筑高度。</li>
</ul>
<p>怎么获得建筑右上角点下面次高的建筑高度？<br>次高的建筑的左边在之前肯定扫描过了，所以可记录下建筑的高度。</p>
<p>也就是要保存所有建筑的左上角点的横坐标和高度、右上角点点横坐标和高度，并且要排序，才能知道哪个是最高哪个是次高。<br>排序还要在线排序才行，不能用离线排序算法，所以用优先队列来存储建筑的点，按高度排序，构建最大堆。</p>
<p>遍历到建筑左上角的点，要么在边际线增高的时候用到，要么在边际线递减的时候用来获得次高的高度，所以左上角点存储后需要保留。</p>
<p>遍历到建筑右上角点，边际线就向右延展结束了，就没有用了，我们需要获得次高的建筑高度，就需要把处在边际线高度的建筑的右上角点从优先队列中去除，这样就可以获得右边界下次高建筑的高度了。</p>
<p>所以优先队列记录的高度还需要区分是建筑的左上角点和右上角点，这里可以用负数表示左上角点的高度，正数表示右上角点的高度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.Comparator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSkyline</span><span class="params">(buildings: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = mutableListOf&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">        <span class="comment">// 建筑物的左上角、右上角顶点坐标提取出来并按横坐标从小到大的排序</span></span><br><span class="line">        <span class="keyword">val</span> points = buildings.toSortedPoints()</span><br><span class="line">        <span class="comment">// 创建大顶堆，用以保存从左向右扫描的高度</span></span><br><span class="line">        <span class="keyword">val</span> queue = PriorityQueue&lt;<span class="built_in">Int</span>&gt;(compareByDescending &#123; it &#125;)</span><br><span class="line">        <span class="comment">// 初始插入0</span></span><br><span class="line">        queue.offer(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 记录先前的天际线高度，如果高度发生变化了说明天际线发生了转折，需要记录</span></span><br><span class="line">        <span class="comment">// 因为有可能有几个高度一样的建筑物重叠在一起</span></span><br><span class="line">        <span class="keyword">var</span> preMax = <span class="number">0</span></span><br><span class="line">        points.forEach &#123; p -&gt;</span><br><span class="line">            <span class="comment">// 遇到左上角顶点，就将该顶点的高度插入最大堆，插入只需要对数时间</span></span><br><span class="line">            <span class="keyword">if</span> (p.y &lt; <span class="number">0</span>) queue.offer(-p.y)</span><br><span class="line">            <span class="comment">// 遇到右上角顶点，就将该顶点高度从最大堆种删除，因为这个建筑不再影响天际线</span></span><br><span class="line">            <span class="comment">// 设堆中有n个元素，从堆中移除，首先需要找到这个元素，最坏需要耗费O(n)时间，与最后一个元素替换当作删除后再调整堆最坏需要耗费O(logn)时间</span></span><br><span class="line">            <span class="keyword">else</span> queue.remove(p.y)</span><br><span class="line">            <span class="comment">// 当前堆顶最大的高度，也就是天际线经过的高度</span></span><br><span class="line">            <span class="keyword">val</span> max = queue.peek()</span><br><span class="line">            <span class="comment">// 天际线高度发生了转折变化</span></span><br><span class="line">            <span class="keyword">if</span> (preMax != max) &#123;</span><br><span class="line">                <span class="comment">// 添加天际线转折点坐标</span></span><br><span class="line">                answer.add(listOf(p.x, max))</span><br><span class="line">                <span class="comment">// 记录这次的最大高度</span></span><br><span class="line">                preMax = max</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    求出每个建筑左上角和右上角坐标（横坐标,高度）, 并按横坐标从小到大的顺序排序</span></span><br><span class="line"><span class="comment">    当横坐标x相等时，该怎么排序，分以下三种情况:</span></span><br><span class="line"><span class="comment">    1. 两个坐标都是左上角的坐标，需要把较高的排在前面</span></span><br><span class="line"><span class="comment">    2. 两个坐标都是右上角的坐标，需要把较低的排在前面</span></span><br><span class="line"><span class="comment">    3. 一个坐标是左上角，另一个坐标是右上角，左上角需要排在前面</span></span><br><span class="line"><span class="comment">    上述判断起来比较麻烦，如果把左上角的高度存储为负数，上述三种情况只需要简单的按高度升序排序就可以达成效果</span></span><br><span class="line"><span class="comment">    同时也可以通过高度的正负来判定哪个是左上角的坐标哪个是右上角的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Array<span class="type">&lt;IntArray&gt;</span>.<span class="title">toSortedPoints</span><span class="params">()</span></span>: List&lt;Point&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> flatMap &#123; building -&gt;</span><br><span class="line">            <span class="keyword">val</span> leftX = building[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> rightX = building[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">val</span> height = building[<span class="number">2</span>]</span><br><span class="line">            listOf(</span><br><span class="line">                    Point(leftX, -height),</span><br><span class="line">                    Point(rightX, height)</span><br><span class="line">            )</span><br><span class="line">        &#125;.sortedWith(Comparator &#123; a, b -&gt; <span class="keyword">if</span> (a.x != b.x) a.x - b.x <span class="keyword">else</span> a.y - b.y &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.221.最大正方形（中等）</title>
    <url>/LeetCode/LeetCode.221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode.221.最大正方形（中等）</a></p>
<p>在一个由  <code>&#39;0&#39;</code>  和  <code>&#39;1&#39;</code>  组成的二维矩阵内，找到只包含  <code>&#39;1&#39;</code>  的最大正方形，并返回其面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最值问题考虑用动态规划。<br>想办法把大问题划分子问题+有限步骤。</p>
<h2 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h2><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h2 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h2><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h2 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h2><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h2 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h2><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h2 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h2><p>记录最大的<code>side[i][j]</code>，再求平方就是最终结果</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>二维数组，空间复杂度O(mn)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxLength = maxOf(maxLength, side[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[i][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[<span class="number">0</span>][j])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    maxLength = maxOf(maxLength, side[i][j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h2 id="优化的代码"><a href="#优化的代码" class="headerlink" title="优化的代码"></a>优化的代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一行状态</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[j])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储上一行状态，以方便接下来读取左上方的状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">	                <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">					<span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">					<span class="comment">// pre[j]: 上方状态</span></span><br><span class="line">                    side[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>], pre[j])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    side[j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = maxOf(maxLength, side[j])</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.224.基本计算器（困难）</title>
    <url>/LeetCode/LeetCode.224.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/basic-calculator/">LeetCode.224.基本计算器（困难）</a></p>
<p>给你一个字符串表达式  <code>s</code>  ，请你实现一个基本计算器来计算并返回它的值。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li>  <code>s</code>  由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和  <code>&#39; &#39;</code>  组成</li>
<li>  <code>s</code>  表示一个有效的表达式<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>表达式计算是<strong>从左到右遍历</strong>的，所以从左到右遍历字符串。</li>
<li>用result变量记录左边已经计算过的表达式的值。</li>
<li>新的表达式计算出来后，与result累加结果。</li>
</ul>
<h2 id="操作数识别"><a href="#操作数识别" class="headerlink" title="操作数识别"></a>操作数识别</h2><ul>
<li>遇到连续数字，就做累加。</li>
<li>每遇到一个数字字符，把前面累加的结果乘以十，再加上当前数字值。</li>
</ul>
<p><strong>什么时候停止累加操作数？</strong></p>
<p>遇到非数字字符操作数就可以确定了。</p>
<p>遇到的非数字字符可能会有：<code>+</code>、<code>-</code>、<code>(</code>、<code>)</code>。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>只有加减运算，优先级相同。</li>
<li>可以把减法当作加法，识别完操作数，如果前面是减号，就当作负数。</li>
<li>用一个sign变量记录运算符，为1表示操作数前是加号，为-1表示操作数前是减号。</li>
<li>操作数识别完后，乘以sign，再与result累加。</li>
</ul>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><ul>
<li>多括号时，优先计算最内层的括号。</li>
<li>遇到左括号时，左侧表达式需要等待括号内表达式计算得出结果才能继续计算，所以需要暂存左侧表达式之前累加的结果和运算符。</li>
<li>括号会有嵌套，需要保存每一层括号的临时计算结果，且是从左向右遍历的，访问临时计算结果又是从右到左，所以用栈存储。</li>
<li>遇到右括号时，需要从栈中取出之前临时状态继续运算。</li>
</ul>
<h2 id="题解1：暴力递归"><a href="#题解1：暴力递归" class="headerlink" title="题解1：暴力递归"></a>题解1：暴力递归</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpResult</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>, <span class="keyword">val</span> endIndex: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">cal</span><span class="params">(i: <span class="type">Int</span>)</span></span>: ExpResult &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> operand = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> sign = <span class="number">1</span></span><br><span class="line">            <span class="keyword">var</span> j = i</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = s[j]</span><br><span class="line">                <span class="keyword">if</span> (c <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 识别操作数</span></span><br><span class="line">                    operand = operand * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 确定操作数，累加到结果中</span></span><br><span class="line">                    result += sign * operand</span><br><span class="line">                    operand = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">when</span> (c) &#123;</span><br><span class="line">                        <span class="string">&#x27;+&#x27;</span> -&gt; sign = <span class="number">1</span></span><br><span class="line">                        <span class="string">&#x27;-&#x27;</span> -&gt; sign = -<span class="number">1</span></span><br><span class="line">                        <span class="string">&#x27;(&#x27;</span> -&gt; &#123;</span><br><span class="line">                            <span class="keyword">val</span> exp = cal(j + <span class="number">1</span>)</span><br><span class="line">                            result += sign * exp.value</span><br><span class="line">                            j = exp.endIndex</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="string">&#x27;)&#x27;</span> -&gt; <span class="keyword">return</span> ExpResult(result, j)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 末尾没有运算符，手动触发累加</span></span><br><span class="line">            result += sign * operand</span><br><span class="line">            <span class="keyword">return</span> ExpResult(result, n - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cal(<span class="number">0</span>).value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解2：基于迭代的栈"><a href="#题解2：基于迭代的栈" class="headerlink" title="题解2：基于迭代的栈"></a>题解2：基于迭代的栈</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于只包含加法和减法，减法可以看作是加负数，统一为加法，只需要处理好括号确定的操作符最终是什么就可以直接相加了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 操作数</span></span><br><span class="line">        <span class="keyword">var</span> operand = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 符号，1表示减法，-1表示减法</span></span><br><span class="line">        <span class="keyword">var</span> sign = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 开括号前的运算结果</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 存储括号前的结果和开括号前的运算符</span></span><br><span class="line">        <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="keyword">when</span> (char) &#123;</span><br><span class="line">                <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; &#123;</span><br><span class="line">                    operand = operand * <span class="number">10</span> + (char - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">&#x27;+&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到加号，先计算出加号前面的结果</span></span><br><span class="line">                    result += sign * operand</span><br><span class="line">                    <span class="comment">// 记录当前操作符是加号</span></span><br><span class="line">                    sign = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 操作数重置</span></span><br><span class="line">                    operand = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">&#x27;-&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到减号，先计算出加号前面的结果</span></span><br><span class="line">                    result += sign * operand</span><br><span class="line">                    <span class="comment">// 记录当前操作符是加号</span></span><br><span class="line">                    sign = -<span class="number">1</span></span><br><span class="line">                    <span class="comment">// 操作数重置</span></span><br><span class="line">                    operand = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到开括号，先计算出括号前面的结果</span></span><br><span class="line">                    result += sign * operand</span><br><span class="line">                    <span class="comment">// 将开括号前的运算结果和运算符入栈</span></span><br><span class="line">                    stack.push(result)</span><br><span class="line">                    stack.push(sign)</span><br><span class="line">                    <span class="comment">// 重置临时结果和操作符，以便于运算括号内的结果</span></span><br><span class="line">                    sign = <span class="number">1</span></span><br><span class="line">                    result = <span class="number">0</span></span><br><span class="line">                    <span class="comment">// 可以重置操作数，不过开括号前一定是一个操作符，操作符中已经重置过了</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到闭括号，先计算出括号的结果</span></span><br><span class="line">                    result += sign * operand</span><br><span class="line">                    <span class="comment">// result此时为括号内的结果，需要乘以括号前的符号，再和括号前的结果合并</span></span><br><span class="line">                    result *= stack.pop()</span><br><span class="line">                    result += stack.pop()</span><br><span class="line">                    <span class="comment">// 重置操作数</span></span><br><span class="line">                    <span class="comment">// 闭括号后可能继续跟着操作符，也可能没有跟操作符</span></span><br><span class="line">                    <span class="comment">// 如果跟着操作符，可以不在此重置，因为遇到操作符会重置</span></span><br><span class="line">                    <span class="comment">// 如果没跟着操作符，说明整个表达式结束了，为了不影响最后的通式运算，这里重置运算数</span></span><br><span class="line">                    operand = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后可能没有括号了，而上面是遇到了操作符才去计算操作符前面的结果</span></span><br><span class="line">        <span class="comment">// 现在在已经达到尾部了，没有操作符了，最后结算一次</span></span><br><span class="line">        <span class="keyword">return</span> result + sign * operand</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>栈</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.23.合并K个升序链表（困难）</title>
    <url>/LeetCode/LeetCode.23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode.23.合并K个升序链表（困难）</a></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h2><p>普通二路归并排序直接比较两个链表首元素即可。</p>
<p><strong>多个链表首元素怎么比较？</strong></p>
<p>用优先队列，构建小顶堆，每次加入一个节点，优先队列。</p>
<p>调整一次堆需要<code>O(log k)</code>时间，<code>k</code>为列表个数。</p>
<p>由于要把所有节点都加入堆中，设链表节点总数为<code>n</code>，总时间复杂度为<code>O(n * log k)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;ListNode&gt; &#123; n1, n2 -&gt; n1.`<span class="keyword">val</span>` - n2.`<span class="keyword">val</span>` &#125;</span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> p: ListNode? = dummy</span><br><span class="line">        lists.forEach &#123; node -&gt; <span class="keyword">if</span> (node != <span class="literal">null</span>) pq.add(node) &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> smallest = pq.poll()</span><br><span class="line">            <span class="keyword">if</span> (smallest.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(smallest.next)</span><br><span class="line">            &#125;</span><br><span class="line">            p?.next = smallest</span><br><span class="line">            p = p?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> newHead = dummy.next</span><br><span class="line">        dummy.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：分治"><a href="#解法2：分治" class="headerlink" title="解法2：分治"></a>解法2：分治</h2><p>对所有链表两两归并，这样每次链表数量减半，假设总共有k个链表，需要归并<code>log k</code>次。</p>
<p>假设所有链表结点总数为<code>n</code>，每一次的两两归并都要遍历所有结点，总时间复杂度为<code>O(n * log k)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) <span class="keyword">return</span> lists[low]</span><br><span class="line">        <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">val</span> l1 = merge(lists, low, mid);</span><br><span class="line">        <span class="keyword">val</span> l2 = merge(lists, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeTwoList</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> tail: ListNode? = dummy</span><br><span class="line">        <span class="keyword">var</span> p1 = l1</span><br><span class="line">        <span class="keyword">var</span> p2 = l2</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.`<span class="keyword">val</span>` &lt; p2.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                tail?.next = p1</span><br><span class="line">                p1 = p1?.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail?.next = p2</span><br><span class="line">                p2 = p2?.next</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail?.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail?.next = <span class="keyword">if</span> (p1 != <span class="literal">null</span>) p1 <span class="keyword">else</span> p2</span><br><span class="line">        <span class="keyword">val</span> newHead = dummy.next</span><br><span class="line">        dummy.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>优先队列</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.239.滑动窗口最大值（困难）</title>
    <url>/LeetCode/LeetCode.239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode.239.滑动窗口最大值（困难）</a></p>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题解1：暴力"><a href="#题解1：暴力" class="headerlink" title="题解1：暴力"></a>题解1：暴力</h2><p>暴力法很好想。</p>
<ul>
<li>枚举滑动窗口所有起始位置。</li>
<li>遍历滑动窗口内所有元素，记录最大值。</li>
</ul>
<p>设数组长度为n，滑动长度长度为k，时间复杂度O(n * k)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力法，时间复杂度O(n*k)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSlidingWindow</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> intArrayOf()</span><br><span class="line">        <span class="keyword">val</span> answer = IntArray(n - k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.(n - k)) &#123;</span><br><span class="line">            <span class="keyword">val</span> end = start + k - <span class="number">1</span></span><br><span class="line">            <span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;</span><br><span class="line">                max = Math.max(max, nums[i])</span><br><span class="line">            &#125;</span><br><span class="line">            answer[j++] = max</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：单调队列"><a href="#解法2：单调队列" class="headerlink" title="解法2：单调队列"></a>解法2：单调队列</h2><h3 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h3><p>暴力法的问题在于有很多从左到右重复的遍历判断。</p>
<p>如果有办法在滑动窗口移动的时候，就可以知道滑动窗口最大值，这样时间复杂度就可以减少到O(n - k)。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口向右移动时，会在末尾增加一个数，同时开头减少一个数，这个过程很像队列的入队和出队。</p>
<p>在比较新增和减少的元素对滑动窗口最大值的影响，可以发现：</p>
<ul>
<li>如果新增的元素比之前的元素都大，那么之前的元素肯定不会是最大，不用考虑。</li>
<li>如果新增的元素大小位于之前元素的中间水平：<ul>
<li>那么之前的元素中比新增元素小的元素肯定是肯定不会最大，而且新增元素是比新增元素小的元素在后移除出滑动窗口的。</li>
<li>新增元素现在虽然不是最大，但是滑动窗口右移后，之前最大的元素就不存在了，新增的这个元素可能又是最大。</li>
</ul>
</li>
</ul>
<p>所以滑动窗口的队列只需要存储单调递减的元素。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度O(n - k)：滑动窗口要移动n - k次。</li>
<li>空间复杂度O(k)：单调队列最多存储滑动窗口中所有元素。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护一个队列，仅存放滑动窗口内的数字，每次向队尾插入数字前，先从队首依次检查并删除小于新插入的元素，这样队首始终是滑动窗口的最大值</span></span><br><span class="line"><span class="comment">     * 由于只会遍历数组依次，因此时间复杂度O(n)，用一个队列存储滑动窗口内的元素，最多存储k个，因此空间复杂度是O(k)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSlidingWindow</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> intArrayOf()</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">val</span> answer = IntArray(n - k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> queue = MonotonicQueue()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) queue.enqueue(nums[i])</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.enqueue(nums[i])</span><br><span class="line">                answer[i - k + <span class="number">1</span>] = queue.max()</span><br><span class="line">                queue.dequeue(nums[i - k + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单调递减的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span></span>() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用双端队列模拟单调递减队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> deque: Deque&lt;<span class="built_in">Int</span>&gt; = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将[num]放入队尾，同时移除队列中比[num]小的数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(num: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 原队列已经保持单调递减，队尾小于新元素就出队</span></span><br><span class="line">            <span class="keyword">while</span> (deque.isNotEmpty() &amp;&amp; deque.peekLast() &lt; num) &#123;</span><br><span class="line">                deque.pollLast()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新元素入队到队尾</span></span><br><span class="line">            deque.offerLast(num)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 队首如果是[num]就删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">(num: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (deque.isNotEmpty() &amp;&amp; deque.peekFirst() == num) &#123;</span><br><span class="line">                deque.pollFirst()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回队列中最大值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> deque.peekFirst()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>滑动窗口</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.25.K 个一组翻转链表（困难）</title>
    <url>/LeetCode/LeetCode.25.K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">LeetCode.25.K 个一组翻转链表（困难）</a></p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>进阶：</p>
<p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>每组翻转后最关键的在于每一组的头尾节点变化了，要把每组重新正确的连接上，梳理整个翻转过程就比较清楚了。</p>
<p>从左到右找到第k个节点，相当于知道了一组节点的头节点和尾节点，对这一组节点进行翻转，记录翻转后的尾节点，在下一组翻转过后，把上一组记录的新尾节点指向下一组的新头节点即可。</p>
<p><strong>边界处理</strong></p>
<p>如果发现最后一组不足k个，不做翻转。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseKGroup</span><span class="params">(head: <span class="type">ListNode</span>?, k: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> tail: ListNode? = head</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line">            tail = tail.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> newHead = reverse(head, tail)</span><br><span class="line">        head.next = reverseKGroup(tail, k)</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表，返回新链表头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverse</span><span class="params">(head: <span class="type">ListNode</span>?, tail: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> pre: ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> cur: ListNode? = head</span><br><span class="line">        <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = cur?.next</span><br><span class="line">            cur?.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n)：n为链表节点总数。<br>空间复杂度O(n/k)：递归一次占用一个方法栈，空间占用多少就看递归深度多少，n个节点每次划分k个一组，一共要递归n/k次。</p>
</blockquote>
<p><strong>迭代</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果一边遍历一边翻转，最后一段长度不足k时也反转了就不对了，所以得先有一个指针往后探路，探到有路了再进行反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseKGroup</span><span class="params">(head: <span class="type">ListNode</span>, k: <span class="type">Int</span>)</span></span>: ListNode &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个虚节点，这样可以统一操作链表的代码，不用做边界情况处理</span></span><br><span class="line">        <span class="keyword">val</span> dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummyHead.next = head</span><br><span class="line">        <span class="comment">// 2. 开拓者指针，往后走k次，如果走了k次后，开拓者不为null，说明是有k个节点，可以翻转；初始时还没走，所以应该在头节点的前一个位置</span></span><br><span class="line">        <span class="keyword">var</span> pioneer: ListNode? = dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 记录当前待翻转区域前面的一个节点，用于把之前已反转的部分跟当前区域反转后重新连接起来，初始时是头节点的前一个节点</span></span><br><span class="line">        <span class="keyword">var</span> predecessor: ListNode? = dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. while循环一开始可能不知道是什么条件，可以先写while(true)，先写遍历代码</span></span><br><span class="line">        <span class="comment">// 13. pioneer探路前，指向的是要翻转的区域的前驱结点，如果不存在要翻转的区域，就不用遍历了，如果还有要翻转的区域则需要继续探路；如果后面不足k个节点，会在循环内break</span></span><br><span class="line">        <span class="keyword">while</span> (pioneer?.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 4. 开拓者要探k次路，如果后面不足k个结点，pioneer应当为null</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                pioneer = pioneer?.next</span><br><span class="line">                <span class="keyword">if</span> (pioneer == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 一开始还没开始翻转，就发现链表不足k个节点的话，按照题意不用翻转，所以就什么都不用做了，先break</span></span><br><span class="line">            <span class="keyword">if</span> (pioneer == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. pioneer不为null，说明是有k个节点的，可以翻转</span></span><br><span class="line">            <span class="comment">// 翻转主要是要解决翻转区域前后节点的连接问题，翻转后翻转区域的头尾都变了</span></span><br><span class="line">            <span class="comment">// 需要把翻转区域前后节点先保存下来，翻转后再重新连接翻转区域到主链表上</span></span><br><span class="line">            <span class="comment">// 当前待翻转区域尾节点就是pioneer，翻转区域后面的节点就是pioneer.next</span></span><br><span class="line">            <span class="keyword">val</span> successor = pioneer?.next</span><br><span class="line">            <span class="comment">// 翻转区域前面的节点还没有记录过，需要有个变量记录一下，到上面定义一下</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 翻转链表链表需要知道头结点，需要记录待翻转区域头节点，翻转后这个节点就变成了尾节点</span></span><br><span class="line">            <span class="keyword">val</span> newTail = predecessor?.next</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 把当前正要翻转区域跟主链表断开连接再做翻转，这样会比较方便，因为本来就是要重新连接的，最后再重新连接上</span></span><br><span class="line">            predecessor?.next = <span class="literal">null</span></span><br><span class="line">            pioneer?.next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10. 翻转链表</span></span><br><span class="line">            <span class="keyword">val</span> newHead = reverse(newTail)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 11. 重新把翻转后的链表连接到原链表</span></span><br><span class="line">            predecessor?.next = newHead</span><br><span class="line">            newTail?.next = successor</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12. 重置前驱指针和开拓者指针，都指向当前翻转区域的尾节点</span></span><br><span class="line">            predecessor = newTail</span><br><span class="line">            pioneer = newTail</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的头节点</span></span><br><span class="line">        <span class="keyword">val</span> newHead = dummyHead.next</span><br><span class="line">        dummyHead.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转链表，返回翻转后的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverse</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> pre: ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> cur: ListNode? = head</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n)：n为链表节点总数，需要遍历所有节点。<br>空间复杂度O(1)：只用了常数个变量。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.264.丑数 II（中等）</title>
    <url>/LeetCode/LeetCode.264.%E4%B8%91%E6%95%B0%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II（中等）</a></p>
<p>给你一个整数  <code>n</code>  ，请你找出并返回第  <code>n</code>  个  <strong>丑数</strong>  。<br><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code>  和/或 <code>5</code> 的正整数。<br>提示：<code>1 &lt;= n &lt;= 1690</code></p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h2><p>根据丑数定义，除了1这个丑数，其他丑数都是从小的丑数乘以2或3或5得到，那么递推就好了。</p>
<p>主要问题是，几个小的丑数乘以2、3、5后的丑数，你不知道哪个大哪个小，不好确定下一个丑数是哪个。比如：</p>
<ol>
<li>丑数3乘以质因数后得到丑数：6、9、15。</li>
<li>丑数4乘以质因数后得到丑数：8、12、20。</li>
</ol>
<p>所以需要排个序，由于参与排序的元素位置和个数并不确定，所以需要在线算法实现，优先队列（堆）恰好适合元素不确定的排序，入队和出队时调整堆只需要O(log n)的时间复杂度。</p>
<p>还有个问题是要去重，比如 <code>丑数4 * 3 = 12</code>， <code>丑数6 * 2 = 12</code>，丑数肯定不重复，从优先队列取出元素后，检查有重复去去除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            pq.add(u * <span class="number">2</span>)</span><br><span class="line">            pq.add(u * <span class="number">3</span>)</span><br><span class="line">            pq.add(u * <span class="number">5</span>)</span><br><span class="line">            u = pq.remove()</span><br><span class="line">            <span class="keyword">while</span> (pq.isNotEmpty() &amp;&amp; pq.peek() == u) pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用哈希表来去重，用空间换时间，出队入队还是要占用一点不必要的时间的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> factors = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (factor <span class="keyword">in</span> factors) &#123;</span><br><span class="line">                <span class="keyword">val</span> nextU = u * factor</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nextU)) &#123;</span><br><span class="line">                    pq.add(nextU)</span><br><span class="line">                    visited.add(nextU)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            u = pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：三指针"><a href="#解法2：三指针" class="headerlink" title="解法2：三指针"></a>解法2：三指针</h3><p>3个质因数都要跟每个丑数乘一次，相当于形成3个丑数序列，每次取3个序列中最小值，作为新数组的元素，这很像归并排序，可以用3个指针3路归并。</p>
<p>已经递推出来的丑数要用数组记录下来，因为3个指针位置不确定，可能某个指针会访问到以前较小的丑数。</p>
<p>由于不能有重复值，再取完3个序列左边最小值后，要把相同值给跳过。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p3 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p5 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> u = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        u[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">val</span> v2 = u[p2] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> v3 = u[p3] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">val</span> v5 = u[p5] * <span class="number">5</span></span><br><span class="line">            <span class="keyword">val</span> nextU = minOf(v2, v3, v5)</span><br><span class="line">            <span class="comment">// 多个序列有重复元素要跳过，丑数不能有重复</span></span><br><span class="line">            <span class="keyword">if</span> (nextU == v2) p2++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v3) p3++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v5) p5++</span><br><span class="line">            u[i] = nextU</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.273.整数转换英文表示（困难）</title>
    <url>/LeetCode/LeetCode.273.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E8%8B%B1%E6%96%87%E8%A1%A8%E7%A4%BA%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/integer-to-english-words/">LeetCode.273.整数转换英文表示（困难）</a></p>
<span id="more"></span>

<p>将非负整数  <code>num</code>  转换为其对应的英文表示。</p>
<p>示例 1：</p>
<p>输入：num = 123<br>输出：”One Hundred Twenty Three”<br>示例 2：</p>
<p>输入：num = 12345<br>输出：”Twelve Thousand Three Hundred Forty Five”<br>示例 3：</p>
<p>输入：num = 1234567<br>输出：”One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven”<br>示例 4：</p>
<p>输入：num = 1234567891<br>输出：”One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One”</p>
<ul>
<li>  <code>0 &lt;= num &lt;= 2^31  - 1</code></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="定义问题，发现规律"><a href="#定义问题，发现规律" class="headerlink" title="定义问题，发现规律"></a>定义问题，发现规律</h2><p>根据示例，可以发现：</p>
<ul>
<li>每3位数的读法是一样的。</li>
<li>每3位数末尾的量词读法不一样。</li>
</ul>
<p>那么问题一下子就明确了，只需要：</p>
<ul>
<li>按每三个数一组，拆分原数字。</li>
<li>每一组调用统一的三位数读法处理方法。</li>
<li>每一组的末尾用不同的量词。</li>
</ul>
<p>接下来的问题就是：</p>
<ul>
<li>如何三位一组拆分原数字？</li>
<li>怎么知道要拆分几组？</li>
<li>每一组怎么把数字对应上英文？</li>
</ul>
<h1 id="如何三位一组拆分原数字？"><a href="#如何三位一组拆分原数字？" class="headerlink" title="如何三位一组拆分原数字？"></a>如何三位一组拆分原数字？</h1><p>利用不保留余数的除法。</p>
<p>比如 123456789。</p>
<ul>
<li>如何得到789？<ul>
<li>123456789 % 1000 = 789</li>
</ul>
</li>
<li>如何得到456？<ul>
<li>123456789 / 1000 = 123456</li>
<li>123456 % 1000 = 456</li>
</ul>
</li>
<li>如何得到123？<ul>
<li>123456789 / 1000 / 1000 = 123</li>
</ul>
</li>
</ul>
<p>这样的拆分这是可以递归进行的。</p>
<h1 id="怎么知道要拆分几组？"><a href="#怎么知道要拆分几组？" class="headerlink" title="怎么知道要拆分几组？"></a>怎么知道要拆分几组？</h1><p>比如</p>
<ul>
<li>1、12、123就不需要拆分了。</li>
<li>1234、12345、123456可以拆分为两组。</li>
<li>1234567、12345678、123456789可以拆分为三组。</li>
<li>1234567890可以拆分为四组。</li>
</ul>
<p>再多的位数不考虑了。</p>
<p>因为<code>num &lt;= 2^31  - 1 </code>，其中<code>2^31 = 2147483648</code>，是10位数。</p>
<h1 id="每一组怎么把数字对应上英文？"><a href="#每一组怎么把数字对应上英文？" class="headerlink" title="每一组怎么把数字对应上英文？"></a>每一组怎么把数字对应上英文？</h1><p>每一组是小于1000的，得看英文中是怎么描述小于1000的数字的。</p>
<p>可以小于100的一些数有单独的单词：</p>
<ul>
<li>0到9</li>
<li>10到19</li>
<li>20、30、40、50、60、70、80、90</li>
</ul>
<p>这里可以用哈希表存储数字对应的单词。</p>
<p>大于20小于100，没有单独单词的数字怎么读？</p>
<ul>
<li>个位置零后的两位数单词 + 个位数对应的单词</li>
</ul>
<p>100到1000的数怎么读？</p>
<ul>
<li>百位数单独读法 +  Hundred + 两位数或个位数读法</li>
</ul>
<p>所有情况都罗列出来了，可以直接照着写。</p>
<h1 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h1><p>不能拆分，说明是0，要读Zero。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li>时间复杂度O(n)：n为数字位数，需要检测每一位的数字的读法。</li>
<li>空间复杂度O(1)：仅用常数个变量。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> map = mapOf(</span><br><span class="line">            <span class="number">0</span> to <span class="string">&quot;Zero&quot;</span>,</span><br><span class="line">            <span class="number">1</span> to <span class="string">&quot;One&quot;</span>,</span><br><span class="line">            <span class="number">2</span> to <span class="string">&quot;Two&quot;</span>,</span><br><span class="line">            <span class="number">3</span> to <span class="string">&quot;Three&quot;</span>,</span><br><span class="line">            <span class="number">4</span> to <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">            <span class="number">5</span> to <span class="string">&quot;Five&quot;</span>,</span><br><span class="line">            <span class="number">6</span> to <span class="string">&quot;Six&quot;</span>,</span><br><span class="line">            <span class="number">7</span> to <span class="string">&quot;Seven&quot;</span>,</span><br><span class="line">            <span class="number">8</span> to <span class="string">&quot;Eight&quot;</span>,</span><br><span class="line">            <span class="number">9</span> to <span class="string">&quot;Nine&quot;</span>,</span><br><span class="line">            <span class="number">10</span> to <span class="string">&quot;Ten&quot;</span>,</span><br><span class="line">            <span class="number">11</span> to <span class="string">&quot;Eleven&quot;</span>,</span><br><span class="line">            <span class="number">12</span> to <span class="string">&quot;Twelve&quot;</span>,</span><br><span class="line">            <span class="number">13</span> to <span class="string">&quot;Thirteen&quot;</span>,</span><br><span class="line">            <span class="number">14</span> to <span class="string">&quot;Fourteen&quot;</span>,</span><br><span class="line">            <span class="number">15</span> to <span class="string">&quot;Fifteen&quot;</span>,</span><br><span class="line">            <span class="number">16</span> to <span class="string">&quot;Sixteen&quot;</span>,</span><br><span class="line">            <span class="number">17</span> to <span class="string">&quot;Seventeen&quot;</span>,</span><br><span class="line">            <span class="number">18</span> to <span class="string">&quot;Eighteen&quot;</span>,</span><br><span class="line">            <span class="number">19</span> to <span class="string">&quot;Nineteen&quot;</span>,</span><br><span class="line">            <span class="number">20</span> to <span class="string">&quot;Twenty&quot;</span>,</span><br><span class="line">            <span class="number">30</span> to <span class="string">&quot;Thirty&quot;</span>,</span><br><span class="line">            <span class="number">40</span> to <span class="string">&quot;Forty&quot;</span>,</span><br><span class="line">            <span class="number">50</span> to <span class="string">&quot;Fifty&quot;</span>,</span><br><span class="line">            <span class="number">60</span> to <span class="string">&quot;Sixty&quot;</span>,</span><br><span class="line">            <span class="number">70</span> to <span class="string">&quot;Seventy&quot;</span>,</span><br><span class="line">            <span class="number">80</span> to <span class="string">&quot;Eighty&quot;</span>,</span><br><span class="line">            <span class="number">90</span> to <span class="string">&quot;Ninety&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> units = arrayOf(<span class="string">&quot;Thousand&quot;</span>, <span class="string">&quot;Million&quot;</span>, <span class="string">&quot;Billion&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberToWords</span><span class="params">(num: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> strings = helper(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (strings.isNotEmpty()) <span class="keyword">return</span> strings.joinToString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="string">&quot;Zero&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">helper</span><span class="params">(num: <span class="type">Int</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> emptyList()</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">20</span>) <span class="keyword">return</span> listOf(map.getValue(num))</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> listOf(map.getValue(num / <span class="number">10</span> * <span class="number">10</span>)) + helper(num % <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> listOf(map.getValue(num / <span class="number">100</span>), <span class="string">&quot;Hundred&quot;</span>) + helper(num % <span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">1000L</span>.pow(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">val</span> high = num / <span class="number">1000L</span>.pow(i).toInt()</span><br><span class="line">                <span class="keyword">val</span> remain = num % <span class="number">1000L</span>.pow(i).toInt()</span><br><span class="line">                <span class="keyword">return</span> helper(high) + listOf(units[i - <span class="number">1</span>]) + helper(remain)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">pow</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">1L</span></span><br><span class="line">        repeat(n) &#123; result *= <span class="keyword">this</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>分治</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.279.完全平方数（中等）</title>
    <url>/LeetCode/LeetCode.279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/perfect-squares/">LeetCode.279.完全平方数（中等）</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h2><p>给定一个目标，有一组选择，做出选择，得出最优的结果，就是背包问题。<br>完全平方数没有限定选择个数，所以是完全背包问题。</p>
<p>设<code>dp[i]</code>表示和为i的完全平方数的最少数量。<br>对于每个<code>dp[i]</code>求解，从小到大穷举所有可选的完全平方数做出一次选择，挑选一个使用平方数数量最少的。</p>
<p>状态转移方程<br><code>dp[i] = minOf(dp[i], 1 + dp[i - j * j] + 1</code>，其中<code>1 &lt;= j &lt;= i</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numSquares</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i]表示和为i的完全平方数的最少数量</span></span><br><span class="line">        <span class="comment">// dp[0]没意义</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// dp[i]最多数量就是全部1相加，当做默认值，看有没有小的</span></span><br><span class="line">            dp[i] = i</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (j * j &lt;= i) &#123;</span><br><span class="line">                dp[i] = minOf(dp[i], <span class="number">1</span> + dp[i - j * j])</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：$O(n *\sqrt{n})$<br>空间复杂度：$O(n)$</p>
</blockquote>
<h2 id="解法2：bfs"><a href="#解法2：bfs" class="headerlink" title="解法2：bfs"></a>解法2：bfs</h2><p>如果先用递归求解，画出递归树就很好想象了。<br>可以进行层序遍历一层一层的算。<br>第一层依次减去一个平方数得到第二层；<br>第二层依次减去一个平方数得到第三层；<br>每递进一层，使用过的平方数个数加1；<br>当某一层出现了0，当前层数就是答案。</p>
<p><strong>注意点</strong><br>因为会有重叠子问题，所以要避免重复纳入已经计算过的节点，用visited数组记录访问过的节点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numSquares</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        queue.add(n)</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            level++</span><br><span class="line">            <span class="keyword">val</span> size = queue.size</span><br><span class="line">            repeat(size) &#123;</span><br><span class="line">                <span class="keyword">val</span> num = queue.poll()</span><br><span class="line">                visited.add(num)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (j * j &lt;= num) &#123;</span><br><span class="line">                    <span class="keyword">val</span> small = num - j * j</span><br><span class="line">                    <span class="keyword">if</span> (small == <span class="number">0</span>) <span class="keyword">return</span> level</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(small)) &#123;</span><br><span class="line">                        queue.add(small)</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.295.数据流的中位数（困难）</title>
    <url>/LeetCode/LeetCode.295.%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">LeetCode.295.数据流的中位数（困难）</a></p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<span id="more"></span>

<p>进阶:</p>
<ul>
<li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
<li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：排序-二分查找"><a href="#解法1：排序-二分查找" class="headerlink" title="解法1：排序 + 二分查找"></a>解法1：排序 + 二分查找</h2><p><strong>数据结构</strong><br>列表</p>
<p><strong>如何添加元素？</strong></p>
<p>如果每次添加新元素都要排序，时间复杂度为O(n * logn)。</p>
<p>而列表本身已经是升序，可以用二分查找寻找插入位置，时间复杂度O(log n)，插入后要把插入元素后面的元素全部往后移动一位。</p>
<p>最坏情况下插入到第一个位置，移动所有的数，所以最坏时间复杂度为O(n)。</p>
<p><strong>如何取中位数？</strong></p>
<p>中位数直接取列表的中间的值，时间复杂度为O(1)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span></span>() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> nums = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addNum</span><span class="params">(num: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> insertedIndex = binarySearchInsertIndex(num)</span><br><span class="line">        <span class="comment">// 每次添加新元素都要把插入元素后面的元素全部往后移动一位，最坏情况下插入到第一个位置，移动所有的数，所以最坏时间复杂度为O(n)</span></span><br><span class="line">        nums.add(insertedIndex, num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找插入位置最坏的时间复杂度为O(lgn)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">binarySearchInsertIndex</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> high = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span> || num &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中位数直接取列表的值，时间复杂度为O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedian</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) (nums[n / <span class="number">2</span> - <span class="number">1</span>] + nums[n / <span class="number">2</span>]).toDouble() / <span class="number">2f</span></span><br><span class="line">        <span class="keyword">else</span> nums[n / <span class="number">2</span>].toDouble()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：大顶堆-小顶堆"><a href="#解法2：大顶堆-小顶堆" class="headerlink" title="解法2：大顶堆 + 小顶堆"></a>解法2：大顶堆 + 小顶堆</h2><h3 id="数据结构的选择"><a href="#数据结构的选择" class="headerlink" title="数据结构的选择"></a>数据结构的选择</h3><p>要保证查询中位数的时间复杂度是O(1)，就要在插入元素的时候就保持元素有序，才能直接查询到中位数。</p>
<p>从数据流中不停的插入新元素并保持有序，用离线排序算法复杂度较高，考虑在线排序算法，用堆排序，API层使用优先队列，添加一个新元素调整堆的时间复杂度最多为O(log n)。</p>
<h3 id="用优先队列怎么获取中位数？"><a href="#用优先队列怎么获取中位数？" class="headerlink" title="用优先队列怎么获取中位数？"></a>用优先队列怎么获取中位数？</h3><p><strong>中位数的定义？</strong><br>假设一共有n个数：</p>
<ul>
<li>n为奇数时，中位数 = 第n / 2 + 1大的数。</li>
<li>n为偶数时，中位数 = (第n / 2大的数 + 第n / 2 + 1大的数) / 2</li>
</ul>
<p><strong>优先队列怎么取元素的？</strong></p>
<ul>
<li>如果是小顶堆，只能取堆顶最小的元素。</li>
<li>如果是大顶堆，只能取堆顶最大的元素。</li>
</ul>
<p>我们需要取第n / 2大的数和第n / 2 + 1大的数，但是却只能从堆顶取，那么：</p>
<ul>
<li>用一个大顶堆存储第1大到第n / 2大的数，堆顶就是第n / 2大的数。</li>
<li>用一个小顶堆存储第n / 2 + 1大到第n大的数，堆顶就是第n / 2 + 1大的数。</li>
<li>n为奇数时，大顶堆比小顶堆多存储一个数，堆顶就是中位数。</li>
<li>n为偶数时，大顶堆和小顶堆元素个数一样多。</li>
</ul>
<h3 id="添加新元素时要怎么往优先队列里插入？"><a href="#添加新元素时要怎么往优先队列里插入？" class="headerlink" title="添加新元素时要怎么往优先队列里插入？"></a>添加新元素时要怎么往优先队列里插入？</h3><p>初始时，两个堆都为空，允许大顶堆比小顶堆多一个元素，一开始就插入大顶堆。</p>
<p>后续添加新元素，由于是要寻找所有元素中的中位数，所以添加新元素后，中位数可能会变化，两个堆中元素都要调整顺序。</p>
<p>新元素先添加到大顶堆，筛选出最大的数到堆顶，再取出大顶堆的堆顶元素插入小顶堆，这样就保持两个堆顶都是正确的中位数了。</p>
<p>如果后续添加新元素后，元素总数变成奇数，需要在上面的基础上再把小顶堆的顶堆元素取出插入大顶堆中，让大顶堆比小顶堆多一个元素。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>设元素总数为n。</p>
<p>添加元素时，最坏情况下需要三次插入堆，一次插入堆的时间复杂度是O(log n)，三次就是3 * O(log n)，所以添加元素最坏时间复杂度为O(log n)。</p>
<p>查询中位数时间复杂度O(1)。</p>
<p>空间复杂度O(n)：两个优先队列存储数据流所有的数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用大顶堆有序数组的中位数的前半部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxHeap = PriorityQueue&lt;<span class="built_in">Int</span>&gt; &#123; o1, o2 -&gt; o2 - o1 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用小顶堆保存有序数组中位数的后半部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> minHeap = PriorityQueue&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已保存的数字个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addNum</span><span class="params">(num: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        maxHeap.offer(num)</span><br><span class="line">        minHeap.offer(maxHeap.poll())</span><br><span class="line">        <span class="keyword">if</span> (count and <span class="number">1</span> != <span class="number">0</span>) maxHeap.offer(minHeap.poll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedian</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="comment">// 元素总数为奇数，直接取大顶堆堆顶元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (count and <span class="number">1</span> != <span class="number">0</span>) maxHeap.peek().toDouble()</span><br><span class="line">        <span class="keyword">else</span> (maxHeap.peek() + minHeap.peek()).toDouble() / <span class="number">2f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.297.二叉树的序列化与反序列化（困难）</title>
    <url>/LeetCode/LeetCode.297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">LeetCode.297.二叉树的序列化与反序列化（困难）</a></p>
<span id="more"></span>

<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：广度优先搜索"><a href="#解法1：广度优先搜索" class="headerlink" title="解法1：广度优先搜索"></a>解法1：广度优先搜索</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>按照层序遍历记录节点值，拼接成字符串，节点之间用空格分隔。</li>
<li>空节点记为#，以便识别节点没有子树了。</li>
</ul>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><ul>
<li>拆解字符串为节点列表。</li>
<li>反序列化跟序列化顺序保持一致，也是层序遍历，才能识别出节点位置。</li>
<li>按照层序遍历的过程，构建二叉树。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">val</span> nullNode = TreeNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">val</span> queue = java.util.ArrayDeque&lt;TreeNode&gt;()</span><br><span class="line">        queue.add(root)</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (node != nullNode) &#123;</span><br><span class="line">                sb.append(node.`<span class="keyword">val</span>`)</span><br><span class="line">                queue.add(node.left ?: nullNode)</span><br><span class="line">                queue.add(node.right ?: nullNode)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> nodes = <span class="keyword">data</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> queue = java.util.ArrayDeque&lt;TreeNode&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> root = nodes[<span class="number">0</span>].toNode()!!</span><br><span class="line">        queue.add(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty() &amp;&amp; i &lt; nodes.size) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> left = nodes[i].toNode()</span><br><span class="line">            node.left = left</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(left)</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> right = nodes[i].toNode()</span><br><span class="line">            node.right = right</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(right)</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">toNode</span><span class="params">()</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="string">&quot;#&quot;</span>) <span class="literal">null</span></span><br><span class="line">        <span class="keyword">else</span> TreeNode(toInt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：深度优先搜索"><a href="#解法2：深度优先搜索" class="headerlink" title="解法2：深度优先搜索"></a>解法2：深度优先搜索</h2><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>按照DFS根、左、右的遍历顺序记录节点，节点之间用空格分割。</li>
<li>遇到空节点记为#，以便在反序列化时知道没有子树了。</li>
</ul>
<h3 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h3><ul>
<li>把字符串转换为迭代器做遍历。</li>
<li>按照DFS根、左、右的遍历顺序构建二叉树。</li>
<li>遇到#说明没有子树。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;#&quot;</span>).append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(root.`<span class="keyword">val</span>`).append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> nodes = <span class="keyword">data</span>.split(<span class="string">&quot; &quot;</span>).map &#123; it.toNode() &#125;.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">rebuild</span><span class="params">(nodes: <span class="type">Iterator</span>&lt;<span class="type">TreeNode</span>?&gt;)</span></span>: TreeNode? &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nodes.hasNext()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            <span class="keyword">val</span> root = nodes.next() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            root.left = rebuild(nodes)</span><br><span class="line">            root.right = rebuild(nodes)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rebuild(nodes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">toNode</span><span class="params">()</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="string">&quot;#&quot;</span>) <span class="literal">null</span></span><br><span class="line">        <span class="keyword">else</span> TreeNode(toInt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.30.串联所有单词的子串（困难）</title>
    <url>/LeetCode/LeetCode.30.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">LeetCode.30.串联所有单词的子串（困难）</a></p>
<p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力推导"><a href="#暴力推导" class="headerlink" title="暴力推导"></a>暴力推导</h3><ol>
<li>穷举出所有s可能的子串。</li>
<li>对每个子串检查能不能拿words中所有单词串联得出。</li>
</ol>
<h3 id="穷举出所有s可能的子串，有什么优化？"><a href="#穷举出所有s可能的子串，有什么优化？" class="headerlink" title="穷举出所有s可能的子串，有什么优化？"></a>穷举出所有s可能的子串，有什么优化？</h3><p>题目要求恰好可以用words中所有单词串联形成的子串，所以子串的长度是确定的，只要穷举这个特定长度所有子串就行了，不需要穷举所有长度的子串。</p>
<p>其实这就相当于弄一个滑动窗口依次检测。</p>
<h3 id="怎么检查子串能不能拿words中所有单词串联得出？"><a href="#怎么检查子串能不能拿words中所有单词串联得出？" class="headerlink" title="怎么检查子串能不能拿words中所有单词串联得出？"></a>怎么检查子串能不能拿words中所有单词串联得出？</h3><p>按道理得组合所有words中单词的情况。</p>
<p>但是题目说所有单词长度相同，假设长度为n，可以把大子串再分割成m分长度为n的小子串，看小子串是不是在words里。</p>
<p>检查一个东西是不是在某个集合里，可以想到用哈希表，用O(1)时间查询得出结果。</p>
<p>但是哈希表不能存储相同的单词，所以要给重复出现的单词计数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findSubstring</span><span class="params">(s: <span class="type">String</span>, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (words.isEmpty()) <span class="keyword">return</span> emptyList()</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> wordCount = words.size</span><br><span class="line">        <span class="comment">// 每个单词的长度</span></span><br><span class="line">        <span class="keyword">val</span> wordLength = words.first().length</span><br><span class="line">        <span class="comment">// 生成哈希表：记录每个单词有多少个</span></span><br><span class="line">        <span class="keyword">val</span> allWords = words.groupingBy &#123; it &#125;.eachCount()</span><br><span class="line">        <span class="comment">// 穷举所有可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.(s.length - wordCount * wordLength)) &#123;</span><br><span class="line">            <span class="keyword">val</span> countMap = mutableMapOf&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; wordCount) &#123;</span><br><span class="line">	            <span class="comment">// 子串按单词长度切片，检查每一片是否在单词列表里</span></span><br><span class="line">                <span class="keyword">val</span> word = s.substring(i + j * wordLength, i + (j + <span class="number">1</span>) * wordLength)</span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(word)) &#123;</span><br><span class="line">                    <span class="comment">// 注意对重复单词计数，单词在子串中出现过的次数与在words出现的次数应该一致</span></span><br><span class="line">                    <span class="keyword">val</span> count = countMap.getOrDefault(word, <span class="number">0</span>)</span><br><span class="line">                    countMap[word] = count + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> (countMap[word]!! &gt; allWords[word]!!) &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span></span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == wordCount) &#123;</span><br><span class="line">                result.add(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度O(mn)：<br>假设字符串s长度为m，滑动窗口穿过整个s，最坏情况下滑动窗口大小为1，需要移动m次。<br>判断每个滑动窗口的子串是不是能由words所有单词组成，最坏情况需要遍历words所有单词，假设words长度为n，就就要遍历n次。</p>
<p>空间复杂度O(n)：<br>用哈希表记录words中所有单词出现的次数。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>滑动窗口</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.300.最长递增子序列（中等）</title>
    <url>/LeetCode/LeetCode.300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">LeetCode.300.最长递增子序列（中等）</a></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最值问题考虑动态规划，看能不能把大问题先拆分为子问题+有限步骤。</p>
<p><strong>如果已知最长严格递增子序列，它是怎么得来的呢？上一步的最小操作是什么？</strong></p>
<ul>
<li>如果前面没有递增子序列，当前字符作为新的递增子序列起点。</li>
<li>如果前面有了递增子序列，当前字符比前面子序列最后一个数字大，可以形成新的递增子序列，长度加1。</li>
</ul>
<p><strong>前面的递增子序列可能有很多个，应该追加到哪个递增子序列的后面？</strong><br>找长度最大的递增子序列。</p>
<p><strong>数组前面的部分又是怎么找到最长递增子序列的？</strong><br>还是一样的拆解，递归进行，这里划分出了子问题+有限步骤。</p>
<ul>
<li>子问题是最优的，经过有限步骤得出下一个问题的最优解，符合最优子结构。</li>
<li>子问题的结果不受更大问题的影响，无后效性。</li>
<li>计算长的子数组的最长递增子序列的长度，都要访问前面的递增子序列的长度，有重叠子问题。</li>
</ul>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i]</code>为以<code>nums[i]</code>结尾的最长递增子序列的长度。<br>遍历<code>nums[0, i - 1]</code>，寻找<code>j</code>（<code>0 &lt;= j &lt;= i - 1</code>）：</p>
<ul>
<li>对于所有满足<code>nums[i] &gt; nums[j]</code>的<code>j</code>，找出最大<code>dp[j]</code>，<code>dp[i] = 1 + 最大的dp[j]</code>。</li>
<li>如果<code>nums[i]</code>比<code>nums[0, i - 1]</code>都小，<code>dp[i] = 1</code>。</li>
</ul>
<p><strong>复杂度</strong><br>时间复杂度$O(n^2)$：<br>计算所有<code>dp[i]</code>得遍历整个数组，需要$O(n)$；<br>计算每个<code>dp[i]</code>需要遍历<code>[0, i - 1]</code>，即$O(n)$。<br>双循环共执行<code>1 + 2 + 3 + ... + n - 1 = (1 + n - 1) * (n - 1) / 2 = n(n - 1) / 2次</code>。</p>
<p>空间复杂度$O(n)$：<br><code>dp</code>数组占用线性空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLIS</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> preMaxLen = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    preMaxLen = maxOf(preMaxLen, dp[j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = <span class="number">1</span> + preMaxLen</span><br><span class="line">            maxLen = maxOf(maxLen, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间优化</strong></p>
<p><strong>计算所有<code>dp[i]</code>的时间能不能优化？</strong><br>计算所有<code>dp[i]</code>必须要遍历整个数组，无法优化。</p>
<p><strong>计算每个<code>dp[i]</code>的时间能不能优化？</strong><br>先看计算单个<code>dp[i]</code>的过程：<br>是要在已经发现的递增子序列中看<code>nums[i]</code>能接到哪些子序列后面，再在能接上去的这些子序列中找一个长度最大的。</p>
<p><strong>直接找之前最长子序列的去接行不行？</strong><br>行，如果能接上肯定最好。</p>
<p><strong>如果接不上最长的，还有必要去接短的递增子序列吗？</strong><br>有必要的，比如数组<code>[1, 6, 7, 2, 3, 4]</code>，有递增子序列是<code>[1]</code>、<code>[1, 6]</code>和<code>[1, 6, 7]</code>，2是接不到<code>[1, 6, 7]</code>后面的，但是可以接在<code>[1]</code>后面形成<code>[1, 2]</code>，最后遇到3和4，可以接在<code>[1, 2]</code>后面形成长度为4的递增子序列，比<code>[1, 6, 7]</code>还要长。</p>
<p>这里就引发一个问题，如果<strong>之前最长的子序列可能会有多个，应该去接哪个？</strong><br>跟末尾元素最小的比较，是最快的；否则要是接不上，得比较多次。<br>比如上面长度为2的子序列有<code>[1, 6]</code>和<code>[1, 2]</code>，后面遇到3和4肯定直接跟2比较，比较次数是最少的。</p>
<p>所以如果当前数字接不到最长的，但是能接到短的子序列后面，如果当前数字比之前子序列末尾元素小，接上去对后面接更长的子序列是有意义的。</p>
<p><strong>能否在查找方法上做优化？</strong><br>一说到查找和比较，就能想到最优化的查找元素方法是二分查找，可以把时间复杂度降低到$O(log n)$。</p>
<p>二分查找是要求在有序数组里做查找比较的，那就把递增子序列的末尾数字从小到大排序。</p>
<p>我们想通过比较末尾元素，是想更新某个长度的递增子序列的末尾元素为更小的。</p>
<p>递增子序列末尾元素的大小顺序和子序列的长度有没有什么关联？</p>
<p>可以发现，如果相同长度的子序列只保留最小的末尾数字，那么长度大的子序列的末尾元素一定比长度小的子序列的末尾元素大。<br>因为只有新的数字比原来短的递增子序列的末尾元素大，才能形成长度更长的递增子序列；如果新的数字比原来短的递增子序列的末尾元素小，是无法形成长度更长的递增子序列的。</p>
<hr>
<p><strong>能否在查找方法上做优化？</strong><br>一说到查找和比较，就能想到最优化的查找元素方法是二分查找，可以把时间复杂度降低到$O(log n)$。</p>
<p>二分查找是要求在有序数组里做查找比较的，那就把递增子序列的末尾数字从小到大排序。<br>新的数字去二分比较后，能否确定新数字可以拼接的子序列最长长度？只有能确定，才可以不跟所有末尾数字比较，二分查找才能节约出时间，否则还得顺序扫描所有元素。</p>
<p>换句话说，递增子序列末尾元素的大小顺序和子序列的长度有没有什么关联？</p>
<p>可以发现，如果相同长度的子序列只保留最小的末尾数字，那么长度大的子序列的末尾元素一定比长度小的子序列的末尾元素大。<br>因为只有新的数字比原来短的递增子序列的末尾元素大，才能形成长度更长的递增子序列；如果新的数字比原来短的递增子序列的末尾元素小，是无法形成长度更长的递增子序列的；如果新数字比某长度的递增子序列的最小的末尾数字都要小，那肯定是无法接在它后面形成长度更长的递增子子序列了。</p>
<p>所以二分查找是可行的，可以保存每个长度的递增子序列的最小末尾数字形成数组，递增子序列长度作为数组索引，数组元素默认就是严格递增。<br>遇到新的数字用二分查找，就可以知道应该更新哪个长度的子序列的末尾元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLIS</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// dp[i]表示以长度为i + 1的所有上升子序列中结尾最小的数，0 &lt;= i &lt;= n - 1，n为数组长度</span></span><br><span class="line">        <span class="comment">// 由于上升子序列的长度可能是小于n的，所以这里创建动态列表来作为状态存储</span></span><br><span class="line">        <span class="keyword">val</span> dp = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp.add(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 可以形成更长的子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; dp.last()) &#123;</span><br><span class="line">                dp.add(nums[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不能形成更长的子序列，但是要更新之前子序列末尾的元素为更小的，方便后续快速比较</span></span><br><span class="line">                <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">                <span class="keyword">var</span> right = dp.size - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">when</span> &#123;</span><br><span class="line">                        <span class="comment">// 要找比子序列末尾元素大的位置，所以不会是mid本身，要mid + 1</span></span><br><span class="line">                        dp[mid] &lt; nums[i] -&gt; left = mid + <span class="number">1</span></span><br><span class="line">                        <span class="comment">// dp[mid] &gt; nums[i]，dp严格递增，不存在dp[mid] == nums[i]</span></span><br><span class="line">                        <span class="keyword">else</span> -&gt; right = mid - <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 熟悉二分法可知，循环结束后，一定会有 nums[left - 1] &lt; nums[i] &lt; nums[left]</span></span><br><span class="line">                <span class="comment">// 更新子序列末尾元素为更小的</span></span><br><span class="line">                dp[left] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.301.删除无效的括号（困难）</title>
    <url>/LeetCode/LeetCode.301.%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">LeetCode.301.删除无效的括号（困难）</a></p>
<p>给你一个由若干括号和字母组成的字符串  <code>s</code>  ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按  <strong>任意顺序</strong>  返回。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入：s = “()())()”<br>输出：[“(())()”,”()()()”]<br>示例 2：</p>
<p>输入：s = “(a)())()”<br>输出：[“(a())()”,”(a)()()”]<br>示例 3：</p>
<p>输入：s = “)(“<br>输出：[“”]</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 25</code></li>
<li>  <code>s</code>  由小写英文字母以及括号  <code>&#39;(&#39;</code>  和  <code>&#39;)&#39;</code>  组成</li>
<li>  <code>s</code>  中至多含  <code>20</code>  个括号</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：广度优先搜索"><a href="#解法1：广度优先搜索" class="headerlink" title="解法1：广度优先搜索"></a>解法1：广度优先搜索</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>寻找最短路径考虑使用广度优先搜索。</p>
<ul>
<li>不知道删除哪个括号，就把所有的括号都依次删除试一遍。</li>
<li>一直试到发现了可以形成有效括号，不用再试了。</li>
</ul>
<h3 id="怎么判断是否可以形成有效括号？"><a href="#怎么判断是否可以形成有效括号？" class="headerlink" title="怎么判断是否可以形成有效括号？"></a>怎么判断是否可以形成有效括号？</h3><p>左括号个数与右括号个数相等。</p>
<h3 id="BFS下一层是什么？"><a href="#BFS下一层是什么？" class="headerlink" title="BFS下一层是什么？"></a>BFS下一层是什么？</h3><ul>
<li>初始时，<code>s</code>作为第一层。</li>
<li>删除<code>s</code>中的一个括号，得到下一层的字符串。<ul>
<li>不知道删除<code>s</code>中的哪个括号，就把所有位置的括号都试着删除一次。</li>
<li>删除一个括号后，剩余字符串可能会重复，存储时可以添加到HashSet里去重。</li>
</ul>
</li>
</ul>
<h3 id="BFS怎么发现需要删除最少的括号数？"><a href="#BFS怎么发现需要删除最少的括号数？" class="headerlink" title="BFS怎么发现需要删除最少的括号数？"></a>BFS怎么发现需要删除最少的括号数？</h3><ul>
<li>每一层都会针对所有可能的有效括号字符串删除一个字符得到新的字符串集合。</li>
<li>如果新的字符串集合中有可以形成有效括号的字符串，BFS已经遍历的层数就是需要删除的最少括号数。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeInvalidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> level = mutableSetOf(s)</span><br><span class="line">        <span class="keyword">while</span> (level.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> validResult = level.filter &#123; it.hasValidBrackets() &#125;</span><br><span class="line">            <span class="keyword">if</span> (validResult.isNotEmpty()) <span class="keyword">return</span> validResult</span><br><span class="line">            <span class="keyword">val</span> nextLevel = mutableSetOf&lt;String&gt;()</span><br><span class="line">            level.forEach &#123; str -&gt;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> str.indices) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">val</span> newString = StringBuilder(str).deleteCharAt(i).toString()</span><br><span class="line">                        nextLevel.add(newString)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level = nextLevel</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level.toList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有有效的括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">hasValidBrackets</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> s = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> leftBracketCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="keyword">when</span> (c) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; leftBracketCount++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (leftBracketCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                    leftBracketCount--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBracketCount == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：深度优先搜索"><a href="#解法2：深度优先搜索" class="headerlink" title="解法2：深度优先搜索"></a>解法2：深度优先搜索</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>找出不合法的左括号个数和右括号个数。</li>
<li>利用DFS不断删除左括号或者右括号，直到不合法括号个数为0。</li>
<li>检验删除后的括号串是否合法。</li>
</ul>
<h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><p>相邻两个字符相同的话，删除这两个字符所得到的字符串是一样的，处理就重复了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidBracketCount</span></span>(<span class="keyword">val</span> left: <span class="built_in">Int</span>, <span class="keyword">val</span> right: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeInvalidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> invalidBracketCount = s.invalidBracketCount</span><br><span class="line">        <span class="keyword">val</span> result = mutableSetOf&lt;String&gt;()</span><br><span class="line">        dfs(s, <span class="number">0</span>, invalidBracketCount.left, invalidBracketCount.right, result)</span><br><span class="line">        <span class="keyword">return</span> result.toList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>, start: <span class="type">Int</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>, result: <span class="type">MutableSet</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.hasValidBrackets()) &#123;</span><br><span class="line">                result.add(s)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> start until s.length) &#123;</span><br><span class="line">            <span class="comment">// 相邻两个字符相同的话，删除这两个字符所得到的字符串是一样的，处理就重复了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newString = s.removeRange(i, i + <span class="number">1</span>)</span><br><span class="line">                dfs(newString, i, left - <span class="number">1</span>, right, result)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newString = s.removeRange(i, i + <span class="number">1</span>)</span><br><span class="line">                dfs(newString, i, left, right - <span class="number">1</span>, result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> String.invalidBracketCount: InvalidBracketCount</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> s = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">                <span class="keyword">when</span> (c) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (left == <span class="number">0</span>) right++</span><br><span class="line">                        <span class="keyword">else</span> left--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> InvalidBracketCount(left, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有有效的括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">hasValidBrackets</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> s = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> leftBracketCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="keyword">when</span> (c) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; leftBracketCount++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (leftBracketCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                    leftBracketCount--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBracketCount == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</title>
    <url>/LeetCode/LeetCode.304.%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</a></p>
<p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<ul>
<li>计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。<br>实现 NumMatrix 类：</li>
<li>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化</li>
<li>int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>与<a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a>思路相同。</p>
<p>NumMatrix.sumRegion()要想做到O(1)时间复杂度查询，就要提前计算好二位前缀和。</p>
<p>设<code>preSum[i][j]</code>为<code>[0, 0]</code>到<code>[i, j]</code>矩形区域所有元素和。</p>
<p>求矩形区域d的元素和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a a a b b b b b   </span><br><span class="line">a a a b b b b b</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>设矩形d左上角坐标<code>(x1, y1)</code>，右下角坐标<code>(x2, y2)</code>。<br><code>整个区域所有元素和 = preSum[x2][y2]</code><br><code>区域a所有元素和 + 区域b所有元素和 = preSum[x1 - 1][y2]</code><br><code>区域a所有元素和 + 区域c所有元素和 = preSum[x2][y1 - 1]</code></p>
<p>所以:<br><code>区域d所有元素和 = preSum[x2][y2] - preSum[x1 - 1][y2] - preSum[x2][y1 - 1] + preSum[x1 - 1][y1 - 1]</code></p>
<p>遇到边界特殊处理一下就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span></span>(matrix: Array&lt;IntArray&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> m = matrix.size</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 求二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            preSum[<span class="number">0</span>][j] = preSum[<span class="number">0</span>][j - <span class="number">1</span>] + matrix[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            preSum[i][<span class="number">0</span>] = preSum[i - <span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> left = preSum[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> top = preSum[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">val</span> leftTop = preSum[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                preSum[i][j] = left + top - leftTop + matrix[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sumRegion</span><span class="params">(row1: <span class="type">Int</span>, col1: <span class="type">Int</span>, row2: <span class="type">Int</span>, col2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> all = preSum[row2][col2]</span><br><span class="line">        <span class="keyword">val</span> left = <span class="keyword">if</span> (col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row2][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> top = <span class="keyword">if</span> (row1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col2]</span><br><span class="line">        <span class="keyword">val</span> leftTop = <span class="keyword">if</span> (row1 == <span class="number">0</span> || col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> all - left - top + leftTop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.309.最佳买卖股票时机含冷冻期（中等）</title>
    <url>/LeetCode/LeetCode.309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode.309.最佳买卖股票时机含冷冻期（中等）</a></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最优化问题考虑用动态规划。</p>
<h2 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h2><p>第<code>i</code>天的基本操作有：买入、卖出、什么都不做。<br>买入有冷冻期限制，第i天可能无法买入，也就是只能什么都不做了，所有的操作还是这三种，不影响确定最终状态。<br>经过选择操作后可得第i天的最终状态只有：持有股票或不持有股票。<br>买入冷冻期的限制在状态转移方程中做状态转移时体现出来就行。</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p><code>dp[i][0]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1</code>天一样</li>
<li>之前持有股票，第<code>i</code>天卖出</li>
</ol>
<p>可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code></p>
<p><code>dp[i][1]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1天</code>一样</li>
<li>之前不持有股票，第<code>i</code>天买入；买入有冷冻期限制，如果是第<code>i - 1</code>天卖出的，第<code>i</code>天就不能买入了。</li>
</ol>
<p>可得<code>dp[i][1] = max(dp[i - 1], dp[i - 2][0] - prices[i])</code></p>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>dp[i][k]</code>只与前面两个状态有关，用变量记录前面的状态，不需要数组记录所有状态。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 0</span></span><br><span class="line">        <span class="keyword">var</span> preNoholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> preHoldProfit = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 1</span></span><br><span class="line">        <span class="keyword">var</span> curNoholdProfit = maxOf(preNoholdProfit, preHoldProfit + prices[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> curHoldProfit = maxOf(preHoldProfit, preNoholdProfit - prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(curNoholdProfit, curHoldProfit + prices[i])</span><br><span class="line">            <span class="comment">// 买入有冷冻期，只能从前天没有持有股票的状态转移而来</span></span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(curHoldProfit, preNoholdProfit - prices[i])</span><br><span class="line"></span><br><span class="line">            preNoholdProfit = curNoholdProfit</span><br><span class="line">            preHoldProfit = curHoldProfit</span><br><span class="line"></span><br><span class="line">            curNoholdProfit = newNoholdProfit</span><br><span class="line">            curHoldProfit = newHoldProfit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curNoholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.31.下一个排列（中等）</title>
    <url>/LeetCode/LeetCode.31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/">LeetCode.31.下一个排列（中等）</a></p>
<p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="字典序是什么意思？"><a href="#字典序是什么意思？" class="headerlink" title="字典序是什么意思？"></a>字典序是什么意思？</h3><p>顾名思义，就跟字典里的单词排布顺序一样。</p>
<h3 id="字典序中下一个排列是什么意思？"><a href="#字典序中下一个排列是什么意思？" class="headerlink" title="字典序中下一个排列是什么意思？"></a>字典序中下一个排列是什么意思？</h3><p>只能查定义，然后举几个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 2 3 5 4</span><br><span class="line">1 2 4 3 5</span><br><span class="line">1 2 4 5 3</span><br><span class="line">1 2 5 3 4</span><br><span class="line">1 2 5 4 3</span><br></pre></td></tr></table></figure>
<p>每一个排列都是从小到大递增的。</p>
<p>总结下一个排列的大致规律：</p>
<ul>
<li>数字要变大</li>
<li>变大的幅度要最小</li>
</ul>
<p>具体怎么获取下一个排列，可以一步步推理分析。</p>
<h3 id="怎么增大一个普通的数？"><a href="#怎么增大一个普通的数？" class="headerlink" title="怎么增大一个普通的数？"></a>怎么增大一个普通的数？</h3><p>把某一位的数字变大。</p>
<h3 id="如何保证一个普通的数增大的幅度最小？"><a href="#如何保证一个普通的数增大的幅度最小？" class="headerlink" title="如何保证一个普通的数增大的幅度最小？"></a>如何保证一个普通的数增大的幅度最小？</h3><ul>
<li>在最低位做加法。</li>
<li>加最小的数字1。</li>
</ul>
<h3 id="增大给定的数字序列可以跟增大一个普通数字一样吗？"><a href="#增大给定的数字序列可以跟增大一个普通数字一样吗？" class="headerlink" title="增大给定的数字序列可以跟增大一个普通数字一样吗？"></a>增大给定的数字序列可以跟增大一个普通数字一样吗？</h3><p>不一样。</p>
<p>因为要找下一个排列，数字还是序列中的那些数，数字不能随便用，只能用给定的数字序列里的数字。</p>
<h3 id="那怎么增大给定的数字序列？"><a href="#那怎么增大给定的数字序列？" class="headerlink" title="那怎么增大给定的数字序列？"></a>那怎么增大给定的数字序列？</h3><ol>
<li>确定一个要变大的位，假设这一位数字为x。</li>
<li>再找一个比x的大的位，两个位的数字做交换，保证不使用额外数字。</li>
</ol>
<p>同时要变大的位尽可能是低位，才能保证增幅最小。</p>
<h3 id="具体需要怎样的条件，交换数字位后才能获得更大的数字序列？"><a href="#具体需要怎样的条件，交换数字位后才能获得更大的数字序列？" class="headerlink" title="具体需要怎样的条件，交换数字位后才能获得更大的数字序列？"></a>具体需要怎样的条件，交换数字位后才能获得更大的数字序列？</h3><p>某两位交换，一个是高位，一个是低位。</p>
<ul>
<li>如果 <code>高位数字 &gt;= 低位数字</code>，交换过后，整个数变得更小了。</li>
<li>只有在 <code>高位数字 &lt; 低位数字</code>时做交换，整个数才会变得更大。</li>
</ul>
<h3 id="应该选取哪个低位数字和哪个高位数字做交换？"><a href="#应该选取哪个低位数字和哪个高位数字做交换？" class="headerlink" title="应该选取哪个低位数字和哪个高位数字做交换？"></a>应该选取哪个低位数字和哪个高位数字做交换？</h3><p>刚才的分析明确了两个条件：</p>
<ul>
<li>要从低位往高位找数字位。</li>
<li>高位数字 &lt; 低位数字。</li>
</ul>
<p>也就是说，如果低位有一个非递增序列（递减或相等序列），可以确定要找的高位数字肯定不在这个非递增序列里的，否则交换后无法变得更大。</p>
<p><strong>那要找的高位数字在哪？</strong></p>
<p>一定是处在一个递增序列中，且位数尽可能低。</p>
<p>也就是从右到左发现的第一个递增序列中第二大的数。</p>
<p>比如[1, 2, 3, 8, 6, 1]，我们要找到的高位数字是3。</p>
<p>为什么不能是8？</p>
<ul>
<li>因为8要是高位，低位只能在8的右边找一个数，这两个是递减的，交换后不会让整体更大。</li>
<li>如果3是要找的高位，至少可以跟比3大的8互换，整体可以形成更大的数，并且3是最低的符合条件的位了。</li>
</ul>
<p>换成代码表达：<br>从右到左遍历<code>num</code>数组，一旦第一次发现<code>num[i - 1] &lt; num[i]</code>，<code>num[i - 1]</code>就是要找到的高位数字。</p>
<p><strong>要找的低位数字在哪？</strong></p>
<p>现在有3个已知条件：</p>
<ul>
<li>要从低位往高位找。</li>
<li>高位数字 &lt; 低位数字。</li>
<li>高位数字位置已确定。</li>
</ul>
<p>高位数字位置已确定，低位数字位置的范围也就确定了，肯定在末尾的非递增序列里。</p>
<p>那么就从右到左遍历，寻找第一个大于高位数字的数就是要找的低位数字了。</p>
<p><strong>为什么要寻找第一个大于高位数字的数？</strong></p>
<p>假设：</p>
<ul>
<li>第一个大于高位数字的数去做交换后，得到的整个数变为a。</li>
<li>第二个大于高位数字的数去做交换后，得到的整个数变为b。</li>
</ul>
<p>可以发现<code>b &gt; a</code>，a是更大的数中增幅较小的那个，b不满足题目要求。</p>
<h3 id="交换后得到的新数字是下一个排列吗？"><a href="#交换后得到的新数字是下一个排列吗？" class="headerlink" title="交换后得到的新数字是下一个排列吗？"></a>交换后得到的新数字是下一个排列吗？</h3><p>回到最开始的例子，带入观察。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 2 3 5 4</span><br><span class="line">1 2 4 3 5</span><br><span class="line">1 2 4 5 3</span><br><span class="line">1 2 5 3 4</span><br><span class="line">1 2 5 4 3</span><br></pre></td></tr></table></figure>

<p>以<code>1 2 3 5 4</code>为例，要找的高位是3、低位是4，交换后得到<code>1 2 4 5 3</code>，但不是下一个排列，下一个排列是是<code>1 2 4 3 5</code>。<br>两者区别在于，交换后低位的<code>5 3</code>变成了<code>3 5</code>才算是更小的排列。</p>
<h3 id="交换后怎么得到下一个排列？"><a href="#交换后怎么得到下一个排列？" class="headerlink" title="交换后怎么得到下一个排列？"></a>交换后怎么得到下一个排列？</h3><p>把末尾递减序列变成递增序列，就是更大的排列中最小的那个排列，也就是下一个排列。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>四步走：</p>
<ul>
<li>从右到左寻找第一个递增序列，确定高位<code>x</code>。</li>
<li>从右到左寻找第一个大于<code>x</code>的低位<code>y</code>。</li>
<li>交换<code>x</code>和<code>y</code>。</li>
<li>把高位右边的递减序列从小到大排序。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>如果序列完全递减，找不到递增序列，要做边界判断。</p>
<h3 id="如何高效的排序递减序列？"><a href="#如何高效的排序递减序列？" class="headerlink" title="如何高效的排序递减序列？"></a>如何高效的排序递减序列？</h3><p>这里可以不需要排序算法，递减序列变递增序列只需要用双指针不停的首尾交换就行了，这样只需要O(n)时间，避免了排序的O(n * log n)。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度O(n)：n为序列长度，寻找递增序列、寻找低位、递增变递减最多遍历完整个序列，都是O(n)时间，线性叠加还是O(n)。</li>
<li>空间复杂度O(1)。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextPermutation</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找要变大的位</span></span><br><span class="line">        <span class="keyword">var</span> i = n - <span class="number">2</span></span><br><span class="line">        <span class="comment">// 末尾是递减序列（或相等）就跳过，直到发现递增序列</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时若i == -1，说明序列全部递减</span></span><br><span class="line">        <span class="comment">// 若i &gt;= 1，说明发现了递增序列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过交换把数字序列变大，且增幅最小</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从末尾递减序列中从右向左找到第一个大于nums[i]的数</span></span><br><span class="line">            <span class="keyword">var</span> k = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= nums[k]) k--</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换后，变成更大的数，增幅最小</span></span><br><span class="line">            nums.swap(i, k)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 末尾递减序列变成递增序列，使得整体序列最小</span></span><br><span class="line">        <span class="keyword">var</span> start = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> end = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            nums.swap(start, end)</span><br><span class="line">            start++</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> nums = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> tmp = nums[i]</span><br><span class="line">        nums[i] = nums[j]</span><br><span class="line">        nums[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.32.最长有效括号（困难）</title>
    <url>/LeetCode/LeetCode.32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode.32.最长有效括号（困难）</a></p>
<p>给你一个只包含  <code>&#39;(&#39;</code> 和  <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h2><p>括号匹配时，左右括号数量相等，子串长度就是左右括号之和。</p>
<p>可以从左到右遍历字符串，记录左右括号的数量，通过数量来判断子串是否是是有效括号。</p>
<ul>
<li>当右括号数量大于左括号时，当前子串肯定不是有效的括号，计数对于累加有效括号子串已经无意义，可以清零，以便后续子串。</li>
<li>当左括号数量大于右括号，有可能还有匹配的右括号在后面，只要右括号数量跟左括号相等，就可以认定当前子串是有效的括记录子串长度，并比较最长的长度。<ul>
<li>这种情况下有可能最终左括号的数量一直大于右括号数量，导致无法触发记录，例如((((((((((())。</li>
<li>此时可以从右向左再遍历一次字符串，就可以触发到左右括号相等的时候，当左括号数量大于右括号，括号数量计数清零。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                left == right -&gt; maxLength = maxOf(maxLength, <span class="number">2</span> * right)</span><br><span class="line">                right &gt; left -&gt; &#123;</span><br><span class="line">                    left = <span class="number">0</span></span><br><span class="line">                    right = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.length - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                left == right -&gt; maxLength = maxOf(maxLength, <span class="number">2</span> * left)</span><br><span class="line">                right &lt; left -&gt; &#123;</span><br><span class="line">                    left = <span class="number">0</span></span><br><span class="line">                    right = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：栈"><a href="#解法2：栈" class="headerlink" title="解法2：栈"></a>解法2：栈</h2><h3 id="怎么计算有效括号长度？"><a href="#怎么计算有效括号长度？" class="headerlink" title="怎么计算有效括号长度？"></a>怎么计算有效括号长度？</h3><p>从左到右遍历字符串时，发现如果有一个子串是有效括号，要计算它的长度，就是用结束索引减去起始索引得到长度。所以的想办法记录左括号的起始索引。</p>
<h3 id="怎么存储索引比较合适？"><a href="#怎么存储索引比较合适？" class="headerlink" title="怎么存储索引比较合适？"></a>怎么存储索引比较合适？</h3><p>从左到右遍历发现右括号后，得知道左边有没有左括号，如果有，计算括号匹配长度是要知道这个左括号前面一个位置的索引。</p>
<p>如果发现了多个右括号，是要从右到左依次访问匹配的左括号前面一个位置的索引，遍历顺序和访问顺序相反，可以用栈来存储左括号索引。</p>
<p>遍历到右括号时，发现栈不为空说明有左括号，匹配到左括号出栈后，栈顶就是匹配的左括号的前一个位置的索引。</p>
<p>如果匹配的左括号出栈后栈为空，就要手动记录一下第一个左括号左边的索引。</p>
<h3 id="何时入栈？"><a href="#何时入栈？" class="headerlink" title="何时入栈？"></a>何时入栈？</h3><p>有效括号子串的第一个字符一定是一个左括号，因为如果开头是右括号则不是有效括号子串。<br>所以遇到左括号就要记录其索引，因为它有可能是一个长的有效括号子串的起始索引。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> left = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="comment">// 记录可能的有效括号子串的前一个位置，可以利用此索引计算子串的长度</span></span><br><span class="line">        <span class="keyword">var</span> prev = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left.push(i)</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到右括号，如果前面有左括号，说明匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (left.isNotEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 匹配的左括号从栈中移出</span></span><br><span class="line">                        left.pop()</span><br><span class="line">                        <span class="comment">// 如果前面还有左括号，这个左括号的索引是刚才有效括号子串的前一个位置</span></span><br><span class="line">                        <span class="comment">// 如果前面没有左括号了，读取遇到左括号前记录的位置，也是刚才有效括号子串的前一个位置</span></span><br><span class="line">                        <span class="keyword">val</span> prevOfStart = <span class="keyword">if</span> (left.isNotEmpty()) left.peek() <span class="keyword">else</span> prev</span><br><span class="line">                        <span class="comment">// 当前位置减去有效括号子串的前一个位置就是有效括号子串的长度</span></span><br><span class="line">                        <span class="keyword">val</span> length = i - prevOfStart</span><br><span class="line">                        <span class="comment">// 记录最大长度</span></span><br><span class="line">                        maxLength = max(maxLength, length)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 遇到右括号，但前面没有左括号，说明当前字符结尾的子串没办法构成有效括号</span></span><br><span class="line">                        <span class="comment">// 但后面的子串还有可能是有效的子串，记录当前位置，如果后面紧接着的子串是有效括号子串，可以利用此索引计算子串的长度</span></span><br><span class="line">                        prev = i</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：动态规划"><a href="#解法3：动态规划" class="headerlink" title="解法3：动态规划"></a>解法3：动态规划</h2><p>最值问题考虑用动态规划。尝试划分为子问题+有限步骤。</p>
<p>如果字符串s是一个有效的括号串，最后一个字符一定是右括号。</p>
<ul>
<li>如果最后一个字符不是右括号，去除最后一个字符查看前面的子串是不是有效括号，前面子串查看方法是一样的。</li>
<li>如果最后一个字符是右括号：<ul>
<li>倒数第二个字符是左括号，发生了一次匹配，有效括号长度可以加2了，再继续看前面的子串的有效括号的长度。</li>
<li>倒数第二个字符是右括号，得看前面的有没有左括号能跟最后一个右括号匹配上才行。</li>
</ul>
</li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; length = <span class="number">2</span> + longest(i - <span class="number">2</span>)</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = longest(i - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="comment">// 看前面有没有跟s[i]这个右括号匹配的左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// 匹配到左括号前面的有效括号子串长度还要加上</span></span><br><span class="line">                            length = <span class="number">2</span> + midLen + longest(left - <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (length &gt; maxLength) maxLength = length</span><br><span class="line">            longest(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        &#125;</span><br><span class="line">        longest(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记忆化递归</strong></p>
<p>暴力递归有很多重叠子问题。</p>
<p>例如两次longest(i - 1)和一次longest(i - 2)计算结果是一样的，但是都重复计算了。</p>
<p>需要记录中间计算状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i]</span><br><span class="line">            <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; length = <span class="number">2</span> + longest(i - <span class="number">2</span>)</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = longest(i - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="comment">// 看前面有没有跟s[i]这个右括号匹配的左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// 匹配到左括号前面的有效括号子串长度还要加上</span></span><br><span class="line">                            length = <span class="number">2</span> + midLen + longest(left - <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = length</span><br><span class="line">            <span class="keyword">if</span> (length &gt; maxLength) maxLength = length</span><br><span class="line">            longest(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        &#125;</span><br><span class="line">        longest(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>设<code>dp[i]</code>表示以字符<code>s[i]</code>结尾的最长有效的括号子串的长度。</p>
<p>状态转移方程按照递归的方式写就行了。</p>
<p>边界条件单独判断一下就OK。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 从第2个字符开始遍历，一个字符无法形成有效括号</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; dp[i] = <span class="number">2</span> + <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="number">0</span> <span class="keyword">else</span> dp[i - <span class="number">2</span>]</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = dp[i - <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            dp[i] = <span class="number">2</span> + midLen + <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> dp[left - <span class="number">1</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.322.零钱兑换（中等）</title>
    <url>/LeetCode/LeetCode.322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">LeetCode.322.零钱兑换（中等）</a></p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一组东西中进行多种选择最终达到一个目标值，联想到背包问题，尝试划分子问题。</p>
<p>得到amount的上一步一定是从coins选择一个硬币得来的，但是不知道哪种选择所需的硬币数最少，那么就每个都试一下，取硬币数最少的。</p>
<p>选取一个硬币coin后，剩下amout - coin的金额是怎么得来的，也是同样的选择过程，并且这个子问题加上新的选择过程得到最优的最终结果，符合最优子结构。</p>
<p>如果一直选择先去有可能发现不能用选择过的硬币累加成amount，那就是无法组合。</p>
<p>如果一直选下去，发现可以凑成amount，记录选择过的硬币数量，同时每次对比最终取一个最少的硬币数量。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重叠子问题</strong><br>画出递归树，会发现会有重叠子问题，有大量的重复计算。<br>例如<code>coins = [1,2,4]</code>。<br>四次<code>select(amount - 1)</code>跟一次<code>select(amount - 4)</code>是重复计算的。<br>两次<code>select(amount - 2)</code>跟一次<code>select(amount - 4)</code>是重复计算的。</p>
<p><strong>记忆化递归</strong><br>消除重叠子问题就是记录中间计算结果。<br>计算的结果是硬币数，中间状态是跟<code>amount</code>有关，但是并不是0到<code>amount</code>都会有计算结果，所以可以用哈希表来存储中间状态，节省一点空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[amount] != <span class="literal">null</span>) memo[amount]!!</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">            memo[amount] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>记忆化递归从大的amount往小的amount去算，也可以从小的amount去递推大的amount。<br>初始值<code>dp[0] = 0</code>要存储一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (a <span class="keyword">in</span> <span class="number">1.</span>.amount) &#123;</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = dp.getOrDefault(a - coin, -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, count + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            dp[a] = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[amount]!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.343.整数拆分（中等）</title>
    <url>/LeetCode/LeetCode.343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/integer-break/">LeetCode.343.整数拆分（中等）</a></p>
<p>给定一个正整数 _n_，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目已经说出了步骤，直接干。</p>
<p>穷举所有n可能被拆解的可能性，看哪种拆分的乘积最大。</p>
<p>n可以被拆解为<code>j</code>和<code>n - j</code>两个正整数，穷举所有的<code>j</code>，看哪个<code>j * (n - j)</code>最大就选哪个<code>j</code>，<code>1 &lt;= j &lt;= n - 1</code>。</p>
<p>题目说至少是拆分两个，还可以继续拆分，所以可以对<code>n - j</code>继续拆分，也可以不继续拆分。<br><code>n - j</code>继续拆解，就划分为子问题了。</p>
<p><strong>暴力递归拆解</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxProduct = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> i = n - j</span><br><span class="line">            maxProduct = maxOf(</span><br><span class="line">                maxProduct,</span><br><span class="line">                j * i,</span><br><span class="line">                j * integerBreak(i)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProduct</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记忆化递归</strong><br>存在很多重叠子问题，计算量过大，时间复杂度指数级别，需要记录中间计算结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            <span class="keyword">var</span> maxProduct = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> i = n - j</span><br><span class="line">                maxProduct = maxOf(</span><br><span class="line">                    maxProduct,</span><br><span class="line">                    j * i,</span><br><span class="line">                    j * integerBreak(i)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            memo[n] = maxProduct</span><br><span class="line">            <span class="keyword">return</span> maxProduct</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>设<code>dp[i]</code>为<code>i</code>拆解为多个正整数后的最大乘积。<br>先求出小的<code>dp[i]</code>再求大的；每个<code>dp[i]</code>穷举所有拆解情况。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until i) &#123;</span><br><span class="line">                dp[i] = maxOf(</span><br><span class="line">                    dp[i],</span><br><span class="line">                    j * (i - j),</span><br><span class="line">                    j * dp[i - j]</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.37.解数独（困难）</title>
    <url>/LeetCode/LeetCode.37.%E8%A7%A3%E6%95%B0%E7%8B%AC%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">LeetCode.37.解数独（困难）</a></p>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ul>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右从上到下遍历所有没有填空的位置，尝试去填数字；填过的位置就跳过。</p>
<p>填过的数字就不能再用了，但是不知道填哪个数字，所以要尝试所有的可能性，采用暴力回溯解法。</p>
<p>填数字时要有三个限制条件，都是保证数字不重复，那么就要存储已访问过的数字，按行、按列、按3x3宫格分开记录和判断，这样最方便快速。</p>
<p>如果能按照限制条件填满一种可能性，就不用再尝试其他可能性了，直接结束程序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solveSudoku</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.isEmpty()) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> n = board.size</span><br><span class="line">        <span class="keyword">val</span> rowUsed = Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> columnUsed = Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> boxUsed = Array(<span class="number">3</span>) &#123; Array(<span class="number">3</span>) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] <span class="keyword">in</span> <span class="string">&#x27;1&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    rowUsed[i][num] = <span class="literal">true</span></span><br><span class="line">                    columnUsed[j][num] = <span class="literal">true</span></span><br><span class="line">                    boxUsed[i / <span class="number">3</span>][j / <span class="number">3</span>][num] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(row: <span class="type">Int</span>, column: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> r = row</span><br><span class="line">            <span class="keyword">var</span> c = column</span><br><span class="line">            <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">                c = <span class="number">0</span></span><br><span class="line">                r++</span><br><span class="line">                <span class="keyword">if</span> (r == n) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rowUsed[r][i] || columnUsed[c][i] || boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i]) <span class="keyword">continue</span></span><br><span class="line">                    board[r][c] = i.toString()[<span class="number">0</span>]</span><br><span class="line">                    rowUsed[r][i] = <span class="literal">true</span></span><br><span class="line">                    columnUsed[c][i] = <span class="literal">true</span></span><br><span class="line">                    boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(r, c + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    board[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    rowUsed[r][i] = <span class="literal">false</span></span><br><span class="line">                    columnUsed[c][i] = <span class="literal">false</span></span><br><span class="line">                    boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(r, c + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.376.摆动序列（中等）</title>
    <url>/LeetCode/LeetCode.376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LeetCode.376.摆动序列（中等）</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最值问题考虑动态规划，先划分子问题。</p>
<p>从某个摆动序列最后一个元素开始倒推，得到这个摆动序列有两个情况：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递增的。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递减的。</li>
</ol>
<p>子摆动序列怎么得来的，也是同样的递归划分。</p>
<p>这里有两个状态变化，一个是元素位置，一个是末尾差值。</p>
<p>设<code>dp[i][k]</code>表示数组中第0个到第<code>i</code>元素之间最长摆动序列长度；<br>k表示<code>nums[i]</code>和前面元素是递增或递减的情况；<br><code>k == 0</code> 时，表示递减；<br><code>k == 1</code> 时，表示递增。</p>
<p>考虑之前相反的情况，如果：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递减的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递增，也就更有可能得到更长的摆动序列。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递增的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递减，也就更有可能得到更长的摆动序列。</li>
</ol>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>nums[i] &lt; nums[i - 1]</code>，递减：<br>  <code>dp[i][0] = maxOf(dp[i][0], dp[i - 1][1] + 1)</code></li>
<li><code>nums[i] &gt; nums[i - 1]</code>，递增：<br>  <code>dp[i][1] = maxOf(dp[i][1], dp[i - 1][0] + 1)</code></li>
<li><code>nums[i] == nums[i - 1]</code>，持平：<br>  <code>dp[i][0] = dp[i - 1][0]</code><br>  <code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p><strong>边界处理</strong><br>最一开始只有一个元素，没有形成递增或递减，所以摆动序列长度为0。<br><code>dp[0][0] = 0</code><br><code>dp[0][1] = 0</code></p>
<p><strong>最后取值</strong><br>取<code>dp[n - 1][0]</code>和<code>dp[n - 1][1]</code>中较大的。<br>最后结果还要加1，因为我们是在发生新的摆动的时候才给序列增加长度的，遍历到最后时没有新的摆动了，但是目前的摆动没有算进长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br><code>dp[i]</code>只与<code>dp[i - 1]</code>有关，可以用变量记录状态，不用数组。</p>
<p>用<code>up</code>记录末尾递增的摆动序列的最长长度。<br>用<code>down</code>记录末尾递减的摆动序列的最长长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> up = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> down = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = maxOf(down, up + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = maxOf(up, down + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(up, down) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.377.组合总和 Ⅳ（中等）</title>
    <url>/LeetCode/LeetCode.377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">LeetCode.377.组合总和 Ⅳ（中等）</a></p>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<span id="more"></span>

<p>示例 1：</p>
<blockquote>
<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>只要看到目标值、数组、选择，这三要素，就直接可以反应想到是背包问题。</p>
<p>这里数组中的元素是可以重复选取的，所以是完全背包问题。</p>
<p>大的target可以拆解为小target加一系列选择求解，所以要遍历所有的target取值可能，还要遍历所有数字取值可能，有两层循环。</p>
<p>这里要注意顺序不同的序列被视作不同的组合，这涉及到双层循环的哪一个循环应该放在外层。<br>由于不锁定数字选择顺序，<code>nums</code>数组遍历应该放在内层，这样target才可以由不同顺序的选择得到。<br>如果<code>nums</code>数组遍历放在外层，会锁定<code>nums</code>数组的选取顺序，一个target只会有一种顺序的选择得到。<br>这与<a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a>情况正好相反。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum4</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(target + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (t <span class="keyword">in</span> <span class="number">0.</span>.target) &#123;</span><br><span class="line">            <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= num) &#123;</span><br><span class="line">                    dp[t] += dp[t - num]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.392.判断子序列（简单）</title>
    <url>/LeetCode/LeetCode.392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/is-subsequence">LeetCode.392.判断子序列（简单）</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：<br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h2><p>可以直接拿s和t做比较，遇到不相同的字符就跳过，只要保证s所有字符在t中，并且顺序没有改变即可。</p>
<p>时间复杂度O(m + n)：m为字符串s长度，n为字符串t长度，最坏情况下两个指针都要移动到字符串末尾。<br>空间复杂度O(1)：没有额外空间占用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：后续挑战-动态规划"><a href="#解法2：后续挑战-动态规划" class="headerlink" title="解法2：后续挑战 - 动态规划"></a>解法2：后续挑战 - 动态规划</h2><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。</p>
<p>双指针的问题在于：<br>S中的一个字符跟T中的字符匹配后，再去匹配下一个字符，需要在T中顺序查找，如果能直接查表得到位置，时间就降下来了。<br>假设S的长度为m，那么复杂度就可以降低为O(m)。</p>
<p>可以对T做预处理，记录位于<code>T</code>中第<code>i</code>个位置时字符<code>j</code>第一次出现的索引位置，用<code>dp[i][j]</code>来表示。<br>字符集是常数个，所以<code>j</code>的取值范围是一个常量。</p>
<p><strong>状态转移方程</strong><br>因为<code>dp[i][j]</code>记录的是<code>j</code>在<code>i</code>或<code>i</code>之后第一次出现的位置；<br>如果<code>T[i] == j</code>，<code>dp[i][j] = i</code>。<br>如果<code>T[i] != j</code>，<code>dp[i][j] = dp[i + 1][j]</code>。<br>如果<code>i</code>之后不存在字符<code>j</code>，令<code>dp[i][j] = -1</code><br>要从后往前递推。</p>
<p><strong>复杂度</strong><br>设m为S长度，n为T长度。<br>预处理时间复杂度O(n)。<br>判断子序列时间复杂度O(m)。</p>
<p>空间复杂度O(n * 字符集个数)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (t.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = t.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">26</span>) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = (<span class="string">&#x27;a&#x27;</span>.toInt() + j).toChar()</span><br><span class="line">                <span class="keyword">if</span> (t[i] == c) dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> indexT = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="comment">// t已经没有后续字符了，s还没匹配完，那肯定不是子序列</span></span><br><span class="line">            <span class="keyword">if</span> (indexT == n) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">val</span> cIndex = c.toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">            <span class="keyword">if</span> (dp[indexT][cIndex] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="comment">// s中的字符c匹配到了T中的字符，从T中下一个字符开始继续匹配</span></span><br><span class="line">            indexT = dp[indexT][cIndex] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.4.寻找两个正序数组的中位数（困难）</title>
    <url>/LeetCode/LeetCode.4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode.4.寻找两个正序数组的中位数（困难）</a></p>
<p>给定两个大小分别为  <code>m</code>  和  <code>n</code>  的正序（从小到大）数组 <code>nums1</code>  和 <code>nums2</code>。请你找出并返回这两个正序数组的  <strong>中位数</strong>  。</p>
<p>进阶：你能设计一个时间复杂度为  <code>O(log (m+n))</code>  的算法解决此问题吗？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1-归并"><a href="#解法1-归并" class="headerlink" title="解法1: 归并"></a>解法1: 归并</h2><h3 id="一个数组怎么找中位数？"><a href="#一个数组怎么找中位数？" class="headerlink" title="一个数组怎么找中位数？"></a>一个数组怎么找中位数？</h3><ul>
<li>数组元素有奇数个，中位数是最中间的一个数。</li>
<li>数组元素有偶数个，中位数是最中间的两个数的平均值。</li>
</ul>
<p>设数组长度为n。</p>
<ul>
<li>n为奇数时，中位数应该是第<code>n / 2 + 1</code>个数，由于数组索引从0开始，所以中位数是<code>nums[n / 2]</code>。</li>
<li>n为偶数时，左中位数是第<code>n / 2</code>个数，右中位数是第<code>n / 2 + 1</code>个数；由于数组索引从0开始，左中位数为<code>nums[n / 2 - 1]</code>，右中位数为<code>nums[n / 2]</code>，实际中位数为<code>(nums[n / 2 - 1] + nums[n / 2]) / 2</code>。</li>
</ul>
<h3 id="两个数组怎么找中位数？"><a href="#两个数组怎么找中位数？" class="headerlink" title="两个数组怎么找中位数？"></a>两个数组怎么找中位数？</h3><p>把两个数组归并为一个有序数组。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(m + n)</code>：需要遍历两个数组所有元素做归并。</li>
<li>空间复杂度<code>O(m + n)</code>：额外需要一个<code>m + n</code>长度的数组存储归并后的元素。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = nums1.size</span><br><span class="line">        <span class="keyword">val</span> n = nums2.size</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二路归并</span></span><br><span class="line">        <span class="keyword">val</span> nums = IntArray(m + n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> i1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> i2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; m &amp;&amp; i2 &lt; n) &#123;</span><br><span class="line">            nums[j++] = <span class="keyword">if</span> (nums1[i1] &lt; nums2[i2]) nums1[i1++] <span class="keyword">else</span> nums2[i2++]            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; m) nums[j++] = nums1[i1++]</span><br><span class="line">        <span class="keyword">while</span> (i2 &lt; n) nums[j++] = nums2[i2++]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取中位数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = (m + n) / <span class="number">2</span></span><br><span class="line">            nums[mid].toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMid = (m + n) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rightMid = leftMid + <span class="number">1</span></span><br><span class="line">            (nums[leftMid] + nums[rightMid]).toDouble() / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：二分"><a href="#解法2：二分" class="headerlink" title="解法2：二分"></a>解法2：二分</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>归并排序产生了新数组，增加了空间复杂度。</p>
<p>既然在一个数组中找中位数不需要额外空间，两个数组应该也能。</p>
<p>我们的思路还是把两个数组往一个数组的情况上考虑，也就是把不熟悉的情况往熟悉的情况上靠拢。</p>
<h3 id="合二为一"><a href="#合二为一" class="headerlink" title="合二为一"></a>合二为一</h3><p>找中位数是跟数组总个数有关的，如果把小的元素和大的元素正好能各分一半，那么看中间的数就行。</p>
<p>可以把两个数组分割为左右两部分，两个数组的左半部分元素个数跟右半部分元素个数相等的时候，直接看中间的元素就行了。</p>
<p>设<code>nums1</code>数组长度为<code>m</code>，<code>nums2</code>数组长度为<code>n</code>。<br>把<code>nums1</code>分为前<code>i</code>个元素和后<code>m - i</code>个元素。<br>把<code>nums2</code>分为前<code>j</code>个元素和后<code>n - j</code>个元素。</p>
<p>如果<code>m + n</code>是偶数，<code>i + j = (m + n) / 2</code>。<br>如果<code>m + n</code>是奇数，<code>i + j = (m + n) / 2 + 1</code>。<br>知道了<code>i</code>就可以确定<code>j</code>。</p>
<h3 id="怎么确定i-？"><a href="#怎么确定i-？" class="headerlink" title="怎么确定i ？"></a>怎么确定<code>i</code> ？</h3><p>左半部分所有元素都小于右半部分的元素。</p>
<p>数组本身是有序的，所以要求两个数组的不同部分也保持顺序，即：<br><code>nums1[i - 1] &lt; nums2[j] &amp;&amp; nums2[j - 1] &lt; nums1[i]</code></p>
<p>这个条件等价于在<code>nums1</code>数组中查找最大的<code>i</code>来满足<code>nums1[i - 1] &lt; nums2[j]</code>，查找过程可以用二分查找。</p>
<h3 id="二分查找的细节"><a href="#二分查找的细节" class="headerlink" title="二分查找的细节"></a>二分查找的细节</h3><p>当发现<code>nums[i - 1] &gt; nums2[j]</code>，说明左半部分的元素多了，要减少，应当继续寻找更小的<code>i</code>。<br>当发现<code>nums[i - 1] &lt;= nums2[j]</code>，说明左半部分可能正好，也可能少了，可以尝试寻找更大的<code>i</code>。</p>
<h3 id="查找完毕后怎么确定中位数？"><a href="#查找完毕后怎么确定中位数？" class="headerlink" title="查找完毕后怎么确定中位数？"></a>查找完毕后怎么确定中位数？</h3><p>查找到最大的<code>i</code>过后，就可以选取中位数了。</p>
<ul>
<li>如果<code>m + n</code>是奇数，分割数组的时候可以让左半部分多一个元素，两数组左半部分最大值即为中位数。</li>
<li>如果<code>m + n</code>是偶数，两数组左半部分最大值和右半部分最小值的平均数即为中位数。</li>
</ul>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(log(min(m, n)))</code>，在短的数组里做了二分查找。</li>
<li>空间复杂度<code>O(1)</code>，只使用了常数个的辅助变量。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = nums1.size</span><br><span class="line">        <span class="keyword">val</span> n = nums2.size</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> leftCount = <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">0</span>) (m + n) / <span class="number">2</span> <span class="keyword">else</span> (m + n) / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = m</span><br><span class="line">        <span class="comment">// 循环结束时left == right，不用思考选取left还是right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算mid向上取整，否则最后只剩两个元素的时候，下面一直走到else，左边界不会更新</span></span><br><span class="line">            <span class="keyword">val</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> j = leftCount - i</span><br><span class="line">            <span class="comment">// i不满足条件，要找更小的</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) right = i - <span class="number">1</span></span><br><span class="line">            <span class="comment">// i满足条件，i可能是要求解的结果，不要跳过i</span></span><br><span class="line">            <span class="keyword">else</span> left = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> i = left</span><br><span class="line">        <span class="keyword">val</span> j = leftCount - left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> nums1LeftMax = <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> nums2LeftMax = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> nums1RightMin = <span class="keyword">if</span> (i == m) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[i]</span><br><span class="line">        <span class="keyword">val</span> nums2RightMin = <span class="keyword">if</span> (j == n) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMax = maxOf(nums1LeftMax, nums2LeftMax)</span><br><span class="line">            <span class="keyword">val</span> rightMin = minOf(nums1RightMin, nums2RightMin)</span><br><span class="line">            (leftMax + rightMin).toDouble() / <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMax = maxOf(nums1LeftMax, nums2LeftMax).toDouble()</span><br><span class="line">            leftMax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：分治"><a href="#解法3：分治" class="headerlink" title="解法3：分治"></a>解法3：分治</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们可以从简单理想的情况开始着手，逐步改变条件，看需要考虑的因素会发生什么变化。</p>
<h3 id="理想情况"><a href="#理想情况" class="headerlink" title="理想情况"></a>理想情况</h3><p>假设m + n是奇数，中位数是第(m + n) / 2个数，令k = (m + n) / 2。</p>
<p>如果两数组长度相同，那么直接比较nums1[k / 2]和nums2[k / 2]的大小，就知道应该取哪个数是中位数了，这是很自然推导。</p>
<h3 id="如果m-n，再比较nums1-k-2-和nums2-k-2-的大小，还能直接得出中位数是哪个吗？"><a href="#如果m-n，再比较nums1-k-2-和nums2-k-2-的大小，还能直接得出中位数是哪个吗？" class="headerlink" title="如果m != n，再比较nums1[k / 2]和nums2[k / 2]的大小，还能直接得出中位数是哪个吗？"></a>如果m != n，再比较nums1[k / 2]和nums2[k / 2]的大小，还能直接得出中位数是哪个吗？</h3><p>不能，但是可以排除掉k / 2个元素不用再参与比较，这样其实就优化了时间复杂度。</p>
<p>比如nums1[k / 2] &lt; nums2[k / 2]时，可得：</p>
<ul>
<li>nums2[k / 2]有可能是第k大的数字，也有可能不是。</li>
<li>但是nums1[k / 2]绝对不是第k大的数。</li>
<li>nums1数组的前k / 2个元素也都不可能是第k大的数，因为nums1是从小到大排序的。</li>
</ul>
<p>第k大的数是有可能出现在nums2的0到k / 2之中的，考虑极端情况：</p>
<ul>
<li>如果nums1[k / 2]后续如果正好有个k / 2 - 1个元素比nums2[0]小，那么nums2[0]就是第k大的数。</li>
<li>如果nums1[k / 2]之后没有元素了，只能在在nums2[k / 2]后面再继续找第k大的数。</li>
</ul>
<h3 id="接下来怎么找第k大的数？"><a href="#接下来怎么找第k大的数？" class="headerlink" title="接下来怎么找第k大的数？"></a>接下来怎么找第k大的数？</h3><p>已经排除了k / 2个元素不用比较后，接着其实是要寻找第 k - k / 2 个数，寻找过程是一样的，这里就划分出了子问题，可以递归进行。<br>并且每次折半查找，时间复杂度是对数级别的。</p>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul>
<li>k一直缩减到1，就是最终想要得到的中位数。</li>
<li>如果数组没有第k / 2个数可选择，就取数组末尾的数比较。</li>
</ul>
<h3 id="m-n是偶数怎么办？"><a href="#m-n是偶数怎么办？" class="headerlink" title="m + n是偶数怎么办？"></a>m + n是偶数怎么办？</h3><p>可以分别查找到左中位数和右中位数，再求平均值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = nums1.size</span><br><span class="line">        <span class="keyword">val</span> len2 = nums2.size</span><br><span class="line">        <span class="keyword">val</span> len = len1 + len2</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> left = len / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> (getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, left) + getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, right)) / <span class="number">2.</span>toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = len / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, mid).toDouble()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getKth</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>, i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = nums1.size - i1</span><br><span class="line">        <span class="keyword">val</span> len2 = nums2.size - i2</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, nums1, i2, i1, k)</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[i2 + k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> minOf(nums1[i1], nums2[i2])</span><br><span class="line">        <span class="keyword">val</span> j1 = i1 + minOf(k / <span class="number">2</span>, len1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> j2 = i2 + minOf(k / <span class="number">2</span>, len2) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (nums1[j1] &lt; nums2[j2]) &#123;</span><br><span class="line">            getKth(nums1, nums2, j1 + <span class="number">1</span>, i2, k - (j1 - i1 + <span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getKth(nums1, nums2, i1, j2 + <span class="number">1</span>, k - (j2 - i2 + <span class="number">1</span>))</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.41.缺失的第一个正数（困难）</title>
    <url>/LeetCode/LeetCode.41.%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">LeetCode.41.缺失的第一个正数（困难）</a></p>
<p>给你一个未排序的整数数组  <code>nums</code>  ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><ul>
<li>如果用哈希表记录，空间复杂度超过<code>O(1)</code>。</li>
<li>如果用排序，时间复杂度超过<code>O(n)</code> 。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>虽然不能用排序，但是可以先看正常判断过程是怎样的，看能不能换一种方式达到同样的目的。</li>
<li>如果排序完了，从左到右遍历数组，如果发现<code>nums[i] != i + 1</code>，<code>i + 1</code>就是没有出现的最小正整数。</li>
<li>换句话说有没有办法不用排序也能把数组中<code>i + 1</code>这个数放到第<code>i</code>个位置存储，这样就能判断了。</li>
<li>可以在遍历的时候直接把数字放到对应位置上，只耗费常数级别时间复杂度。</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>设<code>nums</code>数组长度为<code>n</code>，如果<code>nums[i]</code>是<code>1</code>到<code>n</code>之间的数，就把<code>nums[i]</code>放到<code>nums[i] - 1</code>的索引位置上。</p>
<p>这样从左到右遍历数组就可以知道没有出现的最小正整数是哪个了。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><ul>
<li><code>1</code>到<code>n</code>之间的数交换到数组对应索引上只需要一次交换。</li>
<li>需要遍历整个数组检查每个元素是否在对应索引位置上。</li>
</ul>
<h4 id="空间复杂度O-1"><a href="#空间复杂度O-1" class="headerlink" title="空间复杂度O(1)"></a>空间复杂度O(1)</h4><p>没有额外的空间开辟，只用了常数个变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">firstMissingPositive</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把1放到索引0</span></span><br><span class="line"><span class="comment">        把2放到索引1</span></span><br><span class="line"><span class="comment">        把3放到索引2</span></span><br><span class="line"><span class="comment">        把4放到索引3</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        如[3,4,-1,1]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] <span class="keyword">in</span> <span class="number">1.</span>.nums.size &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums.swap(i, nums[i] - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所求一定是在[1,n+1]之间</span></span><br><span class="line">        <span class="comment">// 如果是[1,2,3,4]，最小的就是n+1</span></span><br><span class="line">        <span class="comment">// 如果是[7,8,9,10]，最小的是1</span></span><br><span class="line">        <span class="keyword">return</span> nums.size + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.413.等差数列划分（中等）</title>
    <url>/LeetCode/LeetCode.413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">LeetCode.413.等差数列划分（中等）</a></p>
<p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<blockquote>
<p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。</p>
</blockquote>
<p>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。<br>子数组 是数组中的一个连续序列。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>子数组起始索引和结束索引各不相同，可以先按结束索引给子数组分类，分析统计相同结束索引下的等差数列子数组个数，最后累加所有不同结束索引的等差数列子数组个数。</p>
<p>先看以<code>nums[i]</code>结尾的数组中等差子数组个数，可以设其值为<code>a[i]</code>。</p>
<h2 id="等差数列如何判断？"><a href="#等差数列如何判断？" class="headerlink" title="等差数列如何判断？"></a>等差数列如何判断？</h2><p><code>nums[i] - nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]</code></p>
<h2 id="如果已知a-i-1-，如何得到a-i-？即如何递推？"><a href="#如果已知a-i-1-，如何得到a-i-？即如何递推？" class="headerlink" title="如果已知a[i - 1]，如何得到a[i]？即如何递推？"></a>如果已知a[i - 1]，如何得到a[i]？即如何递推？</h2><p>分两种情况：</p>
<ol>
<li><code>nums[i]</code>不能跟前面的元素形成等差数列，那么<code>a[i] = 0</code></li>
<li><code>nums[i]</code>能跟前面的元素形成等差数列，这时候会新增几个等差数列子数组？<ol>
<li>新增长度最短的等差数列：<code>nums[i - 2]、nums[i - 1]、nums[i]</code></li>
<li>所有以<code>nums[i - 1]</code>结尾的子数组，末尾加上<code>nums[i]</code>，所形成的新数组。所有以<code>nums[i - 1]</code>结尾的子数组的个数为<code>a[i - 1]</code>。</li>
</ol>
 即<code>a[i] = a[i - 1] + 1</code></li>
</ol>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>a[i]</code>只跟上一个状态有关，所以可以不用数组记录每一个状态，用一个变量记录上一个状态即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> isCommonDiff = nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">val</span> cur = <span class="keyword">if</span> (isCommonDiff) pre + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum += cur</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.42.接雨水（困难）</title>
    <url>/LeetCode/LeetCode.42.%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode.42.接雨水（困难）</a></p>
<p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度数组height，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：动态规划，O-n-空间复杂度"><a href="#解法1：动态规划，O-n-空间复杂度" class="headerlink" title="解法1：动态规划，O(n)空间复杂度"></a>解法1：动态规划，O(n)空间复杂度</h2><h3 id="拆分问题"><a href="#拆分问题" class="headerlink" title="拆分问题"></a>拆分问题</h3><p>所有的积水由每一列的积水量累加得来。</p>
<h3 id="某一列的积水量由什么决定？"><a href="#某一列的积水量由什么决定？" class="headerlink" title="某一列的积水量由什么决定？"></a>某一列的积水量由什么决定？</h3><ol>
<li>先要看左右两边最高的柱子有多高，这决定了当前列能积多高的水，并且最多只能积到较矮的那个柱子的高度，否则水会溢出。</li>
<li>这个高度减去当前柱子高度，就是当前列可以积的水量。</li>
</ol>
<h3 id="第i列的积水量求解公式"><a href="#第i列的积水量求解公式" class="headerlink" title="第i列的积水量求解公式"></a>第i列的积水量求解公式</h3><p><code>第i列的积水量 = min(0到i - 1列中最高的柱子的高度, i + 1列到n - 1列中最高柱子的高度) - 当前列柱子高度</code></p>
<p>所以要把每一列左边和右边最高的柱子先求出来。</p>
<h3 id="第i列左边的最高的柱子怎么找？"><a href="#第i列左边的最高的柱子怎么找？" class="headerlink" title="第i列左边的最高的柱子怎么找？"></a>第i列左边的最高的柱子怎么找？</h3><p>从0到i - 1遍历一遍height数组，找最大的。<br>实际可以从左到右遍历一遍height数组，把前面记录的最大的柱子高度跟第i - 1个柱子高度比较，取较大值就行了。</p>
<h3 id="第i列右边的最高的柱子的高度怎么找？"><a href="#第i列右边的最高的柱子的高度怎么找？" class="headerlink" title="第i列右边的最高的柱子的高度怎么找？"></a>第i列右边的最高的柱子的高度怎么找？</h3><p>从右向左遍历一遍height数组，把前面记录的最大的柱子高度跟第i + 1个柱子高度做对比，取较大的。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p>第1个柱子左边没有柱子，其左边最高柱子高度是0，也无法积水。<br>最后1个柱子右边没有柱子，其右边最高柱子高度是0，也无法积水。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">val</span> maxLeft = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> maxRight = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxLeft[i] = maxOf(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> (n - <span class="number">2</span>) downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxRight[i] = maxOf(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">val</span> h = maxOf(maxLeft[i], maxRight[i])</span><br><span class="line">            <span class="keyword">if</span> (h &gt; height[i]) &#123;</span><br><span class="line">                water += h - height[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：  O(n)<br>空间复杂度：  O(n)</p>
</blockquote>
<h2 id="解法2：动态规划，O-1-空间复杂度"><a href="#解法2：动态规划，O-1-空间复杂度" class="headerlink" title="解法2：动态规划，O(1)空间复杂度"></a>解法2：动态规划，O(1)空间复杂度</h2><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>求每一列的积水的时候，<code>maxLeft[i]</code>和<code>maxRight[i]</code>只用到了一次，后续不会再查询之前的值，所以可以用两个变量<code>leftMax</code>、<code>rightMax</code>代替数组。</p>
<h3 id="怎么用leftMax代替maxLeft数组？"><a href="#怎么用leftMax代替maxLeft数组？" class="headerlink" title="怎么用leftMax代替maxLeft数组？"></a>怎么用leftMax代替maxLeft数组？</h3><p><code>maxLeft</code>数组是从左到右遍历数组height求得的，在从左到右遍历height数组求第i列积水量的时候，就可以顺便计算出第i个柱子左边最高的柱子的高度，即<code>leftMax</code>。</p>
<h3 id="怎么用rightMax代替maxRight数组？"><a href="#怎么用rightMax代替maxRight数组？" class="headerlink" title="怎么用rightMax代替maxRight数组？"></a>怎么用rightMax代替maxRight数组？</h3><p><code>maxRight</code>数组是从右到左遍历数组height求得的，想办法能想办法能从右到左遍历数组就行了。</p>
<h3 id="什么时候应该从右到左遍历？什么时候从左到右？"><a href="#什么时候应该从右到左遍历？什么时候从左到右？" class="headerlink" title="什么时候应该从右到左遍历？什么时候从左到右？"></a>什么时候应该从右到左遍历？什么时候从左到右？</h3><p>当左侧的柱子高度比右侧柱子高，需要看较矮的右侧的柱子高度，才能决定某一列能积多少水，左边不管多高都不会决定能积多少水，此时应该从右到左遍历。<br>直到右侧柱子比左侧柱子高，才需要从左边到右边检查。</p>
<h3 id="初始情况是怎样的？怎么开始？"><a href="#初始情况是怎样的？怎么开始？" class="headerlink" title="初始情况是怎样的？怎么开始？"></a>初始情况是怎样的？怎么开始？</h3><p>第一列左边没有柱子，无法积水。<br>最后一列右边没有柱子，无法积水。<br>计算积水只考虑区间<code>[1, n - 2]</code>。<br>可以直接令：<br><code>leftMax = height[0]</code><br><code>rightMax = height[n - 1]</code></p>
<h3 id="具体怎么判断决定height数组的遍历方向？"><a href="#具体怎么判断决定height数组的遍历方向？" class="headerlink" title="具体怎么判断决定height数组的遍历方向？"></a>具体怎么判断决定height数组的遍历方向？</h3><ol>
<li>如果发现左边柱子比右边矮，即<code>leftMax &lt; rightMax</code>，可以先计算左边的积水，随后如果发现当前柱子高度比leftMax高，再更新leftMax。</li>
<li>如果发现右边柱子比左边矮，即<code>leftMax &gt; rightMax</code>，先计算右边的积水，随后如果发现当前柱子高度比rightMax高，再更新rightMax。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> leftMax = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> rightMax = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> right = n - <span class="number">2</span></span><br><span class="line">        <span class="comment">// 要计算区间[1, n - 2]中所有列的积水情况，所以边界条件要包含left == right的情况，才能包含所有的情况</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftMax &gt; height[left]) &#123;</span><br><span class="line">                    water += leftMax - height[left]</span><br><span class="line">                &#125;</span><br><span class="line">                leftMax = maxOf(leftMax, height[left])</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightMax &gt; height[right]) &#123;</span><br><span class="line">                    water += rightMax - height[right]</span><br><span class="line">                &#125;</span><br><span class="line">                rightMax = maxOf(rightMax, height[right])</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度： O(n)<br>空间复杂度： O(1)</p>
</blockquote>
<h2 id="解法3：直观模拟-gt-单调栈"><a href="#解法3：直观模拟-gt-单调栈" class="headerlink" title="解法3：直观模拟 -&gt; 单调栈"></a>解法3：直观模拟 -&gt; 单调栈</h2><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><p>要能积水，需要多根柱子形成凹槽。</p>
<h3 id="如何判断形成了凹槽？"><a href="#如何判断形成了凹槽？" class="headerlink" title="如何判断形成了凹槽？"></a>如何判断形成了凹槽？</h3><p>朝一个方向依次看柱子高低，是否能形成高、低、高的排列。<br>在已经形成下坡的情况下，一旦发现出现了上坡，就形成了凹槽，就可以计算积水量了。<br>如果发现上坡，但是前面没有下坡，无法积水。</p>
<h3 id="如何计算凹槽的积水量"><a href="#如何计算凹槽的积水量" class="headerlink" title="如何计算凹槽的积水量"></a>如何计算凹槽的积水量</h3><p>穷举出凹槽的所有可能情况，逐个分析，再归纳。<br>从最基本的情况看起，再添加有限的步骤，推导出更复杂的情况。</p>
<h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>一个凹槽最少也要3个柱子，假设3个柱子从左到右依次叫L、M、R，高度排列依次是高、低、高。<br><code>凹槽积水量 = minOf(L高度, R高度) - M高度</code></p>
<h3 id="如果有多个相同高度的M，计算方式会怎么变化？"><a href="#如果有多个相同高度的M，计算方式会怎么变化？" class="headerlink" title="如果有多个相同高度的M，计算方式会怎么变化？"></a>如果有多个相同高度的M，计算方式会怎么变化？</h3><p>就变成求矩形面积了：<br><code>凹槽积水量 = (minOf(L高度, R高度) - M高度) * L到R的距离</code><br><code>L到R的距离 = R索引 - L索引 - 1</code></p>
<h3 id="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"><a href="#如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？" class="headerlink" title="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"></a>如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？</h3><p>因为是从左到右看柱子高度的，一旦发现上坡就触发计算，所以可以先看下坡中柱子多的情况，比如：[3,2,1,4]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             #   </span><br><span class="line">       # a b #</span><br><span class="line">       # # c #</span><br><span class="line">       # # # #</span><br><span class="line">index: 0 1 2 3</span><br><span class="line"></span><br><span class="line">#表示柱子，小写字母表示积水区域</span><br></pre></td></tr></table></figure>
<p>此时积水面积不是矩形，左下方是一个阶梯型。<br>如果按之前的办法求解，从3依次回看2、1，会检测到凹槽形成，可以求得c的面积。<br>积水面积剩下a、b，可以发现刚好是一个矩形，面积为<code>(minOf(3高度, 2高度) - 1高度) * 1到3的距离</code>。<br>如果左边还有更高的柱子，会形成新的矩形，还是一样的计算过程。</p>
<h3 id="计算规律"><a href="#计算规律" class="headerlink" title="计算规律"></a>计算规律</h3><p>这种阶梯形状的积水面积，可以按行拆分为不同的矩形，先求下面的矩形面积，再求上面的矩形面积，最后累加。</p>
<p>然后再看右边柱子多的情况，得看右边形成新的凹槽才有讨论意义，那就是看一下有两个凹槽的情况会怎样。</p>
<h4 id="有两个凹槽时，计算方式会怎样变化？"><a href="#有两个凹槽时，计算方式会怎样变化？" class="headerlink" title="有两个凹槽时，计算方式会怎样变化？"></a>有两个凹槽时，计算方式会怎样变化？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   #</span><br><span class="line">       # b b b b b #</span><br><span class="line">       # a a # b b #</span><br><span class="line">       # # a # b b #</span><br><span class="line">       # # # # # # #</span><br><span class="line">index: 0 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>可以发现0到3的第一个凹槽中第0个最高的柱子会影响到4到6的第二个凹槽的积水面积的计算。<br>第一个凹槽积水量计算过后，1和2两个柱子对于第二个凹槽积水面积计算没有影响了。<br>在计算新凹槽积水量的时候，需要读取以前比较高的柱子高度，太低的柱子就可以忽略了。</p>
<h3 id="怎么获取和存储计算积水量需要的信息？"><a href="#怎么获取和存储计算积水量需要的信息？" class="headerlink" title="怎么获取和存储计算积水量需要的信息？"></a>怎么获取和存储计算积水量需要的信息？</h3><p>每个矩形面积的计算，是在发现有上坡后开始的，检测上坡就是需要知道当前柱子高度和前一个柱子高度，这个在遍历height数组时可以直接获取。</p>
<p>发现上坡后，需要知道：</p>
<ol>
<li>前面有没有形成下坡的柱子</li>
<li>柱子之间的距离</li>
<li>柱子的高度</li>
</ol>
<p>柱子距离必须要记录柱子索引位置；<br>形成下坡意思就是柱子高度要单调递减；<br>柱子高度可以根据柱子索引查询height数组；<br>访问下坡中柱子还要从右到左依次访问。</p>
<p>我们遍历检查的顺序是从左到右，访问顺序反过来，符合这个特点的数据结构就是栈。<br>入栈时保存的是柱子索引。<br>栈内柱子保持高度单调递减，不存储递增的柱子，因为对于后续计算积水没有意义。<br>当前柱子前面一个柱子也算下坡中，也存储在栈中，方便统一处理。<br>判断前面有没有形成下坡，就判断栈是否不为空。</p>
<h3 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 栈存储形成下坡的柱子</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> height.indices) &#123;</span><br><span class="line">            <span class="comment">// 之前有下坡，现在发现上坡，形成凹槽了，可以计算积水面积了</span></span><br><span class="line">            <span class="comment">// 凹槽积水面积可能是阶梯形，所以要不停的读取前面下坡中的柱子计算矩形积水面积，这里需要一个循环</span></span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;</span><br><span class="line">                <span class="comment">// 前面凹槽中高度低的柱子要出栈，因为其对于后面凹槽的计算没有意义</span></span><br><span class="line">                <span class="keyword">val</span> cur = stack.pop()</span><br><span class="line">                <span class="comment">// 相同高度的柱子会形成矩形面积的积水，一起计算积水量</span></span><br><span class="line">                <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] == height[cur]) &#123;</span><br><span class="line">                    stack.pop()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前面有下坡，才能形成凹槽，计算积水才有意义，所以要对栈判空，有可能之前栈里只存储了一个柱子</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 现在栈顶的柱子高度是大于curHeight的，形成凹槽了</span></span><br><span class="line">                    <span class="keyword">val</span> h = minOf(height[stack.peek()], height[i]) - height[cur]</span><br><span class="line">                    <span class="keyword">val</span> w = i - stack.peek() - <span class="number">1</span></span><br><span class="line">                    water += w * h</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法4：数学拆解-gt-O-1-空间复杂度"><a href="#解法4：数学拆解-gt-O-1-空间复杂度" class="headerlink" title="解法4：数学拆解 -&gt; O(1)空间复杂度"></a>解法4：数学拆解 -&gt; O(1)空间复杂度</h2><p>从图形上看积水区域特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        b  b  b  b  b  #  a  a  #  c  c  c  c  c</span><br><span class="line">        b  b  #  a  a  #  a  a  #  a  #  c  c  c</span><br><span class="line">        #  a  #  a  a  #  a  a  #  a  #  a  #  c</span><br><span class="line">index:  0  1  2  3  4  5  6  7  8  9 10 11 12 13</span><br></pre></td></tr></table></figure>
<p>观察得知：<br><code>区间矩形面积 = a的面积 + #的面积 + b的面积 + c的面积</code></p>
<p>区间矩形面积已知。<br><code>区间矩形面积 = 区间宽度 * 最高柱子高度</code></p>
<p>#的面积已知。<br><code>#的面积 = 所有柱子高度的和</code></p>
<p><strong>有没有办法知道b和c的面积？</strong><br>b和c是阶梯状的，不好单独计算。<br>可以看其处于哪个好计算的部分，再看能不能把b和c的面积拆解出来。</p>
<ol>
<li>如果从左到右遍历height数组，是可以知道 <code>#的面积 + a的面积 + c的面积</code>，遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为left。</li>
<li>如果从右到左遍历height数组，是可以知道 <code>#的面积 + a的面积 + b的面积</code>，也是遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为right。</li>
</ol>
<p><code>left + right = #的面积 + a的面积 + (#的面积 + a的面积 + b的面积 + c的面积)</code><br>化简得：<br><code>left + right = #的面积 + a的面积 + 区间矩形面积</code><br>可得：<br><code>a的面积 = left + right - #的面积 - 区间矩形面积</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            left += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            right += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rectArea = n * maxHeight</span><br><span class="line">        <span class="keyword">val</span> pillarArea = height.sum()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left + right - rectArea - pillarArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.44.通配符匹配（困难）</title>
    <url>/LeetCode/LeetCode.44.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/wildcard-matching/">LeetCode.44.通配符匹配（困难）</a></p>
<p>给定一个字符串 s 和一个字符模式 p，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<blockquote>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。</p>
</blockquote>
<p>两个字符串完全匹配才算匹配成功。</p>
<span id="more"></span>

<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右遍历<code>s</code>和<code>p</code>做匹配，用双指针<code>i</code>、<code>j</code>分别做匹配。</p>
<p><code>p[j] == ?</code>时，当作普通字符跟<code>s[i]</code>匹配就好了。</p>
<p><code>p[j] == *</code>时：</p>
<ul>
<li>匹配0个字符时，让<code>s[i]</code>跟<code>p[j + 1]</code>继续匹配。</li>
<li>匹配1个或多个字符时，让<code>s[i + 1]</code>跟<code>p[j]</code>继续匹配，因为<code>*</code>可以匹配多个字符。</li>
</ul>
<p><strong>边界处理</strong></p>
<p>由于<code>*</code>是会匹配多个字符或0个字符的，如果<code>p</code>后面有很多个<code>*</code>，在<code>i</code>走到头后，<code>j</code>还没走到头的时候，对<code>p</code>尾部的<code>*</code>要做处理。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                <span class="keyword">var</span> k = j</span><br><span class="line">                <span class="keyword">while</span> (k &lt; n &amp;&amp; p[k] == <span class="string">&#x27;*&#x27;</span>) k++</span><br><span class="line">                <span class="keyword">return</span> k == n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (isCharMatch) match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) match(i, j + <span class="number">1</span>) || match(i + <span class="number">1</span>, j) <span class="comment">// 匹配s中的0个或1个字符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>自底向上动态规划</strong></p>
<p>递归已经给出了状态转移方程。</p>
<p>设<code>dp[i][j]</code>  表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前 <code>j</code> 个字符是否匹配。</p>
<ul>
<li><code>s[i - 1] == p[j - 1] || p[j - 1] == &#39;?&#39;</code>时，直接匹配上了，<code>dp[i][j] = dp[i - 1][j - 1]</code>。</li>
<li><code>p[j - 1] == &#39;*&#39;</code>时，匹配0个或1个字符，<code>dp[i][j] = dp[i - 1][j] || dp[i][j - 1]</code>。</li>
</ul>
<p>边界处理：</p>
<p>p开头都是<code>*</code>时可以匹配空字符串，要单独处理一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m + <span class="number">1</span>) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="comment">// 空字符串跟空字符串可以匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// *可以匹配空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 匹配1个字符</span></span><br><span class="line">                    s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> -&gt; dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment">// *匹配0个字符或1个字符</span></span><br><span class="line">                    p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> -&gt; dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.45.跳跃游戏 II（中等）</title>
    <url>/LeetCode/LeetCode.45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> <a href="https://leetcode-cn.com/problems/jump-game-ii/">LeetCode.45.跳跃游戏 II（中等）</a></p>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>不知道怎么办，先模拟一遍跳跃过程。<br>假设<code>nums[0]</code>是3，那么可以选择跳到1、2、3的位置。<br>假设<code>nums[1]</code>是1、<code>nums[2]</code>是10、<code>nums[3]</code>是3，那么肯定选择先跳到2的位置，再跳10个长度，这样跳跃次数最少。<br>后面再跳跃还是重复这个同样的选择过程。</p>
<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p>可以得知下一步的跳跃选择，应该在当前可以跳跃到的范围内找一个最远的长度来跳。就是贪心选择，从局部最优得出全局最优。</p>
<h2 id="怎么找最远可以跳跃的长度？"><a href="#怎么找最远可以跳跃的长度？" class="headerlink" title="怎么找最远可以跳跃的长度？"></a>怎么找最远可以跳跃的长度？</h2><p>只有一个个遍历数组，漏一个都不行</p>
<h2 id="什么时候计数跳跃次数？"><a href="#什么时候计数跳跃次数？" class="headerlink" title="什么时候计数跳跃次数？"></a>什么时候计数跳跃次数？</h2><p>因为会在可以跳跃到的范围内找到一个最远的长度来跳，也就是说这个范围内只会跳一次。那就顺便在遍历数组的时候等到达了跳跃范围的边界就可以计数跳跃次数了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxNext = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            maxNext = maxOf(maxNext, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxNext</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode中等</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.5.最长回文子串（中等）</title>
    <url>/LeetCode/LeetCode.5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode.5.最长回文子串（中等）</a></p>
<p>给你一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h2><p>最值问题考虑动态规划，先拆分大问题为子问题+有限步骤。</p>
<p>判断一个字符串是不是回文串，先看字符串两端字符是否相同，然后去除首尾两端字符后的剩余字符串如果是回文串，整个字符串就是回文串。<br>剩余字符串是不是回文串判断方法是一样的。<br>整个判断可以递归进行，符合最优子结构，无后效性。<br>重叠子问题也有，长度大的回文串是由长度小的回文串推导而来，而长度相同的字符串有很多，会有重复判断。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文串。<br><code>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>
<p><strong>边界处理</strong><br>字符串<code>s</code>长度只有1时，是对称的，是回文串，<code>dp[i][j] = 1</code>。<br>字符串<code>s</code>为2时，去除首尾字符后没有子串了，只需要判断首尾字符是否相同即可，<code>dp[i][j] = s[i] == s[j]</code>。</p>
<p><strong>结果如何求解</strong><br>要遍历所有长度的子字符串，寻找有没有回文串，并记录最大长度的回文串。<br>长度相同的子字符串有很多，都要列举出来。</p>
<p><strong>复杂度</strong><br>设字符串长度为n。<br>穷举所有长度子串需要O(n)时间。<br>穷举每个长度的可能的子串也需要O(n)时间。<br>总的时间复杂度$O(n^2)$。</p>
<p>用二维数组记录了所有子串的是否是回文串状态，空间复杂度$O(n^2)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; BooleanArray(n) &#123; j -&gt; i == j &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 穷举子串左端起点</span></span><br><span class="line">            <span class="keyword">for</span> (l <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="comment">// 子串右端终点</span></span><br><span class="line">                <span class="keyword">val</span> r = l + len - <span class="number">1</span></span><br><span class="line">                dp[l][r] = <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">else</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> (dp[l][r] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len</span><br><span class="line">                    maxLeft = l</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLeft, maxLeft + maxLen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：中心扩散"><a href="#解法2：中心扩散" class="headerlink" title="解法2：中心扩散"></a>解法2：中心扩散</h2><p>解法1动态规划是从外向里判断的，也可以从里向外扩散判断。</p>
<p>穷举所有所有可能的中心点，向左右两端扩散，如果左右两端字符相同，说明能构成回文串，再继续扩散查看。</p>
<p>但是回文的中心点有两种可能。<br>回文串字符数是奇数，中心只有一个字符。<br>回文串字符数是偶数，中心有两个字符。</p>
<p>不知道哪种中心扩散生成的回文串长度最大，那就两个都试一下，取最大值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">centerSpread</span><span class="params">(l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">var</span> left = l</span><br><span class="line">            <span class="keyword">var</span> right = r</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] != s[right]) <span class="keyword">break</span></span><br><span class="line">                left--</span><br><span class="line">                right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里扩散完发现的回文串索引范围是[left + 1, right - 1]</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(left + <span class="number">1</span>, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> odd = centerSpread(i, i)</span><br><span class="line">            <span class="keyword">val</span> even = centerSpread(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> longer = <span class="keyword">if</span> (odd.length &gt; even.length) odd <span class="keyword">else</span> even</span><br><span class="line">            <span class="keyword">if</span> (longer.length &gt; longest.length) longest = longer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong><br>穷举中心点，需要遍历所有元素，消耗时间$O(n)$。<br>从中心点向两边扩散，最多扩展到整个字符串，所以最大消耗时间$O(n)$。<br>总体时间复杂度$O(n^2)$。</p>
<p>没有占用额外存储空间，空间复杂度$O(1)$。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.509. 斐波那契数（简单）</title>
    <url>/LeetCode/LeetCode.509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number">LeetCode.509. 斐波那契数（简单）</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<blockquote>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
</blockquote>
<p>给你 n ，请计算 F(n) 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h3><p>根据定义，可以直接写出递归式，最简单。<br>但是递归会有很多重叠子问题，重复计算很耗时。</p>
<p>可以想象出函数调用的递归树，F(n)总共调用次数就是树的节点数。<br>从F(n)到F(n - 1)一直分解到F(1)，这样逐一递减，一共n层递归树。<br>第i层(从上到下数)节点数为2的i次方，递归树总节点数为 2的0次方 + 2的1次方 + 2的2次方 + …… + 2的n - 1次方，等比数列求和为2的n次方。递归求解的时间复杂度为O(2^n)。</p>
<p>把会重复使用到的计算结果记下来，每一项只计算一次，时间复杂度降低为线性。<br>自上而下做动态规划。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            memo[n] = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：自下而上的动态规划"><a href="#解法2：自下而上的动态规划" class="headerlink" title="解法2：自下而上的动态规划"></a>解法2：自下而上的动态规划</h3><p>直接根据公式递推</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            cur = prepre + pre</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.51.N皇后（困难）</title>
    <url>/LeetCode/LeetCode.51.N%E7%9A%87%E5%90%8E%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">LeetCode.51.N皇后（困难）</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>提示：</p>
<ul>
<li>  <code>1 &lt;= n &lt;= 9</code></li>
<li>  皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul>
<li>尝试所有摆放的可能，用回溯。</li>
<li>每一行都放一个皇后，需要遍历所有行。</li>
<li>但是每一行放哪一列不确定，就遍历所有的列，都尝试一遍。</li>
<li>所有行放完了，完成了一种放置结果，添加到结果集。</li>
</ul>
<p><strong>限制条件如何检查？</strong></p>
<p>因为是从上到下放皇后的，当前行肯定没有其他皇后，只需检查当前列、左上方斜线、右上方斜线有没有放置过皇后，若有有放置过，当前行的当前列不能选择，得选择下一列。</p>
<p>标准的dfs，时间复杂度O(n!)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> result: MutableList&lt;List&lt;String&gt;&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> grid: Array&lt;CharArray&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理解题意是关键</span></span><br><span class="line"><span class="comment">     * 期盼上每一行每一列都只能有1个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solveNQueens</span><span class="params">(n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        grid = Array(n) &#123; CharArray(n) &#123; <span class="string">&#x27;.&#x27;</span> &#125; &#125;</span><br><span class="line">        result = mutableListOf()</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(r: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = grid.size</span><br><span class="line">        <span class="comment">// 所有的行选择完了，n个皇后也摆放完了，可以添加结果了</span></span><br><span class="line">        <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">            <span class="keyword">val</span> solution = grid.map &#123; row -&gt; row.joinToString(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">            result.add(solution)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前后的每一列都可以做出选择</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(r, c)) <span class="keyword">continue</span></span><br><span class="line">            grid[r][c] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            backtrack(r + <span class="number">1</span>)</span><br><span class="line">            grid[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = grid.size</span><br><span class="line">        <span class="comment">// 检查第c列有没有皇后，有皇后了就不能选这列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][c] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 斜着的也能走，要考虑斜着的四个方向，但其实我们选择的时候是从上往下选择的，所以只要考虑左上和右上的方向有没有皇后</span></span><br><span class="line">        <span class="comment">// 检查左上方有没有皇后</span></span><br><span class="line">        <span class="keyword">var</span> i = r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> j = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            i--</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方有没有皇后</span></span><br><span class="line">        i = r - <span class="number">1</span></span><br><span class="line">        j = c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            i--</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.516.最长回文子序列（中等）</title>
    <url>/LeetCode/LeetCode.516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">LeetCode.516.最长回文子序列（中等）</a></p>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>回文子序列的定义一定要搞清，不然不知道怎么求解。</p>
<p>根据示例，一个回文子序列是要求首尾字符是相同的，中间可以不是回文子串，但是求解序列长度其实是要删除不能构成回文子串的字符，然后再看剩下能构成回文子串的字符数是多少。</p>
<p><strong>那么什么情况下不能构成回文串？</strong><br>一个字符串首尾字符不相同，一定不是回文串。</p>
<p><strong>那应该删除首尾哪一个字符？</strong><br>因为要求最长的回文子序列，删除哪个字符后能够得到最长的回文子序列就删除哪个，但是不知道是哪个是最长的，所以都分别删除试一下，然后取最大值。</p>
<p><strong>删除字符后怎么办？</strong><br>删除字符后剩余字符串判断是不是回文子序列，还是一样的方法，所以可以递归进行。</p>
<p><strong>递归处理</strong><br>先看字符串两端字符是否相同：</p>
<ul>
<li>如果相同，可以算作回文子序列了，长度加2，但是总长度多少还得看去除首尾字符后剩余的字符串的回文子序列长度。</li>
<li>如果不相同，删除最左边字符，或者删除最右边字符，再看剩下的字符串的回文子序列长度。</li>
</ul>
<p><strong>边界</strong><br>递归一直在缩减字符串。<br>如果字符串是偶数个字符，每次两个字符的删减，最后肯定只剩两个字符，再缩减，会出现左指针索引大于指针右索引，直接返回0就行。<br>如果字符串一直一个个的缩减，最后左指针和右指针都会指向一个字符，一个字符是回文子串，长度返回1。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">	                <span class="comment">// 删除最左边字符</span></span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    <span class="comment">// 删除最右边字符</span></span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现递归是存在很多重叠子问题的，因为长的序列要依赖短的序列求解，比较短的序列结果就要反复被递归，这增加了耗时，所以给中间计算过的状态记录一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">`            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            memo[i][j] = <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>状态转移方程：<br>设<code>dp[i][j]</code>为字符串<code>s[i, j]</code>最长回文子序列长度。<br><code>s[i] == s[j]</code>时，<code>dp[i][j] = 2 + dp[i + 1][j - 1]</code><br><code>s[i] != s[j]</code>时，<code>dp[i][j] = maxOf(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>注意递推顺序，<code>i</code>是从<code>i + 1</code>递推来的，所以要从大到小遍历。<br><code>j</code>依赖<code>j - 1</code>，所以<code>j</code>是从小到大遍历。</p>
<p>由于<code>s[i, j]</code>要构成字符串，所以<code>i &lt;= j &lt; n</code>。<br><code>i == j</code>时，<code>dp[i][j] = 1</code>，可以单独处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; IntArray(n) &#123; j -&gt; <span class="keyword">if</span> (i == j) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (s[i] == s[j]) <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n^2)<br>空间复杂度O(n^2)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.518.零钱兑换 II（中等）</title>
    <url>/LeetCode/LeetCode.518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a></p>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>划分子问题</strong><br>设<code>dp[i]</code>为凑成总金额<code>i</code>的硬币组合数。<br>假设<code>coins = [1, 2, 5]</code>，那么<code>dp[i]</code>其实就是硬币总额<code>i - 1</code>、<code>i - 2</code>、<code>i - 5</code>子问题之和。</p>
<p><strong>状态转移方程</strong><br><code>for (coin: coins) dp[i] += dp[i - coin]</code></p>
<p><strong>注意点</strong><br>所求的是硬币的组合数，不是排列数。<br>比如<code>coins = [1, 2]</code>，<code>amount = 3</code>，<code>1 + 2</code>和<code>2 + 1</code>是同一种组合，但是两个排列。<br>如果我们是先确定一个<code>amount</code>，再去用所有硬币去凑，就会凑出来不同的排列。<br>所以要锁定硬币使用的顺序，同一个金额下就不会有不同顺序的硬币的使用情况了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">change</span><span class="params">(amount: <span class="type">Int</span>, coins: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(amount + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (a <span class="keyword">in</span> coin..amount) &#123;</span><br><span class="line">                dp[a] += dp[a - coin]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.52.N皇后 II（困难）</title>
    <url>/LeetCode/LeetCode.52.N%E7%9A%87%E5%90%8E%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-queens-ii/">LeetCode.52.N皇后 II（困难）</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<span id="more"></span>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 9</code></li>
<li>  皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最笨的办法就跟求出N皇后所有选择方案，取选择方案的个数，但这样空间复杂度大，本题只要求方案数，我们得看看空间复杂度能不能降低。</p>
<h3 id="N皇后问题的求解步骤"><a href="#N皇后问题的求解步骤" class="headerlink" title="N皇后问题的求解步骤"></a>N皇后问题的求解步骤</h3><ol>
<li>遍历先所有行</li>
<li>每一行遍历所有列</li>
<li>判断当前列可以放置，进行放置</li>
<li>然后再深度优先搜索，继续放置</li>
<li>直到放置完最后一行</li>
</ol>
<h3 id="什么情况下需要占用额外空间？"><a href="#什么情况下需要占用额外空间？" class="headerlink" title="什么情况下需要占用额外空间？"></a>什么情况下需要占用额外空间？</h3><p>在判断当前行当前列是不是可以放置皇后这个问题上，可能会需要一定的空间记录之前放置过皇后的情况。</p>
<h3 id="怎么判断某一列之前是否已经放置过皇后了？"><a href="#怎么判断某一列之前是否已经放置过皇后了？" class="headerlink" title="怎么判断某一列之前是否已经放置过皇后了？"></a>怎么判断某一列之前是否已经放置过皇后了？</h3><p>如果在某一列放置过皇后之后，就把这一列记录下来，到下一行再遍历所有列进行列选择时，就可以查询之前哪些列是放过的，放过的就不在这一列放了。</p>
<p>假设列总数是n，最多也就记录n个列有没有被放过皇后，可以用一个数组保存。</p>
<h3 id="怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？"><a href="#怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？" class="headerlink" title="怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？"></a>怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？</h3><p>如果从上往下斜着看，当在上一行第x列放置过皇后之后，我们可以知道下一行的第x + 1列和第x - 1列肯定也不能再放皇后了，因为都处于斜线位置上。</p>
<p>所以在遍历下一行的时候可以直接排除第x + 1列和第x - 1列，就相当于排除了斜线上不能放的位置。</p>
<p>但是到再下一行时，斜线会蔓延到第x + 2列和第x - 2列不可以放皇后。</p>
<p>也就是说斜线上禁止放皇后的位置随着行的增大而平移，位置需要随行保持更新，而且两个方向的斜线更新的方向也不一样。</p>
<p>所以这里需要两个数组存储两个方向斜线列的变化，每增加一行，数组值都要往左和往右移动一个位置。</p>
<h3 id="如何优化空间复杂度？"><a href="#如何优化空间复杂度？" class="headerlink" title="如何优化空间复杂度？"></a>如何优化空间复杂度？</h3><p>使用数组记录状态会占用O(n)的空间复杂度。</p>
<p>可以注意到<code>1 &lt;= n &lt;= 9</code>，能够使用二进制的位来记录状态，这样就节省了数组的空间开销，每个状态各自需要一个整数就可以判断，整数总共有32位，足以容纳9个状态值。</p>
<h3 id="怎么用二进制记录三种状态？"><a href="#怎么用二进制记录三种状态？" class="headerlink" title="怎么用二进制记录三种状态？"></a>怎么用二进制记录三种状态？</h3><ul>
<li>用整数变量<code>c</code>的每一位是否是1，表示某一列是否已经已经放过皇后了</li>
<li>用整数变量<code>ld</code>的每一位是否是1，表示某一列的右上角是否已经已经放过皇后了</li>
<li>用整数变量<code>rd</code>的每一位是否是1，表示某一列的左上角是否已经已经放过皇后了</li>
</ul>
<h3 id="怎么知道哪些列还能放皇后？"><a href="#怎么知道哪些列还能放皇后？" class="headerlink" title="怎么知道哪些列还能放皇后？"></a>怎么知道哪些列还能放皇后？</h3><p>具体到某一行时，需要知道哪些列还能放皇后。</p>
<p>哪些列不能放皇后，我们求<code>c</code>、<code>ld</code>、<code>rd</code>三个变量的或的结果<code>q</code>就知道了。</p>
<p><code>q</code>的二进制中所有为1的位就是已经放过皇后的，不能再放了。</p>
<p>找<code>q</code>中所有为0的位就是可以放皇后的位置；位数不超过n。</p>
<p>0不方便找，也不方便判断，1方便判断，所以可以反过来，把<code>q</code>取反，这样所有为1的位置都是可以放皇后的，但是高位会有多余的1，所以再跟n个1做与操作，把高位多余的1给截取掉。</p>
<p>n个1怎么快速求？可以把1左移n位，再减1。模拟一下就知道。</p>
<p>用<code>bits</code>变量来存储 <code>q</code>取反再跟n个1与操作的结果，<code>bits</code>的某一位为1表示这一位可以放皇后。</p>
<h3 id="怎么遍历所有可以放皇后的列？"><a href="#怎么遍历所有可以放皇后的列？" class="headerlink" title="怎么遍历所有可以放皇后的列？"></a>怎么遍历所有可以放皇后的列？</h3><ul>
<li>依次取<code>bits</code>每一位的1。</li>
<li>遍历何时结束？可以把访问过的1都消除掉，bits为0说明遍历完所有的1了。同时把访问过的1消除掉，也方便取下一个1。</li>
</ul>
<h4 id="怎么依次取bits每一位的1？"><a href="#怎么依次取bits每一位的1？" class="headerlink" title="怎么依次取bits每一位的1？"></a>怎么依次取<code>bits</code>每一位的1？</h4><p>可以想办法通过位运算快速求解，充分发挥二进制的优势。</p>
<p>可以每次取最低位的1，我们只要构造一个二进制数，跟bits前面的所有位都相反，就在最后一个1的位置跟bits一样，这样两者做一下与操作就可以得到最低位1。</p>
<p>取反可以想到反码，如果对bits取反，最低位1变成0，接着后面全部都是1，我们可以给反码加1，就可以把最低位的0和1变回来。</p>
<p>反码加1就是补码，所以取<code>-bits</code>跟<code>bits</code>做与操作，得到<code>bits</code>最低位的1。</p>
<h4 id="怎么消除最低位的1？"><a href="#怎么消除最低位的1？" class="headerlink" title="怎么消除最低位的1？"></a>怎么消除最低位的1？</h4><p><code>bits - 1</code>后，最低位1就没了，但是更低位本来全部是0现在都变成1，再跟<code>bits</code>与一下，它们的高位都相同，而<code>bits</code>低位都是0，这样就把<code>bit</code>最低位的1给消除了。</p>
<h4 id="怎么更新c、ld、rd？"><a href="#怎么更新c、ld、rd？" class="headerlink" title="怎么更新c、ld、rd？"></a>怎么更新<code>c</code>、<code>ld</code>、<code>rd</code>？</h4><p>取出的<code>bits</code>的最低位的1为<code>pick</code>。</p>
<p><code>pick</code>二进制中的1代表的列是不能被下一行再访问了，<code>c</code>要多增加这一列的1，<code>c = c or pick</code> 。</p>
<p><code>pick</code>二进制中的1代表的列的左下方的列在下一行是不能被访问的，并且<code>ld</code>中所有不能访问的列都要左移1位，正好可以用移位运算符很方便的做移动，<code>ld = (ld or pick) shl 1</code>。</p>
<p><code>pick</code>二进制中的1代表的列的右下方的列在下一行是不能被访问的，并且<code>rd</code>中所有不能访问的列都要右移1位，正好可以用移位运算符很方便的做移动，<code>rd = (rd or pick) shr 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">totalNQueens</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(row: <span class="type">Int</span>, c: <span class="type">Int</span>, ld: <span class="type">Int</span>, rd: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> bits = (c or ld or rd).inv() and ((<span class="number">1</span> shl n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (bits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> pick = bits and -bits</span><br><span class="line">                find(row + <span class="number">1</span>, c or pick, (pick or ld) shl <span class="number">1</span>, (pick or rd) shr <span class="number">1</span>)</span><br><span class="line">                bits = bits and (bits - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>回溯</tag>
        <tag>二进制</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.53.最大子序和（简单）</title>
    <url>/LeetCode/LeetCode.53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode.53.最大子序和（简单）</a></p>
<p>给定一个整数数组  <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最值问题考虑用动态规划，从某个状态倒推，拆解为上一个状态+所有可能的最小步骤，看是否符合动态规划的条件。</p>
<h2 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h2><p>设<code>dp[i]</code>为以<code>nums[i]</code>为结尾的连续子数组的最大和。</p>
<p>求<code>dp[i]</code>肯定是要加上<code>nums[i]</code>的，此时合成子数组有两种选择：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>和前面的连续子数组合并</li>
</ol>
<p>如何选择？</p>
<ol>
<li>如果 <code>dp[i - 1] + nums[i] &gt; nums[i]</code>，那么<code>dp[i] = dp[i - 1] + nums[i]</code>。</li>
<li>如果 <code>dp[i - 1] + nums[i] &lt; nums[i]</code>，那<code>nums[i]</code>单独成子数组后和反而更大，<code>dp[i] = nums[i]</code>。</li>
</ol>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p><code>dp[i] = max(dp[i - 1] + nums[i], nums[i]) </code></p>
<h2 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h2><p><code>dp[0]</code>就是<code>nums[0]</code>本身了，只包含自己的子数组。</p>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>dp[i]</code>只依赖于前一项的递推，可以不用数组，只用一个变量记录上一个值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="kotlin">class Solution &#123;
    fun maxSubArray(nums: IntArray): Int &#123;
        if (nums.isEmpty()) return 0
        var pre = 0
        var maxSum = nums[0]
        for (num in nums) &#123;
            val cur = maxOf(pre + num, num)
            maxSum = maxOf(maxSum, cur)
            pre = cur
        &#125;
        return maxSum
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.55.跳跃游戏（中等）</title>
    <url>/LeetCode/LeetCode.55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/jump-game/">LeetCode.55.跳跃游戏（中等）</a></p>
<p>给定一个非负整数数组 <code>nums</code>  ，你最初位于数组的  <strong>第一个下标</strong>  。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="到达最后一个下标需要什么条件？"><a href="#到达最后一个下标需要什么条件？" class="headerlink" title="到达最后一个下标需要什么条件？"></a>到达最后一个下标需要什么条件？</h2><p>跳过的长度要大于等于数组长度</p>
<h2 id="什么情况下不能到达最后一个下标？"><a href="#什么情况下不能到达最后一个下标？" class="headerlink" title="什么情况下不能到达最后一个下标？"></a>什么情况下不能到达最后一个下标？</h2><p>到达某个位置后，不继续往后跳了，比如到了某个位置，可跳跃长度为0，就不会往后跳了，跳到最后一个位置就无从谈起。</p>
<h2 id="我怎么知道总共跳跃的长度有没有超过数组的长度？"><a href="#我怎么知道总共跳跃的长度有没有超过数组的长度？" class="headerlink" title="我怎么知道总共跳跃的长度有没有超过数组的长度？"></a>我怎么知道总共跳跃的长度有没有超过数组的长度？</h2><p>只能从头到尾遍历数组，记录最多能跳多远，会不会在某个位置停止跳跃，如果不会停止跳跃，肯定能跳到终点。</p>
<h2 id="停止跳跃有什么特征？怎么判断有没有停止跳跃？"><a href="#停止跳跃有什么特征？怎么判断有没有停止跳跃？" class="headerlink" title="停止跳跃有什么特征？怎么判断有没有停止跳跃？"></a>停止跳跃有什么特征？怎么判断有没有停止跳跃？</h2><p>如果记录最远能够跳到的位置，停止跳跃的时候，记录的位置不会再改变了。<br>在遍历数组检查最多能跳多远的时候，如果发现数组当前遍历的下标超过记录的最远跳过的位置，说明跳跃停止了。因为遍历数组相当于每次跳1步，是最低速度，如果能持续跳跃，不会低于这个速度，最低也是持平。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            j = maxOf(j, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums.size) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode中等</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.62.不同路径（中等）</title>
    <url>/LeetCode/LeetCode.62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/unique-paths/">LeetCode.62.不同路径（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li>从上边<code>[m - 1, n]</code>来</li>
<li>从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？<br>按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为整个路径是要从上到下的，从下面上来，最后还是要下去，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为整个路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。<br>而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径数，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径数时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径数。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，达到的路径数量就是1。<br>第一行所有格子没有上面，都只能从左边过来，路径数都是1。<br>第一列所有格子没有左边，都只能从上边过来，路径数都是1。</p>
<p><strong>复杂度</strong><br>需要查看所有格子的情况来寻找路径数，所以要遍历所有网格，时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>记录所有达到所有格子的路径数，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径数推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径数？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径数，所以记录一行是必须的。<br>读取上一行格子的路径数，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.63.不同路径 II（中等）</title>
    <url>/LeetCode/LeetCode.63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode.63.不同路径 II（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>有障碍物说明不能达到，换句话说，到达障碍物格子的路径数为0。</p>
<p>设<code>dp[i][j]</code>为到达<code>[i, j]</code>格的路径数。</p>
<p><strong>状态转移方程</strong></p>
<ol>
<li><code>[i, j]</code>没有障碍物，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</li>
<li><code>[i, j]</code>有障碍物，<code>dp[i][j] = 0</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，下面格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br>只关心左边和上边的格子的路径数，不需要记录所有行的数据，只需要记录一行。<br>能不能只记录左边和上边，用两个变量完成？<br>不能，终点在最右边，路径可能从最左边过来，所以要记录一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment">// dp[j]: 达到上方格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]: 达到左方格子的路径数</span></span><br><span class="line">                <span class="keyword">else</span> dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.64.最小路径和（中等）</title>
    <url>/LeetCode/LeetCode.64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">LeetCode.64.最小路径和（中等）</a></p>
<p>给定一个包含非负整数的  <code>_m_ x _n_</code> 网格 <code>grid</code>  ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li> 从上边<code>[m - 1, n]</code>来</li>
<li> 从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？  按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为从起点到终点的路径是要从上到下的，如果从下面上来最后还是要下去，路径和增大了，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为起点到终点的路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。  而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径和，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径和时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径和。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，路径和就是当前元素值。<br>第一行所有格子没有上面，都只能从左边过来，路径和从左边累加。<br>第一列所有格子没有左边，都只能从上边过来，路径和从右边累加。</p>
<p><strong>复杂度</strong><br>要遍历所有网格，才能找到最少路径和，所以时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>如果记录达到所有格子的路径和，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + minOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径和推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径和？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径和，所以记录一行是必须的。  读取上一行格子的路径和，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径和。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 第一行不能从上边过来，特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) grid[i][j] + dp[j]</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] + minOf(dp[j], dp[j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.65.有效数字（困难）</title>
    <url>/LeetCode/LeetCode.65.%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/valid-number/">LeetCode.65.有效数字（困难）</a></p>
<span id="more"></span>

<p>有效数字（按顺序）可以分成以下几个部分：</p>
<ul>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
</ul>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：<ul>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ul>
</li>
</ul>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
<p>部分有效数字列举如下：</p>
<ul>
<li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li>
</ul>
<p>部分无效数字列举如下：</p>
<ul>
<li>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</li>
</ul>
<p>给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 20</code></li>
<li>  <code>s</code>  仅含英文字母（大写和小写），数字（<code>0-9</code>），加号  <code>&#39;+&#39;</code>  ，减号  <code>&#39;-&#39;</code>  ，或者点  <code>&#39;.&#39;</code>  。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：正则表达式"><a href="#解法1：正则表达式" class="headerlink" title="解法1：正则表达式"></a>解法1：正则表达式</h2><p>检查字符串是不是符合某种规则，用正则表达式是最直接的想法。</p>
<h3 id="怎么表示一个整数？"><a href="#怎么表示一个整数？" class="headerlink" title="怎么表示一个整数？"></a>怎么表示一个整数？</h3><p><code>[+-]?\\d+</code></p>
<ul>
<li><code>[+-]?</code>满足整数条件1：<code>（可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）</code>。</li>
<li><code>\\d+</code>满足整数条件2：<code>至少一位数字</code>。</li>
</ul>
<h3 id="怎么表示一个小数？"><a href="#怎么表示一个小数？" class="headerlink" title="怎么表示一个小数？"></a>怎么表示一个小数？</h3><p><code>[+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)</code></p>
<ul>
<li><code>[+-]?</code>满足条件<code>（可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）</code>。</li>
<li><code>(\\d+\\.)</code>满足条件<code>至少一位数字，后面跟着一个点 &#39;.&#39;</code>。</li>
<li><code>(\\d+\\.\\d+)</code>    满足条件<code>至少一位数字，后面跟着一个点 &#39;.&#39; ，后面再跟着至少一位数字</code>。</li>
<li><code>(\\.\\d+)</code>满足条件<code>一个点 &#39;.&#39; ，后面跟着至少一位数字</code>。</li>
</ul>
<h3 id="怎么表示科学计数法？"><a href="#怎么表示科学计数法？" class="headerlink" title="怎么表示科学计数法？"></a>怎么表示科学计数法？</h3><p>一个整数或者小数 + <code>([eE][+-]?\\d+) </code></p>
<p><code>([eE][+-]?\\d+) </code>满足条件<code>一个 &#39;e&#39; 或 &#39;E&#39; ，后面跟着一个 整数</code>，根据示例，e后面的整数前面可以带正负号。</p>
<h3 id="满足题意的正则表达式？"><a href="#满足题意的正则表达式？" class="headerlink" title="满足题意的正则表达式？"></a>满足题意的正则表达式？</h3><p>把上面三个综合起来，就能得到最终的表达式：</p>
<p><code>([+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)|(\\d+)))([eE][+-]?\\d+)?</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> regex = Regex(<span class="string">&quot;([+-]?(\\d+(\\.\\d*)?|(\\.\\d+)))([eE][+-]?\\d+)?&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> regex.matches(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：模拟"><a href="#解法2：模拟" class="headerlink" title="解法2：模拟"></a>解法2：模拟</h2><p>暴力模拟逻辑会比较乱，可以做一个简单的分类，这样相对会比较清晰。</p>
<p>有效数字有三种可能的字符串形式：</p>
<ol>
<li>整数</li>
<li>小数</li>
<li>科学计数</li>
</ol>
<p>针对三种形式的数字，分别写一个校验器做判断即可。</p>
<p>在科学计数的校验器中，可以去除科学计数的特征字符，再复用整数校验器和小数校验器的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> validator = Decorator()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validator.validate(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> s.all &#123; it.isDigit() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dotIndex = s.indexOf(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> intPart = s.substring(<span class="number">0</span>, dotIndex)</span><br><span class="line">        <span class="keyword">val</span> decimalPart = s.substring(dotIndex + <span class="number">1</span>, s.length)</span><br><span class="line">        <span class="keyword">return</span> intPart.all &#123; it.isDigit() &#125; &amp;&amp; decimalPart.all &#123; it.isDigit() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScienceFormatValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> floatValidator = FloatValidator()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> intValidator = IntValidator()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> eIndex = s.indexOf(<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (eIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (eIndex == s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> left = s.substring(<span class="number">0</span>, eIndex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> right = s.substring(eIndex + <span class="number">1</span>, s.length)</span><br><span class="line">        <span class="keyword">if</span> (right[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || right[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            right = right.substring(<span class="number">1</span>, right.length)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (intValidator.validate(left) || floatValidator.validate(left)) &amp;&amp; intValidator.validate(right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> validators = listOf(</span><br><span class="line">            IntValidator(),</span><br><span class="line">            FloatValidator(),</span><br><span class="line">            ScienceFormatValidator()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> str = s.trimSpaceAndSign()</span><br><span class="line">        validators.forEach &#123; validator -&gt;</span><br><span class="line">            <span class="keyword">if</span> (validator.validate(str)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">trimSpaceAndSign</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> s = trim()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (s.isNotEmpty() &amp;&amp; (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">        s.substring(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：DFA"><a href="#解法3：DFA" class="headerlink" title="解法3：DFA"></a>解法3：DFA</h2><p>字符匹配规则的过程，可以看作是状态转移的过程，字符作为输入，即状态改变的条件，让一个状态产生转移另一个状态，如果能转换到最终状态，说明字符串是匹配的。</p>
<p>可以用状态机来解决字符串匹配。这里使用DFA，即确定有穷状态机，对每个状态和输入符号可以得到下一个唯一到状态。</p>
<p>那么问题就转变为：</p>
<ol>
<li>有哪些状态？</li>
<li>初始状态是什么？</li>
<li>结束状态是什么？</li>
<li>输入有哪些？</li>
<li>状态转移失败怎么办？</li>
<li>状态转移的所有情况有哪些？</li>
</ol>
<h3 id="有哪些状态？"><a href="#有哪些状态？" class="headerlink" title="有哪些状态？"></a>有哪些状态？</h3><p>我们把所有正确的、互相独立的状态列出来，然后看输入什么字符可以从一个状态转换到另一个状态，就构建出了状态机。</p>
<p>可以把 当前处理到有效数字字符串的哪个部分 当作状态，所有的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.空字符串</span><br><span class="line">1.符号位</span><br><span class="line">2.整数部分数字</span><br><span class="line">3.左侧有整数的小数点</span><br><span class="line">4.左侧无整数的小数点</span><br><span class="line">5.小数部分的数字</span><br><span class="line">6.指数字符e或E</span><br><span class="line">7.指数后面的符号位</span><br><span class="line">8.指数后面的整数部分</span><br></pre></td></tr></table></figure>

<h3 id="初始状态是什么？"><a href="#初始状态是什么？" class="headerlink" title="初始状态是什么？"></a>初始状态是什么？</h3><p>0.空字符串</p>
<h3 id="结束状态是什么？"><a href="#结束状态是什么？" class="headerlink" title="结束状态是什么？"></a>结束状态是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.整数部分数字</span><br><span class="line">3.左侧有整数的小数点</span><br><span class="line">5.小数部分的数字</span><br><span class="line">8.指数后面的整数部分</span><br></pre></td></tr></table></figure>

<h3 id="输入有哪些？"><a href="#输入有哪些？" class="headerlink" title="输入有哪些？"></a>输入有哪些？</h3><ul>
<li>空格</li>
<li>正负号  <code>+</code>  或<code>-</code>  </li>
<li>数字<code>0-9</code></li>
<li>点  <code>.</code>  </li>
<li>英文字母<code>e</code>或<code>E</code></li>
<li>其他字符</li>
</ul>
<h3 id="状态转移失败怎么办？"><a href="#状态转移失败怎么办？" class="headerlink" title="状态转移失败怎么办？"></a>状态转移失败怎么办？</h3><p>如果对于某个输入不能转换到下一个状态，应该提前终止匹配。</p>
<h3 id="状态转移的所有情况有哪些？"><a href="#状态转移的所有情况有哪些？" class="headerlink" title="状态转移的所有情况有哪些？"></a>状态转移的所有情况有哪些？</h3><p>可以用状态表描述所有状态转移的情况，结合规则和示例定义所有状态的转移情况。</p>
<p>如果状态不可转移，用-1表示。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>空格</th>
<th>+/-</th>
<th>0-9</th>
<th>.</th>
<th>e/E</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>0.空字符串</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>1.符号位</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>2.整数部分数字</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>3.左侧有整数的小数点</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>4.左侧无整数的小数点</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>5.小数部分的数字</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>6.指数字符e或E</td>
<td>-1</td>
<td>7</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>7.指数后面的符号位</td>
<td>-1</td>
<td>-1</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>8.指数后面的整数部分</td>
<td>-1</td>
<td>-1</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="状态表怎么存储？"><a href="#状态表怎么存储？" class="headerlink" title="状态表怎么存储？"></a>状态表怎么存储？</h3><ul>
<li>二维数组。</li>
<li>哈希表嵌套，不存储-1的状态，这样还可以节约一点空间。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h4><p>字符串长度为n，需要遍历字符串所有字符。</p>
<p>状态转移查表只需要O(1)时间。</p>
<h4 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O(1)"></a>空间复杂度：O(1)</h4><p>虽然状态表占用一定的空间，但跟字符串长度无关，并且大小固定，所以可以认为是常数空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      |       状态        |空格|+/-|0-9|. |e/E|其他|</span></span><br><span class="line"><span class="comment">     *      | -----------------|----|---|---|--|---|--|</span></span><br><span class="line"><span class="comment">     *      |0.空字符串          |0  |1  |2  |4  |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |1.符号位            |-1 |-1 |2  |4 |-1  |-1|</span></span><br><span class="line"><span class="comment">     *      |2.整数部分数字       |-1 |-1 |2  |3  |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |3.左侧有整数的小数点  |-1 |-1 |5  |-1 |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |4.左侧无整数的小数点  |-1 |-1 |5  |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |5.小数部分的数字     |-1 |-1 |5  |-1 |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |6.指数字符e或E       |-1 |7 |8  |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |7.指数后面的符号位    |-1 |-1 |8 |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |8.指数后面的整数部分  |-1 |-1 |8 |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table = arrayOf(</span><br><span class="line">        intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> finalState = arrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            state = table[state][c.index]</span><br><span class="line">            <span class="keyword">if</span> (state == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state <span class="keyword">in</span> finalState</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="built_in">Char</span>.index: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="string">&#x27; &#x27;</span> -&gt; <span class="number">0</span></span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span> -&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="number">2</span></span><br><span class="line">            <span class="string">&#x27;.&#x27;</span> -&gt; <span class="number">3</span></span><br><span class="line">            <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;E&#x27;</span> -&gt; <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>正则表达式</tag>
        <tag>DFA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.68.文本左右对齐（困难）</title>
    <url>/LeetCode/LeetCode.68.%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/text-justification/">LeetCode.68.文本左右对齐（困难）</a></p>
<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<span id="more"></span>

<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<p>说明:</p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 maxWidth。</li>
<li>输入单词数组 words 至少包含一个单词。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>顺着题目说明思考步骤。</p>
<h3 id="怎么知道一行可以放多少个单词？"><a href="#怎么知道一行可以放多少个单词？" class="headerlink" title="怎么知道一行可以放多少个单词？"></a>怎么知道一行可以放多少个单词？</h3><p>依次遍历单词，累加单词长度，跟<code>maxWidth</code>对比，找出一行可以容纳的最多的单词。</p>
<p>如果一行有<code>n</code>个单词，要注意，前<code>n - 1</code>个单词末尾都要至少有一个空格，需要考虑进去。</p>
<h3 id="如何知道每行有多少个空格？"><a href="#如何知道每行有多少个空格？" class="headerlink" title="如何知道每行有多少个空格？"></a>如何知道每行有多少个空格？</h3><p><code>maxWidth - 这一行所有单词长度</code></p>
<h3 id="如何平均分配空格到每个单词的末尾？"><a href="#如何平均分配空格到每个单词的末尾？" class="headerlink" title="如何平均分配空格到每个单词的末尾？"></a>如何平均分配空格到每个单词的末尾？</h3><p>假设一行的空格数有<code>spaceCount</code>，一行可以放置的单词有<code>n</code>个。</p>
<ul>
<li>只有前<code>n - 1</code>个单词的末尾需要分配空格。</li>
<li>按照平均分配的原则，每个单词末尾的空格数应当为<code>spaceCount / (n - 1)</code>。</li>
<li>如果<code>spaceCount / (n - 1)</code>不能整除，说明一行单词间的空格不能均匀分配，按照题意，左侧放置的空格数要多于右侧的空格数。<ul>
<li>多出来的空格数是<code>spaceCount % (n - 1)</code>，从左到右给每个单词末尾加一个空格，均匀掉。</li>
</ul>
</li>
</ul>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><ul>
<li>对于最后一行，按照题意：<code>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</code>，同时末尾要全部填满空格。</li>
<li>对于一行只有一个单词，空格只能全部填在末尾，让单词左对齐。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fullJustify</span><span class="params">(words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, maxWidth: <span class="type">Int</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> n = words.size</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 统计一行能放多少个单词</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这一行所有单词的长度</span></span><br><span class="line">            <span class="keyword">var</span> wordsLength = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> j = i</span><br><span class="line">            <span class="comment">// 每个单词末尾一个空格数量的累加为 j - i</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; wordsLength + words[j].length + j - i &lt;= maxWidth) &#123;</span><br><span class="line">                wordsLength += words[j].length</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 最后一行单独处理，因为处理空格的逻辑跟普通行不一样，所以放在普通行处理空格的前面</span></span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">val</span> line = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> i until j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line.isNotEmpty()) line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                    line.append(words[k])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> line.length until maxWidth) &#123;</span><br><span class="line">                    line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(line.toString())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;&lt;&lt; </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 平均分配空格到单词末尾</span></span><br><span class="line">            <span class="keyword">val</span> line = StringBuilder()</span><br><span class="line">            <span class="keyword">val</span> wordCount = j - i</span><br><span class="line">            <span class="keyword">val</span> spaceLength = <span class="keyword">if</span> (wordCount == <span class="number">1</span>) <span class="number">0</span> <span class="keyword">else</span> (maxWidth - wordsLength) / (wordCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">var</span> extraSpaceLength = <span class="keyword">if</span> (wordCount == <span class="number">1</span>) <span class="number">0</span> <span class="keyword">else</span> (maxWidth - wordsLength) % (wordCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> i until j) &#123;</span><br><span class="line">                <span class="comment">// 空格分配在每个单词前面</span></span><br><span class="line">                <span class="keyword">if</span> (line.isNotEmpty()) &#123;</span><br><span class="line">                    repeat(spaceLength) &#123; line.append(<span class="string">&quot; &quot;</span>) &#125;</span><br><span class="line">                    <span class="keyword">if</span> (extraSpaceLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                        extraSpaceLength--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                line.append(words[k])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;&lt;&lt; </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于一行只有一个单词和最后一行，末尾填充空格</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> line.length until maxWidth) &#123;</span><br><span class="line">                line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加一行的结果</span></span><br><span class="line">            result.add(line.toString())</span><br><span class="line"></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.70.爬楼梯（简单）</title>
    <url>/LeetCode/LeetCode.70.%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> <a href="https://leetcode-cn.com/problems/climbing-stairs/">LeetCode.70.爬楼梯（简单）</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑用动态规划，看是否符合动态规划的条件。<br>一般从最终状态做倒推，拆解当前状态问题为上一个状态+有限的步骤。</p>
<h3 id="倒推"><a href="#倒推" class="headerlink" title="倒推"></a>倒推</h3><p>爬到第n阶，最后一步一定是只有两种可能：</p>
<ol>
<li>先爬到第n-1个台阶，再爬1个台阶</li>
<li>先爬到第n-2个台阶，再爬2个台阶</li>
</ol>
<p>把两种可能的方法数累加就是爬到第n阶第方法数。</p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>爬到第1阶，只有1种爬法，即爬1个台阶。<br>爬到第2阶，可以从第0阶爬2个台阶，也可以从第1阶爬1个台阶，共2种爬法。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.703.数据流中的第 K 大元素（简单）</title>
    <url>/LeetCode/LeetCode.703.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">LeetCode.703.数据流中的第 K 大元素（简单）</a></p>
<p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>
<p>请实现 KthLargest 类：</p>
<p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。<br>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：堆"><a href="#解法1：堆" class="headerlink" title="解法1：堆"></a>解法1：堆</h2><p>第k大的数就是数组按照从大到小的顺序下的第k位。</p>
<p>利用小顶堆的特性，堆只保留k个元素，第1大到第k大的数都在堆里，第k大的数正好是堆顶。</p>
<p>如果要插入的数比堆顶元素大，堆顶元素就变为了第k+1大的数，应该从堆中舍弃，于是就将堆顶元素替换为新元素，再调整堆使其满足小顶堆的特性，此时堆顶依然是第k大的数。</p>
<p>如果要插入的数比堆顶元素小，则忽略，因为第k+1大、k+2大等等的数字我们并不关心。</p>
<p>建立堆的时间是O(n)，一次向下调整堆的时间复杂度是O(log k)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> k: <span class="built_in">Int</span>,</span><br><span class="line">    nums: IntArray</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> heap: IntArray</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原始堆的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> length = nums.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 题意限制 nums 的长度≥ k-1，即 k 的最大值为 nums 的长度 + 1</span></span><br><span class="line">        <span class="comment">// 令 n = nums 的长度，当 k = n + 1 时，给堆预留一个存储空间，用于第一次add时把值放入堆中，以便统计第k大的数</span></span><br><span class="line">        heap = <span class="keyword">if</span> (k == length + <span class="number">1</span>) &#123;</span><br><span class="line">            IntArray(length + <span class="number">1</span>).apply &#123;</span><br><span class="line">                nums.copyInto(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> nums</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建小顶堆</span></span><br><span class="line">        buildMinHeap(heap, length)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆中只保留k个元素，不断的删除堆顶元素，把堆底元素换到堆顶，再调整堆</span></span><br><span class="line">        keepHeapSize(heap, length, k)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(`<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 题意限制 nums 的长度≥ k-1，即 k 的最大值为 nums 的长度 + 1</span></span><br><span class="line">        <span class="comment">// 当k超过 nums 的长度，刚好是 nums 的长度 + 1 时，在第一次add时，要把add的值放入堆中，以便后续比较</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; heap.size) &#123;</span><br><span class="line">            <span class="comment">// 堆顶最小元素放到末尾，下面会再把新元素插入插入堆顶，再从堆顶向下调整堆</span></span><br><span class="line">            heap[length] = heap[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">// 改变原始堆长度</span></span><br><span class="line">            length++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时 k &lt;= n，可以保证堆顶元素就是第k大的数</span></span><br><span class="line">            <span class="comment">// 堆顶元素是最小的元素，堆有k个数，堆的其他元素都比堆顶元素大，那么堆顶元素就是第k大的数</span></span><br><span class="line">            <span class="comment">// 如果要插入的数值小于等于最小的元素，堆顶元素依然是第k大的，就要插入的数值就不用插入堆中了</span></span><br><span class="line">            <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt;= heap[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要插入的数值大于最小的元素，当前堆顶元素就不是最小的了，也就是不是第k大的了，就要调整堆了</span></span><br><span class="line">        <span class="comment">// 此时应该将新插入的数放入堆顶，舍弃原来最小的数，因为原来最小的数（原堆顶元素）一定不是第k大的数了，还放在大小为k的堆里没有意义</span></span><br><span class="line">        heap[<span class="number">0</span>] = `<span class="keyword">val</span>`</span><br><span class="line">        <span class="comment">// 新元素插入堆顶后，可能会破坏堆，需要向下调整</span></span><br><span class="line">        sink(heap, <span class="number">1</span>, k)</span><br><span class="line">        <span class="comment">// 调整后的堆顶元素就是最小的元素，也就是第k大的数</span></span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保持堆[nums]为指定的大小[size]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">keepHeapSize</span><span class="params">(nums: <span class="type">IntArray</span>, originalSize: <span class="type">Int</span>, size: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (originalSize &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次删除堆顶元素</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> originalSize downTo size + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将堆末尾的数放到堆顶，覆盖原来的数，以达到删除堆顶元素的效果</span></span><br><span class="line">            nums.swap(<span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 从堆顶开始向下调整堆</span></span><br><span class="line">            <span class="comment">// 最后一个元素已删除，所以不在堆调整范围内</span></span><br><span class="line">            sink(nums, <span class="number">1</span>, length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 末尾空余的位置不管，k就是堆的大小，是小于等于原堆大小的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建初始的小顶堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildMinHeap</span><span class="params">(nums: <span class="type">IntArray</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子结点开始到根节点，不停的向下调整堆，最后整体就是小根堆，为什么建堆是这样遍历需要复习堆排序的知识</span></span><br><span class="line">        <span class="keyword">for</span> (parent <span class="keyword">in</span> length / <span class="number">2</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            sink(nums, parent, length)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从第[k]个数开始上向下调整堆[nums]，堆的大小为[length]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sink</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> parent = k</span><br><span class="line">        <span class="keyword">while</span> (parent &lt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> child = parent * <span class="number">2</span></span><br><span class="line">            <span class="comment">// child 和 parent 都是编号，在数组的实际索引要减1</span></span><br><span class="line">            <span class="keyword">if</span> (child &lt; length &amp;&amp; nums[child - <span class="number">1</span>] &gt; nums[child]) child++</span><br><span class="line">            <span class="keyword">if</span> (nums[parent - <span class="number">1</span>] &lt;= nums[child - <span class="number">1</span>]) <span class="keyword">break</span></span><br><span class="line">            nums.swap(parent - <span class="number">1</span>, child - <span class="number">1</span>)</span><br><span class="line">            parent = child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组IntArray的扩展函数swap，用以交换数组内两个位置[i]和[j]的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：二叉搜索树"><a href="#解法2：二叉搜索树" class="headerlink" title="解法2：二叉搜索树"></a>解法2：二叉搜索树</h2><p>二叉搜索树法原理参见二叉搜索树探索卡片<br><a href="https://leetcode-cn.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/66/conclusion/182/">https://leetcode-cn.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/66/conclusion/182/</a><br><code>鉴于我们同时需要插入和搜索操作，为什么不考虑使用一个二叉搜索树结构存储数据呢？ 我们知道，对于二叉搜索树的每个节点来说，它的左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。 换言之，对于二叉搜索树的每个节点来说，若其左子树共有m个节点，那么该节点是组成二叉搜索树的有序数组中第m + 1个值。</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span></span>(k: <span class="built_in">Int</span>, nums: IntArray) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> bst: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> kth = k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nums.forEach &#123;</span><br><span class="line">            bst = BST.insert(bst, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(`<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        bst = BST.insert(bst, `<span class="keyword">val</span>`)</span><br><span class="line">        <span class="keyword">val</span> node = BST.search(bst, kth)</span><br><span class="line">        <span class="keyword">return</span> node!!.`<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> BST &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(root: <span class="type">TreeNode</span>?, value: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> TreeNode(value, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                root.left = insert(root.left, value)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                root.right = insert(root.right, value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重复元素不添加新节点，只是更新当前节点的计数</span></span><br><span class="line">            root.count++</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(root: <span class="type">TreeNode</span>?, k: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左子树节点数量</span></span><br><span class="line">            <span class="keyword">val</span> leftNodeCount = root.left?.count ?: <span class="number">0</span></span><br><span class="line">            <span class="comment">// 右子树节点数量</span></span><br><span class="line">            <span class="keyword">val</span> rightNodeCount = root.right?.count ?: <span class="number">0</span></span><br><span class="line">            <span class="comment">// 当前节点数量，当前节点可能存在重复的</span></span><br><span class="line">            <span class="keyword">val</span> currentNodeCount = root.count - leftNodeCount - rightNodeCount</span><br><span class="line">            <span class="comment">// 根据二叉搜索树特点，大于当前节点的数都在右子树</span></span><br><span class="line">            <span class="comment">// 如果k小于等于右子树的节点数，说明第k大的数在右子树，要去右子树寻找，否则要在当前节点和左子树中寻找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                k &lt;= rightNodeCount -&gt; search(root.right, k)</span><br><span class="line">                k &gt; rightNodeCount + currentNodeCount -&gt; search(root.left, k - rightNodeCount - currentNodeCount)</span><br><span class="line">                <span class="keyword">else</span> -&gt; root</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>(<span class="keyword">var</span> `<span class="keyword">val</span>`: <span class="built_in">Int</span>, <span class="keyword">var</span> count: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode简单</tag>
        <tag>优先队列</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.714.买卖股票的最佳时机含手续费（中等）</title>
    <url>/LeetCode/LeetCode.714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode.714.买卖股票的最佳时机含手续费（中等）</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>状态转移方程同<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>卖出时计算利润时把交易费扣除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>, fee: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            noholdProfit = maxOf(noholdProfit, holdProfit + prices[i] - fee)</span><br><span class="line">            holdProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.72.编辑距离（困难）</title>
    <url>/LeetCode/LeetCode.72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">LeetCode.72.编辑距离（困难）</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看着题目就给出了原子化的最小操作步骤了，看着就能拆成子问题的样子。</p>
<p>从两个单词末尾开始看起。</p>
<ul>
<li>如果<code>word1[i1] == word2[i2]</code>，就不用操作；<br>  接着就是去对比<code>word1[0, i1 - 1]</code>和<code>word2[0, i2 - 1]</code>这两个子字符串是不是一样，看子问题。</li>
<li>如果<code>word1[i1] != word2[i2]</code>，那么每个单词都有三种操作可以变成另一个；<br>具体哪种操作后的总操作数最少呢？只能每个都试一下，然后选个操作数最少的。</li>
</ul>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>是<code>word1[0, i]</code>转换为<code>word2[0, j]</code>的操作数。</p>
<ul>
<li><code>word1[i] == word2[j]</code>时，<br><code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>word1[i] != word2[j]</code>时：<ul>
<li><code>word1</code>末尾插入一个与<code>word2[j]</code>相同的字符，插入之前的操作数是<code>dp[i][j - 1]</code>。</li>
<li><code>word1</code>末尾删除一个字符，删除之前的操作数是<code>dp[i - 1][j]</code>。</li>
<li><code>word1</code>末尾字符替换为<code>word2[j]</code>，替换之前的操作数是<code>dp[i - 1][j - 1]</code>。</li>
<li>取插入、删除、替换操作数中最小的一个，<code>dp[i][j] = 1 + minOf(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])</code></li>
</ul>
</li>
</ul>
<p><strong>边界条件</strong></p>
<ul>
<li><code>i == 0</code>时，<ul>
<li><code>dp[i - 1][j]</code>表示空字符串变换到<code>word2[0, j]</code>需要的操作数，很显然要插入<code>j + 1</code>个字符，操作数是<code>j + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>j == 0</code>时，<ul>
<li><code>dp[i][j - 1]</code>表示空字符串变换到<code>word1[0, i]</code>需要的操作数，很显然要插入<code>i + 1</code>个字符，操作数是<code>i + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>i == 0 &amp;&amp; j == 0</code>时，<ul>
<li><code>dp[i - 1][j - 1]</code>（即<code>dp[-1][-1]</code>）表时空字符串转换到空字符串，操作数为0。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(word1.length - <span class="number">1</span>, word2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度</p>
<p>设m为word1长度，n为word2长度，m &lt; n。</p>
<p>画出递归树可以观察到，一个大问题最多可以拆解为3个子问题，也就是一个结点的下一层最多有3个结点，可以一直这样扩张，树高也就是m和n中的较大值。<br>最坏时间复杂度就是递归树的所有结点数，通过等比数列求和公式可得结点总数为 $O(3^n)$。</p>
<p>一次递归占用一个方法栈，空间复杂度就看同一时刻最多会有多少个方法栈存在，因为递归没有发现结果会回溯，所以得到正确答案的时候递归深度最深，也就是方法栈最多的时候。<br>空间复杂度 $O(n)$。</p>
</blockquote>
<p>递归有大量重叠子问题，比如<code>min(i1 - 1, i2 - 1)</code>在依次经历过<code>min(i1 - 1, i2)</code>和<code>min(i1 - 1, i2 - 1)</code>后可以得到，计算了两次，后续递归还有更多重叠子问题，得把中间计算结果保存一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n1) &#123; IntArray(n2) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1 - <span class="number">1</span>, n2 - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong><br>自底向上递推会用到前一项的值，为了避免大量边界判断，把dp数组长度加1。<br><code>dp[i][j]</code>表示<code>word1[0, i - 1]</code>和<code>word2[0, j - 1]</code>的最小编辑距离。</p>
<p><code>dp[i][0]</code>表示<code>word1[0, i - 1]</code>变成空字符串需要多少步操作，很显然是要删除<code>word1[0,i - 1]</code>所有字符，共有<code>i</code>个字符。</p>
<p><code>dp[0][j]</code>表示空字符串要变成<code>word2[0,j - 1]</code>需要多少步操作，很显然是要插入<code>word2[0, j - 1]</code>全部字符，总共<code>j</code>个字符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(len1 + <span class="number">1</span>) &#123; IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len1) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len2) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until len1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until len2) &#123;</span><br><span class="line">	            <span class="comment">// 当前字符相等，不需要操作，操作步数看上一个状态</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前字符不等，可以插入、替换、删除</span></span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + dp[i][j]</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[i + <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[i][j + <span class="number">1</span>]</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(mn)，需要用二维dp数组记录中间计算状态。</p>
</blockquote>
<p><strong>空间优化</strong><br><code>dp[i][j]</code>只跟左、上、左上三项有关，不需要用二维数组记录所有状态，只需要一行数组记录上一行状态即可。</p>
<p>这里有个问题在于，从左到右更新<code>dp</code>数组时会把左上角的值给覆盖掉，所以要在更新左边的值之前，把左上角的值先提前保存一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.len2) dp[j] = j</span><br><span class="line">        <span class="comment">// 表示左上角的值</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len1) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.len2) &#123;</span><br><span class="line">	            <span class="comment">// 更新左边的值之前，把左上角的值先提前保存一下</span></span><br><span class="line">                <span class="keyword">val</span> tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[j] = pre</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + pre</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[j]</span><br><span class="line">                    dp[j] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(n)，只需要用一维dp数组记录中间计算状态。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.740.删除并获得点数（中等）</title>
    <url>/LeetCode/LeetCode.740.%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">LeetCode.740.删除并获得点数（中等）</a></p>
<p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于要删除值相邻的元素，可以在脑海里先按元素值对nums数组排序，方便梳理题意，最终求解的东西跟数组顺序也没关系。</p>
<p>删除一个<code>nums[i]</code>获得点数后，所有<code>nums[i] - 1</code>和<code>nums[i] + 1</code>的相邻元素被删除了（不计点数），数组里剩下的所有等于<code>nums[i]</code>的值都还是要逐个主动删除并且计入点数的，因为它们不会因为是某个被删除元素的相邻元素而被删除，因为相邻元素从删除第一个<code>nums[i]</code>就删完了。</p>
<p>所以，假设<code>nums[i]</code>在数组里有<code>c</code>个，删除<code>nums[i]</code>可以获得的点数是<code>nums[i] * c</code>。</p>
<p>可以用一个数组<code>sum</code>记录<code>nums</code>数组中所有相同元素的和，以<code>nums[i]</code>作为<code>sum</code>数组的下标，方便查询点数。即<code>sum[nums[i]] = nums[i] * c</code>。</p>
<p>获取了<code>sum[nums[i]]</code>就不能选取<code>sum[nums[i] - 1]</code>和<code>sum[nums[i] + 1]</code>了，这就转变为打家劫舍的最优化问题。  </p>
<p><code>sum</code>数组的长度为<code>nums数组的最大值 + 1</code>，是一个常数空间，对性能影响可以接受。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteAndEarn</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> maxValue = nums.max()!!</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(maxValue + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            sum[num] += num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until nums.size) &#123;</span><br><span class="line">            cur = maxOf(pre2 + nums[i], pre1)</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.746.使用最小花费爬楼梯（简单）</title>
    <url>/LeetCode/LeetCode.746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">LeetCode.746.使用最小花费爬楼梯（简单）</a></p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最优化问题，往动态规划上考虑，看是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>一般从最终状态做倒推，拆分步骤，列出所有到达最终状态的步骤，看能否拆分为上一个同性质的子问题+有限步骤，拆分步骤的过程得出状态转移方程。</p>
<p>cost数组长度为n，到达楼顶就是到达下标n的地方。<br>设<code>dp[i]</code>表示达到到达下标i所需的最小花费，<code>0 &lt;= i &lt;= n</code>。</p>
<h2 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h2><p>可以从下标为0或1的阶梯开始爬，说明<code>dp[0] = dp[1] = 0</code>。</p>
<h2 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h2><p>达到第i个阶梯，最后一步有两种选择：</p>
<ol>
<li>在第i-1层爬1个阶梯。</li>
<li>在第i-2层爬2个阶梯。</li>
</ol>
<p>到达第i-1层的最小花费是<code>dp[i-1]</code>，爬1个阶梯需要耗费<code>cost[i-1]</code><br>到达第i-2层的最小花费是<code>dp[i-2]</code>，爬2个阶梯需要耗费<code>cost[i-2]</code><br>那么，到达第i层阶梯就是取两者中较小值。</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>dp[i]</code>只与前两项值有关，所以不需要数组，用两个变量保存前面两项值即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">            cur = minOf(pre1 + cost[i - <span class="number">1</span>], pre2 + cost[i - <span class="number">2</span>])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.75.颜色分类（中等）</title>
    <url>/LeetCode/LeetCode.75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/">LeetCode.75.颜色分类（中等）</a></p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="排序解法"><a href="#排序解法" class="headerlink" title="排序解法"></a>排序解法</h3><p>直接用排序算法排序数组即可得到结果。</p>
<p>采用不同的排序算法，时间复杂度和空间复杂度各不同。</p>
<p>如果用基于比较的排序算法，平均时间复杂度最低为O(n * log n)，空间复杂度O(1)，例如快速排序、堆排序。</p>
<p>由于数组元素取值就三种情况，是常数个，可以使用不基于元素比较的线性时间排序算法，如计数排序，时间复杂度O(n)，空间复杂度O(n)。</p>
<h3 id="更优的解法"><a href="#更优的解法" class="headerlink" title="更优的解法"></a>更优的解法</h3><p>由于元素取值只有极少的常数个，可以发现这里元素归位的过程很像快速排序的划分算法，把不同类型的元素放在轴心元素的两边。</p>
<p>如果只有两个颜色（红色和白色），可以直接用划分了，而一次划分时间复杂度是O(n)，空间复杂度O(1)。</p>
<p>快速排序的划分算法：</p>
<ul>
<li>双指针分别指向数组开始和末尾。</li>
<li>左指针遇到白色就与右指针交换元素，把白色放在右边，右指针向左前进一位。</li>
<li>右指针遇到红色就与左指针交换元素，把红色放在左边，左指针向右前进一位。</li>
<li>左右指针相遇后，红色和白色都放置在各自的一边了。</li>
</ul>
<p>划分算法的关键是，遇到不是这个位置的元素，就把它放到属于它的那一类的位置。</p>
<p>可以发现，左指针的左边总是红色元素，右指针的右边总是白色元素。</p>
<p><strong>三个颜色会有什么不同？</strong></p>
<p>那就再增加一个蓝色指针，表示这个指针的左边到红色指针的右边都是蓝色元素。</p>
<p>在用蓝色指针遍历数组时：</p>
<ul>
<li>发现红色元素，放到红色指针左边。</li>
<li>发现白色元素，放到白色指针右边。</li>
<li>发现蓝色元素，已经在自己这边了，前进一个位置。</li>
</ul>
<p>蓝色指针和白色指针相遇后，所有颜色就正确归位了。</p>
<p>最终还是一次线性划分就能解决。<br>时间复杂度O(n)，空间复杂度O(1)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sortColors</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p0 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> p2 = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">when</span>(nums[p1]) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    nums.swap(p0, p1)</span><br><span class="line">                    p0++</span><br><span class="line">                    p1++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    nums.swap(p1, p2)</span><br><span class="line">                    p2--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; p1++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode中等</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.76.最小覆盖子串（困难）</title>
    <url>/LeetCode/LeetCode.76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode.76.最小覆盖子串（困难）</a></p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<span id="more"></span>
<p>注意：</p>
<ul>
<li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li>
<li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在  <code>o(n)</code>  时间内解决此问题的算法吗？</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力朴素法"><a href="#暴力朴素法" class="headerlink" title="暴力朴素法"></a>暴力朴素法</h3><p>设<code>s</code>长度为<code>n</code>，<code>t</code>长度为<code>m</code>。</p>
<p>把<code>t</code>的字符都存在哈希表中，相同字符进行计数。</p>
<p>从<code>s</code>的每一个位置开始，看后面的<code>m</code>个字符是否都在哈希表中，并且相同字符的个数也一样。</p>
<p>这样匹配的时间复杂度是<code>O(mn)</code>，空间复杂度<code>O(m)</code>。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>暴力法有很多重复的判断，所以时间复杂度高，如果能把已经判断过的东西不用再判断了就可以降低时间复杂度。</p>
<p>可以使用滑动窗口，最多也就是滑动窗口的左右边界走完整个字符串，时间复杂度是<code>O(n)</code>的。</p>
<p>算法步骤：</p>
<ol>
<li>不停的扩大窗口，直至窗口中包含了t中所有字符。</li>
<li>不停的缩小窗口，直至窗口中没有包含t中所有字符。</li>
<li>重复上述两步，每一步记录最小的窗口的大小。</li>
</ol>
<p>还是需要把<code>t</code>的字符都存在哈希表中，方便判断窗口中有没有包含t中所有字符，相同字符进行计数。</p>
<p>细节见源码注释。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    滑动窗口两步走:</span></span><br><span class="line"><span class="comment">    1. 不停的扩大窗口，直至窗口中包含了t中所有字符；如果不能再扩大了就不扩大了</span></span><br><span class="line"><span class="comment">    2. 不停的缩小窗口，直至窗口中没有包含t中所有字符，缩小前记录最小的符合答案条件的子串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minWindow</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// S中包含T所有字符的最小子串</span></span><br><span class="line">        <span class="keyword">var</span> minSubstr = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">val</span> window = Window(s, t)</span><br><span class="line">        <span class="keyword">while</span> (window.extend()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (window.match()) &#123;</span><br><span class="line">                <span class="comment">// 有更小的满足答案的窗口，那就要记录下来</span></span><br><span class="line">                <span class="comment">// 但是初始时minSubstr是长度为0，需要特殊对待，因为一旦发现了满足答案的窗口，就要更新记录</span></span><br><span class="line">                <span class="keyword">if</span> (minSubstr.isEmpty() || window.windowSize() &lt; minSubstr.length) &#123;</span><br><span class="line">                    minSubstr = window.windowString()</span><br><span class="line">                &#125;</span><br><span class="line">                window.shorten()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSubstr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>(</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> s: String,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> t: String</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 记录t中所有字符出现的次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> tMap = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口已出现的字符的次数，可以只记录t中存在的字符，t中不存在的字符记录也没啥意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> wMap = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录匹配的字符数量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> matchedCharCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> right = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            t.forEach &#123; c -&gt;</span><br><span class="line">                tMap[c] = <span class="number">1</span> + tMap.getOrDefault(c, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 扩大窗口</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果还能继续扩大返回true，不能再扩大了返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">extend</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 窗口已经滑动到字符串最右侧了</span></span><br><span class="line">            <span class="keyword">if</span> (right == s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            right++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 窗口又增加一个字符</span></span><br><span class="line">            <span class="keyword">val</span> c = s[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">                <span class="comment">// 窗口只记录t中存在的字符，记录t中不存在的字符也没啥意义</span></span><br><span class="line">                wMap[c] = <span class="number">1</span> + wMap.getOrDefault(c, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果窗口内当前字符c的个数已经达到t中c字符的数量，记录匹配的字符数量</span></span><br><span class="line">                <span class="comment">// 字符数量过多不管它，在缩小窗口时一起考虑这个问题</span></span><br><span class="line">                <span class="keyword">if</span> (tMap.containsKey(c) &amp;&amp; tMap[c] == wMap[c]) &#123;</span><br><span class="line">                    matchedCharCount++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口中有字符串t中所有的字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchedCharCount == tMap.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 减少左边界缩短窗口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">shorten</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> c = s[left]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">                wMap[c] = wMap.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 窗口里c字符数量小于t中c的字符数量，匹配字符数量减1</span></span><br><span class="line">                <span class="comment">// 这里感觉有多减的风险，但是其实不会发生，因为一旦不匹配了，就不会再继续缩小窗口了，而是会扩大窗口，所以不用考虑</span></span><br><span class="line">                <span class="keyword">if</span> (wMap[c]!! &lt; tMap[c]!!) &#123;</span><br><span class="line">                    matchedCharCount--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口字符串长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">windowSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">windowString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.84.柱状图中最大的矩形（困难）</title>
    <url>/LeetCode/LeetCode.84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a></p>
<p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><p>暴力法虽然时间复杂度往往比较高，但是可以理清思路。</p>
<p><strong>思路</strong></p>
<p>就是枚举以每个柱子高度作为边长的最大矩形面积。</p>
<p>从每个柱子向左和向右检查是否有相同高度或更高的柱子，统计可以形成的矩形的最大宽度，然后计算面积，记录最大的。</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度<code>O(n ^ 2)</code>：</p>
<ul>
<li>枚举所有柱子需要访问数组所有元素。</li>
<li>一次中心扩散最坏情况下要访问数组所有元素，比如所有柱子高度相同。</li>
</ul>
<p>空间复杂度<code>O(1)</code>：</p>
<ul>
<li>没有额外空间开销</li>
</ul>
<h3 id="暴力法多余的时间开销在哪？"><a href="#暴力法多余的时间开销在哪？" class="headerlink" title="暴力法多余的时间开销在哪？"></a>暴力法多余的时间开销在哪？</h3><p>中心扩散时，当前柱子的向右扩散，和后面柱子的向左扩散，这两个是重复的动作，应该优化。</p>
<h3 id="应该怎么优化时间开销？"><a href="#应该怎么优化时间开销？" class="headerlink" title="应该怎么优化时间开销？"></a>应该怎么优化时间开销？</h3><p>由于要查看每一个柱子高度能够形成多大面积的矩形，所以至少要遍历一次数组。</p>
<p>我们是从左到右遍历数组的，可以想办法避免向右扩散，只向左扩散来计算当前矩形面积，因为左边的柱子已经遍历过了。</p>
<p>那么现在问题变为：</p>
<ul>
<li>遇到什么样的柱子才能向左扩散？</li>
<li>向左扩散时，左边的柱子什么时候计算以它们的高度为矩形边长的面积？</li>
</ul>
<h3 id="遇到什么样的柱子才能向左扩散？"><a href="#遇到什么样的柱子才能向左扩散？" class="headerlink" title="遇到什么样的柱子才能向左扩散？"></a>遇到什么样的柱子才能向左扩散？</h3><ul>
<li>看暴力法中向右扩散的条件是，右边的柱子比当前柱子高，才需要扩散。</li>
<li>那么右边柱子如果比当前柱子矮，就无法向右扩散，只能向左扩散。</li>
</ul>
<h3 id="向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？"><a href="#向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？" class="headerlink" title="向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？"></a>向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？</h3><p>在遇到不能向右扩散的柱子之前，所遍历过的柱子的特点是：它们高度是从左到右递增或相等的，否则就应该向左扩散了。</p>
<p>假设在遍历时，发现当前柱子比前一个柱子矮，设当前柱子是第i个。</p>
<h4 id="以第i-1个柱子高度构成的矩形面积怎么求？"><a href="#以第i-1个柱子高度构成的矩形面积怎么求？" class="headerlink" title="以第i - 1个柱子高度构成的矩形面积怎么求？"></a>以第i - 1个柱子高度构成的矩形面积怎么求？</h4><ul>
<li>要寻找左右边界在哪。</li>
<li>右边界是知道的，就是i，因为第i - 1个柱子的高度不能向右扩散了。</li>
<li>左边界是i - 2，因为第i - 2个柱子到第i - 1个柱子的高度是递增的，第i - 1个柱子的高度不能向左扩散。</li>
</ul>
<h4 id="以第i-2个柱子高度构成的矩形面积怎么求？"><a href="#以第i-2个柱子高度构成的矩形面积怎么求？" class="headerlink" title="以第i - 2个柱子高度构成的矩形面积怎么求？"></a>以第i - 2个柱子高度构成的矩形面积怎么求？</h4><ul>
<li>左边界是i - 3，因为左边柱子高度是递增的。</li>
<li>右边界在哪，要取决于第i - 2个柱子和第i个柱子哪个更高。<ul>
<li>如果第i - 2个柱子比第i个柱子高，右边界是i，因为第i - 2个柱子到第i - 1个柱子的高度是递增的，所以第i - 2个柱子可以把矩形扩散到比它高的柱子下面。</li>
<li>如果第i - 2个柱子比第i个柱子矮，右边界不是i了，因为第i - 2个柱子的高度还可以向右扩散。<ul>
<li>什么时候可以计算以第i - 2个柱子高度的矩形面积呢？要在后面遇到比第i - 2个柱子矮的柱子才行，右边界就是后面那个矮柱子的索引，左边界是i - 3。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应该怎么记录左边柱子的信息？"><a href="#应该怎么记录左边柱子的信息？" class="headerlink" title="应该怎么记录左边柱子的信息？"></a>应该怎么记录左边柱子的信息？</h3><ul>
<li>由于在遇到高度递减的柱子时，会求以左边柱子高度构成的矩形面积，而且并且有的柱子会求有的柱子不会求，所以要记录下所有没有求过矩形面积的柱子索引，并要能添加和移除，需要用一个集合保存。</li>
<li>由于要访问左边柱子的高度，而遍历顺序是从左到右的，所以符合这个数据访问顺序的数据结构是栈。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>计算第一个柱子高度的矩形面积时左边界是-1，取做边界的时候要特殊处理一下。</li>
<li>如果末尾的柱子都是递增的，不会触发向左扩散，需要再遍历结束后手动触发一下。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><ul>
<li>遍历一次数组需要访问n个元素。</li>
<li>虽然访问栈需要往回看，但是入栈的元素都是不重复的，并且每个元素只会访问一次，往回看最多访问n个元素。</li>
</ul>
<h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><p>最坏情况下，数组完全递增，栈最多保存n个元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">largestRectangleArea</span><span class="params">(heights: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = heights.size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">                <span class="keyword">val</span> right = i</span><br><span class="line">                <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">                maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发末尾递增柱子的矩形面积计算</span></span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">val</span> right = n</span><br><span class="line">            <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">            maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.85.最大矩形（困难）</title>
    <url>/LeetCode/LeetCode.85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">LeetCode.85.最大矩形（困难）</a></p>
<p>给定一个仅包含 <code>0</code>  和  <code>1</code>  、大小为  <code>rows x cols</code>  的二维二进制矩阵，找出只包含  <code>1</code>  的最大矩形，并返回其面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果以某一行为横轴，该行以上的列为纵轴区域，问题就转变为<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a>。</p>
<p>某一行下，每一列下，与行相连的1的个数就是柱子高度。</p>
<h3 id="整个求解过程"><a href="#整个求解过程" class="headerlink" title="整个求解过程"></a>整个求解过程</h3><ul>
<li>统计每一行下柱子的高度</li>
<li>带入<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a>的求解公式里求出柱子可以形成的最大矩形面积</li>
<li>然后在所有行的最大矩形面积里取一个最大值。</li>
</ul>
<h3 id="每行柱子高度统计方法优化"><a href="#每行柱子高度统计方法优化" class="headerlink" title="每行柱子高度统计方法优化"></a>每行柱子高度统计方法优化</h3><ul>
<li>如果到达每一行，再往上遍历遍历每列柱子高度，是有重复计算的。</li>
<li>可以保存之前行的柱子高度的结果，在到下一行的时候，发现这一行某一列是1，就累加高度，是0就清空柱子高度，因为无法形成柱子。这样就不用重复计算了。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalRectangle</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> heights = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (col <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) heights[col]++</span><br><span class="line">                <span class="keyword">else</span> heights[col] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> area = largestRectangleArea(heights)</span><br><span class="line">            maxArea = maxOf(maxArea, area)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">largestRectangleArea</span><span class="params">(heights: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = heights.size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">                <span class="keyword">val</span> right = i</span><br><span class="line">                <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">                maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发末尾递增柱子的矩形面积计算</span></span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">val</span> right = n</span><br><span class="line">            <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">            maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-mn"><a href="#时间复杂度O-mn" class="headerlink" title="时间复杂度O(mn)"></a>时间复杂度O(mn)</h4><p>m为矩阵行数，n为矩阵列数。</p>
<ul>
<li>求柱子高度需要遍历矩阵所有元素，所有元素有m*n个。</li>
<li>求每个柱子高度需要O(n)。</li>
</ul>
<h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><ul>
<li>高度数组占用O(n)。</li>
<li>求柱子最大矩形面积需要O(n)的栈。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.87.扰乱字符串（困难）</title>
    <url>/LeetCode/LeetCode.87.%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/scramble-string/">LeetCode.87.扰乱字符串（困难）</a></p>
<p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：</p>
<ul>
<li>如果字符串的长度为 1 ，算法停止</li>
<li>如果字符串的长度 &gt; 1 ，执行下述步骤：<ul>
<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。</li>
<li>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。</li>
<li>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
</ul>
</li>
</ul>
<p>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目描述已经给出了拆解步骤和子问题的划分。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从最后一步开始想：</p>
<ul>
<li>设s1拆解为a1和a2，s2拆解为b1和b2</li>
<li>因拆解后子串顺序有两种，如果s1能扰乱为s2，那么s1和s2对应关系也就有两种：<ul>
<li>a1是否能从b1扰乱来，并且，a2是否能从b2扰乱来；其中<code>a1.length == b1.length &amp;&amp; a2.length == b2.length</code>。</li>
<li>a1是否能从b2扰乱来，并且，a2是否能从b1扰乱来；其中<code>a1.length == b2.length &amp;&amp; a2.length == b1.length</code>。</li>
</ul>
</li>
</ul>
<p>子问题和拆解步骤就出来了。</p>
<h3 id="应该怎么拆解字符串？"><a href="#应该怎么拆解字符串？" class="headerlink" title="应该怎么拆解字符串？"></a>应该怎么拆解字符串？</h3><p>穷举所有可以拆解的位置</p>
<h3 id="有哪些状态？"><a href="#有哪些状态？" class="headerlink" title="有哪些状态？"></a>有哪些状态？</h3><ul>
<li>拆解字符串需要知道起始索引和结束索引。</li>
<li>有两个字符串，也就有4个状态。</li>
<li>但是拆解过后的子串长度是相等的，所以可以不记录两个结束索引，只记录拆解的子串长度，缩减为3个状态。</li>
</ul>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li>如果两个字符串长度不相等，两者无法通过扰乱变为一致。</li>
<li>如果两个字符串长度相等，但每种字符个数不相等，两者无法通过扰乱变为一致。</li>
<li>拆到只有一个字符的时候，直接判断字符是否相同。</li>
</ul>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> s1CharCountMap = s1.groupingBy&#123;it&#125;.eachCount()</span><br><span class="line">        <span class="keyword">val</span> s2CharCountMap = s2.groupingBy&#123;it&#125;.eachCount()</span><br><span class="line">        <span class="keyword">if</span> (s1CharCountMap != s2CharCountMap) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> a1 = s1.substring(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> a2 = s1.substring(i + <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">val</span> b1 = s2.substring(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> b2 = s2.substring(i + <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (isScramble(a1, b1) &amp;&amp; isScramble(a2, b2)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (isScramble(a1, b2) &amp;&amp; isScramble(a2, b1)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度指数级别</p>
</blockquote>
<h3 id="指针递归"><a href="#指针递归" class="headerlink" title="指针递归"></a>指针递归</h3><p>上面的递归解法非常直白，但是不方便存储中间计算结果，子串改成指针形式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1[i1, i1 + length - 1]和s2[i2, i2 + length - 1]是否有一样的字符和字符个数</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hasSameChars</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> counts = IntArray(<span class="number">26</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i1 until i1 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s1[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i2 until i2 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s2[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counts.sum() == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">1</span>) <span class="keyword">return</span> s1[i1] == s2[i2]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 词频不一样，肯定不能转换</span></span><br><span class="line">            <span class="keyword">if</span> (!hasSameChars(i1, i2, length)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k为s1和s2分割出来的左半部分的长度</span></span><br><span class="line">            <span class="comment">// 左子串最短长度为1</span></span><br><span class="line">            <span class="comment">// 左子串最长长度为length - 1，因为要留一个长度给右子串</span></span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2, k) &amp;&amp; test(i1 + k, i2 + k, length - k)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2 + length - k, k) &amp;&amp; test(i1 + k, i2, length - k)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test(<span class="number">0</span>, <span class="number">0</span>, n) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h3><p>暴力递归有重叠子问题，需要记录中间计算状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1[i1, i1 + length - 1]和s2[i2, i2 + length - 1]是否有一样的字符和字符个数</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hasSameChars</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> counts = IntArray(<span class="number">26</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i1 until i1 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s1[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i2 until i2 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s2[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counts.sum() == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; Array(n) &#123; IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2][length] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> matched = s1[i1] == s2[i2]</span><br><span class="line">                memo[i1][i2][length] = <span class="keyword">if</span> (matched) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> matched</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 词频不一样，肯定不能转换</span></span><br><span class="line">            <span class="keyword">if</span> (!hasSameChars(i1, i2, length)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k为s1和s2分割出来的左半部分的长度</span></span><br><span class="line">            <span class="comment">// 左子串最短长度为1</span></span><br><span class="line">            <span class="comment">// 左子串最长长度为length - 1，因为要留一个长度给右子串</span></span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2, k) &amp;&amp; test(i1 + k, i2 + k, length - k)) &#123;</span><br><span class="line">                    memo[i1][i2][length] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2 + length - k, k) &amp;&amp; test(i1 + k, i2, length - k)) &#123;</span><br><span class="line">                    memo[i1][i2][length] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test(<span class="number">0</span>, <span class="number">0</span>, n) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度O-n-4"><a href="#时间复杂度O-n-4" class="headerlink" title="时间复杂度O(n^4)"></a>时间复杂度O(n^4)</h3><ul>
<li>递归会枚举所有length的取值情况，1 &lt;= length &lt;= n。</li>
<li>对于每个length枚举了左子串字符数k的所有取值可能，1 &lt;= k &lt;= length。</li>
<li>递归枚举了所有i1的取值情况，0 &lt;= i1 &lt;= n - 1</li>
<li>递归枚举了所有i2的取值情况，0 &lt;= i2 &lt;= n - 1</li>
</ul>
<h3 id="空间复杂度O-n-3"><a href="#空间复杂度O-n-3" class="headerlink" title="空间复杂度O(n^3)"></a>空间复杂度O(n^3)</h3><p>状态存储是三维数组。</p>
<h3 id="自底向上的动态规划"><a href="#自底向上的动态规划" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h3><p>记忆化递归的备忘录数组的填充过程已经给出了状态转移方程。</p>
<p>设<code>dp[i][j][len]</code>代表  <code>s1</code>  从  <code>i</code>  开始，<code>s2</code>  从  <code>j</code>  开始，后面长度为  <code>len</code>  的字符是否能形成扰乱字符串。</p>
<p><strong>状态转移方程</strong></p>
<p>设<code>s1</code>的左子串的长度为<code>k</code>。</p>
<p><code>dp[i][j][len] = dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k] || dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]</code></p>
<p><strong>边界情况</strong></p>
<p>长度为1时，只需要判断字符是否相同。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = s1[i] == s2[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k] || dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]) &#123;</span><br><span class="line">                            dp[i][j][len] = <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.91.解码方法（中等）</title>
    <url>/LeetCode/LeetCode.91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/decode-ways/">LeetCode.91.解码方法（中等）</a></p>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<blockquote>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
</blockquote>
<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<ul>
<li>“AAJF” ，将消息分组为 (1 1 10 6)</li>
<li>“KJF” ，将消息分组为 (11 10 6)</li>
</ul>
<p>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>思考能否将某个状态下的问题拆分为子问题+有限步骤。</p>
<p>设<code>a[i]</code>为<code>s[0..i]</code>中解码方法总数。</p>
<h2 id="a-i-取值受什么影响？"><a href="#a-i-取值受什么影响？" class="headerlink" title="a[i]取值受什么影响？"></a>a[i]取值受什么影响？</h2><p>受<code>s[i - 1]</code>和<code>s[i - 2]</code>的取值影响，因为要决定是解析一个字符还是两个字符。<br><code>a[i]</code>可以通过<code>a[i - 1]</code>或<code>a[i - 2]</code>递推而来。</p>
<h2 id="s-i-1-和s-i-2-组合的数有哪些情况？"><a href="#s-i-1-和s-i-2-组合的数有哪些情况？" class="headerlink" title="s[i - 1]和s[i - 2]组合的数有哪些情况？"></a><code>s[i - 1]</code>和<code>s[i - 2]</code>组合的数有哪些情况？</h2><p>根据题意，没有直接映射到0的情况，要注意：</p>
<ol>
<li>不能单独映射0，只能作为10或者20整体解析，方案数不变，<code>a[i] = a[i - 1]</code>。一旦出现0的前面不是1或2，整个s无法解析，直接返回0方案数。</li>
<li>06这样的0处在十位数的也不能作为个位数解析，只能一个个解析，方案数不变，<code>a[i] = a[i - 1]</code></li>
</ol>
<p>两个数字剩余的合法取值范围在[11, 19]、[21, 26]，此时可以映射一个字母，也可以映射两个字母。<br><code>a[i] = a[i - 1] + a[i - 2]</code></p>
<p>其他大于26的情况，只能映射一个字母，方案数不变，<code>a[i] = a[i - 1]</code></p>
<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p><code>a[i]</code>只与前两个状态有关，只用两个保存状态即可，不需要数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numDecodings</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始的一个字符只有一种映射方案</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始时，前两个字符的解析方案数</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> num = parseInt(s[<span class="number">0</span>], s[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cur = pre</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第3个字符开始解析</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> num = parseInt(s[i - <span class="number">1</span>], s[i])</span><br><span class="line">                <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) pre + prepre <span class="keyword">else</span> pre</span><br><span class="line">            &#125;</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(a: <span class="type">Char</span>, b: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tens = (a.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()) * <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> units = b.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line">        <span class="keyword">return</span> tens + units</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.918.环形子数组的最大和（中等）</title>
    <url>/LeetCode/LeetCode.918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">LeetCode.918.环形子数组的最大和（中等）</a></p>
<p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p>
<p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，且当 i &gt;= 0 时 C[i+A.length] = C[i]）</p>
<p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="环形数组跟非环形数组的区别是什么？"><a href="#环形数组跟非环形数组的区别是什么？" class="headerlink" title="环形数组跟非环形数组的区别是什么？"></a>环形数组跟非环形数组的区别是什么？</h2><p>环形数组中最终求得的最大和子数组有两种情况</p>
<ol>
<li>数组A的首尾元素不会连接</li>
<li>数组A的首尾元素会连接</li>
</ol>
<h2 id="数组A的首尾元素不会连接的情况如何求解？"><a href="#数组A的首尾元素不会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素不会连接的情况如何求解？"></a>数组A的首尾元素不会连接的情况如何求解？</h2><p>第1种情况就是非环形数组的普通求法，参与计算的区间为<code>[0, n - 1]</code></p>
<h2 id="数组A的首尾元素会连接的情况如何求解？"><a href="#数组A的首尾元素会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素会连接的情况如何求解？"></a>数组A的首尾元素会连接的情况如何求解？</h2><p>第2种情况不好用非环形数组的方法求解，实际观察结果可以得到等价情况：先求出中间部分的子数组的最小和，再用整个数组A的和减去中间的最小和就是两端首尾相连的子数组的最大和。<br>这时只在数组A的<code>[1, n - 2]</code>区间求解，这才能保证首尾不连接。</p>
<h2 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubarraySumCircular</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMaxSumInLinearCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = maxOf(pre + nums[i], nums[i])</span><br><span class="line">                maxSum = maxOf(maxSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMinSumInCyclicCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minSum = nums[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = minOf(pre + nums[i], nums[i])</span><br><span class="line">                minSum = minOf(minSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            getMaxSumInLinearCase(), </span><br><span class="line">            nums.sum() - getMinSumInCyclicCase()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.931.下降路径最小和（中等）</title>
    <url>/LeetCode/LeetCode.931.%20%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">LeetCode.931.下降路径最小和（中等）</a></p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最值问题考虑动态规划，拆分大问题为子问题+有限步骤。</p>
<p>下降路径在第一行任何元素都能开始。</p>
<p>针对第一行某个元素，要选取左下方、正下方、右下方三条向下路径中和最小的路径的和，再加上当前元素的值，就是当前元素开始的下降路径的最小和。<br>第二行每个元素的和最小的下降路径求法一样，直到最后一行。</p>
<p>第一行每个元素的下降路径最小和都逐个求出后，选取一个最小的。</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>设<code>dp[r][c]</code>是第r行第c列下降路径最小和。<br><code>dp[r][c] = matrix[r][c] + minOf(dp[r + 1, c - 1], dp[r + 1, c], dp[r + 1, c + 1])</code></p>
<h2 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h2><ul>
<li>最后一行，没有下面一行了<br><code>dp[r][c] = matrix[r][c]</code></li>
<li>第一列，只能读取下方和右下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c], dp[r + 1, c + 1])</code></li>
<li>最后一列，只能读取下方和左下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c - 1], dp[r + 1, c])</code></li>
</ul>
<h2 id="递推顺序"><a href="#递推顺序" class="headerlink" title="递推顺序"></a>递推顺序</h2><p>从下往上</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> dp = Array(rows) &#123; IntArray(columns) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            dp[rows - <span class="number">1</span>][c] = matrix[rows - <span class="number">1</span>][c]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                dp[r][c] = matrix[r][c] + </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, dp[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p>因为是逐行递推的，所以可以用原数组存储，不用额外开辟二维数组。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                matrix[r][c] += </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, matrix[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.931.下降路径最小和（中等）</title>
    <url>/LeetCode/LeetCode.931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">LeetCode.931.下降路径最小和（中等）</a></p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，拆分大问题为子问题+有限步骤。</p>
<p>下降路径在第一行任何元素都能开始。</p>
<p>针对第一行某个元素，要选取左下方、正下方、右下方三条向下路径中和最小的路径的和，再加上当前元素的值，就是当前元素开始的下降路径的最小和。<br>第二行每个元素的和最小的下降路径求法一样，直到最后一行。</p>
<p>第一行每个元素的下降路径最小和都逐个求出后，选取一个最小的。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是第r行第c列下降路径最小和。<br><code>dp[r][c] = matrix[r][c] + minOf(dp[r + 1, c - 1], dp[r + 1, c], dp[r + 1, c + 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>最后一行，没有下面一行了<br><code>dp[r][c] = matrix[r][c]</code></li>
<li>第一列，只能读取下方和右下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c], dp[r + 1, c + 1])</code></li>
<li>最后一列，只能读取下方和左下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c - 1], dp[r + 1, c])</code></li>
</ul>
<h3 id="递推顺序"><a href="#递推顺序" class="headerlink" title="递推顺序"></a>递推顺序</h3><p>从下往上</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> dp = Array(rows) &#123; IntArray(columns) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            dp[rows - <span class="number">1</span>][c] = matrix[rows - <span class="number">1</span>][c]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                dp[r][c] = matrix[r][c] + </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, dp[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>因为是逐行递推的，所以可以用原数组存储，不用额外开辟二维数组。</p>
<h3 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                matrix[r][c] += </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, matrix[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.96.不同的二叉搜索树（中等）</title>
    <url>/LeetCode/LeetCode.96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode.96.不同的二叉搜索树（中等）</a></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<blockquote>
<p>提示：  <code>1 &lt;= n &lt;= 19</code></p>
</blockquote>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树的问题第一反应会想到递归，进而想到能不能划分子问题。</p>
<p>从基本情况开始梳理。<br>构造一棵树，要选一个根节点。<br>如果以某个数字为根节点，左子树有a种，右子树有b种，那么这棵树就有a * b种可能。</p>
<p>左子树和右子树的构建，也要选择根节点，选择逻辑一样，可以递归进行，但是能选的根节点数量少了一个。</p>
<p>递推下去可以发现，如果剩余可选节点数越少，种数就越少。</p>
<p>设<code>sum[i]</code>为节点总数为<code>i</code>的二叉搜索树的种数。<br>除去根节点，假设左子树有<code>j</code>个节点，右子树就有<code>i - 1 - j</code>个节点，其中<code>j</code>的取值范围是<code>0 &lt;= j &lt;= i - 1</code>，得把所有的<code>j</code>可能情况都取一遍值，最后累加结果，就得到<code>sum[i]</code>。</p>
<p><strong>状态转移方程</strong><br><code>sum[i]= ∑ sum[j] * sum[i - 1 - j]</code>，<code>0 &lt;= j &lt;= i - 1</code></p>
<p><strong>边界处理</strong><br>总共只有0个节点，是空树，也算一种树，<code>sum[0] = 1</code>。想象一下如果左子树为空，右子树有n种，那么当前树也应该有n种。<br>总共只有1个节点，只有一种情况，<code>sum[1] = 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        sum[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                sum[i] += sum[j] * sum[i - <span class="number">1</span> - j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-CAS</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CAS/</url>
    <content><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源</p>
<p>所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁更新方式认为：在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。</p>
<p>但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。</p>
<p>CAS机制就是乐观锁的典型实现。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p>
<ul>
<li>  主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li>
<li>  工作内存中共享变量的副本值，也叫预期值：A</li>
<li>  需要将共享变量更新到的最新值：B</li>
</ul>
<h1 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h1><ol>
<li> 可以保证变量操作的原子性；</li>
<li> 并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li>
<li> 在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li>
</ol>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p>
<h2 id="可能会消耗较高的CPU"><a href="#可能会消耗较高的CPU" class="headerlink" title="可能会消耗较高的CPU"></a>可能会消耗较高的CPU</h2><p>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
<h2 id="不能保证代码块的原子性"><a href="#不能保证代码块的原子性" class="headerlink" title="不能保证代码块的原子性"></a>不能保证代码块的原子性</h2><p>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-CyclicBarrier</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-CyclicBarrier/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul>
<li>CyclicBarrier构造函数传入一个数字N。</li>
<li>线程调用CyclicBarrier.await()会阻塞等待，直到有第N个线程调用CyclicBarrier.await()，所有线程一起执行await()方法后续逻辑。</li>
<li>再次调用await()可以继续这一波操作，循环使用。</li>
</ul>
<p>比喻：</p>
<ul>
<li>人到齐了一起走，没到齐每个人都一直等着不走。</li>
<li>走完了过后，下一波人来了继续这个流程。</li>
</ul>
<p>可循环利用的屏障。</p>
<p>举例：</p>
<p>CyclicBarrier barrier = new CyclicBarrier(5);</p>
<p>然后各个线程调用barrier.await();</p>
<p>当有5个线程await()过后，会继续执行await()后续代码</p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>调用CyclicBarrier的await()方法，通过ReentrantLock先加锁，然后用Condition的await实现等待。</p>
<p>每次调用await()会计数，当第个N个线程执行await()后，会对Condition对象signalAll()来让所有等待线程的继续执行。</p>
<p>然后重新计数，继续同样的过程。</p>
<h1 id="CountDownLatch和CyclicBarrier区别？"><a href="#CountDownLatch和CyclicBarrier区别？" class="headerlink" title="CountDownLatch和CyclicBarrier区别？"></a>CountDownLatch和CyclicBarrier区别？</h1><p>CountDownLatch主要是实现了1个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行操作，描述的是1个线程或N个线程等待其他线程的关系。</p>
<p>CyclicBarrier主要是实现了多个线程之间相互等待，直到所有的线程都满足了条件之后各自才能继续执行后续的操作，描述的多个线程内部相互等待的关系。</p>
<p>CountDownLatch是一次性的，而CyclicBarrier则可以被重置而重复使用。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>CyclicBarrier</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-ReadWriteLock、StampedLock</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ReadWriteLock%E3%80%81StampedLock/</url>
    <content><![CDATA[<h1 id="读写锁存在的意义？解决了什么问题？"><a href="#读写锁存在的意义？解决了什么问题？" class="headerlink" title="读写锁存在的意义？解决了什么问题？"></a>读写锁存在的意义？解决了什么问题？</h1><p>synchronzied和ReentraintLock的锁是排他锁，同一时刻只允许一个线程访问同一个资源。</p>
<p>然而在读多写少的情况下，排他锁会让多个并发的读之间互斥，但多个线程同时读不会影响数据的一致性，写的时候保证获取的是排他锁保证数据一致性即可。</p>
<p>也就是读与读之间不互斥，写与读、写与写之间互斥。</p>
<p>这样的话就提高了系统整体的吞吐量。</p>
<h1 id="ReentraintReadWriteLock实现原理是什么？"><a href="#ReentraintReadWriteLock实现原理是什么？" class="headerlink" title="ReentraintReadWriteLock实现原理是什么？"></a>ReentraintReadWriteLock实现原理是什么？</h1><p>内部有ReadLock和WriteLock两个类，分别实现读锁和写锁。</p>
<p>两个Lock类里是通过Sync来实现锁的语义，Sync类继承AQS，并且分为非公平实现和公平的实现。</p>
<p>由于AQS的state是int类型的变量，在内存中占用4个字节，也就是32位。将其拆分为两部分：高16位和低16位，其中高16位用来表示读锁的个数，低16位用来表示写锁重入次数。</p>
<p>当设置读锁成功时，就将高16位加1，释放读锁时，将高16位减1；当设置写锁成功时，就将低16位加1，释放写锁时，将第16位减1。如下图所示。</p>
<p>这样读锁和写锁就可以都通过CAS去操作同一个state变量，实现读和写之间的互斥。</p>
<h1 id="读写锁适用场景？"><a href="#读写锁适用场景？" class="headerlink" title="读写锁适用场景？"></a>读写锁适用场景？</h1><p>读多写少，又需要保持线程安全，可以有效提高吞吐量。</p>
<h1 id="StampedLock解决了什么问题？"><a href="#StampedLock解决了什么问题？" class="headerlink" title="StampedLock解决了什么问题？"></a>StampedLock解决了什么问题？</h1><p>ReentraintReadWriteLock读写锁在读多写少的情况下，必须要等待所有读锁释放才能获取写锁，可能会导致写饥饿，写可能要等待很久，这是一种悲观的读锁。</p>
<p>正确的做法应该是，如果检测到有写入，已经获取读锁的线程不应该继续读了，把读锁让出来，给写入线程优先执行，写入完成了再读，这样就不会写饥饿了。</p>
<p>StampedLock做的就是，先不加锁的读数据，读完了检测一下是否有线程写过数据了，有写过数据则需要重新读最新的数据，并且要加悲观读锁读，以阻止新的写入锁获取，确保读的数据一定是最新修改的。</p>
<p>更通俗的讲就是在读锁没有释放的时候是可以获取到一个写锁，获取到写锁之后，读锁阻塞，这一点和读写锁一致，唯一的区别在于读写锁不支持在没有释放读锁的时候获取写锁。</p>
<h1 id="StampedLock如何检测是否有数据写入？"><a href="#StampedLock如何检测是否有数据写入？" class="headerlink" title="StampedLock如何检测是否有数据写入？"></a>StampedLock如何检测是否有数据写入？</h1><p>在第一次读数据之前先从StampedLock获取一个stamp，如果有数据写入，StampedLock里的stamp就会变，然后第一次读数据后，检测stamp变了说明有写入。</p>
<h1 id="StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？"><a href="#StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？" class="headerlink" title="StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？"></a>StampedLock第二次加悲观读锁读数据不还是有同样的写饥饿问题吗？</h1><p>确实面临同样的问题，但这种情况发生的概率很小，因为StampedLock使用场景就是读多写少，检测到有写操作后，可以认为大概率之后的一段时间是不会有写操作发生的。</p>
<h1 id="StampedLock如何解决ABA问题？"><a href="#StampedLock如何解决ABA问题？" class="headerlink" title="StampedLock如何解决ABA问题？"></a>StampedLock如何解决ABA问题？</h1><p>StampedLock用一个long类型的state变量保存锁的状态，其中state的低7位存储读锁的个数，第8位存储写锁的标志，第8位为0表示没有获取到写锁，第8位为1表示已获取到写锁。</p>
<p>每次获取和释放写锁，都会给state加上1000 0000，也就是在state的第8位上加1，这样在高位就产生了进位，每次获取写锁后state的值都不一样，这样就可以知道发生了ABA。</p>
<p>long总共有64位，高位一共有64-8=56位，一共可以记录2的55次方种状态。</p>
<h1 id="StampedLock为什么不设计为可重入？"><a href="#StampedLock为什么不设计为可重入？" class="headerlink" title="StampedLock为什么不设计为可重入？"></a>StampedLock为什么不设计为可重入？</h1><p>StampedLock为了解决ABA问题，state变量低7位记录读锁个数，第8位记录是否获取了写锁，第9位到第64位记录了写锁的状态，没有地方存储写锁的重入次数。</p>
<p>对比ReentraintReadWriteLock的实现原理，其实也可以在state的高位中划分一部分区域记录写锁的重入次数。</p>
<h1 id="StampedLock的锁升级是为了解决什么问题？"><a href="#StampedLock的锁升级是为了解决什么问题？" class="headerlink" title="StampedLock的锁升级是为了解决什么问题？"></a>StampedLock的锁升级是为了解决什么问题？</h1><p>有时候写数据只在数据处于特定的条件下才去更改，也就是有可能不修改数据，那如果一开始先获取写锁就会阻碍读锁的获取，吞吐量降低，所以得先获取读锁，判断符合特定条件后，确定需要写入了，再获取写锁，此时就是锁的升级，把读锁释放升级为写锁，前提是当前只有一个读锁；</p>
<p>如果有多个读锁，升级就失败，转为获取正常的写锁，获取不到就阻塞当前线程。</p>
<h1 id="StampedLock有什么缺点？"><a href="#StampedLock有什么缺点？" class="headerlink" title="StampedLock有什么缺点？"></a>StampedLock有什么缺点？</h1><ol>
<li> 不可重入</li>
<li> 不支持Condition</li>
<li> 不支持公平竞争</li>
</ol>
<p>所以也不能完全替代synchronized和ReentrantLock。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>AQS</tag>
        <tag>ReadWriteLock</tag>
        <tag>StampedLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-Semaphore</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-Semaphore/</url>
    <content><![CDATA[<h1 id="Semaphore作用"><a href="#Semaphore作用" class="headerlink" title="Semaphore作用"></a>Semaphore作用</h1><p>如果限定某些资源最多有N个线程可以访问，那么超过N个则不允许再有线程来访问。<br>同时当现有线程结束后，就会释放，然后允许新的线程进来。</p>
<p>类似于锁的lock与 unlock过程 ，区别在于Semaphore多加锁和解锁是计数的。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">semaphore.release(); <span class="comment">// 释放一个许可</span></span><br></pre></td></tr></table></figure>
<p>Semephore构造函数传入0，也可以release进行+1</p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>Semaphore构造函数传递的值会保存在AQS的state变量中</p>
<p>调用acquire方法，尝试给state减1，如果state变为负数，就会阻塞当前线程，把当前线程作为结点插入到AQS队列中。如果state不为负数，则继续执行线程的后续代码。</p>
<p>调用release方法，会给state加1，如果AQS队列里有等待的线程，就唤醒等待的线程，并把结点移除队列。</p>
<h1 id="3个线程交替打印123456789…"><a href="#3个线程交替打印123456789…" class="headerlink" title="3个线程交替打印123456789…"></a>3个线程交替打印123456789…</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s1.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;T1: &quot;</span> + n);</span><br><span class="line">                        n++;</span><br><span class="line">                        s2.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s2.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;T2: &quot;</span> + n);</span><br><span class="line">                        n++;</span><br><span class="line">                        s3.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s3.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;T3: &quot;</span> + n);</span><br><span class="line">                        n++;</span><br><span class="line">                        s1.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>AQS</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-ThreadLocal原理</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-ThreadLocal%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="ThreadLocal作用"><a href="#ThreadLocal作用" class="headerlink" title="ThreadLocal作用"></a>ThreadLocal作用</h1><p>让不同的线程持有相同数据类型的不同的数据副本。</p>
<h1 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h1><p>如果一个对象在多线程之间通过加锁竞争的共享，会引起较大的性能损失，且对象占用内存不是很大的情况下，就应该考虑用ThreadLocal为每个线程分配单独的对象。比如多线程下产生随机数，可以写代码打印耗时，验证这一点。</p>
<h1 id="ThreadLocal实现原理简述"><a href="#ThreadLocal实现原理简述" class="headerlink" title="ThreadLocal实现原理简述"></a>ThreadLocal实现原理简述</h1><p>set(value)</p>
<p>每个线程都有一个ThreadLocalMap，set时会先取当前线程的ThreadLocalMap，以当前的ThreadLocal对象为key，存储value。</p>
<p>get()</p>
<p>从当前的线程的TheadLocalMap中取数据，key为ThreadLocal对象。</p>
<p>ThreadLocalMap是自定义的哈希表，用一个table数组来存储key value，key value被封装在一个Entry对象中，Entry对象是继承WeakReference，WeakReference引用了ThreadLocal对象，ThreadLocal对象没有别的地方引用的时候，在垃圾回收触发时就可以回收了，value是被Entry类强引用的，而Entry类是被ThreadLocalMap中的table数组强引用的，所以value有内存泄露的风险，特别是线程池的核心线程是会一直运行的，线程对象一直存在，ThreadLocalMap也就一直存在，Entry对象中value也就一直不会释放，所以ThreadLocal如果用完了，最好及时remove()掉。</p>
<p>如果没有手动remove清理，ThreadLocalMap也会在get()和set()的时候去清理掉过期的Entry对象，但如果你不调用set和get就不会回收了。特别的，在set()方法做清理的时候做了一个优化，会以对数级别的时间复杂度跳跃式的扫描整个数组，来去寻找过期的Entry对象，这样避免全表扫描，又保证垃圾不会堆积过多。</p>
<p>ThreadLocalMap也有扩容机制，当存储元素个数超过数组长度的2/3后，会把数组扩容为原来的2倍。</p>
<p>table数组的大小始终是2的次方，保持2的次方的大小，是为了计算索引时能够散列的比较均匀。</p>
<p>key value应该存储在数组的哪个索引位置是怎么计算的呢？</p>
<p>首先获取Key对象的hashCode，然后与数组容量-1这个数做与操作得到索引，数组容量是2的次方，减1后的数字的二进制低位全部都是1，跟key的hashCode做与操作，相当于截取了hashCode的低位，散列会比较均匀，如果数组容量不是2的次方，容量-1的这个数的二进制数在低位中就会有0，再与key的hashCode做与操作会导致元素堆积也就是是散列冲突。</p>
<p>在ThreadLocalMap中，key对象hashCode获取并不是调用ThreadLocal对象的hashCode方法，而是使用ThreadLocal中定义的一个静态变量的值，每当创建一个ThreadLocal对象时，这个静态变量就增加固定的值，这个固定的值很特殊，它是一个黄金分割数，带来的效果就是让散列比较均匀。</p>
<p>如果发生了哈希冲突，采用的是线性探测来解决，就是一个个往数组后面去寻找有没有没有被填充的空位来存储。这里有个特别的地方，就是清理过期的Entry的时候，会重新哈希过期的Entry对象后面的Entry对象，因为后面的这些Entry对象可能是有哈希冲突经过线性探测放在了后面，放在后面后查找次数也就多了，重新rehash计算索引，把Entry对象往前方，也就是尽可能减少线性探测的查找次数，提高访问速度。</p>
<p>为什么不用拉链法解决散列冲突呢？因为拉链法链表结点中的指针占用额外空间，如果把这些空间用来增大表容量，可以使得装载因子变小，从而减少开放寻址冲突，提高平均查找效率，效果也是类似的。同时ThreadLocal数据量也不会特别大，所以不需要红黑树来处理极端情况。</p>
<hr>
<h1 id="ThreadLocalMap是做什么的？"><a href="#ThreadLocalMap是做什么的？" class="headerlink" title="ThreadLocalMap是做什么的？"></a>ThreadLocalMap是做什么的？</h1><p>自定义的简单的哈希表的实现，散列方式是开放定址法之线性探测。</p>
<h1 id="ThreadLocalMap数据结构"><a href="#ThreadLocalMap数据结构" class="headerlink" title="ThreadLocalMap数据结构"></a>ThreadLocalMap数据结构</h1><p>Entry数组存储数据</p>
<ol>
<li> Entry类是一个WeakReference</li>
<li> Entry类存储了ThreadLocal这个key和对应的value</li>
<li> 对ThreadLocal持有弱引用，对value持有强引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TheadLocal如何保证唯一性？"><a href="#TheadLocal如何保证唯一性？" class="headerlink" title="TheadLocal如何保证唯一性？"></a>TheadLocal如何保证唯一性？</h1><p>ThreadLocal作为映射表的Key，需要具备唯一的标识，每创建一个新的ThreadLocal，这个标识就变的跟之前不一样了。 如何保证每一个ThreadLocal的唯一性呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 每一个ThreadLocal对象的HashCode都不一样</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 下一个HashCode，是在已有基础上增加0x61c88647</span></span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal内部有一个名为threadLocalHashCode的变量，每创建一个新的ThreadLocal对象，这个变量的值就会增加0x61c88647。 正是因为有这么一个神奇的数字，它能够保证生成的Hash值可以均匀的分布在0~(2^N-1)之间，N是数组长度。 更多关于数字0x61c88647，可以参考<a href="https://www.javaspecialists.eu/archive/Issue164.html">Why 0x61c88647?</a></p>
<h1 id="ThreadLocalMap如何计算value应该存在table数组中哪个索引位置？"><a href="#ThreadLocalMap如何计算value应该存在table数组中哪个索引位置？" class="headerlink" title="ThreadLocalMap如何计算value应该存在table数组中哪个索引位置？"></a>ThreadLocalMap如何计算value应该存在table数组中哪个索引位置？</h1><p>Map的key是ThreadLocal</p>
<p>用ThreadLocal的属性threadLocalHashCode跟table数组长度做与运算得到索引位置</p>
<p>参考ThreadLocalMap的set()方法</p>
<h1 id="ThreadLocalMap如何解决哈希冲突"><a href="#ThreadLocalMap如何解决哈希冲突" class="headerlink" title="ThreadLocalMap如何解决哈希冲突"></a>ThreadLocalMap如何解决哈希冲突</h1><p>开放定址法之线性探测法</p>
<p>求得索引后，table数组中当前索引有Entry，并且Entry的key不为null，则继续看数组的下一个位置是不是空的</p>
<p>参考ThreadLocalMap的set()方法</p>
<h1 id="ThreadLocalMap的table数组空间不够放了怎么办？"><a href="#ThreadLocalMap的table数组空间不够放了怎么办？" class="headerlink" title="ThreadLocalMap的table数组空间不够放了怎么办？"></a>ThreadLocalMap的table数组空间不够放了怎么办？</h1><p>一句话：</p>
<p>添加元素时如果已存储的元素个数超过装载因子就扩容为原容量的两倍</p>
<p>set()方法里会检查当前的存储的对象个数是否已经超出了阈值（threshold的值）大小，如果超出了，需要重新对table数组扩容为原来的2倍长度，并将所有的对象重新计算位置（rehash函数来实现），顺便清理掉Entry.get()为null的Entry，threshold为table数组长度的2/3，threshold相当于是map的装载因子。</p>
<h1 id="ThreadLocalMap-expungeStaleEntry-int-staleSlot-做了什么？"><a href="#ThreadLocalMap-expungeStaleEntry-int-staleSlot-做了什么？" class="headerlink" title="ThreadLocalMap.expungeStaleEntry(int staleSlot)做了什么？"></a>ThreadLocalMap.expungeStaleEntry(int staleSlot)做了什么？</h1><p>table数组中staleSlot位置的Entry的get()为null了，value不为null，在expungeStaleEntry()中把它的value置为null，size–</p>
<p>然后从staleSlot位置的下一个位置线性检查Entry，一直到Entry为null结束，如果</p>
<ol>
<li> Entry.get()为null，则把Entry的value置空，防止内存泄露</li>
<li> Entry.get()不为null，重新计算当前Entry的索引，也就是rehash，放入rehash过后的索引位置，如果有冲突（已经存放了Entry）就线性向后查找空位进行存放。这样做是为了减少哈希冲突时线性查找次数。</li>
</ol>
<hr>
<h1 id="ThreadLocalMap-cleanSomeSlots-int-staleSlot-做了什么？"><a href="#ThreadLocalMap-cleanSomeSlots-int-staleSlot-做了什么？" class="headerlink" title="ThreadLocalMap.cleanSomeSlots(int staleSlot)做了什么？"></a>ThreadLocalMap.cleanSomeSlots(int staleSlot)做了什么？</h1><p>在新元素添加进来，或清理另一个过期的Entry时调用</p>
<p>对数级别时间复杂度清理对象，避免添加元素时线性扫描整个table数组，也防止垃圾堆积过多</p>
<h1 id="TheadLocal存在有什么问题？为什么？如何解决？"><a href="#TheadLocal存在有什么问题？为什么？如何解决？" class="headerlink" title="TheadLocal存在有什么问题？为什么？如何解决？"></a>TheadLocal存在有什么问题？为什么？如何解决？</h1><p>问题：可能会内存泄露</p>
<p>为什么：因为ThreadLocal存储在ThreadLocalMap是弱引用，ThreadLocal被回收后，Entry还是被ThreadLocalMap的table数组引用，Entry的value是强引用，value可能会内存泄漏</p>
<p>解决：使用完ThreadLocal手动调用一下remove()</p>
<h1 id="TheadLocal有哪些典型使用到的地方？"><a href="#TheadLocal有哪些典型使用到的地方？" class="headerlink" title="TheadLocal有哪些典型使用到的地方？"></a>TheadLocal有哪些典型使用到的地方？</h1><ol>
<li> 每个线程都有一个自己的Looper对象</li>
<li> Android SQLiteDatabase中数据库连接每个线程都持有一个</li>
<li> 用户session对话</li>
</ol>
<p>ThreadLocal 适用于如下两种场景</p>
<ol>
<li> 每个线程需要有自己单独的实例</li>
<li> 实例需要在多个方法中共享，但不希望被多线程共享</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-happens-before</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-happen-before/</url>
    <content><![CDATA[<h1 id="什么是happens-before原则？"><a href="#什么是happens-before原则？" class="headerlink" title="什么是happens-before原则？"></a>什么是happens-before原则？</h1><p>前一个操作的结果对后续操作是可见的</p>
<h1 id="为什么需要happens-before原则？"><a href="#为什么需要happens-before原则？" class="headerlink" title="为什么需要happens-before原则？"></a>为什么需要happens-before原则？</h1><p>虚拟机会做编译优化，进行指令重排序，以提高CPU利用率，防止CPU出现空等待；但有些情况是不能重排序的，否则并发下会出问题，所以就要规定这些情况，happens-before原则就是这个规定.</p>
<h1 id="典型场景？"><a href="#典型场景？" class="headerlink" title="典型场景？"></a>典型场景？</h1><p>比如写一个单例，new一个对象，指令执行的步骤是：</p>
<ol>
<li> 给对象分配内存</li>
<li> 对象初始化</li>
<li> 将对象内存地址关联</li>
</ol>
<p>指令重排序，可能会导致对象还没初始化，就会已经被使用了，所以需要volatile来禁止指令重排序</p>
<h1 id="有哪些happens-before原则？"><a href="#有哪些happens-before原则？" class="headerlink" title="有哪些happens-before原则？"></a>有哪些happens-before原则？</h1><ol>
<li> 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li> 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li> volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li> 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li> 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li> 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li> 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li> 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>happens-before</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-synchronized、ReentrantLock</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/</url>
    <content><![CDATA[<h1 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h1><p>让一段代码在多线程之间互斥访问，保证原子性、有序性、可见性，并且是可重入的。</p>
<h1 id="synchronized使用方式"><a href="#synchronized使用方式" class="headerlink" title="synchronized使用方式"></a>synchronized使用方式</h1><ul>
<li>synchronized修饰代码块时需要传入一个对象作为锁，这个对象可以是任意的，进入同步代码块前要获取这个锁，没有获得锁的线程就要阻塞等待，同步代码块执行完释放锁。</li>
<li>修饰成员方法时，锁是对象实例。</li>
<li>修饰静态方法时，锁是类的class实例。</li>
</ul>
<h1 id="synchronized原理综述"><a href="#synchronized原理综述" class="headerlink" title="synchronized原理综述"></a>synchronized原理综述</h1><p>每个Java对象都关联一个监视器锁对象，同步代码块在字节码层面是通过在代码块的指令前后加上monitorenter和monitorexit指令来标识的。</p>
<p>当线程执行到monitorenter指令时，当前线程试图获取监视器对象所有权，如果未加锁或者已被当前线程持有，就把锁计数加1；执行到monitorexit指令的时候，锁计数减1。锁计数为0时，锁就被释放了。</p>
<p>如果当前线程获取监视器对象失败，线程会阻塞等待，线程会作为一个结点存入监视器对象的锁池队列中，等待唤醒。</p>
<p>监视器对象还有一个等待池队列，在同步代码块中调用锁对象的wait方法的时候，线程会阻塞，并被封装为一个结点，进入监视器对象的等待池队列，调用锁对象的notify和notifyAll的时候，会把等待池队列中的线程放入锁池队列中，只有锁池中的线程才能参与竞争锁。</p>
<p>wait和notify用来线程之间同步过程的，比如实现生产者消费者模型。</p>
<p>监视器锁底层是通过操作系统的互斥锁实现的，操作系统做线程切换需要从用户态转换到内核态，所以比较消耗性能。这种依赖于操作系统互斥锁而实现的锁叫做重量级锁。</p>
<p>如果线程竞争并不激烈，切换线程的开销是不划算的，特别是多个线程在不同的时段获取同一把锁，可以用自旋锁，就是CAS+循环，CAS由硬件之间实现，开销比切换线程开销要小，这就是轻量级锁，在JDK6引入。</p>
<p>锁信息具体存储在对象头的MarkWord里，一个对象在虚拟机的内存布局分为三部分，对象头、实例数据、对齐填充，其中对象头又分为MarkWord、类型指针、数组长度，MarkWord存储了锁相关的信息、hashCode、垃圾回收的分代年龄等。</p>
<p>轻量级锁的CAS操作具体修改的是锁对象头的mark word，修改为指向当前线程栈帧中的锁记录的指针。虚拟机会为每个线程在当前线程栈帧中创建一块锁记录空间，存储锁对象的对象头中的mark word的拷贝。</p>
<p>如果CAS修改成功，当前线程就获得了轻量级锁。</p>
<p>如果更新失败，说明有线程竞争，开始自旋，自旋超过一定次数，升级为重量级锁。避免竞争激烈的情况下自旋空耗CPU。</p>
<p>如果压根都没有线程竞争，只有单线程访问同步代码块，其实每次进行CAS操作获取轻量级锁也是没有必要的开销，所以JDK6又引入了偏向锁，只在第一次申请锁的时候，对Java对象头的MARK WORD做CAS操作，记录下当前申请锁的线程ID，退出同步代码块后，也不释放锁，锁对象的对象头中记录的还是当前的线程ID，同一个线程再次进入这个锁的同步代码块的时候，检查锁的对象头中记录的线程ID是否还是自己，是的话就直接进入，不用再CAS了。当有多个线程要申请锁的时候，就会升级到轻量级锁。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<h1 id="ReentrantLock与synchronized的区别？"><a href="#ReentrantLock与synchronized的区别？" class="headerlink" title="ReentrantLock与synchronized的区别？"></a>ReentrantLock与synchronized的区别？</h1><p>ReentrantLock与synchronized有相同的功能和语义，添加了更多灵活的功能。<br>synchronized能干的ReentrantLock都能干，ReentrantLock能干synchronized不一定能干。</p>
<p>最主要区别有三点：支持等待可中断、可实现公平锁、锁可以绑定多个条件。</p>
<p>详细区别：<br>|   |ReentrantLock|synchronized<br>|—|—|—|<br>|底层实现|继承AQS|监视器模式<br>|灵活性|支持响应中断、超时、尝试获取锁|不灵活<br>|释放锁形式|必须显式调用unlock()释放锁，可跨方法调用|自动释放监视器，不可跨方法释放<br>|锁类型|公平锁和非公平锁|非公平锁<br>|条件队列|可关联多个条件队列|只有一个条件队列<br>|错误排查|没有释放锁，很追溯发生错误的位置，因为没有记录应该释放锁的时间和位置难度|synchronized加锁解锁过程有完整的日志</p>
<h1 id="该用ReentrantLock还是synchronized？"><a href="#该用ReentrantLock还是synchronized？" class="headerlink" title="该用ReentrantLock还是synchronized？"></a>该用ReentrantLock还是synchronized？</h1><p>除非需要ReentrantLock的特定的功能，否则还是应该优先使用synchronized，因为简单易用，不会忘记释放锁。</p>
<h1 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h1><p>底层通过继承AbstractQueuedSynchronizer实现。</p>
<p>大致过程：</p>
<ul>
<li>先通过cas修改int类型的state变量，修改成功则获取互斥锁成功。</li>
<li>cas修改失败则把当前线程生成一个节点，放入一个等待队列中，线程被挂起。<ul>
<li>等待队列操作也都是通过cas加自旋的方式来完成，避免同步开销。</li>
</ul>
</li>
<li>释放锁后，会唤醒队列去自旋CAS去修改state来获取互斥锁。</li>
</ul>
<p>state变量记录锁的重入次数。</p>
<h1 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h1><ul>
<li>jdk1.6之前synchronized直接就上重量级锁。</li>
<li>jdk1.6开始synchronized会先由无锁转为偏向锁，再转为轻量级锁，再转为重量级锁，锁只能升级不能降级。</li>
</ul>
<p>偏向锁、轻量级锁是针对synchronized优化。</p>
<h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h1><p>JVM中，对象在内存中除了存储对象本身的数据，还会额外存储关于对象的一些附加信息。</p>
<ul>
<li>普通对象的对象头中存储mark word和类型指针（指向对象所属类的指针）。</li>
<li>数组对象还会存储数组长度。</li>
</ul>
<p>mark word存储对象的hashcode、GC分代年龄、锁状态等信息。</p>
<p>mark word长度在32位系统上为32位，64位系统上长度为64位。</p>
<p>为了在有限的空间存储较多的信息，其数据格式不固定，数据位共享复用。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210826195541.png"></p>
<p>当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；</p>
<p>当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；</p>
<p>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>研究发现，大多数情况下不仅不存在锁竞争，而且总是由同一个线程多次重入，为了让同一个线程多次重入获取锁的代价更低，就引入了偏向锁的概念。</p>
<p>偏向锁获取过程：</p>
<ol>
<li> 当前线程访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认是否为可偏向状态。</li>
<li> 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>
<li> 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li>
<li> 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致当前获得偏向锁的线程被暂停）</li>
<li> 执行同步代码。</li>
</ol>
<p>偏向锁的释放：</p>
<p>偏向锁只有当遇到其他线程也尝试获取偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。（也就是对于获取偏向锁的线程 只有lock的动作，没有unlock的动作，这是因偏向的需要，即使可能这个线程已经死亡。）偏向锁的撤销步骤如下：</p>
<ol>
<li> 等到全局安全点（在这个时间点上没有正在执行的字节码）。</li>
<li> 暂停持有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果线程不处于活动状态，则将对象头设置为无锁状态。争抢锁的线程会再走生成偏向锁的过程，然后成为偏向锁的拥有者。</li>
<li> 如果持有偏向锁的线程还处于活动状态，则将锁升级为轻量级锁。</li>
</ol>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>轻量级锁实现是自旋锁，没有抢到锁的线程将自旋，即不停的循环判断是否能获取到锁，不会让线程阻塞。获取锁的操作就是通过CAS修改对象头的锁标记位。</p>
<p>长时间的循环是很占用CPU的，一个线程持有锁，其他线程只能原地空耗CPU，不执行任何有效的任务，这种现象称为busy-waiting。</p>
<p>利用短时间的busy-waiting换取线程的阻塞和唤醒在用户态和内核态切换的开销。</p>
<p>busy-waiting是有限度的（JVM可以设置参数调节循环次数上限），如果锁竞争激烈，自旋超过一定次数，就升级为重量级锁。</p>
<p>具体的CAS过程：</p>
<ul>
<li>  当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>
<li>  若CAS操作成功，则轻量级锁的上锁过程成功；</li>
<li>  若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>
</ul>
<p>轻量级锁比重量级锁性能更高的前提是：</p>
<ul>
<li>在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>
</ul>
<p>轻量级锁是为了在线程交替执行同步块时提高性能。</p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>阻塞所有竞争锁但未获得锁的线程。</p>
<p>实现依赖于操作系统的同步函数，在linux上使用mutex互斥锁，涉及到用户态和内核态的切换、进程线程上下文的切换，成本较高。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>AQS</tag>
        <tag>synchronized</tag>
        <tag>ReentrantLock</tag>
        <tag>偏向锁</tag>
        <tag>轻量级锁</tag>
        <tag>重量级锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-volatile</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-volatile/</url>
    <content><![CDATA[<h1 id="volatile综述"><a href="#volatile综述" class="headerlink" title="volatile综述"></a>volatile综述</h1><p>volatile主要保证两点</p>
<ol>
<li> 变量的值在多线程之间是可见的</li>
<li> 阻止指令重排序，间接的保证变量值的可见性</li>
</ol>
<p>但不保证原子性，所以开销比synchronized加锁要小</p>
<p>可见性的解释涉及到java内存模型，每个线程都有自己的私有内存，对应堆中的虚拟机栈中，当多个线程访问主存上同一个变量时，会拷贝变量到各自私有线程中，线程对变量做出修改都是在私有内存中的修改，线程并不知道各自的修改值，也就是所谓的不可见。</p>
<p>用volatile修饰变量后，对变量的修改会立刻刷新到主存，读volatile变量也会从主存去读取，保证可见性，但这让缓存失效，牺牲了一定的访问速度。</p>
<p>指令重排序有好几个层面的，有CPU层面和编译器层面的。</p>
<p>为什么要进行指令重排序呢？是为了提高CPU利用率。</p>
<p>CPU层面的指令重排序是因为防止CPU指令流水线的停顿，指令流水线是做什么的呢？一条指令可以分为多个执行步骤，每个执行步骤可以由多个功能单元的硬件来执行，这样就不用串行的执行指令了，可以让多个功能单元并行的执行指令的不同的步骤，多个指令的执行速度一下提升好几倍。但是如果指令之间存在数据依赖，流水线就只能停顿等待，但是如果把没有依赖的指令重排序一下，就不用停顿等待了，这样CPU利用率就提高了。</p>
<p>编译器的重排序要达到的目的也是提高CPU利用率。</p>
<p>检查编译器有没有做重排序，可以开两个线程做验证，给两个变量a1、a2赋初始值0，线程1执行两条语句，先给a1赋值1，然后打印a2，线程2也执行两条语句，先给a2赋值1，然后打印a1，正常执行结果是打印1和1，执行很多次过后会发现有一次打印出来的两个结果是10、01甚至00，打印语句被重排序到前面去先执行了。</p>
<p>既然指令重排序这么好，为什么还要阻止呢？</p>
<p>因为指令重排序虽然不会影响单线程的代码语义，但是在多线程下会影响程序运行的正确性，有时候需要手动阻止。这个可以写代码验证的。</p>
<p>volatile阻止指令重排序具体是通过内存屏障来实现的。</p>
<p>内存屏障分为读屏障和写屏障，读屏障将内存数据拷贝到缓存，写屏障将缓存数据刷新到内存。</p>
<p>volatile写操作之前插入StoreStore屏障，之后插入StoreLoad屏障</p>
<p>volatile写操作volatile读操作之后插入LoadLoad屏障和LoadStore屏障</p>
<p>内存屏障有两个作用：</p>
<ol>
<li> 阻止内存屏障两侧的指令重排序</li>
<li> 强制把缓存数据回写到主内存，对所有线程可见</li>
</ol>
<p>但也不能总是用volatile来保证有序性，那样太麻烦了。所有Java内存模型规定了一个happens-before原则，保证前一个操作的结果对后续操作是可见的，来帮助开发者辅助判断代码是否有线程安全的问题。</p>
<p>比如</p>
<ol>
<li> 一个线程内必须保持语义的串行，按照代码顺序执行</li>
<li> 解锁操作要发生在对这个锁的加锁操作之前</li>
<li> 线程start()方法先于线程的每个动作</li>
</ol>
<p>在多线程中需要修改和读取的变量，不需要保证原子性的，但要保证可见性的，就要用volatile修饰</p>
<p>一个典型的使用场景是双重检查锁定的单例模式，对单例对象加volatile修饰，以防止new对象的时候发生指令重排序，进而导致得到了一个对象的引用但是对象还没有初始化。</p>
<h1 id="volatile解决了什么问题？"><a href="#volatile解决了什么问题？" class="headerlink" title="volatile解决了什么问题？"></a>volatile解决了什么问题？</h1><ol>
<li> 保证变量的可见性，多线程可读取到变量最新修改值</li>
<li> 保证变量的有序性，阻止指令重排序</li>
</ol>
<h1 id="可见性是什么意思？"><a href="#可见性是什么意思？" class="headerlink" title="可见性是什么意思？"></a>可见性是什么意思？</h1><p>首先要介绍Java内存模型，Java的数据都存储在主存中，每个线程读写主存的数据时，都会把数据拷贝到线程自己的工作内存中再进行读写，工作内存可以理解为线程自己的缓存，多个线程对同一个数据修改时，修改的都是线程自己工作内存的数据拷贝，多个线程的工作内存之间是非共享的，对数据做出修改后互相不可见。</p>
<h1 id="volatile是如何保证可见性的？"><a href="#volatile是如何保证可见性的？" class="headerlink" title="volatile是如何保证可见性的？"></a>volatile是如何保证可见性的？</h1><p>多线程读写主存中存储的某个volatile变量时，会把这个变量所在的内存块都复制到线程的工作内存，当某个线程修改了工作内存中的volatile变量，会立即将新数据写入共享内存，其他线程的工作内存中这一缓存块会被标记失效，被要求重新从共享内存读取数据，保证读取到的是最新的值。</p>
<p>可以参考缓存一致性协议来理解。</p>
<h1 id="为什么要有指令重排序，指令重排序有什么好处？"><a href="#为什么要有指令重排序，指令重排序有什么好处？" class="headerlink" title="为什么要有指令重排序，指令重排序有什么好处？"></a>为什么要有指令重排序，指令重排序有什么好处？</h1><p>减少CPU空等，提高CPU整体的吞吐量。</p>
<p>编译器层面有编译器对指令顺序的优化。</p>
<p>CPU层面有指令流水线对指令执行的优化。</p>
<h1 id="虚拟机是如何为volatile实现可见性和有序性？如何防止指令重排序？"><a href="#虚拟机是如何为volatile实现可见性和有序性？如何防止指令重排序？" class="headerlink" title="虚拟机是如何为volatile实现可见性和有序性？如何防止指令重排序？"></a>虚拟机是如何为volatile实现可见性和有序性？如何防止指令重排序？</h1><p>通过内存屏障来实现。</p>
<p>内存屏障之前所有的写操作都要回写到主存，内存屏障之后的所有读操作都能获取内存屏障之前的所有写操作的最新结果，这样就保证了可见性。</p>
<p>因此也就禁止把内存屏障之后的指令重排序到内存屏障之前。</p>
<p>先简单了解两个指令：</p>
<ul>
<li>Store：将处理器缓存的数据刷新到内存中。</li>
<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>屏障类型</strong></th>
<th><strong>指令示例</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad  Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td>
</tr>
<tr>
<td>StoreStore  Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td>
</tr>
<tr>
<td>LoadStore  Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td>
</tr>
<tr>
<td>StoreLoad  Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<h1 id="volatile为什么不能保证原子性？"><a href="#volatile为什么不能保证原子性？" class="headerlink" title="volatile为什么不能保证原子性？"></a>volatile为什么不能保证原子性？</h1><p>因为一个volatile变量的操作，比如i++，本身多个字节码指令，并且每条指令也不一定是原子化的，所以volatile变量的操作也不可能是原子化的。</p>
<p>这个可以用程序验证，volatile变量初始值为0，两个线程分别对其自增一万次，最后变量的值是小于两万的。</p>
<p>可以从字节码指令看出来</p>
<p>如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increament</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后value++的字节码指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GETFIELD VolatileDemo.value : I</span><br><span class="line">ICONST_1</span><br><span class="line">IADD</span><br><span class="line">PUTFIELD VolatileDemo.value : I</span><br></pre></td></tr></table></figure>
<p>GETFIELD指令是获取对象的字段值，将值压入栈顶<br>ICONST_1指令是int型常量1入栈，因为要加1，所以就入栈1<br>IADD指令是弹出栈顶的两个数字进行相加，相加的和再压入栈<br>PUTFIELD指令是给对象的变量赋值栈顶的值</p>
<p>volatile可以保证GETFIELD时可以读取到value的最新值，但是iconst_1和add时，其他线程可能已经把value值也改变了，最后PUTFIELD是过期的值，所以多线程调用increament时，最终的值会变小。</p>
<p>一个volatile变量自增操作有4个指令，一条字节码指令也不一定是原子的，可能还会转换为若干条本地机器码指令，所以volatile不能保证原子性。</p>
<p>需要通过synchronized或java.util.concurrent包下的锁或原子类来保证原子性。</p>
<h1 id="volatile使用案例"><a href="#volatile使用案例" class="headerlink" title="volatile使用案例"></a>volatile使用案例</h1><ol>
<li>volatile可以使得long和double的赋值是原子的</li>
<li>多线程需要实时读取的值，例如：<br> a. AtomicInteger里的value都是volatile的<br> b. AQS里的state变量也是volatile</li>
<li>CopyOnWriteArrayList里的数组也是volatile的，保证数组拷贝过后，对其他读线程立即可见</li>
<li>阻止if或while中条件变量的重排序，防止出现不符合预期的结果。if或while语句内部的变量，跟条件变量的赋值，如果在同一个方法中执行，因为没有依赖关系，可能会发生重排序。比如方法a里会读取先通过if判断flag变量是否为true，为true就打印变量c的值，然后在方法b中，先对c赋值，再对flag赋值true，b方法中两个语句可能会重排序的，在多线程执行的时候，就会导致flag先为true，但是c还没赋值，另外一个线程已经执行方法a了，</li>
<li>双重检查锁定的单例</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-条件变量、wait()与notify()、await()与signal()</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-wait()%E3%80%81notify()%E3%80%81notifyAll()/</url>
    <content><![CDATA[<h1 id="Object-wait-为什么要配合while使用？"><a href="#Object-wait-为什么要配合while使用？" class="headerlink" title="Object.wait()为什么要配合while使用？"></a>Object.wait()为什么要配合while使用？</h1><p>wait之前一般都是要判断某个条件成立才会wait，这个判断条件需要写成while：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (check pass) &#123;</span><br><span class="line">	wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果写成if，wait过后当前线程交出锁，等当前线程重新被唤起后，条件是否满足是不知道的，其他线程可能修改了条件的状态，要重新判断一下，否则可能条件未满足就继续执行了。</p>
<p>以生产者消费者模型为例。</p>
<ul>
<li>有1个生产者往缓冲区加数据，有2个消费者从缓冲区取数据。</li>
<li>消费者取数据前会检查缓冲区是否为空，不为空才能取数据，为空的话要等待。</li>
<li>假设两个消费者线程都等待了。</li>
<li>然后生产者往缓冲区添加数据后做notifyAll唤醒所有消费者，会唤醒两个等待的消费者线程，让消费者线程从监视器的等待队列移动到锁竞争队列，两者竞争锁。</li>
<li>其中一个线程竞争到锁后，消费了缓冲区数据，缓冲区没有数据了，释放锁后另外一个消费者获得到了锁，开始取从缓冲区取数据，而没有再做条件检查了。</li>
</ul>
<p>这种现象叫做虚假唤醒。</p>
<h1 id="Object的notify-和notifyAll-有什么区别？"><a href="#Object的notify-和notifyAll-有什么区别？" class="headerlink" title="Object的notify()和notifyAll()有什么区别？"></a>Object的notify()和notifyAll()有什么区别？</h1><p>每一个对象都有一个内部锁，即监视器（Monitor），虚拟机会给每个对象维护两个线程集合（可能是队列），一个叫Entry Set（入口集），另外一个叫Wait Set（等待集），对于任意对象object，object的Entry Set用于存储等待获取object内部锁的所有线程，object的Wait Set存储执行了object.wait()和object.wait(long timeout)的线程。</p>
<ul>
<li>notify()会唤醒Wait Set里的一个线程。</li>
<li>notifyAll()会唤醒Wait Set里的所有线程，线程被唤醒后去竞争获取锁，没有获取锁的线程进入Entry Set。</li>
</ul>
<h1 id="什么时候用notify-？什么时候用notifyAll"><a href="#什么时候用notify-？什么时候用notifyAll" class="headerlink" title="什么时候用notify()？什么时候用notifyAll()?"></a>什么时候用notify()？什么时候用notifyAll()?</h1><p>如果所有线程都在等待相同的条件，并且一次只有一个线程可以从条件变为true，则可以使用notify。</p>
<p>在这种情况下，notify是优于notifyAll 因为唤醒所有这些因为我们知道只有一个线程会受益而所有其他线程将再次等待，所以调用notifyAll方法只是浪费CPU。</p>
<p>虽然这看起来很合理，但仍有一个警告，即无意中的接收者吞下了关键通知。通过使用notifyAll，我们确保所有收件人都会收到通知。</p>
<h1 id="Object的wait-notifyAll-和Condition的await-signalAll-的区别？"><a href="#Object的wait-notifyAll-和Condition的await-signalAll-的区别？" class="headerlink" title="Object的wait()/notifyAll()和Condition的await()/signalAll()的区别？"></a>Object的wait()/notifyAll()和Condition的await()/signalAll()的区别？</h1><p>以生产者消费者模型为例。</p>
<ul>
<li>使用wait()、notify()/notifyAll()的缺点在于在生产者唤醒消费者、或者消费者唤醒生产者时，由于生产者和消费者使用同一个锁，所以生产者也会将生产者唤醒，消费者也会将消费者唤醒。</li>
<li>如果能让消费者只唤醒生产者，或者生产者只唤醒消费者，就没有性能浪费了。</li>
<li>所以一个ReentrantLock支持创建多个Condition，以应对这种场景。</li>
<li>synchronized的锁对象没有提供多条件唤醒。</li>
</ul>
<p>ArrayBlockingQueue是典型的生产者消费者的例子，源码是很好的参考。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>synchronized</tag>
        <tag>Object.wait()</tag>
        <tag>Object.notify()</tag>
        <tag>Object.notifyAll()</tag>
        <tag>Condition.await()</tag>
        <tag>Condition.signal()</tag>
        <tag>虚假唤醒</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-伪共享</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h1><p>计算机可分为两种结构</p>
<ol>
<li> 冯诺依曼结构</li>
<li> 哈佛结构</li>
</ol>
<p>冯诺依曼结构提出计算机由运算器、控制器、存储器、输入设备、输出设备5个部分组成。</p>
<p>冯诺依曼结构特点是指令存储和数据存储合并在一起的存储结构，指令和数据统一编址，使用同一条总线传输，CPU读取指令和数据的操作是互斥的，同一时间只能做一件事，只能分时复用，无法并行，速度慢，CPU吞吐量低。</p>
<p>哈佛结构特点是指令存储和数据存储分开的存储结构，指令和数据独立独立编址，使用两条独立的总线传输，CPU读取指令和数据操作可以并行，速度快，CPU吞吐量高。</p>
<p>因为cpu速度快，而总线速度慢。冯诺依曼结构中，数据存储器和指令存储器使用同一总线，总线繁忙，cpu需要停下来等待总线读取数据。在哈佛结构中，数据存储器和指令存储器使用不同总线，减少了cpu停止工作等待数据读取的时间，因此提升了效率。</p>
<p>冯诺依曼结构由于指令和数据共用总线，速度慢、效率低、吞吐量低，但因为指令存储区域和数据存储区域大小可以动态调整，存储器利用率高，适用场景更通用，所以也便宜。</p>
<p>哈佛结构由于指令和数据分开存储，速度快、效率高、吞吐量大，但不能灵活调整存储区，适用比较做单一的功能，针对不同的功能要做单独的设计，成本也提高了。</p>
<h1 id="冯诺依曼瓶颈"><a href="#冯诺依曼瓶颈" class="headerlink" title="冯诺依曼瓶颈"></a>冯诺依曼瓶颈</h1><p>指令和数据存储在一起，导致指令读取和数据处理不能同时进行，而CPU运算速度远远超过主存储器读写的速度，CPU就会浪费时间等待主存数据读写，CPU吞吐量低。</p>
<p>解决瓶颈途径之一：</p>
<p>CPU访问主存数据具有时间局部性和空间局部性特点，在CPU和主存储器之间增加缓存，缓存的命中率很高，大大减少访问主存的次数。</p>
<p>同时CPU缓存采用哈佛结构，指令和数据分开存储，以提高存储量。</p>
<p>数据访问的时间局部性：如果一项信息最近被访问，那么近期很可能被再次访问。产生这个效果的典型原因是代码存在大量循环操作。</p>
<p>数据访问的空间局部性：将来马上要用到的信息，很可能与正在使用的信息，在空间存储位置上是临近的</p>
<p>所以当访问主存中某一个数据的时候，把这个数据相邻的数据都放入缓存中，可以大大减少CPU访问主存消耗的时间。</p>
<h1 id="CPU缓存和内存为什么要分块？"><a href="#CPU缓存和内存为什么要分块？" class="headerlink" title="CPU缓存和内存为什么要分块？"></a>CPU缓存和内存为什么要分块？</h1><p>CPU访问主存数据具有时间和空间局部性的特点。</p>
<p>时间局部性：如果一个数据被访问了，那么近期很可能被再次访问。产生这个效果的典型原因是代码存在大量循环操作。</p>
<p>空间局部性：访问内存上的一个数据，这个数据邻近位置的数据，最近也很大可能会被访问</p>
<p>所以应该把该数据邻近的位置的数据都一起读入缓存中，这样可以减少CPU访问主存的次数，CPU直接访问缓存的速度是很快的，这样CPU的吞吐量就提高了。</p>
<p>虚拟内存机制，也是建立了主存和外存之间的缓存关系，也是利用数据访问的局部性原理，把暂时不用的数据放到访问速度更慢的外存，需要频繁使用的数据按页交换到访问速度更快的主存中。这样内存中可以运行更多的进程。</p>
<h1 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h1><p>为了便于CPU缓存和主存交换数据，CPU缓存和主存都被划分位长度相等的块，缓存块又称为缓存行，大小为2的次方，CPU缓存从主存读入数据一次读一整块，向主存更新数据，也是一次写入一整块。</p>
<h1 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h1><p>多个CPU同时读写主存上某个连续区域的不同变量时，会各自把该该主存块拷贝一份放入自己的CPU缓存中，多个线程在访问缓存行内的不同变量时，由缓存一致性协议可知该缓存行会失效，多个CPU之间互相等待对方先把缓存行写入主存，自己再从主存读入最新的数据块，表现为缓存频繁未命中，CPU演变为直接与主存交互，CPU访问主存速度很慢，CPU吞吐量因此降低。</p>
<h1 id="伪共享的解决：字节填充"><a href="#伪共享的解决：字节填充" class="headerlink" title="伪共享的解决：字节填充"></a>伪共享的解决：字节填充</h1><p>保证不同的CPU处理的数据位于不同的缓存行中，就不会引发缓存行的频繁失效。</p>
<p>java里定义类的成员变量时，可以倾向于把不变的遍历放在一起（一组位置），易变的变量放在一起，使它们尽量不在同一个缓存行，这样每次对象的易变变量变化时，不会引起不变的属性所在缓存行失效，从而提高缓存命中率，避免频繁从主存读取数据，提高CPU吞吐量。</p>
<p>Jdk6中可以通过添加填充变量进行字节填充来解决伪共享，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  <span class="comment">// 实际数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6; <span class="comment">// 填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想象PaddingObject里本来只有一个value属性，现在有多个线程需要读写一个PaddingObject数组（修改数组每一项里的value），由于数组的存储空间在内存中是连续的，根据CPU访问数据的空间局部性特点，CPU在访问数组某个元素的时候，会把该元素所在的内存块整个拷贝到CPU缓存中，这个内存块包含了数组中一些相邻的元素，多个线程同时修改数组中相邻的一些元素时，这个缓存行会频繁失效，CPU缓存命中率低，如果数组的每一个元素位于不同的内存块，也就可以位于不同的缓存行，多线程就不会竞争同一个缓存行</p>
<p>Jdk7中有的版本用上述方式无效，添加的无用变量会被优化去除，需要使用继承的方式组织优化，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;<span class="comment">// 填充</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingObject</span> <span class="keyword">extends</span> <span class="title">AbstractPaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;    <span class="comment">// 实际数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jdk8开始提供了@sun.misc.Contended 注解进行字节填充，不用再手动声明无用的变量了，同时要开启 JVM 参数：-XX:-RestrictContended=false</p>
<p>字节填充会增大目标对象的体积，是用空间换时间。</p>
<h2 id="伪共享应用场景"><a href="#伪共享应用场景" class="headerlink" title="伪共享应用场景"></a>伪共享应用场景</h2><h3 id="数组优于链表"><a href="#数组优于链表" class="headerlink" title="数组优于链表"></a>数组优于链表</h3><p>从伪共享的角度，数据和链表的区别，不仅是结构上的区别，在缓存命中率上是完全不一样的，因为数组的存储空间连续，缓存命中率更高，链表的缓存命中率低，访问速度慢。</p>
<h3 id="快速排序优于堆排序"><a href="#快速排序优于堆排序" class="headerlink" title="快速排序优于堆排序"></a>快速排序优于堆排序</h3><p>堆排序访问数据时，也不是访问连续内存空间的数据，所以堆排序和快速排序虽然都有相近的时间复杂度，但是常用的还是快速排序</p>
<h3 id="二维数组横向遍历优于竖向遍历"><a href="#二维数组横向遍历优于竖向遍历" class="headerlink" title="二维数组横向遍历优于竖向遍历"></a>二维数组横向遍历优于竖向遍历</h3><p>横向遍历二维数组，比竖向遍历缓存命中率要高，因为数组在内存中的存储是每行每行的连续存储，先按行遍历再按列遍历，会访问内存空间连续的数据，先按列遍历再按行遍历访问的不是内存存储空间连续的数据，数据不在同一块，缓存的命中率低</p>
<h3 id="二维数组维数短的写在外层更优"><a href="#二维数组维数短的写在外层更优" class="headerlink" title="二维数组维数短的写在外层更优"></a>二维数组维数短的写在外层更优</h3><p>二维数组，维数短的写在外层，缓存命中率更高，因为会减少跨缓存块访问数据，集中在一个缓存块上访问数据，如果长的一维写在外层，访问二维数组元素时，访问数据的内存地址跨度可能超过一个内存块长度，就要频繁的交换CPU缓存，缓存命中率低</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>伪共享</tag>
        <tag>False Sharing</tag>
        <tag>虚拟内存</tag>
        <tag>冯诺依曼瓶颈</tag>
        <tag>字节填充</tag>
        <tag>计算机结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-线程池</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h1><ol>
<li> 线程的创建和销毁是消耗性能的，如果频繁的开线程执行任务，可以考虑复用已启动的线程，避免无谓的性能开销，提高系统整体吞吐量</li>
<li> 对任务异步调度进行了抽象，方便统一控制和测试</li>
</ol>
<h1 id="线程池的几个参数的作用分别是什么？"><a href="#线程池的几个参数的作用分别是什么？" class="headerlink" title="线程池的几个参数的作用分别是什么？"></a>线程池的几个参数的作用分别是什么？</h1><p>线程池是ThreadPoolExecutor类，构造函数的参数如下：</p>
<ol>
<li> int corePoolSize：核心线程数量，除非手动shutdown否则核心线程一直运行</li>
<li> int maximumPoolSize：最大线程数量，最大线程数减去核心线程数的线程为非核心线程</li>
<li> long keepAliveTime：非核心线程空闲时的存活时间</li>
<li> TimeUnit unit：非核心线程空闲时的存活时间单位</li>
<li> BlockingQueue<Runnable> workQueue：存放任务的工作队列，核心线程全都在执行任务时，没法执行新的任务了，新任务就存放在这里</li>
<li> ThreadFactory threadFactory：线程创建的工厂，可以给线程设置名字，方便排查问题</li>
<li> RejectedExecutionHandler handler：存放任务的阻塞队列存不下新的任务时的拒绝策略，做限流保护</li>
</ol>
<h1 id="任务拒绝策略有哪些？"><a href="#任务拒绝策略有哪些？" class="headerlink" title="任务拒绝策略有哪些？"></a>任务拒绝策略有哪些？</h1><p>AbortPolicy：抛出一个异常，默认的</p>
<p>DiscardPolicy：直接丢弃任务</p>
<p>DiscardOldestPolicy：丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</p>
<p>CallerRunsPolicy：交给线程池调用所在的线程进行处理</p>
<h1 id="线程池有哪些工作队列，分别什么场景使用？"><a href="#线程池有哪些工作队列，分别什么场景使用？" class="headerlink" title="线程池有哪些工作队列，分别什么场景使用？"></a>线程池有哪些工作队列，分别什么场景使用？</h1><p>主要三种：无界队列、有界队列、同步移交队列</p>
<h2 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h2><p>LinkedBlockingQueue，队列大小无限。</p>
<p>Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue。</p>
<p>当某些任务耗时较长时，可能会导致队列中堆积存储大量任务，进而导致内存溢出。</p>
<h2 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h2><ul>
<li>ArrayBlockingQueue</li>
<li>有界的LinkedBlockingQueue</li>
<li>支持设置优先级的PriorityBlockingQueue</li>
</ul>
<p>有界队列的大小要和线程池大小配合，线程池比有界队列大时可以减少内存消耗、降低CPU使用率和上下文切换，但会限制吞吐量。</p>
<h2 id="同步移交队"><a href="#同步移交队" class="headerlink" title="同步移交队"></a>同步移交队</h2><p>SynchronousQueue</p>
<p>其并不真正存储任务，当一个放入任务到队列中必须同时有一个线程正在等待取任务，无限数量的线程池可以使用队列，这样每次提交任务都会立刻执行。</p>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>LinkedTransferQueue 是 SynchronousQueue 和 LinkedBlockingQueue 的合体，性能比 LinkedBlockingQueue 更高（没有锁操作），比 SynchronousQueue能存储更多的元素。</p>
<p>当 put 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。</p>
<p>put 和 transfer 方法的区别是 put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。transfer方法和 SynchronousQueue的 put 方法类似。</p>
<h1 id="往线程池里提交一个任务会发生什么？"><a href="#往线程池里提交一个任务会发生什么？" class="headerlink" title="往线程池里提交一个任务会发生什么？"></a>往线程池里提交一个任务会发生什么？</h1><p>线程池的核心接口是Executor，里面只有一个execute(Runnable)方法，ExecutorService接口继承了Executor，提供了submit、shutdown、invokeAll、invokeyAny等方法。</p>
<p>提交任务有execute和submit两种方式，execute只能提交无返回值的Runnable，submit可以提交有返回值的Callable和无返回值的Runnable，submit方法会新建一个FutureTask封装传入的Callback和Runnable，Runnable会被适配为Callback对象，FutureTask是集成Runnable的，最终还是执行execute(Runnable)，FutureTask内部只处理Callable</p>
<p>execute(Runnable)里的逻辑：</p>
<p>如果运行的线程数少于corePoolSize，则创建新线程执行任务。</p>
<p>如果运行的线程数大于corePoolSize，则将新任务加入工作队列，而不添加新的线程，核心线程执行完一个任务就从工作队列中取任务继续执行。</p>
<p>如果队列已满无法再加入，则创建新的线程执行，一直到线程总数超过maximumPoolSize时，对新任务执行拒绝策略。</p>
<p>execute里addWorker(null, false);，传递空任务，代表新建线程，不为空表示新建线程并添加第一个任务</p>
<p>submit任务后，任务内抛出的异常会拦截，通过Future获取异常对象，通过execute执行的任务，抛出的异常原封不动的向上抛。</p>
<h1 id="线程池的大小应该设置多大？"><a href="#线程池的大小应该设置多大？" class="headerlink" title="线程池的大小应该设置多大？"></a>线程池的大小应该设置多大？</h1><p>任务分三类：</p>
<ol>
<li> CPU计算密集型</li>
<li> IO密集型</li>
<li> 计算和IO混合型</li>
</ol>
<p>CPU计算密集型任务大部分时间用来做计算逻辑，消耗CPU资源，这种任务同时执行的数量应该跟CPU数量相等。因为任务同时执行的数量少于CPU数量的话，明明有CPU空闲，任务却得不到执行，就浪费资源了，系统整体吞吐量低；任务同时执行的数量多于CPU数量的话，由于所有的CPU都满载了，要让CPU分时间片给各个任务才能保证多出的人得到执行，而切换任务是有成本的，要保存恢复任务（线程）的上下文环境。</p>
<p>CPU密集型任务的线程池大小可以设置为CPU数量 + 1，额外多分配一个线程是因为其他线程偶尔会因为故障或其他原因暂停运行了，额外的一个线程可以确保CPU有任务执行不会被浪费。</p>
<p>IO密集型任务，多数线程处于阻塞状态等待IO完成，让出CPU，不消耗CPU资源，故而应该让线程池多处理一些任务。线程池大小一般设置为 2 * CPU数量 + 1。</p>
<p>假设有一个任务，计算需要C毫秒，IO操作需要等待W毫秒，整个任务的耗时就是C+W，一个CPU执行这个任务，CPU利用率U=C/(C+W)，很明显0 &lt;= U &lt;=1，也就是说一个CPU一个线程的情况下该线程的CPU利用为U，如果想要使得CPU利用率为1，那就多开几个线程，让几个线程的CPU利用率加起来等于1就完事了，那么总共就需要 1/U=(C+W)/C=1+W/C 个线程，1个CPU利用率100%需要1+W/C个线程，那么N个CPU利用率要100%就再乘以N就好了，所以总线程数就是N*(1+W/C)</p>
<p>CPU计算密集型，可以认为没有IO操作，W=0，那么公式计算就会得到N</p>
<p>IO密集型，C应该比较小，W比较大，那么W/C就会大于1，代入公式得到总线程数至少是2N，但是线程数也不能很大，每创建一个线程都会占用内存空间，线程数量过大会内存溢出，还要考虑硬盘和网络带宽等IO资源的限制，线程搞多了IO处理不了也没有意义，只会浪费内存。IO密集型线程池大小一般就设为2N+1，加1也是为了防止有线程因为某种原因故障或暂停了，额外的这个线程确保CPU不会浪费。</p>
<p>线程等待的时间越长，需要越多的线程数；线程计算的时间越长，需要的线程数越少。</p>
<p>任务的等待时间和计算时间可以通过基准测试工具测试出来，求一个近似值，再代入公式，即可估算出线程池大小。如果实际不同种类的任务等待时间和计算时间差异较大，只能用一个线程池的情况下，那就取平均值。</p>
<p>也不是线程越多、CPU越多就可以无限提高运算速度，这是有上限的，可以用Amdahl（阿姆达尔）定律来衡量处理器并行运算之后效率的提升能力和上限，加速比 = 并行前系统耗时 / 并行后的系统耗时，加速比可以看作并行后提升了多少倍的执行速度。</p>
<p>并行前系统耗时可以分为两个部分，一个是只能串行执行的部分，一个是可以并行执行的部分，设p为可以并行执行的部分的比例，必须串行执行的部分的比例就是1-p，设cpu数量（或线程数）为n，可并行部分执行的时间就是p/n，并行后的执行时间就是 1-p+p/n，并行前执行时间就是1了，加速比即1/(1-p+p/n)</p>
<p>也可以设f为必须串行执行的部分的比例，可以并行执行的部分的比例就是1-f，设cpu数量（或线程数）为n，可并行部分执行的时间就是(1-f)/n，并行后的执行时间就是 f+(1-f)/n，加速比为1/(f+(1-f)/n)</p>
<p>必须串行执行的部分越大，加速比就越小，这就是多核（多线程）加速的上限值。</p>
<h1 id="线程池的非核心线程什么时候会被释放？"><a href="#线程池的非核心线程什么时候会被释放？" class="headerlink" title="线程池的非核心线程什么时候会被释放？"></a>线程池的非核心线程什么时候会被释放？</h1><p>非核心线程的保活借由BlockingQueue的带超时参数的poll()方法实现了，在keepAliveTime时间内没有从队列取到任务，就一直阻塞当前线程。</p>
<h1 id="核心线程为什么一直可以运行，如何保证不销毁的？"><a href="#核心线程为什么一直可以运行，如何保证不销毁的？" class="headerlink" title="核心线程为什么一直可以运行，如何保证不销毁的？"></a>核心线程为什么一直可以运行，如何保证不销毁的？</h1><p>线程的运行没有停止就不会消耗。</p>
<p>提交任务的执行路径：execute() -&gt; addWorker() -&gt; Worker.run() -&gt; runWorker() -&gt; getTask()</p>
<p>核心线程会在getTask()中阻塞的从工作队列中获取任务，即如果工作队列中没有任务，就一直阻塞当前线程，非核心线程从队列取不到任务就立刻返回不阻塞线程，线程逻辑就会走完。</p>
<p>通过判断当前线程池线程总数是否大于核心线程数来判断当前线程是否应该当做核心线程。</p>
<h1 id="线程池有哪些坑？"><a href="#线程池有哪些坑？" class="headerlink" title="线程池有哪些坑？"></a>线程池有哪些坑？</h1><p>要注意ThreadLocal的value内存泄漏问题，要及时remove。</p>
<h1 id="自定义线程池的场景"><a href="#自定义线程池的场景" class="headerlink" title="自定义线程池的场景"></a>自定义线程池的场景</h1><p>追溯调用线程池之前的堆栈，防止线程里报错不知道外面哪里调用的。</p>
<h1 id="ForkJoinPool解决了什么问题？"><a href="#ForkJoinPool解决了什么问题？" class="headerlink" title="ForkJoinPool解决了什么问题？"></a>ForkJoinPool解决了什么问题？</h1><p>任务窃取机制，避免了取任务的时候多线程竞争一个队列，减少线程间竞争的等待开销，所以更快。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>线程池</tag>
        <tag>ForkJoinPool</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-指令重排序、指令流水线</title>
    <url>/%E5%B9%B6%E5%8F%91/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="如何验证指令发生了重排序？"><a href="#如何验证指令发生了重排序？" class="headerlink" title="如何验证指令发生了重排序？"></a>如何验证指令发生了重排序？</h1><p>定义两个变量设置初始值，在两个线程中分别赋新的值，然后打印在赋值语句后面打印另外一个线程修改的变量。</p>
<p>执行很多次，如果发生了打印的都是变量的初始值，就是发生重排序了，违反直觉，但是编译器觉得两条语句没有依赖关系，允许指令重排序</p>
<h1 id="CPU的指令流水线是什么？解决了什么问题？"><a href="#CPU的指令流水线是什么？解决了什么问题？" class="headerlink" title="CPU的指令流水线是什么？解决了什么问题？"></a>CPU的指令流水线是什么？解决了什么问题？</h1><p>一条指令可以分为多个步骤完成，每个步骤可以由不同的硬件功能单元来执行，这样就可以让多个功能单元并行执行指令的不同步骤，不需要等待一个指令执行完再执行执行下一个指令，流水线可以让指令的一个步骤完成了就可以执行下一个指令的同一个步骤</p>
<h1 id="CPU指令流水线存在什么问题？"><a href="#CPU指令流水线存在什么问题？" class="headerlink" title="CPU指令流水线存在什么问题？"></a>CPU指令流水线存在什么问题？</h1><p>如果指令之间存在数据相关性，导致前一条指令执行完后才能执行后一条指令，指令重叠就会发生冲突，无法并行执行，后面的指令只能等待，这个时候就可以把数据无关的指令重排序，以防止流水线停顿。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210826215853.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210826215901.png"></p>
<h1 id="CPU指令流水线什么情况下会需要指令重排序"><a href="#CPU指令流水线什么情况下会需要指令重排序" class="headerlink" title="CPU指令流水线什么情况下会需要指令重排序?"></a>CPU指令流水线什么情况下会需要指令重排序?</h1><p>一条指令可以分为多个步骤完成，如下:</p>
<ol>
<li> 取指 IF</li>
<li> 译码和取寄存器操作数 ID</li>
<li> 执行或者有效地址计算 EX</li>
<li> 存储器访问 MEM</li>
<li> 写回 WB</li>
</ol>
<p>CPU在工作时，需要将上述指令分为多个步骤依次执行</p>
<p>为了提高硬件利用率，CPU指令是按流水线技术来执行的，如下：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210826215936.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210826215945.png"></p>
<ol>
<li> LW指令 表示 load，其中LW R1,b表示把b的值加载到寄存器R1中</li>
<li> LW R2,c 表示把c的值加载到寄存器R2中</li>
<li> ADD 指令表示加法，把R1 、R2的值相加，并存入R3寄存器中。</li>
<li> SW 表示 store 即将 R3寄存器的值保持到变量a中</li>
<li> LW R4,e 表示把e的值加载到寄存器R4中</li>
<li> LW R5,f 表示把f的值加载到寄存器R5中</li>
<li> SUB 指令表示减法，把R4 、R5的值相减，并存入R6寄存器中。</li>
<li> SW d,R6 表示将R6寄存器的值保持到变量d中</li>
</ol>
<p>上述便是汇编指令的执行过程，在某些指令上存在X的标志，X代表中断的含义，也就是只要有X的地方就会导致指令流水线技术停顿，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，那为什么停顿呢？这是因为部分数据还没准备好，如执行ADD指令时，需要使用到前面指令的数据R1，R2，而此时R2的MEM操作没有完成，即未拷贝到存储器中，这样加法计算就无法进行，必须等到MEM操作完成后才能执行，也就因此而停顿了，其他指令也是类似的情况。前面阐述过，停顿会造成CPU性能下降，因此我们应该想办法消除这些停顿，这时就需要使用到指令重排了，如下图，既然ADD指令需要等待，那我们就利用等待的时间做些别的事情，如把LW R4,e 和 LW R5,f 移动到前面执行，毕竟LW R4,e 和 LW R5,f执行并没有数据依赖关系，对他们有数据依赖关系的SUB R6,R5,R4指令在R4,R5加载完成后才执行的，没有影响</p>
<p>正如上图所示，所有的停顿都完美消除了，指令流水线也无需中断了，这样CPU的性能也能带来很好的提升，这就是处理器指令重排的作用。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>指令重排序</tag>
        <tag>指令流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中数据库相关的类</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/Android%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Android中数据库相关类"><a href="#Android中数据库相关类" class="headerlink" title="Android中数据库相关类"></a>Android中数据库相关类</h1><ul>
<li>  SQLiteOpenHelper：管理SQLite的帮助类，提供获取SQLIteDatabase实例的方法，它会在第一次使用数据库时调用获取实例方法时创建SQLiteDatabase实例，并且处理数据库版本变化，开发人员在实现ContentProvider时都要实现一个自定义的SQLiteOpenHelper类，处理数据的创建、升级和降级。</li>
<li>  SQLiteDatabase：代表一个打开的SQLite数据库，提供了执行数据库操作的接口方法。如果不需要在进程之间共享数据，应用程序也可以自行创建这个类的实例来读写SQLite数据库。</li>
<li>  SQLiteSession：SQLiteSession负责管理数据库连接和事务的生命周期，通过SQLiteConnectionPool获取数据库连接来执行具体的数据库操作。</li>
<li>  SQLiteConnectionPool：数据库连接池，管理所有打开的数据库连接（Connection）。所有数据库连接都是通过它来打开，打开后会加入连接池，在读写数据库时需要从连接池中获取一个数据库连接来使用。</li>
<li>  SQLiteConnection：代表了数据库连接，每个Connection封装了一个native层的sqlite3实例，通过JNI调用SQLite动态库的接口方法操作数据库，Connection要么被Session持有，要么被连接池持有。</li>
<li>  CursorFactory：可选的Cursor工厂，可以提供自定义工厂来创建Cursor。</li>
<li>  DatabaseErrorHandler：可选的数据库异常处理器（目前仅处理数据库Corruption），如果不提供，将会使用默认的异常处理器。</li>
<li>  SQLiteDatabaseConfiguration：数据库配置，应用程序可以创建多个到SQLite数据库的连接，这个类用来保证每个连接的配置都是相同的。</li>
<li>  SQLiteQuery和SQLiteStatement：从抽象类SQLiteProgram派生，封装了SQL语句的执行过程，在执行时自动组装待执行的SQL语句，并调用SQLiteSession来执行数据库操作。这两个类的实现应用了设计模式中的命令模式。</li>
</ul>
<h1 id="使用SQLiteOpenHelper的原因"><a href="#使用SQLiteOpenHelper的原因" class="headerlink" title="使用SQLiteOpenHelper的原因"></a>使用SQLiteOpenHelper的原因</h1><p>之所以需要使用SQLiteOpenHelper，而不是调用Context的方法来直接得到SQLiteDatabase，主要是因为它有两个好处：</p>
<ol>
<li> 自动管理创建：当需要对数据库进行操作的时候，不用关心SQLiteOpenHelper所关联的SQLiteDatabase是否创建，SQLiteOpenHelper会帮我们去判断，如果没有创建，那么就先创建该数据库后，再返回给使用者。</li>
<li> 自动管理版本：当需要对数据库进行操作之前，如果发现当前声明的数据库的版本和手机内的数据库版本不同的时候，那么会分别调用onUpgrade和onDowngrade，这样使用者就可以在里面来处理新旧版本的兼容问题。</li>
</ol>
<h1 id="SQLiteOpenHelper跟数据库连接池的关系是怎样的？"><a href="#SQLiteOpenHelper跟数据库连接池的关系是怎样的？" class="headerlink" title="# SQLiteOpenHelper跟数据库连接池的关系是怎样的？"></a># SQLiteOpenHelper跟数据库连接池的关系是怎样的？</h1><p>一个SQLiteOpenHelper对象存有一个SQLiteDatabase对象</p>
<p>一个SQLiteDatabase对象存有一个SQLiteConnectionPool对象</p>
<p>一个SQLiteConnectionPool对象</p>
<ol>
<li> 在journal-mode下最多存有1个SQLiteConnection</li>
<li> 在wal-mode下最多存有2个SQLiteConnection</li>
</ol>
<h1 id="SQL-语句的执行过程"><a href="#SQL-语句的执行过程" class="headerlink" title="SQL 语句的执行过程"></a>SQL 语句的执行过程</h1><p>创建SQLiteStatement对象，把SQL语句传给SQLiteStatement构造函数，调用SQLiteStatement的executeInsert()</p>
<p>SQLiteStatement.executeInsert()内部的增删改查方法都会先getSession()获取SQLiteSession，再调用SQLiteSession的execute方法</p>
<p>继续追查可以发现SQLiteSession是在SQLiteDatabase里以ThreadLocal形式存储，也就是每个线程只能有一个SQLiteSession</p>
<p>SQLiteSession的execute方法里会从数据库连接获取一个连接，每个SQLiteSession对象有一个SQLiteConnection对象</p>
<h1 id="SQLiteSession存在的价值"><a href="#SQLiteSession存在的价值" class="headerlink" title="SQLiteSession存在的价值"></a>SQLiteSession存在的价值</h1><p>给数据库连接代理了一层，管理事务和连接的生命周期。</p>
<p>在事务执行过程中一直持有数据库连接。</p>
<p>由于数据库连接数量是有限的，所以连接用完后要及时释放连接。</p>
<p>事务开启后，从连接池获取连接。</p>
<p>事务结束后，把连接归还到连接池。</p>
<h1 id="数据库连接是什么意思？"><a href="#数据库连接是什么意思？" class="headerlink" title="数据库连接是什么意思？"></a>数据库连接是什么意思？</h1><p>一个连接对应一个事务操作</p>
<h1 id="如果一个数据库连接始终不关闭会有什么影响？"><a href="#如果一个数据库连接始终不关闭会有什么影响？" class="headerlink" title="如果一个数据库连接始终不关闭会有什么影响？"></a>如果一个数据库连接始终不关闭会有什么影响？</h1><p>SQLite连接数有最大限制，不关闭，会导致别的进程无法连接数据库。</p>
<h1 id="SQLiteConnectionPool连接池大小是怎么定的"><a href="#SQLiteConnectionPool连接池大小是怎么定的" class="headerlink" title="SQLiteConnectionPool连接池大小是怎么定的?"></a>SQLiteConnectionPool连接池大小是怎么定的?</h1><p>目前Android系统的实现中，如果以非WAL模式打开数据库，连接池中只会保持一个数据库连接，如果以WAL模式打开数据库，连接池中的最大连接数量则根据系统配置决定，默认配置是两个。</p>
<h1 id="数据库连接池只提供最多1个连接会有什么影响？"><a href="#数据库连接池只提供最多1个连接会有什么影响？" class="headerlink" title="数据库连接池只提供最多1个连接会有什么影响？"></a>数据库连接池只提供最多1个连接会有什么影响？</h1><p>如果应用程序中有大量的并发数据库读和写操作的话，每个操作的时长都可能受到影响，所以数据库操作应放在工作线程中执行，以免影响UI响应。</p>
<p>因为每个事务都是在SQLiteSession中执行的，执行事务前会从连接池获取连接，调用的是SQLiteConnectionPool.acquireConnection()，方法内如果获取不到Connection就会阻塞线程等待，用链表存储阻塞的线程，直到连接被释放，也就是别的事务执行完成。</p>
<p>我们平时在多线程中的数据库操作都是串行的。</p>
<h1 id="Android里开启事务，事务模式用的是哪个？"><a href="#Android里开启事务，事务模式用的是哪个？" class="headerlink" title="Android里开启事务，事务模式用的是哪个？"></a>Android里开启事务，事务模式用的是哪个？</h1><ul>
<li>SQLiteDatabase.beginTransaction()开启的是EXCLUSIVE。</li>
<li>SQLiteDatabase.beginTransactionNonExclusive()开启的是IMMEDIATE。</li>
</ul>
<p>注意这两个事务模式只针对回滚日志模式下的事务。</p>
<p><a href="https://sqlite.org/lang_transaction.html#:%7E:text=EXCLUSIVE%20is%20similar%20to%20IMMEDIATE,while%20the%20transaction%20is%20underway.">SQLite官网</a>说在WAL日志模式下，EXCLUSIVE和IMMEDIATE是一样的。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>数据库</tag>
        <tag>SQLiteOpenHelper</tag>
        <tag>SQLiteConnectionPool</tag>
        <tag>SQLiteSession</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite事务、回滚日志、WAL</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E4%BA%8B%E5%8A%A1%E3%80%81%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E3%80%81WAL/</url>
    <content><![CDATA[<h1 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h1><p>事务定义了一组数据库操作的边界，这组操作要么全部执行，要么全部不执行，这也是事务的原子性特征</p>
<h1 id="为什么要发明事务？事务存在的价值是什么？"><a href="#为什么要发明事务？事务存在的价值是什么？" class="headerlink" title="为什么要发明事务？事务存在的价值是什么？"></a>为什么要发明事务？事务存在的价值是什么？</h1><p>在操作数据库的情况下，需要考虑的特别的场景处理特别多，例如并发操作、系统崩溃等，发明事务这个模型，就可以用来简化讨论，把复杂的场景归类为少数的几个特定类型的场景，降低处理成本。</p>
<p>数据库操作例如增删改查、建立索引、建立约束等。</p>
<h1 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h1><p>ACID</p>
<h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h2><p>事务内的操作要么全部执行，要么全部不执行，不可再拆分</p>
<h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><p>保证数据库从一个正确的状态转变到另一个正确的状态，正确的状态指的是当前数据库中的数据都满足预定的约束条件。</p>
<p>AID是保证一致性的必要条件，但不是充分条件，因为数据库作为通用的技术，不可能知道具体业务场景的正确逻辑，所以正确的逻辑需要由用户决定应该使用怎样的约束</p>
<h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h2><p>事务的执行不受其他事务的干扰，事务之间的操作只能串行的执行，保证任何事务都不可能读取到其他任何事务内部执行的中间状态，否则会产生数据混乱</p>
<h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h2><p>事务一旦提交，它对数据库中的数据改变就是永久性的，接下来的其他操作或故障都不会影响本次事务提交的结果</p>
<h2 id="事务的原子性是如何实现的？"><a href="#事务的原子性是如何实现的？" class="headerlink" title="事务的原子性是如何实现的？"></a>事务的原子性是如何实现的？</h2><p>SQLite事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。</p>
<p>回滚日志文件，用于实现数据库的原子提交和回滚。 此文件和数据库文件总是在同一个目录，并且有相同的文件名，但是在文件名中添加了一个-journal 字符串。此文件一般在transaction开始时创建，transaction结束时删除。</p>
<p>如果系统crash，Rollback journals文件将被保留，下次打开数据库文件时，系统会检查有没有Rollback journals文件存在，如果有就用它来恢复数据库。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092550.png"></p>
<h1 id="创建回滚日志详细过程是怎样的？"><a href="#创建回滚日志详细过程是怎样的？" class="headerlink" title="创建回滚日志详细过程是怎样的？"></a>创建回滚日志详细过程是怎样的？</h1><ol>
<li> 写数据库前获取保留锁</li>
<li> 创建回滚日志文件，将要修改的页的原始数据写到缓存中</li>
<li> 在用户空间修改页数据</li>
<li> 回滚日志的缓存刷盘到回滚日志文件中</li>
<li> 获取未决锁，等待共享锁都释放后，提升为排它锁</li>
<li> 将用户空间修改过的数据写入数据库文件，会先写到操作系统的缓存中，再刷盘到磁盘上</li>
<li> 删除rollback journal文件</li>
<li> 释放排它锁</li>
</ol>
<h2 id="创建rollback-journal-file"><a href="#创建rollback-journal-file" class="headerlink" title="创建rollback journal file"></a>创建rollback journal file</h2><p>将要修改的pages的原始数据写入rollback journal file，以page为单位写入。</p>
<p>rollback journal file中绿色的部分是header,header中会包括数据库文件的原始大小(即包括多少个page)。每一个page保存到rollback journal中时前边四字节会保存该page的page number。</p>
<ul>
<li>  rollback journal创建之后并没有实际落盘,只是保存在操作系统的缓存中</li>
<li>  rollback journal以page为单位,但每个page前四字节会有一个page number的记录,后四字节有一个checksum</li>
</ul>
<h2 id="在用户空间修改数据库文件"><a href="#在用户空间修改数据库文件" class="headerlink" title="在用户空间修改数据库文件"></a>在用户空间修改数据库文件</h2><p>修改用户进程空间内的数据库文件,注意不同的用户进程有自己的私有内存空间,因此此时的修改并不影响其他进程的读取操作。</p>
<h2 id="将rollback-journal落盘"><a href="#将rollback-journal落盘" class="headerlink" title="将rollback journal落盘"></a>将rollback journal落盘</h2><p>该步骤是保持原子性很关键的一步,保证即使掉电或者操作系统crash,Sqlite也能恢复到原来的状态。</p>
<p>(进行到该步也能看出reserved lock的作用,这种锁是一个中间状态,既能为即将写入做准备,又不影响其他进程的读取操作,提高并行度)。</p>
<p>该步需要刷两次盘,第一次将rollback journal的内容刷到磁盘,第二次在header中记录第一步中刷到磁盘的page个数,然后将header刷盘。</p>
<h2 id="获取排他锁"><a href="#获取排他锁" class="headerlink" title="获取排他锁"></a>获取排他锁</h2><p>在实际写入数据库文件之前,需要获取一个排他锁.获取过程分两步<br>    • 获取一个pending lock<br>    • 将pending lock升级为排他锁<br>获取到pending lock之后,在数据库文件上已经获取到共享锁的进程可以继续读取,但不允许其他进程继续获取共享锁.该锁存在的意义在于防止write starvation(即有大量的读取连接时,一直有新的共享锁产生,导致获取不到排他锁).当所有已经存在的共享锁都释放后,此时该pending lock即可以升级为排他锁。</p>
<h2 id="写入数据库文件"><a href="#写入数据库文件" class="headerlink" title="写入数据库文件"></a>写入数据库文件</h2><p>获取到排他锁后,说明已经没有其他进程在读取该数据库文件.此时可以安全的写入数据库文件.注意也只是写入操作系统的缓存中,并没有落盘。</p>
<h2 id="删除rollback-journal"><a href="#删除rollback-journal" class="headerlink" title="删除rollback journal"></a>删除rollback journal</h2><p>因为数据库文件已经安全落盘,此时可以删除掉rollback journal.若删除之前系统crash或者掉电,则重启后会恢复到事务开始前的状态,如果删除之后系统crash或者掉电,因为数据库文件已经落盘,相当于事务已经执行完成.(那么会不会在删除一半时系统crash或者掉电呢?注意上文中关于硬件的一些假设,删除操作必须是原子性的,即不会发生这种情况)</p>
<p>因为删除一个文件也是一个耗时的操作,因此Sqlite提供了两种方式减少删除过程的耗时.</p>
<ul>
<li>  将一个文件truncate为0</li>
<li>  将journal file header清0.清0操作并不是原子性的,但只要header中有一个byte被清0,该文件就会被识别为无效的格式</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.sqlite.org/lockingv3.html#rollback">The Rollback Journal</a></li>
</ul>
<h1 id="热日志是什么意思？"><a href="#热日志是什么意思？" class="headerlink" title="热日志是什么意思？"></a>热日志是什么意思？</h1><p>每次打开数据库文件，或者从数据库读取页时，都要简单的做一致性检查。</p>
<p>如果发现存在回滚日志文件，但是数据库中没有保留锁，那么创建日志文件的肯定崩溃了或者系统死机了，因为正常情况下，获得保留锁后才会创建回滚日志。</p>
<p>这种情况下日志被称为“热日志”，数据库可能处于不一致的状态（不满足约束条件），要让一切正常需要回滚日志，将数据库还原到初始的被中断的事务之前的状态。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092653.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>
<h1 id="SQLite中事务为什么还要分不同的类型？分别有什么作用？"><a href="#SQLite中事务为什么还要分不同的类型？分别有什么作用？" class="headerlink" title="SQLite中事务为什么还要分不同的类型？分别有什么作用？"></a>SQLite中事务为什么还要分不同的类型？分别有什么作用？</h1><p>是为了解决死锁</p>
<p>SQLite的事务分为</p>
<ol>
<li> deferred</li>
<li> immediate</li>
<li> exclusive</li>
</ol>
<p>begin [ deferred | immediate | exclusive ] transaction</p>
<p>deferred</p>
<ol>
<li> 未指定事务模式时默认的选择</li>
<li> 开始事务时处于未锁定状态</li>
<li> 实际访问数据库时才试图加锁</li>
<li> 第一个读数据库操作试图获取共享锁</li>
<li> 第一个写数据库操作试图获取预留锁</li>
</ol>
<p>immediate</p>
<ol>
<li> 事务开始时试图获取预留锁</li>
<li> 获取预留锁成功后，其他连接中已执行的事务无法再获取到预留锁</li>
<li> 新的连接开始immediate和exclusive的事务也会失败，并返回SQLITE_BUSY错误</li>
<li> 最后提交事务时，预留锁会提升到未决锁</li>
<li> 等待其他连接中的事务释放共享锁</li>
<li> 阻止新的连接获取共享锁</li>
<li> 如果其他事务一直没释放共享锁，会返回SQLITE_BUSY错误</li>
</ol>
<p>exclusive</p>
<ol>
<li> 开始事务时尝试获取排它锁</li>
<li> 获取成功后阻止所有的读写操作</li>
<li> 在事务内可以对数据库进行任意的读写</li>
</ol>
<p>参考《SQLite权威指南（第2版）》118页  第4章 SQLite中的高级SQL - 事务的类型</p>
<h1 id="SQLite-WAL是什么？"><a href="#SQLite-WAL是什么？" class="headerlink" title="SQLite WAL是什么？"></a>SQLite WAL是什么？</h1><p>SQLite在3.7.0开始引入了WAL技术</p>
<p>Write-Ahead Log</p>
<p>预先写日志</p>
<p>默认的 rollback journal 模式工作原理大致为：写操作进行前进行数据库文件拷贝，然后对数据库进行写操作。如果发生 Crash 或者 rallback 则将日志中的原始内容回滚到数据库中进行恢复操作，否则在 Commit 完成时删除日志文件。</p>
<p>WAL模式采用了相反的的做法，</p>
<p>在准备写数据库文件前，会先复制数据库文件的中的原始数据到日志文件，写操作也只更新日志文件，原有数据库文件不变动；</p>
<p>如果事务失败，WAL中的数据被忽略；</p>
<p>如果事务成功，在随后的某个时间点，将WAL中的数据写回到数据库文件，这个时间点称为checkpoint。</p>
<p>WAL使用检查点将修改写回数据库，默认情况下，当WAL文件发现有1000页修改时，将自动调用检查点。这个页数大小可以自行配置。</p>
<p>读数据时，SQLite在WAL中搜索，找到最后一个写入点，并记录，读时忽略这个写入点后面的信息，如果读取在WAL中读取不到数据，则去数据库文件中读取；写数据时继续往记录点后追加写入数据，这样保证了读和写可以同时进行；由于同一时刻只能有一个连接写数据库，写与写之间是互斥的，所以不会产生写入点后面写数据时指针冲突。</p>
<p>由于每个读操作都会搜索整个WAL文件，所以在共享内存加建立了一个wal-index索引，加速查找，避免扫描整个WAL文件。</p>
<h1 id="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"><a href="#WAL提升了哪方面的性能？优点是什么？解决了什么问题？" class="headerlink" title="WAL提升了哪方面的性能？优点是什么？解决了什么问题？"></a>WAL提升了哪方面的性能？优点是什么？解决了什么问题？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093052.png"></p>
<p>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> WAL is significantly faster in most scenarios.</li>
<li> WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</li>
<li> Disk I/O operations tends to be more sequential using WAL.</li>
<li> WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</li>
</ol>
<p>参考：<a href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="WAL的缺点是什么？"><a href="#WAL的缺点是什么？" class="headerlink" title="WAL的缺点是什么？"></a>WAL的缺点是什么？</h1><ol>
<li> 所有的数据库操作必须都在同一台机器上进行，并且该机器的操作系统需要支持 VFS 特性。</li>
<li> 当连接处于 WAL 模式中时我们无法修改页大小</li>
<li> 为满足 Wal 和相关共享内存的需要，使用 WAL 引入了两个额外的半持久性文件 -wal 和 -shm 该文件需要占用一定的存储空间。</li>
<li> 数据库读性能会比 rollback journal 模式略差 （大概慢 1% ～ 2% ），另外写操作也会间歇性的性能下降。</li>
<li> 读操作的性能会比 rollback journal 模式出现部分下降，因为它需要额外对 -wal 文件进行一次检索，而且 Checkpoint 本身就比较耗时且会对读操作进行阻塞。</li>
<li> 频繁 Checkpoint 变得频繁又会影响写操作的性能指标，而且频繁的同步操作也会增加数据库损坏的概率</li>
</ol>
<hr>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828093220.png"><br>参考：《SQLite权威指南（第2版）》第11章 sqlite内部机制及新特性 - wal的优缺点</p>
<hr>
<ol>
<li> All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</li>
<li> Transactions that involve changes against multiple <a href="https://sqlite.org/lang_attach.html">ATTACHed</a> databases are atomic for each individual database, but are not atomic across all databases as a set.</li>
<li> WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</li>
<li> There is an additional quasi-persistent “-wal” file and “-shm” shared memory file associated with each database, which can make SQLite less appealing for use as an <a href="https://sqlite.org/appfileformat.html">application file-format</a>.</li>
</ol>
<p>参考：<a href="https://sqlite.org/wal.html">https://sqlite.org/wal.html</a></p>
<h1 id="Android中如何开启WAL？"><a href="#Android中如何开启WAL？" class="headerlink" title="Android中如何开启WAL？"></a>Android中如何开启WAL？</h1><p>SQLiteDatabase.enableWriteAheadLogging()</p>
<p>根据注释描述，Android默认没有开启WAL。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
        <tag>回滚日志</tag>
        <tag>WAL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite并发</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="SQLite支持多线程吗？"><a href="#SQLite支持多线程吗？" class="headerlink" title="SQLite支持多线程吗？"></a>SQLite支持多线程吗？</h1><p>SQLite支持多线程，但是是有条件的支持，也就是：</p>
<ul>
<li>同一个连接不能在多线程中使用，不同连接才可以在多线程中使用，这个是最宏观的SQLite多线程准则。</li>
<li>SQLite的文件锁是粗颗粒的，也就是以数据库文件为维度加锁，涉及到5种锁状态。</li>
</ul>
<p>为了确保数据库安全，SQLite 内部抽象了两种类型的互斥锁（锁的具体实现和宿主平台有关）来应对线程并发问题：</p>
<ul>
<li>fullMutex<br>可以理解为 connection mutex，和连接句柄（上问描述的 sqlite3 结构体）绑定。<br>保证任何时候，最多只有一个线程在执行基于连接的事务。</li>
<li>coreMutex<br>当前进程中，与文件绑定的锁。<br>用于保护数据库相关临界资源，确保在任何时候，最多只有一个线程在访问。</li>
</ul>
<h2 id="SQLite三种线程模型"><a href="#SQLite三种线程模型" class="headerlink" title="SQLite三种线程模型"></a>SQLite三种线程模型</h2><ul>
<li>single-thread<ul>
<li>  coreMutex 和 fullMutex 都被禁用。</li>
<li>  用户层需要确保在任何时候只有一个线程访问 API，否则抛出异常。</li>
</ul>
</li>
<li>multi-thread<ul>
<li>  coreMutex 保留，fullMutex 禁用。</li>
<li>  可以多个线程基于不同的连接并发访问数据库，但单个连接在任何时候只能被一个线程访问。</li>
<li>单个 connection，如果并发访问，会抛出异常。<ul>
<li>  报错信息：illegal multi-threaded access to database connection。</li>
</ul>
</li>
</ul>
</li>
<li>serialized<ul>
<li>  coreMutex 和 fullMutex 都保留。</li>
</ul>
</li>
</ul>
<h1 id="同一个数据库连接多线程访问会有什么问题？"><a href="#同一个数据库连接多线程访问会有什么问题？" class="headerlink" title="同一个数据库连接多线程访问会有什么问题？"></a>同一个数据库连接多线程访问会有什么问题？</h1><p>一个数据库连接对应一个事务操作，多线程访问一个连接会造成事务不原子化，事务执行结果会混乱。</p>
<h1 id="不同的连接同时写数据库会发生什么？"><a href="#不同的连接同时写数据库会发生什么？" class="headerlink" title="不同的连接同时写数据库会发生什么？"></a>不同的连接同时写数据库会发生什么？</h1><p>就走入了SQLite本身的锁机制。</p>
<p>写数据会去获取保留锁、独占锁。</p>
<p>如果还有连接要写入，就会返回SQLITE_BUSY。</p>
<h1 id="Android中的SQLite的Thread-Mode是什么？"><a href="#Android中的SQLite的Thread-Mode是什么？" class="headerlink" title="Android中的SQLite的Thread Mode是什么？"></a>Android中的SQLite的Thread Mode是什么？</h1><p><a href="http://www.sqlite.org/threadsafe.html">SQLite官网</a>说默认线程模式是serialized</p>
<p>Android的SQLiteDatabase类的<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">setLockingEnabled(boolean lockingEnabled)文档</a>说，默认线程模式是Multi-thread。</p>
<p>API 16 setLockingEnabled() 方法又废弃了。</p>
<p>不管怎么说肯定不是single-thread，不是multi-thread就是serialized。</p>
<p>参考：<br><a href="https://stackoverflow.com/questions/11167834/what-is-the-default-threading-mode-of-sqlite-in-android">What is the Default Threading mode of SQLite in Android?</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>数据库</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite锁机制</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="SQLite锁的粒度到哪里？"><a href="#SQLite锁的粒度到哪里？" class="headerlink" title="SQLite锁的粒度到哪里？"></a>SQLite锁的粒度到哪里？</h1><p>SQLite锁的是整个数据库文件，不支持页锁、表锁和行锁，粒度较粗。</p>
<p>当一个连接要写数据库文件时，所有其他的连接都会阻塞，直到写数据的连接事务结束。</p>
<p>SQLite 3.7.0 新增 Write-Ahead Log 机制改变了事务行为，读写可以并发。</p>
<h1 id="为什么SQLite不支持表锁和行锁呢？"><a href="#为什么SQLite不支持表锁和行锁呢？" class="headerlink" title="为什么SQLite不支持表锁和行锁呢？"></a>为什么SQLite不支持表锁和行锁呢？</h1><p>支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。</p>
<p>同时复杂性增大会增加运行设备电量的损害，对于手机这类这种电量敏感的设备比较重要。</p>
<h1 id="SQLite锁机制是怎样的？"><a href="#SQLite锁机制是怎样的？" class="headerlink" title="SQLite锁机制是怎样的？"></a>SQLite锁机制是怎样的？</h1><p>有多个数据库连接同时访问同一个数据库，就产生了资源竞争，需要锁机制保证资源竞争的正确性</p>
<p>数据库操作无非就是读和写，按道理普通的读写锁就可以实现，但高并发下读写锁仍然有优化的空间，为了提高整体的吞吐量，SQLite使用了锁逐步提升的机制</p>
<p>SQLite共有5种锁状态：</p>
<ol>
<li> 无锁（unlocked）</li>
<li> 共享（shared）</li>
<li> 预留（reserved）</li>
<li> 未决（pending）</li>
<li> 排它（exclusive）</li>
</ol>
<p>每个数据库连接同一时刻只能处于其中一个状态</p>
<p>无锁：</p>
<ol>
<li> 即使事务已经开始，在没有读写数据库前，都是无锁状态</li>
</ol>
<p>共享：</p>
<ol>
<li> 读数据库必须获得共享锁</li>
<li> 多个数据库连接可以同时获得共享锁，即允许多个连接同时读数据库</li>
<li> 写数据库前必须要释放所有的共享锁</li>
</ol>
<p>预留：</p>
<ol>
<li> 写数据需要先获取到预留锁</li>
<li> 持有预留锁后就可以立即把数据写入缓存中，而不用竞争数据库文件，把可以不占用的数据库文件可以完成的事情提前完成，这样最大程度的减少独占数据库文件的时间</li>
<li> 预留锁可以与共享锁共存</li>
<li> 预留锁不影响其他已经持有共享锁的连接继续读数据库</li>
<li> 预留锁不阻止其他连接获得新的共享锁，因为并不确定是否要立即写入数据库文件，可能之后还要修改数据库内容，提交事务的时候才知道后面不会再修改数据库了</li>
<li> 一个数据库同时只能有一个预留锁存在</li>
</ol>
<p>未决：</p>
<ol>
<li> 当连接提交事务时，就要把缓存里的数据往数据库文件中写入，以保证事务的持久性</li>
<li> 对数据库文件写数据前，需要保证没有连接再持有共享锁</li>
<li> 但此时可能还有其他连接持有共享锁，需要等待这些连接释放共享锁后，才能写数据</li>
<li> 同时要阻止新的连接获取共享锁，否则写数据一直得不到执行</li>
<li> 所以从预留锁要转变为未决锁，来阻止新的连接获取共享锁</li>
</ol>
<p>排它：</p>
<ol>
<li> 所有共享锁释放后，未决锁提升为排他锁</li>
<li> 排它锁和未决锁一样，会阻止新的连接获取共享锁，阻止读数据</li>
<li> 获得排它锁后，就可以把缓存中的数据写入数据库文件</li>
</ol>
<p>参考资料：</p>
<p>《SQLite权威指南（第2版）》116页  第4章 SQLite中的高级SQL - 数据库锁</p>
<h1 id="SQLite锁为什么搞这么多状态？"><a href="#SQLite锁为什么搞这么多状态？" class="headerlink" title="SQLite锁为什么搞这么多状态？"></a>SQLite锁为什么搞这么多状态？</h1><ul>
<li>由于写数据时是排他的，其他连接无法读数据库，所以要尽可能的减少写数据时的耗时，才能提高系统整体的吞吐量。</li>
<li>所以写数据时先获取预留锁，把可以在不占用数据库文件的事情提前做好。</li>
<li>那些需要占用数据库文件才能做的事情留到获取到排他锁时再做。<ul>
<li>获取排它锁前需要保证没有连接再获取共享锁。</li>
<li>所以先从预留锁提升到未决锁，用来阻止新的共享锁的获取。</li>
<li>等待已经获取的共享锁的连接执行完后释放了所有的共享锁，最后获取到排它锁写数据库文件。</li>
</ul>
</li>
</ul>
<h1 id="锁的状态转移过程是怎样的？"><a href="#锁的状态转移过程是怎样的？" class="headerlink" title="锁的状态转移过程是怎样的？"></a>锁的状态转移过程是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091837.png"></p>
<h1 id="为什么事务的开始都要先获取未决锁，再获取共享锁？"><a href="#为什么事务的开始都要先获取未决锁，再获取共享锁？" class="headerlink" title="为什么事务的开始都要先获取未决锁，再获取共享锁？"></a>为什么事务的开始都要先获取未决锁，再获取共享锁？</h1><p>因为如果已经获得了未决锁，说明要占用数据库文件进行写操作，就不允许读了，而读数据库需要获得共享锁，这里就阻止别的连接获取共享锁。</p>
<h1 id="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"><a href="#有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？" class="headerlink" title="有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？"></a>有了预留锁，为什么还需要一个未决锁？未决锁存在的作用是什么？没有未决锁会发生什么？</h1><p>获得预留锁时，读写可以并发执行，但是真正写数据库需要阻止共享锁获取。</p>
<p>这样做可以提升系统整体的吞吐量。</p>
<h1 id="SQLite锁机制需要注意什么？"><a href="#SQLite锁机制需要注意什么？" class="headerlink" title="SQLite锁机制需要注意什么？"></a>SQLite锁机制需要注意什么？</h1><p>注意死锁的发生</p>
<h1 id="SQLite什么情况下会发生死锁？"><a href="#SQLite什么情况下会发生死锁？" class="headerlink" title="SQLite什么情况下会发生死锁？"></a>SQLite什么情况下会发生死锁？</h1><p>SQLite发生死锁时会抛出database is locked的异常信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828091949.png"></p>
<p>参考《SQL权威指南（第2版）》117页 SQLite中的高级SQL - 死锁</p>
<h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><p>用正确的事务类型来开启事务</p>
<p>存在并发写数据，就开启immediate或exclusive事务，提供了同步机制</p>
<p>SQLite有三种不同的事务类型：</p>
<ol>
<li> DEFERRED（推迟）</li>
<li> MMEDIATE（立即）</li>
<li> EXCLUSIVE（排它）</li>
</ol>
<p>事务类型在BEGIN命令中指定。</p>
<p>一个deferred事务不获取任何锁，直到它需要锁的时候。而且BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态；默认情况下是这样的。如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取SHARED LOCK；同样，当进行第一次写操作时，它会获取RESERVED LOCK。</p>
<p>由BEGIN开始的Immediate事务会试着获取RESERVED LOCK。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作，但是RESERVED LOCK会阻止其它的连接BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，SQLite会返回SQLITE_BUSY错误。这时你就可以对数据库进行修改操作，但是你不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。</p>
<p>Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 上面那个例子的问题在于两个连接最终都想写数据库，但是他们都没有放弃各自原来的锁，最终，shared 锁导致了问题的出现。如果两个连接都以BEGIN IMMEDIATE开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入BEGIN IMMEDIATE，其它的连接就得等待。BEGIN IMMEDIATE和BEGIN EXCLUSIVE通常被写事务使用。就像同步机制一样，它防止了死锁的产生。 基本的准则是：如果你在使用的数据库没有其它的连接，用BEGIN就足够了。但是，如果你使用的数据库在其它的连接也要对数据库进行写操作，就得使用BEGIN IMMEDIATE或BEGIN EXCLUSIVE开始你的事务。</p>
<h1 id="Android中对SQLite开启的哪一种事务类型？"><a href="#Android中对SQLite开启的哪一种事务类型？" class="headerlink" title="Android中对SQLite开启的哪一种事务类型？"></a>Android中对SQLite开启的哪一种事务类型？</h1><p>SQLiteDatabase开启事务有两个方法：</p>
<ol>
<li> beginTransaction()开启exclusive事务类型</li>
<li> beginTransactionNonExclusive()开启immediate事务类型</li>
</ol>
<h1 id="锁的状态存储在哪里？"><a href="#锁的状态存储在哪里？" class="headerlink" title="锁的状态存储在哪里？"></a>锁的状态存储在哪里？</h1><p>数据库文件是独立于进程的，多个进程可以访问同一个文件，所以数据库锁是存在数据库文件中的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092032.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210828092040.png"></p>
<p>参考《SQL权威指南（第2版）》159页  第5章 SQLite设计与概念 - 写事务</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQLite锁</tag>
      </tags>
  </entry>
  <entry>
    <title>关系型数据库-范式</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="范式解决的是什么问题？"><a href="#范式解决的是什么问题？" class="headerlink" title="范式解决的是什么问题？"></a>范式解决的是什么问题？</h1><p>消除数据冗余，提高增删改查的性能。</p>
<h1 id="范式的优缺点？"><a href="#范式的优缺点？" class="headerlink" title="范式的优缺点？"></a>范式的优缺点？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231020.png"></p>
<p>参考：《高性能MySQL》 4.3.1 范式的优点和缺点。</p>
<h1 id="反范式的优缺点？"><a href="#反范式的优缺点？" class="headerlink" title="反范式的优缺点？"></a>反范式的优缺点？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231049.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231057.png"></p>
<p>参考：《高性能MySQL》 4.3.2 反范式的优点和缺点</p>
<h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>确保每列保持原子性。</p>
<p>每列不可再分割，符合原子性特征，不分割的话你增删改查特定的数据发现不是单独的一列就不方便。</p>
<p>违反第一范式：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231130.png"></p>
<p>符合第一范式：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231142.png"></p>
<h2 id="满足第一范式后还存在什么问题？"><a href="#满足第一范式后还存在什么问题？" class="headerlink" title="满足第一范式后还存在什么问题？"></a>满足第一范式后还存在什么问题？</h2><p>但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231343.png"></p>
<ol>
<li> 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大</li>
<li> 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 ——插入异常</li>
<li> 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常</li>
<li> 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常。</li>
</ol>
<h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>确保每列都和主键相关。</p>
<p>每列依赖于全部的主键而非部分主键，这样才可以唯一确定一行记录，消除一部分冗余。</p>
<h2 id="怎样判断表是否符合第二范式？"><a href="#怎样判断表是否符合第二范式？" class="headerlink" title="怎样判断表是否符合第二范式？"></a>怎样判断表是否符合第二范式？</h2><p>第一步：找出数据表中所有的码（单主键或联合主键）。</p>
<p>第二步：根据第一步所得到的码，找出所有的主属性（主键中的属性）。</p>
<p>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。</p>
<p>第四步：查看是否存在非主属性对码的部分函数依赖，根据上下文分析属性间依赖关系</p>
<h2 id="违反第二范式会怎样？"><a href="#违反第二范式会怎样？" class="headerlink" title="违反第二范式会怎样？"></a>违反第二范式会怎样？</h2><p>为了满足第二范式，会把表进行拆分，这样可以消除表中的冗余信息、插入异常、删除异常、修改异常。</p>
<p>违反第二范式的表：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231441.png"></p>
<p>属性间依赖关系：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231449.png"></p>
<p>满足第二范式后表情况：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231504.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231512.png"></p>
<p>运用第二范式后结果：</p>
<ol>
<li>李小明转系到法律系<br> 只需要修改一次李小明对应的系的值即可。——有改进</li>
<li>数据冗余是否减少了？<br> 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
<li>删除某个系中所有的学生记录<br> 该系的信息仍然全部丢失。——无改进</li>
<li>插入一个尚无学生的新系的信息。<br> 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
</ol>
<h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>确保每列都和主键直接相关而非间接相关。</p>
<p>非主键列之间不应该有依赖关系，这样可以消除冗余信息。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231541.png"></p>
<p>对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231553.png"></p>
<p>对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。</p>
<p>为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：</p>
<ul>
<li>选课（学号，课名，分数）</li>
<li>学生（学号，姓名，系名）</li>
<li>系（系名，系主任）</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231621.png"></p>
<p>结果：</p>
<ol>
<li>删除某个系中所有的学生记录<br> 该系的信息不会丢失。——有改进</li>
<li>插入一个尚无学生的新系的信息。<br> 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
<li> 数据冗余更加少了。——有改进</li>
</ol>
<h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><p>消除多值依赖，不能有多个主键</p>
<p>符合第三范式的表：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827231650.png"></p>
<ol>
<li> 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li> 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量</p>
<p>码：（管理员，物品名），（仓库名，物品名）</p>
<p>主属性：仓库名、管理员、物品名</p>
<p>非主属性：数量</p>
<p>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
<ol>
<li> 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
<li> 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li>
<li> 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li>
</ol>
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
<p>造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）</p>
<p>库存（仓库名，物品名，数量）</p>
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
<h1 id="严格遵守范式会有什么问题？"><a href="#严格遵守范式会有什么问题？" class="headerlink" title="严格遵守范式会有什么问题？"></a>严格遵守范式会有什么问题？</h1><p>一般达到2范式就可以，为了性能和灵活性不需要严格的遵守范式，允许存在冗余，可以带来其他的便利，但是最好要知道是怎么回事。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/20028672">数据库第一二三范式到底在说什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="数据库建立索引是干什么的？"><a href="#数据库建立索引是干什么的？" class="headerlink" title="数据库建立索引是干什么的？"></a>数据库建立索引是干什么的？</h1><p>按某列的条件做查询后（where子句中访问的列），需要线性扫描全表太慢了。</p>
<p>用B+树实现索引可以在对数时间内完成查询。</p>
<h1 id="索引为什么不用平衡二叉查找树，要用B树或B-树做索引？"><a href="#索引为什么不用平衡二叉查找树，要用B树或B-树做索引？" class="headerlink" title="索引为什么不用平衡二叉查找树，要用B树或B+树做索引？"></a>索引为什么不用平衡二叉查找树，要用B树或B+树做索引？</h1><p>B树又称多路平衡二叉查找树，一个结点存储多个值，可以降低树的高度，即降低了访问结点的次数，一次访问可以认为是一次IO，降低了IO次数就会提高整体的访问速度。</p>
<h1 id="为什么不用哈希表做索引？查询时间复杂度不是O-1"><a href="#为什么不用哈希表做索引？查询时间复杂度不是O-1" class="headerlink" title="为什么不用哈希表做索引？查询时间复杂度不是O(1)?"></a>为什么不用哈希表做索引？查询时间复杂度不是O(1)?</h1><ol>
<li> 哈希索引对于范围查询和排序却无法很好地支持，最终导致全表扫描</li>
<li> 哈希索引不支持多列联合索引的最左匹配规则</li>
<li> 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li>
</ol>
<h1 id="为什么用B-树做索引而不用B树？"><a href="#为什么用B-树做索引而不用B树？" class="headerlink" title="为什么用B+树做索引而不用B树？"></a>为什么用B+树做索引而不用B树？</h1><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</p>
<p> B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。</p>
<p>而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间。</p>
<h1 id="使用B树做索引的好处？"><a href="#使用B树做索引的好处？" class="headerlink" title="使用B树做索引的好处？"></a>使用B树做索引的好处？</h1><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h1 id="索引有什么缺点？"><a href="#索引有什么缺点？" class="headerlink" title="索引有什么缺点？"></a>索引有什么缺点？</h1><ol>
<li> 占用空间，因为会把列的信息都复制一遍</li>
<li> 插入、修改、删除时需要额外花时间更新索引</li>
</ol>
<h1 id="索引适用场景？"><a href="#索引适用场景？" class="headerlink" title="索引适用场景？"></a>索引适用场景？</h1><p>适用查询非常频繁而更新不频繁的列。</p>
<h2 id="where子句中对列的访问"><a href="#where子句中对列的访问" class="headerlink" title="where子句中对列的访问"></a>where子句中对列的访问</h2><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p>
<h1 id="为什么外键要加索引？"><a href="#为什么外键要加索引？" class="headerlink" title="为什么外键要加索引？"></a>为什么外键要加索引？</h1><p>避免子表上的全表扫描。（外键在子表上，外键对应主表的主键）</p>
<p>假设删除departments主表id=10的记录，如果employees子表的department_id外键没有索引，那么就会全表扫描employees子表，以确认是否存在department id=10的记录。</p>
<h1 id="联合索引是什么？"><a href="#联合索引是什么？" class="headerlink" title="联合索引是什么？"></a>联合索引是什么？</h1><p>对多个字段联合创建的索引。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232210.png"></p>
<p>只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p>
<p>通俗理解：</p>
<p>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</p>
<p>所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p>
<p>查英语字典、汉语字典也是这样。</p>
<h1 id="联合索引的底层实现是怎样的？"><a href="#联合索引的底层实现是怎样的？" class="headerlink" title="联合索引的底层实现是怎样的？"></a>联合索引的底层实现是怎样的？</h1><p>索引的底层是一颗B+树，联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。</p>
<p>构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。</p>
<p>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232238.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p>联合索引会对最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序，以此类推。</p>
<p>所以如果要利用到联合索引中靠后列的索引，前面列就必须相等，如果前面列不相等（比如用范围查询），那么后面的列没办法保证顺序，后面列的顺序都是在前面列相等的情况下才保持顺序的。</p>
<h1 id="为什么表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么表必须有主键，并且推荐使用整型的自增主键？"></a>为什么表必须有主键，并且推荐使用整型的自增主键？</h1><p>不建主键不代表没有主键，没有建主键innodb会帮你选一个字段，一个可以标识唯一的字段，选为默认字段，如果这个字段唯一的话，不重复，可一键唯一索引的话，就会作为类似于唯一索引，用这个字段来作为唯一索引来维护整个表的数据。如果没有，mysql会生成一个唯一的列，类似于rowid，只不过你看不到，他会用生成的这个唯一列，维护B+Tree的结构，查数据的时候还是用B+Tree的结构去查找。</p>
<h2 id="为什么推荐整型呢？"><a href="#为什么推荐整型呢？" class="headerlink" title="为什么推荐整型呢？"></a>为什么推荐整型呢？</h2><p>我们想象一下查找过程，是把节点load到内存然后在内存里去比较大小，也就是在查找的过程中要不断的去进行数据的比对。假设UUID，既不自增也不是整形。问一下，是整形的1&lt;2比较的效率高还是字符串的“abc”和“abe”比较的效率高呢？显然是前者，因为字符串的比较是转换成ASICI一位一位的比，如果最后一位不一样，比到最后才比较出大小，就比整形比较慢多了，存储空间来说，整形更小。索引越节约资源越好。</p>
<p>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232458.png"></p>
<p>所以建议使用int的auto_increment作为主键。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827232514.png"><br>主键的值是顺序的，所以每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p>
<h2 id="为什么是自增的呢？"><a href="#为什么是自增的呢？" class="headerlink" title="为什么是自增的呢？"></a>为什么是自增的呢？</h2><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h1 id="聚簇索引是什么？"><a href="#聚簇索引是什么？" class="headerlink" title="聚簇索引是什么？"></a>聚簇索引是什么？</h1><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>数据库表数据是用B+树来存储组织的，那么这个B+树可以认为是一种索引，这就是聚簇索引。</p>
<p>索引是针对某一列而言的，一般的聚簇索引就是主键列。</p>
<p>聚簇索引确定了表数据的物理存储顺序，聚簇索引B+树的叶子结点存储的是整个行数据</p>
<p>由于聚簇索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚簇索引。</p>
<p>聚簇索引类似于电话簿，按姓氏排列数据。汉语字典也是聚簇索引的典型应用，在汉语字典里，索引项是字母+声调，字典正文也是按照先字母再声调的顺序排列。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<p>如果是普通的索引，B+树的叶子结点存储的行的主键，然后需要再去聚簇索引下去查询一遍，找到完整的行数据，有一个回表查询的过程，所以在聚簇索引上查询会少了回表查询的过程，查询速度快。</p>
<p>MySQL官方对聚簇索引的解释：</p>
<p><strong>The InnoDB term for a primary key index</strong>. InnoDB table storage is organized based on the values of the primary key columns, to speed up queries and sorts involving the primary key columns. For best performance, choose the primary key columns carefully based on the most performance-critical queries. Because modifying the columns of the clustered index is an expensive operation, choose primary columns that are rarely or never updated.</p>
<p>注意标黑的那段话，聚簇索引就是主键的一种术语。</p>
<h1 id="聚簇索引有什么用？"><a href="#聚簇索引有什么用？" class="headerlink" title="聚簇索引有什么用？"></a>聚簇索引有什么用？</h1><p>聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用<a href="https://baike.baidu.com/item/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">聚集索引</a>可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚簇（物理排序），避免每次查询该列时都进行排序，从而节省成本。</p>
<p>在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查(between、&lt;、&lt;=、&gt;、&gt;=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大大提高查询速度。</p>
<h1 id="为什么非聚簇索引结构叶子节点存储的是主键值？"><a href="#为什么非聚簇索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非聚簇索引结构叶子节点存储的是主键值？"></a>为什么非聚簇索引结构叶子节点存储的是主键值？</h1><p>为了一致性和节省存储空间。已经维护了一套主键索引+数据的B+Tree结构，如果再有其他的非主键索引的话，索引的叶子节点存储的是主键，这是为了节省空间，因为继续存数据的话，那就会导致一份数据存了多份，空间占用就会翻倍。另一方面也是一致性的考虑，都通过主键索引来找到最终的数据，避免维护多份数据导致不一致的情况。</p>
<h1 id="哪些列适合作为聚簇索引？"><a href="#哪些列适合作为聚簇索引？" class="headerlink" title="哪些列适合作为聚簇索引？"></a>哪些列适合作为聚簇索引？</h1><p>1、主键列,该列在where子句中使用并且插入是随机的。</p>
<p>2、按范围存取的列，如pri_order &gt; 100 and pri_order &lt; 200。</p>
<p>3、在group by或order by中使用的列。</p>
<p>4、不经常修改的列。</p>
<p>5、在连接操作中使用的列。</p>
<h1 id="聚簇索引的优点和缺点？"><a href="#聚簇索引的优点和缺点？" class="headerlink" title="聚簇索引的优点和缺点？"></a>聚簇索引的优点和缺点？</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li> 适合范围查询</li>
<li> 适配排序</li>
<li> 当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引只能定位到对应主键，然后要再回表查询聚簇索引，才能找到完整的行数据。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p>
<p>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
<p>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
<p>4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
<h1 id="二级索引是什么？"><a href="#二级索引是什么？" class="headerlink" title="二级索引是什么？"></a>二级索引是什么？</h1><p>表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p>
<p>除了聚簇索引以外的所有索引都称为二级索引，二级索引的叶子节点内容是主键的值。</p>
<p>二级索引没有存储全部的数据，假如二级索引满足查询需求，则直接返回，即为覆盖索引，反之则需要回表去主键索引(聚簇索引)查询。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233004.png"></p>
<h1 id="何时使用聚簇索引与非聚簇索引？"><a href="#何时使用聚簇索引与非聚簇索引？" class="headerlink" title="何时使用聚簇索引与非聚簇索引？"></a>何时使用聚簇索引与非聚簇索引？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827233032.png"></p>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><p>（1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列，即较频繁作为查询条件的字段才去创建索引</p>
<p>（2）取值离散小、查询中很少涉及、重复值比较多的列，索引效果较差，没有必要在此列建立索引</p>
<p>（3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p>
<p>（4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<p>（5）更新频繁字段不适合创建索引。</p>
<h1 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h1><ol>
<li> 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li> 存储引擎不能使用索引范围条件右边的列</li>
<li> 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</li>
<li> mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li> is null,is not null也无法使用索引</li>
<li> like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>B+树</tag>
        <tag>联合索引</tag>
        <tag>聚簇索引</tag>
        <tag>二级索引</tag>
        <tag>主键</tag>
      </tags>
  </entry>
  <entry>
    <title>B树、B+树</title>
    <url>/%E7%AE%97%E6%B3%95/B%E6%A0%91%E3%80%81B+%E6%A0%91/</url>
    <content><![CDATA[<h1 id="B和B-里的B是什么意思"><a href="#B和B-里的B是什么意思" class="headerlink" title="B和B+里的B是什么意思?"></a>B和B+里的B是什么意思?</h1><p>B是Balanced的缩写，平衡的意思。</p>
<p>全称可以叫多路（多叉）平衡查找（搜索）树。</p>
<h2 id="多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？"><a href="#多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？" class="headerlink" title="多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？"></a>多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？</h2><p>由于平衡二叉查找树只有两个分叉，查询叶子结点需要访问$log_2{n}$次节点，即树的高度。</p>
<p>如果要减少查找次数，就要让树变矮一点。</p>
<p>那么一个节点有多个分叉，同时让一个节点存储多个值，就可以降低树的高度，进而减少节点平均的访问次数。</p>
<h2 id="减少节点的访问次数有什么好处？"><a href="#减少节点的访问次数有什么好处？" class="headerlink" title="减少节点的访问次数有什么好处？"></a>减少节点的访问次数有什么好处？</h2><p>访问节点的成本可能非常大，减少访问节点的次数，就可以降低总的访问成本。</p>
<p>例如访问IO比访问内存要慢的多，文件系统中普遍采用多路平衡查找树作为存储数据的结构。</p>
<h2 id="B树与B-的区别？"><a href="#B树与B-的区别？" class="headerlink" title="B树与B+的区别？"></a>B树与B+的区别？</h2><p>B树与B+共同点：</p>
<ol>
<li> 都是一个节点按顺序存储多个值</li>
<li> 每个节点可以有多个分叉</li>
</ol>
<p>B树独有：</p>
<ol>
<li> 非叶子节点存储了数据，非叶子节点占用空间更大</li>
</ol>
<p>B+树独有：</p>
<ol>
<li> 非叶子节点不存数据只存索引信息，数据全部在叶子节点，非叶子节点占用空间更小</li>
<li> 叶子结点用双向链表相连，便于顺序查找</li>
</ol>
<h2 id="B-树作为数据库索引有什么优势？"><a href="#B-树作为数据库索引有什么优势？" class="headerlink" title="B+树作为数据库索引有什么优势？"></a>B+树作为数据库索引有什么优势？</h2><p>非叶子结点的大小可以设置为一页，内存从外存读取数据是按页读取的，这样就减少了IO访问次数。</p>
<p>结点内部是有序的，可以再用二分查找去查找元素。</p>
<p>B+树的非叶子结点不存储数据，只存键，这样同样空间大小可以存的键就更多，非叶子结点的数量就会减少，IO访问次数也就变少了。</p>
<p>B+树的叶子结点用双链表链接，这样对区间查询友好，只需要通过非叶结点查找到区间范围，然后顺序遍历即可，可以减少对非叶结点的访问，进而减少IO访问次数。因为由于虚拟内存机制，非叶结点加载到内存后，可能也会被置换到外存，减少对非叶结点的访问次数，也就降低了置换次数，置换是需要IO访问的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">为什么 MySQL 使用 B+ 树</a></li>
<li><a href="https://blog.csdn.net/v_july_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a></li>
<li><a href="https://mp.weixin.qq.com/s/svL_yNmNJ-wj9aGjtO_Yww">拜托，别再问我什么是B+树 了</a></li>
<li><a href="https://blog.csdn.net/qq_21993785/java/article/details/80580679">B+Tree在数据库索引上拥有独特优势的原因（为什么比红黑树更合适）</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>B+树</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title>LZ77算法</title>
    <url>/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"><a href="#LZ77和哈夫曼编码区别？适用场景上有有什么不同？" class="headerlink" title="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"></a>LZ77和哈夫曼编码区别？适用场景上有有什么不同？</h2><p>哈夫曼编码是基于统计的数据压缩编码，需要先获得信息源的字符出现频率，然后再进行压缩。</p>
<p>但是，如果信息源是流式传输的，就没办法预先做统计，需要换一种思路。</p>
<p>LZ77利用数据的重复结构信息来进行数据压缩，是基于字典的压缩算法，可以做流逝压缩。</p>
<p>GZIP压缩的过程就是先用LZ77算法进行流式压缩，再对结果做哈夫曼编码压缩。</p>
<h2 id="为什么叫LZ77"><a href="#为什么叫LZ77" class="headerlink" title="为什么叫LZ77?"></a>为什么叫LZ77?</h2><p>由以色列的两位大神Jacob Ziv与Abraham Lempel在1977年发表的论文《A Universal Algorithm for Sequential Data Compression》中提出。</p>
<h2 id="LZ77算法思想概述"><a href="#LZ77算法思想概述" class="headerlink" title="LZ77算法思想概述"></a>LZ77算法思想概述</h2><p>核心思想：利用短语表示数据的重复结构信息来进行数据压缩。</p>
<p>LZ77算法一般称为“滑动窗口压缩”，算法的核心是在前面的历史数据中寻找重复字符串。</p>
<p>通过滑动窗口实现动态字典，用前面出现过的字符串作为字典通过映射（与前一个字符串的距离和字符串长度）替代后面重复出现的字符串。</p>
<p>重复现象是具有局部性的，它的基本假设是，如果一个字符串要重复，那么也是在附近重复，远的地方就不用找了，因此设置了一个滑动窗口。</p>
<p>其方式就是把数据中一些可以组织成短语(最长字符)的字符加入字典，然后再有相同字符出现采用标记来代替字典中的短语，如此通过标记代替多数重复出现的方式以进行压缩。</p>
<p>滑动窗口越大，压缩的效果越好，因为编码的短语越多，但是压缩速度越慢，因为要计算的短语数量越多。</p>
<h2 id="基于字典是什么意思？"><a href="#基于字典是什么意思？" class="headerlink" title="基于字典是什么意思？"></a>基于字典是什么意思？</h2><p>滑动窗口内的字符都是已经出现过的字符，已经出现过的字符会编码为字典短语，后面前向缓冲窗口中的字符如果和字典中的短语相同，就用距离和字符串长度来表示，以达到压缩的目的。</p>
<h2 id="LZ77压缩效果"><a href="#LZ77压缩效果" class="headerlink" title="LZ77压缩效果"></a>LZ77压缩效果</h2><p>大多数情况下LZ77压缩算法的压缩比相当高。</p>
<p>实际压缩率和选择的滑动窗口大小、前向缓冲区大小、数据熵有关系。</p>
<h2 id="LZ77缺点"><a href="#LZ77缺点" class="headerlink" title="LZ77缺点"></a>LZ77缺点</h2><p>压缩过程是比较耗时，因为要花费很多时间寻找滑动窗口中的短语匹配。</p>
<p>不过解压过程很快，因为每个标记都明确告知在哪个位置可以读取了。</p>
<h2 id="什么特征的文本用LZ77压缩效果好？"><a href="#什么特征的文本用LZ77压缩效果好？" class="headerlink" title="什么特征的文本用LZ77压缩效果好？"></a>什么特征的文本用LZ77压缩效果好？</h2><p>压缩就是用更短的符号来表示重复出现的字符串。</p>
<p>压缩就是寻找文本的内容分布概率，将出现频率高的部分代替成更短的形式。</p>
<p>内容越是重复，就可以压缩的更小。</p>
<p>内容如果毫无重复，就很难压缩。</p>
<h2 id="LZ77详细原理"><a href="#LZ77详细原理" class="headerlink" title="LZ77详细原理"></a>LZ77详细原理</h2><p>参见： <a href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></p>
<h2 id="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"><a href="#为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？" class="headerlink" title="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"></a>为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？</h2><p>LZ77编码后得到的是，距离（distance）和长度（length），还有未匹配到短语字典的原始字符（literal）。</p>
<p>比较短的距离和长度可能是频繁出现的，就可以用变长编码来压缩，且文本已经确定下来不会变动，可以做词频统计，就可以用到哈夫曼编码了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></li>
<li><a href="https://www.cnblogs.com/en-heng/p/4992916.html">【数据压缩】LZ77算法原理及实现</a></li>
<li><a href="https://www.cnblogs.com/en-heng/p/4992916.html">LZ77算法原理以及实现</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LZ77</tag>
        <tag>GZIP</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼编码</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="什么是哈夫曼编码"><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是哈夫曼编码</h2><p>出现频次越高的字符，编码长度越小。</p>
<h2 id="哈夫曼编码的价值"><a href="#哈夫曼编码的价值" class="headerlink" title="哈夫曼编码的价值"></a>哈夫曼编码的价值</h2><p>变长编码，使得编码的平均长度最短，实现压缩率大的无损压缩。</p>
<p>因为哈夫曼树是最优的，每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<h2 id="哈夫曼编码过程"><a href="#哈夫曼编码过程" class="headerlink" title="哈夫曼编码过程"></a>哈夫曼编码过程</h2><ul>
<li>把文本中字符按出现的频次排序。</li>
<li>每个字符作为一个结点放入一个集合。</li>
<li>取集合最小的两个频次的结点，为左右子结点，生成一个父结点，父结点的频次是两个子结点频次之和，把父结点再加入到集合中。</li>
<li>重复这个构造过程，生成一个最优二叉树。</li>
<li>给二叉树所有左边设置0，所有右边设置1。</li>
<li>字符都在叶子结点。</li>
<li>根结点到叶子结点路径上的0和1组成的码字就是该字符的编码。</li>
</ul>
<p>因为所有字符都出现在叶子结点，保证了哈夫曼编码当中的任何一个字符的编码都不能是另一个字符编码的前缀。也就是说哈夫曼编码是一种前缀编码。</p>
<hr>
<h2 id="如何证明哈夫曼编码是最优的？"><a href="#如何证明哈夫曼编码是最优的？" class="headerlink" title="如何证明哈夫曼编码是最优的？"></a>如何证明哈夫曼编码是最优的？</h2><p>哈夫曼编码过程每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<p>其正确性证明依赖于贪心选择性质和最优子结构。</p>
<hr>
<h2 id="哈夫曼编码的特点"><a href="#哈夫曼编码的特点" class="headerlink" title="哈夫曼编码的特点"></a>哈夫曼编码的特点</h2><ol>
<li> 编码非等长</li>
<li> 编码前缀不重复</li>
</ol>
<h2 id="哈夫曼编码的压缩效果？"><a href="#哈夫曼编码的压缩效果？" class="headerlink" title="哈夫曼编码的压缩效果？"></a>哈夫曼编码的压缩效果？</h2><p>哈夫曼编码可以很有效的压缩数据，具体压缩率依赖于数据本身的特性。</p>
<p>齐夫定律：</p>
<p>发现某一单词出现的频率与其在频率表里名次的常数次幂成反比，也就是说极少数的单词会被经常使用，而绝大多数单词很少被提及，这种20/80法则在很多领域都被逐步发现，这种幂律分布被称为“齐夫定律”（Zipf’s law）</p>
<p>一般信息的分配都是幂率分布。</p>
<p>所以用哈夫曼编码压缩的比例一般都挺高的，70%以上。</p>
<h2 id="信息压缩的极限在哪？"><a href="#信息压缩的极限在哪？" class="headerlink" title="信息压缩的极限在哪？"></a>信息压缩的极限在哪？</h2><p>香农第一定理给出了无损的情况下数据压缩的临界值。</p>
<p>参考：<a href="https://www.ruanyifeng.com/blog/2019/08/information-theory.html">信息论入门教程</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h2 id="字典树特点"><a href="#字典树特点" class="headerlink" title="字典树特点"></a>字典树特点</h2><ul>
<li>查询快</li>
<li>存储少</li>
</ul>
<p>对相同前缀的字符串进行了压缩存储，存储空间少，访问一个字符串最多也只需要访问字符串的长度。</p>
<p>利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。</p>
<h2 id="字典树有什么应用场景？"><a href="#字典树有什么应用场景？" class="headerlink" title="字典树有什么应用场景？"></a>字典树有什么应用场景？</h2><h3 id="单词联想预测、单词纠错。"><a href="#单词联想预测、单词纠错。" class="headerlink" title="单词联想预测、单词纠错。"></a>单词联想预测、单词纠错。</h3><p>在搜索引擎中关键词提示，引擎会自动弹出匹配关键词的下拉框。</p>
<h3 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h3><p>事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。</p>
<p>例如：</p>
<ul>
<li>  1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。</li>
<li>  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</li>
</ul>
<p>这样一方面可以节约存储空间，另一方面先用字典树预处理了海量文本，之后进行字符串查找时，不用在整个文本中查找特定字符串</p>
<h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>给定很长的一个串，统计频数出现次数最多情况。</p>
<p>例如：</p>
<ul>
<li>  有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
<li>  一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
</ul>
<h3 id="字符串最长公共前缀"><a href="#字符串最长公共前缀" class="headerlink" title="字符串最长公共前缀"></a>字符串最长公共前缀</h3><p>Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀，所以可以利用这个特点来解决一些前缀问题。</p>
<p>例如：</p>
<ul>
<li>  给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树、AVL树</title>
    <url>/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/</url>
    <content><![CDATA[<h2 id="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"><a href="#普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？" class="headerlink" title="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"></a>普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？</h2><p>普通的二叉查找树最坏情况下会退化为一个链表，查找元素的时间复杂度由log_2{n}退化到n。</p>
<p>解决时间复杂度退化，就是要让树的高度始终保持尽可能的小，平衡二叉查找树就是让任意节点的左右子树高度都平衡（差的不多）的二叉查找树，这样查找元素的平均时间复杂度可以保持在log_2{n}，</p>
<h2 id="有哪些平衡二叉查找树？"><a href="#有哪些平衡二叉查找树？" class="headerlink" title="有哪些平衡二叉查找树？"></a>有哪些平衡二叉查找树？</h2><p>AVL树、2-3树、红黑树</p>
<h2 id="为什么流行的主要是这几个树？"><a href="#为什么流行的主要是这几个树？" class="headerlink" title="为什么流行的主要是这几个树？"></a>为什么流行的主要是这几个树？</h2><p>因为逻辑比较简单，易于实现，效率也就高。</p>
<h2 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h2><p>任意结点左右子树高度差小于或等于1。</p>
<p>由Adelson-Velskii 以及 Landis发明，故而叫AVL。</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>定义：</p>
<ul>
<li>在满足二叉查找树的性质基础上，一个结点最多可以存储2个键，可以有3个孩子结点。</li>
<li>2结点里存储1个键，可以有2个孩子结点</li>
<li>3结点里存储2个键，可以有3个孩子结点</li>
</ul>
<p>特点</p>
<ul>
<li>2-3树是完美平衡的，任意结点的左右子树高度相等，这可以分析所有插入的情况来证明。</li>
</ul>
<p>自下而上生长：</p>
<ul>
<li>插入位置在2结点中，直接插入，变为3结点。</li>
<li>插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）。<ul>
<li>如果父结点本来是2结点，现在就变成了3结点。</li>
<li>如果父结点本来是3结点，现在就变成了4结点，继续提升的过程。</li>
<li>如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点。</li>
</ul>
</li>
</ul>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1。</p>
<p>一颗含有n个节点的2-3树的高度在log_3{n}（全是3结点）到log_2{n}（全是2结点）之间。</p>
<p>每次插入后调整结点都是局部的，最坏情况下，一条路径上都是3结点，从叶结点插入新键后，会从叶结点一直调整到根结点，调整次数不会超过对数级别。</p>
<p>10亿个结点的2-3树高度仅在19到30之间，性能较高。</p>
<p>各种操作实现较为复杂。</p>
<h2 id="为什么2-3树可以保持完美平衡？"><a href="#为什么2-3树可以保持完美平衡？" class="headerlink" title="为什么2-3树可以保持完美平衡？"></a>为什么2-3树可以保持完美平衡？</h2><p>这可以分析所有插入的情况来证明。</p>
<p>自下而上生长</p>
<ol>
<li><p> 插入位置在2结点中，直接插入，变为3结点</p>
</li>
<li><p> 插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）</p>
</li>
<li><p> 如果父结点本来是2结点，现在就变成了3结点</p>
</li>
<li><p> 如果父结点本来是3结点，现在就变成了4结点，继续提升的过程</p>
</li>
<li><p> 如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点</p>
</li>
</ol>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>实现较为简单，综合性能好。</p>
<p>把2-3树的3结点表示为左斜的红色链接相连的两个2结点，其中一个结点是另一个结点的左子结点，其他链接为黑色链接。</p>
<p>红黑树既是二叉查找树也是2-3树。</p>
<p>等价定义（《算法》第4版 275页 3.3.2.1）：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>红黑树的几条定义都是为了让红黑树满足2-3树的结构。</p>
<p>如果让2-3树中所有链接都为黑色，由于2-3树是完美平衡的，红黑树中红色链接代表3结点，所以红黑树中的黑色链接是完美平衡的。</p>
<p>再把2-3树中的3结点都分解为两个用红色链接相连的2结点，那么不会存在一个结点同时与两条红色链接相连，这一点保证了红色链接是3结点。</p>
<p>对红黑树插入、删除元素后，不满足红黑树的定义，都要通过旋转操作来修正。</p>
<p>红黑树的旋转操作修正，都是符合2-3树的修正的规则的，理解记住了2-3树的各种调整规则，就知道了红黑树各种操作的意义。</p>
<h2 id="红黑树是怎么发明出来的？"><a href="#红黑树是怎么发明出来的？" class="headerlink" title="红黑树是怎么发明出来的？"></a>红黑树是怎么发明出来的？</h2><p>它在1972年由<a href="https://zh.wikipedia.org/wiki/%E9%B2%81%E9%81%93%E5%A4%AB%C2%B7%E8%B4%9D%E5%B0%94">鲁道夫·贝尔</a>发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和<a href="https://zh.wikipedia.org/wiki/Robert_Sedgewick">Robert Sedgewick</a>于<a href="https://zh.wikipedia.org/wiki/1978%E5%B9%B4">1978年</a>写的一篇论文。</p>
<p>红黑树等同于2-3-4树，是2-3-4树的二叉表现形式。</p>
<p>2-3-4树是B树的一种情况。</p>
<p>红黑树结点的颜色表明了当前结点是否属于2-3-4树中的3结点或4结点。</p>
<p>2-3-4树的情况讨论比较复杂，  用2-3树讨论情况较少，可以方便理解。</p>
<hr>
<h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>《算法》第4版 275页 3.3.2.1 定义：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>《算法导论》273页  第13章  红黑树  定义：</p>
<ol>
<li> 节点是红色或黑色</li>
<li> 根节点是黑色</li>
<li> 叶节点是黑色</li>
<li> 红节点的两个子节点都是黑色</li>
<li> 任意节点到叶节点的所有路径上的黑色节点数相同</li>
</ol>
<h2 id="红黑树为什么要这样定义？"><a href="#红黑树为什么要这样定义？" class="headerlink" title="红黑树为什么要这样定义？"></a>红黑树为什么要这样定义？</h2><p>红黑树的几条定义都是为了让红黑树满足2-3树的结构，红黑树是2-3树的一种表示形式，而2-3树是完美平衡的，这样红黑树也是黑色平衡的，2-3树比较难以实现，红黑树比较方便实现。</p>
<h2 id="为什么要用红黑树表示2-3树？"><a href="#为什么要用红黑树表示2-3树？" class="headerlink" title="为什么要用红黑树表示2-3树？"></a>为什么要用红黑树表示2-3树？</h2><ul>
<li>因为2-3树是完美平衡的，任意结点的子树没有高度差。</li>
<li>2-3树的实现较为复杂，红黑树的实现较为简单。</li>
</ul>
<h2 id="红黑树的数据结构如何定义？"><a href="#红黑树的数据结构如何定义？" class="headerlink" title="红黑树的数据结构如何定义？"></a>红黑树的数据结构如何定义？</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">Key : Comparable&lt;Key</span>&gt;, <span class="type">Value&gt;</span></span>(</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 父结点指向本结点的链接颜色，用以标明本结点对应2-3树中的2结点还是3结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> color: Color,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字。用于比较来确定数据的顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> key: Key,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关联的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> value: Value,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> left: Node&lt;Key, Value&gt;? = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> right: Node&lt;Key, Value&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    BLACK, RED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树插入新元素后调整结点的操作规则是怎样的？"><a href="#红黑树插入新元素后调整结点的操作规则是怎样的？" class="headerlink" title="红黑树插入新元素后调整结点的操作规则是怎样的？"></a>红黑树插入新元素后调整结点的操作规则是怎样的？</h2><p>原则：所有操作跟2-3树能逐一对应，保证树的有序性和完美平衡性。</p>
<p>插入新结点先按普通的二叉查找树插入新结点那样进行插入。</p>
<p>普通的二叉查找树插入新元素有三种情况：</p>
<ol>
<li> 树中没有结点，插入的新结点作为根结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的左子结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的右子结点</li>
</ol>
<p>在红黑树中，结点h又可以分为两种情况</p>
<ol>
<li> 结点h是2结点</li>
<li>结点h位于3结点中<ol>
<li> 结点h是红链接左下的结点</li>
<li> 结点h是红链接右上的结点</li>
</ol>
</li>
</ol>
<p>插入新结点要默认新结点的颜色是红色，表示新结点到父节点的链接是红色，这样与2-3树的插入就可以对应上。</p>
<p>在2-3树中如果插入在2结点中，2结点变为3结点，就不再调整；如果插入的在3结点中，3结点临时变为4结点，再把4结点的中间键放入父结点中，左右两边的键分解为两个2结点与父结点相连。</p>
<p>处理这些情况的组合，就是所有的插入情况，针对不符合2-3树的结构的情况进行调整。</p>
<ul>
<li>结点h是2结点<ul>
<li>新结点是h的左子结点，相当于新结点和结点h组成了2-3树中的3结点，符合2-3树的结构，无需调整</li>
<li>新结点是h的右子结点，相当于新结点和结点h组成了2-3树中的3结点，但我们规定红链接要保持左斜，以减少考虑的情况数量，所以要进行左旋转</li>
</ul>
</li>
<li>结点h位于3结点中，新结点的位置有三种情况：左、中、右<ul>
<li>结点h是红链接左下的结点<ul>
<li>新结点是h的左子结点，此时有了两条连续的红链接，连接的3个结点对应2-3树中临时的4结点，需要把中间的键放入父结点，再把两边的键拆为两个2结点分别与父结点相连，所以操作是先右旋，再变换颜色</li>
<li>新结点是h的右子结点</li>
</ul>
</li>
<li>结点h是红链接右上的结点<ul>
<li>新结点是h的右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有三种标准操作：左旋、右旋、颜色转换</p>
<h2 id="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"><a href="#为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？" class="headerlink" title="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"></a>为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？</h2><p>只允许红色的左链接可以减少讨论的情景数量，进而简化代码的实现。</p>
<h2 id="红黑树最坏情况下高度是多少？"><a href="#红黑树最坏情况下高度是多少？" class="headerlink" title="红黑树最坏情况下高度是多少？"></a>红黑树最坏情况下高度是多少？</h2><p>有n个结点的红黑树高度最多为 $2 * log_2{n}$</p>
<p>由于2-3树中的3结点是由左斜红链接连接的两个结点表示的，最坏情况下最左侧路径全部都是红链接，对应2-3树中最左侧都是3结点，其他结点都是2结点。</p>
<p>参考《算法导论》中的证明：<br><a href="https://blog.csdn.net/lanchunhui/java/article/details/75905478">红黑树相关定理及其证明
</a></p>
<h2 id="红黑树的各种操作的时间复杂度是多少？"><a href="#红黑树的各种操作的时间复杂度是多少？" class="headerlink" title="红黑树的各种操作的时间复杂度是多少？"></a>红黑树的各种操作的时间复杂度是多少？</h2><p>设红黑树有n个结点，查找、插入、修改、删除操作的时间复杂度均为O(log n)</p>
<p>查找：</p>
<ul>
<li>最长路径长度不会超过最短路径长度的2倍，查找仍然是对数级别</li>
</ul>
<p>插入：</p>
<ul>
<li>最坏情况下待插入的位置在叶结点，需要从根结点遍历到叶结点，同时最坏情况下遍历的路径都是红链接（路径上都是3结点），此时会从叶结点一直回溯调整结点到根结点，访问次数是2倍的树的高度，而树的高度为log_2{n}</li>
</ul>
<h2 id="红黑树较于AVL树有什么优点？"><a href="#红黑树较于AVL树有什么优点？" class="headerlink" title="红黑树较于AVL树有什么优点？"></a>红黑树较于AVL树有什么优点？</h2><p>单次操作：</p>
<ul>
<li>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</li>
<li>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</li>
</ul>
<p>大量的插入和删除操作：</p>
<ul>
<li>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</li>
<li>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</li>
</ul>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎 </a></li>
</ul>
<h2 id="什么时候用AVL树？"><a href="#什么时候用AVL树？" class="headerlink" title="什么时候用AVL树？"></a>什么时候用AVL树？</h2><p>AVL树平衡性非常好，左右子树高度差不超过1，所以查找次数少。</p>
<p>对于查找非常频繁，插入、修改、删除不频繁的场景，可以使用AVL树。</p>
<h2 id="并发下的问题"><a href="#并发下的问题" class="headerlink" title="并发下的问题"></a>并发下的问题</h2><p>并发情况下，由于平衡搜索树的调整可能要锁整个树。</p>
<p>用跳表这种性能接近于平衡树的数据结构，操作更加局部性，不会锁住太多结点，有利于并发的性能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/wuchanming/p/4444961.html">面试题——轻松搞定面试中的红黑树问题</a></li>
<li><a href="https://www.cnblogs.com/nullzx/p/6111175.html">从2-3-4树到红黑树（上）</a></li>
<li><a href="https://www.zhihu.com/question/30527705/answer/259948086">AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？ - 韦易笑的回答 - 知乎 </a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>红黑树</tag>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h1 id="TCP为什么要三次握手？为什么不能两次握手或四次握手？"><a href="#TCP为什么要三次握手？为什么不能两次握手或四次握手？" class="headerlink" title="TCP为什么要三次握手？为什么不能两次握手或四次握手？"></a>TCP为什么要三次握手？为什么不能两次握手或四次握手？</h1><ol>
<li>三次握手是确认客户端和服务端的发送和接受报文的能力是否正常。</li>
<li>如果是两次握手，服务端受到客户端的历史SYN报文就建立连接，会空耗服务端资源。</li>
<li>确认双方发送数据的初始序号，因为都要给对方发送确认报文，表达已知悉。</li>
</ol>
<p>三次握手是确认客户端和服务端的发送和接受报文的能力是否正常。三次握手足够判断这一点了，四次握手其实多余了，没有必要浪费时间去发送没有意义的报文。</p>
<p>如果不加确认，进行两次握手，服务端收到客户端的SYN报文就直接建立连接，有可能客户端的SYN报文发生了网络拥堵，客户端进行了超时重传，随后拥堵的报文又成功传到了服务端，服务端判断不了这是新的连接请求报文还是历史连接报文，如果服务端收到SYN报文直接建立连接，接受到了客户端历史的SYN报文，会发生空等待，消耗服务端的资源。</p>
<h1 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h1><ol>
<li>客户端发送SYN报文，告知对方初始序号，是否会告知窗口大小</li>
<li>服务端收到后，回应SYN+ACK报文，告知对方初始序号</li>
<li>客户端收到后，回应ACK报文，客户端建立连接，服务端收到ACK后建立连接</li>
</ol>
<p>RFC 793 - Transmission Control Protocol 其实就指出了 TCP 连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
<p>如果是两次握手，正常流程就是，客户端发送SYN，服务端接收到SYN开始建立连接，并发送ACK给客户端，客户端收到ACK开始建立连接。</p>
<p>客户端发送SYN后，可能发生拥堵，然后客户端超时重传SYN，接下来按照正常流程建立连接，然后过了一会服务端又收到了之前拥堵发过来的SYN，并不能确定它历史的连接还是新的连接，如果此时建立新连接就会一直等待客户端发送数据，而这只是一条历史的连接报文，客户端不会发送数据，服务端就会空等，浪费了资源。</p>
<p>如果是三次握手，服务端接收到SYN后，会发送SYN+ACK给客户端，由客户端来判断是否是历史连接，如果序号过期，则认为是历史连接，向服务端发送RST取消连接的建立。服务端是没办法判断客户端的序号是否过期。</p>
<p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>
<ul>
<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>
<li>『四次握手』：TCP 协议的设计可以让我们同时传递 ACK 和 SYN 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>
</ul>
<h1 id="TCP三次握手中，服务端发送了SYN-ACK后，一直没有收到客户端的ACK会怎样？"><a href="#TCP三次握手中，服务端发送了SYN-ACK后，一直没有收到客户端的ACK会怎样？" class="headerlink" title="TCP三次握手中，服务端发送了SYN+ACK后，一直没有收到客户端的ACK会怎样？"></a>TCP三次握手中，服务端发送了SYN+ACK后，一直没有收到客户端的ACK会怎样？</h1><p>server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p>
<h1 id="TCP为什么要先建立连接才能传输数据？"><a href="#TCP为什么要先建立连接才能传输数据？" class="headerlink" title="TCP为什么要先建立连接才能传输数据？"></a>TCP为什么要先建立连接才能传输数据？</h1><p>因为如果不确定对方能够正常的接受和发送数据，一方单方面发送数据就是无意义的资源浪费。</p>
<h1 id="TCP建立连接时做了什么事？"><a href="#TCP建立连接时做了什么事？" class="headerlink" title="TCP建立连接时做了什么事？"></a>TCP建立连接时做了什么事？</h1><ol>
<li>确认双方的发送能力、接受能力是否正常</li>
<li>确定双方发送报文的初始编号</li>
<li>确定窗口大小</li>
<li>确定MSS-最大传输包大小</li>
<li>确定是否使用SACK</li>
</ol>
<h1 id="TCP什么时候可以传输数据？"><a href="#TCP什么时候可以传输数据？" class="headerlink" title="TCP什么时候可以传输数据？"></a>TCP什么时候可以传输数据？</h1><p>第三次握手客户端就可以携带数据了，因为受到服务端的SYN+ACK报文，确认了服务端的接受能力和发送能力是正常的</p>
<h1 id="TCP建立连接时的SYN指令是做什么的？"><a href="#TCP建立连接时的SYN指令是做什么的？" class="headerlink" title="TCP建立连接时的SYN指令是做什么的？"></a>TCP建立连接时的SYN指令是做什么的？</h1><p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p>
<h1 id="什么是SYN攻击？"><a href="#什么是SYN攻击？" class="headerlink" title="什么是SYN攻击？"></a>什么是SYN攻击？</h1><p>客户端发送SYN报文后，服务端会进入SYN_RCVD状态，但服务端发送出去的SYN+ACK报文没有应答，SYN报文发送多了后，会占满服务端的半连接队列</p>
<h1 id="RST消息是什么时候发送？"><a href="#RST消息是什么时候发送？" class="headerlink" title="RST消息是什么时候发送？"></a>RST消息是什么时候发送？</h1><p>建立连接出现错误就会发送RST报文关闭连接</p>
<p>1、端口未打开</p>
<p>2、请求超时</p>
<p>3、提前关闭</p>
<p>4、在一个已关闭的socket上收到数据</p>
<p>5、用于拒绝一个非法连接</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
        <tag>三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP四次挥手</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="TCP断开连接为什么要四次挥手？为什么不能三次挥手？"><a href="#TCP断开连接为什么要四次挥手？为什么不能三次挥手？" class="headerlink" title="TCP断开连接为什么要四次挥手？为什么不能三次挥手？"></a>TCP断开连接为什么要四次挥手？为什么不能三次挥手？</h1><p>因为服务端接收到客户端断开连接的请求报文时，服务端可能还有数据要发送，要等待服务端把数据发送完了，才能向客户端发起断开连接的请求，此时服务端只能先回复客户端一个ACK报文，告知客户端我已经收到了断开连接的请求，你可以不用重复发送断开连接的请求了，等我把数据发完再通知你我可以断开连接。服务端的ACK和FIN指令必须分开发送，所以需要四次挥手，而不能三次。</p>
<h1 id="TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME-WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？"><a href="#TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME-WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？" class="headerlink" title="TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME_WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？"></a>TCP断开连接时，客户端发送最后一个ACK给服务端后，为什么要进入TIME_WAIT等待一段时间才能关闭连接？为什么又要等待2MSL？</h1><ol>
<li>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</li>
<li>保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；</li>
</ol>
<h2 id="阻止延迟报文"><a href="#阻止延迟报文" class="headerlink" title="阻止延迟报文"></a>阻止延迟报文</h2><p>TCP断开连接时，如果客户端在接收到服务端的FIN自己发送完ACK后直接关闭连接，服务端可能没有收到ACK，会超时重传FIN，此时由于客户端已经关闭了连接，如果客户端有新的程序需要向该服务端的同一个端口传输数据，会重新建立TCP连接，并且这个新TCP连接无法和上一个关闭的TCP连接区分开来，因为源IP地址、源端口、目标IP地址、目标端口都一样，此时新连接传输数据过程中如果收到上次连接的传来的FIN，新连接的状态就异常了，新连接SYN握手会失败，服务端会发送RST阻止客户端连接的建立，因为旧的连接并没有关闭。。也有可能会收到其他服务端发送的报文。</p>
<h2 id="保证连接关闭"><a href="#保证连接关闭" class="headerlink" title="保证连接关闭"></a>保证连接关闭</h2><p>服务端发送FIN报文后，如果没有接收到ACK会超时重传FIN，直到收到ACK了才会关闭连接。服务端要等待什么时候超时重传呢？服务端发送FIN后，最多经过一个MSL到达客户端，客户端发送ACK最多经过一个MSL到达服务端，所以服务端等待2MSL没有收到ACK就重发FIN报文，FIN报文最多经过一个MSL到达客户端，所以从客户端发送ACK给服务端要至少等待2MSL，以取保服务端收到了自己发送的ACK，不会超时重传FIN</p>
<h1 id="为什么TIME-WAIT要等待2MSL？"><a href="#为什么TIME-WAIT要等待2MSL？" class="headerlink" title="为什么TIME_WAIT要等待2MSL？"></a>为什么TIME_WAIT要等待2MSL？</h1><p>MSL（Maximum Segment Lifetime，最大报文生存时间）是指任何报文在网络上存在的最长时间，超过这个时间的报文都会被丢弃。</p>
<p>网络中可能存在来自发送方的报文，接收方收到后需要回ACK，一来一回两个MSL，等待两个MSL可以确保网络中一定不存在报文。</p>
<p>服务端发送FIN后，会计时等待接受ACK，等待的时间大约是一个RTT多一点的时间，也就是2MSL左右，如果FIN没丢失，客户端发送ACK，发送ACK时服务端已经等待了一个MSL左右，如果ACK丢失了，服务端再等待一个MSL，超时未收到ACK，则会重传FIN，FIN再次到达客户端也需要一个MSL左右，这样客户端至少得等待2MSL，以让服务端重传的FIN达到，如果2MSL后没有收到服务端的FIN，说明服务端已经接收到ACK了，服务端已经关闭连接，同时网络也不可能有此次连接的任何报文了，客户端就可以安全的关闭连接。</p>
<h1 id="进入TIME-WAIT有什么问题？"><a href="#进入TIME-WAIT有什么问题？" class="headerlink" title="进入TIME_WAIT有什么问题？"></a>进入TIME_WAIT有什么问题？</h1><p>大并发量的短时间传输的连接，会造成连接等待时间变长。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP如何保证可靠性</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    <content><![CDATA[<h1 id="TCP是什么？"><a href="#TCP是什么？" class="headerlink" title="TCP是什么？"></a>TCP是什么？</h1><p>面向连接、保证可靠性传输、基于字节流的传输层通信协议</p>
<h1 id="TCP协议解决的是什么问题？"><a href="#TCP协议解决的是什么问题？" class="headerlink" title="TCP协议解决的是什么问题？"></a>TCP协议解决的是什么问题？</h1><p>保证端到端数据传输的可靠性</p>
<h1 id="TCP如何保证可靠性？"><a href="#TCP如何保证可靠性？" class="headerlink" title="TCP如何保证可靠性？"></a>TCP如何保证可靠性？</h1><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制： 当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>建立连接三次握手，客户端SYN、服务端SYN+ACK、客户端ACK。</p>
<p>断开连接四次握手，客户端FIN、服务端ACK、服务端FIN+ACK、客户端ACK。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>IP报文头的校验和只校验IP首部，TCP报文头的校验和校验的是首部和数据。</p>
<p>tcp报文头部有校验和，发送方生成校验和，接收方检验校验和，传输过程检验到报文有差错直接丢弃。</p>
<h2 id="报文编号"><a href="#报文编号" class="headerlink" title="报文编号"></a>报文编号</h2><ol>
<li>检测丢失：接收方可以知道少了哪些数据。</li>
<li>检测乱序：发送方的报文可能因为网络拥堵乱序到达接收方，接收方可以按照序号重新排序拼接报文，再转交完整的数据给应用层。</li>
<li>检测重复：接收方可以根据编号丢弃已经收到的报文，因为同一个编号的报文可能会因为超时重传机制多次发送。</li>
</ol>
<h2 id="确认应答"><a href="#确认应答" class="headerlink" title="确认应答"></a>确认应答</h2><p>每次接收方收到数据后，会回应ACK确认应答报文给发送方，发送方就知道了这个包没有丢失，而是已经传输成功了。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>每个报文发送后都会开启一个定时器，超时前收到该编号报文确认应答的报文时则取消计时，如果不能及时收到确认则会重新发送这个报文。</p>
<p>超时重传有两种情况，一种是发送的报文未达到接收方，一种是接收方发送的ACK确认报文未达到发送方；前者的情况在接收方收到报文后会正常的发送ACK报文；后者的情况会丢弃编号重复的报文直接发送ACK确认报文。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>如果发送方发生数据过快，接收方来不及处理，接受方只能丢弃数据，这样浪费了流量，增加了不必要的消耗，接收方要告诉发送方自己能接受处理数据的最大数据量是多少，别多发不能处理的数据。</p>
<p>是通过ACK报文头中的窗口大小字段来告知对方自己还能接受多少数据，要发送数据的一方的发送窗口大小就是这个ACK报文头中的窗口大小与拥塞窗口大小的较小值</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制是假设网络不拥堵，只考虑两端数据处理能力，但是整个网络如果发生拥堵，还需另外的处理，即拥塞控制。</p>
<p>拥塞控制主要是四个算法：慢启动、拥塞避免、快重传、快恢复</p>
<h1 id="面向字节流是什么意思？"><a href="#面向字节流是什么意思？" class="headerlink" title="面向字节流是什么意思？"></a>面向字节流是什么意思？</h1><p>消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p>
<h1 id="TCP报文头格式是怎样的？"><a href="#TCP报文头格式是怎样的？" class="headerlink" title="TCP报文头格式是怎样的？"></a>TCP报文头格式是怎样的？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205955.png"></p>
<p>TCP报文头部最大为60字节，头部固定20个字节，TCP Options最大为40字节</p>
<p>包含源端口、目的端口、序列号、确认号、数据偏移、保留位、控制位、窗口大小、校验和、紧急指针、选项等</p>
<p>控制位：</p>
<p>CWR：用于 IP 首部的 ECN 字段。ECE 为 1 时，则通知对方已将拥塞窗口缩小。<br>ECE：在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设置为 1，表示从对方到这边的网络有拥塞。<br>URG：紧急模式<br>ACK：确认<br>PSH：推送，接收方应尽快给应用程序传送这个数据。没用到<br>RST：该位为 1 表示 TCP 连接中出现异常必须强制断开连接。<br>SYN：初始化一个连接的同步序列号<br>FIN：该位为 1 表示今后不会有数据发送，希望断开连接。</p>
<h1 id="为什么-TCP-协议有性能问题？"><a href="#为什么-TCP-协议有性能问题？" class="headerlink" title="为什么 TCP 协议有性能问题？"></a>为什么 TCP 协议有性能问题？</h1><p>在弱网环境下（丢包率高）影响 TCP 性能的三个原因：</p>
<ol>
<li>TCP 的拥塞控制算法会在丢包时主动降低吞吐量；</li>
<li>TCP 的三次握手增加了数据传输的延迟和额外开销；</li>
<li>TCP 的累计应答机制导致了数据段的传输；</li>
</ol>
<h2 id="如何唯一的标识和确认一个TCP连接？"><a href="#如何唯一的标识和确认一个TCP连接？" class="headerlink" title="如何唯一的标识和确认一个TCP连接？"></a>如何唯一的标识和确认一个TCP连接？</h2><p>四元组。</p>
<p>源IP地址、源端口号、目的IP地址、目的端口号。</p>
<h2 id="TCP最大连接数是多少？"><a href="#TCP最大连接数是多少？" class="headerlink" title="TCP最大连接数是多少？"></a>TCP最大连接数是多少？</h2><p>服务端固定监听某个端口。</p>
<p>源IP地址在IP报文头中是32位。</p>
<p>源端口号在TCP报文头是16位。</p>
<p>不考虑其他因素，理论最大连接数是 <code>2^32 * 2^16</code>。</p>
<h1 id="为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？"><a href="#为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？" class="headerlink" title="为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？"></a>为什么TCP报文头里没有数据长度，UDP报文头里有数据长度？</h1><p>TCP数据长度 = IP总长度 - IP首部长度 - TCP首部长度</p>
<p>UDP数据长度 = IP总长度 - IP首部长度 - UDP首部长度</p>
<p>UDP数据长度是可以通过IP总长度减去报文头长度算出来了的。</p>
<p>UDP报文头里有数据长度，是为了网络设备硬件设计和处理方便，首部长度需要是4字节的整数倍。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP报文编号</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="TCP为什么要给报文编号？不编号会有什么问题？"><a href="#TCP为什么要给报文编号？不编号会有什么问题？" class="headerlink" title="TCP为什么要给报文编号？不编号会有什么问题？"></a>TCP为什么要给报文编号？不编号会有什么问题？</h1><p>保证报文的不重复、不丢失、不乱序。</p>
<p>作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。</p>
<h1 id="为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？"><a href="#为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？" class="headerlink" title="为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？"></a>为什么ACK报文中确认序号一定要是已经接收到的连续报文的最大的序号？改为已经接收到的不连续的报文的最大序号会有什么问题？</h1><p>TCP把数据视为一个无结构但有序的字节流，序号建立在传输的字节流之上，而不建立在报文段之上。</p>
<p>接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p>因为TCP有窗口拥塞控制，窗口的拥塞是基于字节的，所以必须给字节编号，如果给数据包编号，拥塞窗口无法调节大小。</p>
<h1 id="TCP三次握手中的初始序号是固定的吗？"><a href="#TCP三次握手中的初始序号是固定的吗？" class="headerlink" title="TCP三次握手中的初始序号是固定的吗？"></a>TCP三次握手中的初始序号是固定的吗？</h1><p>不是固定的，是动态增长+随机选取，可以避免相邻的TCP会话的序列号有重叠，否则并不知道报文是旧连接的还是新连接的</p>
<p>如果初始序号是固定的，攻击者就可以很容易伪造TCP报文发起攻击，初始序号需要动态生成，提高攻击成本。</p>
<p>源IP地址、源端口、目标IP地址、目标端口唯一确定一个TCP会话，允许刚释放的TCP端口重用，如果旧会话中的分组报文仍然在网络中，新会话建立后可能会收到旧会话产生的分组报文，如果序号是一直递增的，就可以分辨出报文是属于旧会话的还是新会话的。</p>
<p>关于ISN的初始化。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="http://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p>
<h1 id="报文编号和确认应答机制存在什么问题？"><a href="#报文编号和确认应答机制存在什么问题？" class="headerlink" title="报文编号和确认应答机制存在什么问题？"></a>报文编号和确认应答机制存在什么问题？</h1><p>队头阻塞。</p>
<p>TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
        <tag>报文编号</tag>
        <tag>队头阻塞</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP拥塞控制</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="什么情况下才算发生了网络拥塞？"><a href="#什么情况下才算发生了网络拥塞？" class="headerlink" title="什么情况下才算发生了网络拥塞？"></a>什么情况下才算发生了网络拥塞？</h1><p>发送方有TCP报文超时了没有收到ACK确认报文</p>
<h1 id="拥塞控制的过程是怎样的？"><a href="#拥塞控制的过程是怎样的？" class="headerlink" title="拥塞控制的过程是怎样的？"></a>拥塞控制的过程是怎样的？</h1><p>慢启动、拥塞避免、快重传、快恢复</p>
<p>拥塞窗口，拥塞窗口大小cwnd（congestion window）表示可以发送的报文字节数，单位是一个MSS（最大报文长度）</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>拥塞窗口初始大小为1，每收到一个ACK，拥塞窗口大小+1，实际效果就是每过一个RTT，拥塞窗口大小为原来的2倍，以指数增长率增长，先慢后快，达到慢开始门限ssthresh则停止慢开始，执行拥塞避免算法。</p>
<p>翻倍后如果大小超过阈值则窗口大小设为阈值。</p>
<p>例如：</p>
<p>初始窗口大小为1</p>
<p>发送第一个报文M0，收到ACK1后窗口大小+1，变为2</p>
<p>发送M1、M2，收到ACK2、ACK3后，窗口大小+2，变为4</p>
<p>再发送4个报文，收到4个ACK后，窗口大小+4，变为8</p>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>每过一个RTT（受到一个ACK），拥塞窗口大小+1</p>
<p>线性增长，避免增长过快</p>
<h2 id="发生拥塞"><a href="#发生拥塞" class="headerlink" title="发生拥塞"></a>发生拥塞</h2><p>发送方有报文超时，未收到ACK确认报文</p>
<p>无论是在慢开始阶段还是拥塞避免阶段，做出以下调整：</p>
<ol>
<li>把慢开始门限ssthresh设置为出现拥塞时发送方拥塞窗口大小的一半（不小于2）</li>
<li>拥塞窗口大小设为1，执行慢开始</li>
</ol>
<p>目的：</p>
<p>迅速减少发送方发送到网络的报文数，在发生拥塞时路由器有足够的时间把队列中挤压的报文发完</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825255523.jpeg"></p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，则不等待定时器结束就直接重传该序号的报文</p>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>发送方收到了三个序号重复的ACK报文，认为该序号的报文丢失，慢开始门限设置为拥塞窗口大小的一半，拥塞窗口不设置为1，也设置为原窗口大小的一半，并执行拥塞避免算法，线性增大拥塞窗口。</p>
<p>因为跳过了拥塞窗口从1开始的慢开始过程，所以称为快恢复。</p>
<p>发送方窗口大小为  流量控制的滑动窗口和拥塞窗口  的较小值</p>
<h1 id="快速重传有什么问题？"><a href="#快速重传有什么问题？" class="headerlink" title="快速重传有什么问题？"></a>快速重传有什么问题？</h1><p>与基于定时器的超时重传拥有同样的问题，即：</p>
<p>不确定应该重发哪些序号的报文，如果只重发一个可能会拖慢整体传输时长，如果重发多个可能会浪费流量、增加整体传输时长，需要知道哪些序号的报文是丢失的，只重发丢失的报文。  </p>
<p>发送方收到同一个序号的多个ACK确认，发送方并不清楚这些ACK是由哪些序号的报文传输成功后ACK回来的，可能会重发接收方已经收到的报文，浪费流量。</p>
<h1 id="带选择确认的重传（SACK）解决了什么？"><a href="#带选择确认的重传（SACK）解决了什么？" class="headerlink" title="带选择确认的重传（SACK）解决了什么？"></a>带选择确认的重传（SACK）解决了什么？</h1><p>一端在发送ACK时通过在TCP报文头部增加SACK（Selective Acknowledgment）选项，告知对方已经收到的包序号区间范围，让对方只重传丢失的报文，并且可以一次性集中重传，避免了网络流量的浪费，也避免了长时间的超时等待。</p>
<p>SACK需要客户端和服务的都开启该功能</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP流量控制</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="为什么要有流量控制？"><a href="#为什么要有流量控制？" class="headerlink" title="为什么要有流量控制？"></a>为什么要有流量控制？</h1><p>双端通信的时候，发送方发送数据速度和接收方处理数据速度不一定相等；</p>
<p>如果发送过快，接收方处理不过来，接收方只能把数据存在缓冲区，缓冲区满了后再收到数据就只能丢弃；</p>
<p>所以需要控制发送方发送数据的速率，让接收方与发送方处于一种动态的平衡中才好。</p>
<p>对于发送方发送速率的控制，称为流量控制。</p>
<h1 id="滑动窗口大小是如何确定的？"><a href="#滑动窗口大小是如何确定的？" class="headerlink" title="滑动窗口大小是如何确定的？"></a>滑动窗口大小是如何确定的？</h1><p>发送数据的一方收到对方发送的ACK报文，其报文头中的窗口大小表示对方的缓冲区大小还能存放多少字节的数据，发送方拿这个窗口大小与本身的拥塞窗口大小在一起取最小值，作为自己滑动窗口的大小。</p>
<p>达到：</p>
<ol>
<li>避免对方缓冲区存不下发送过多的数据而丢弃，进而浪费网络带宽和流量</li>
<li>避免产生网络拥塞</li>
</ol>
<h1 id="滑动窗口中的内容"><a href="#滑动窗口中的内容" class="headerlink" title="滑动窗口中的内容"></a>滑动窗口中的内容</h1><p>滑动窗口内包含两类报文</p>
<ol>
<li>已发送但未收到确认</li>
<li> 允许发送但尚未发送</li>
</ol>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180835235523.jpeg"></p>
<h1 id="滑动窗口什么时候开始滑动？"><a href="#滑动窗口什么时候开始滑动？" class="headerlink" title="滑动窗口什么时候开始滑动？"></a>滑动窗口什么时候开始滑动？</h1><p>窗口左侧的报文收到了ACK报文确认，窗口就往右滑动</p>
<h1 id="如果发送端滑动窗口大小为0，不发送数据了会怎样？"><a href="#如果发送端滑动窗口大小为0，不发送数据了会怎样？" class="headerlink" title="如果发送端滑动窗口大小为0，不发送数据了会怎样？"></a>如果发送端滑动窗口大小为0，不发送数据了会怎样？</h1><p>实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅包含一个字节来获取最新的窗口大小信息。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP超时重传</title>
    <url>/%E7%BD%91%E7%BB%9C/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="超时重传的等待时间设置为多少合适？"><a href="#超时重传的等待时间设置为多少合适？" class="headerlink" title="超时重传的等待时间设置为多少合适？"></a>超时重传的等待时间设置为多少合适？</h1><p>超时重传的等待时间：Retransmission Time Out, RTO。</p>
<p>等待时间过长，若丢包严重，则传输的吞吐量低。</p>
<p>等待时间过短，会导致频繁的发包，增加网络拥堵，占用带宽。</p>
<p>等待时间只能尽可能的短，按照正常的节奏，一端发送报文到收到ACK报文的时间（往返时间Round Trip Time）就是最短的等待时间，RTO可以略微大于RTT，以增加一点容错范围。</p>
<p>但RTT并不是固定的，因为网络拥堵状况随时在发生变化，所以RTT应当不停的动态计算，有一系列的算法支持。</p>
<h1 id="基于定时器的超时重传存在什么问题？"><a href="#基于定时器的超时重传存在什么问题？" class="headerlink" title="基于定时器的超时重传存在什么问题？"></a>基于定时器的超时重传存在什么问题？</h1><p>会重发接收方已经收到的报文，浪费带宽，通信时间被拖长。</p>
<p>接收方发送的ACK报文中确认的报文序号有个特点，就是这个序号之前的报文接收方一定都已经收到了。</p>
<p>这样就会导致一个问题，如果发送方发了一系列序号连续的报文，接收方只有中间的几个报文没有收到，那么收到序号较大的报文后回应的ACK里的确认序号是较小的，这会导致发送方无法确认较大序号的报文接收方有没有收到。</p>
<p>此时发送方该重发哪些报文就成了问题，此时有两种策略：</p>
<p>一种策略是只重传ACK期待的序号的报文，序号较大报文暂时不重发，等待它们的定时器超时了再重发，如果较大序号的报文接收方都接受到了倒没问题，但如果较大序号的报文接收方都没收到，一个个等待报文超时无疑是拖慢了整体的传输时间。</p>
<p>另一种策略就是重传ACK序号后所有的报文，如果丢包严重，这种做法效率挺高，但如果丢包并不严重，这种做法会浪费很多流量。</p>
<p>如果能知道没有收到的报文序号是哪些就很好办了，用SACK可以解决这个问题。</p>
<p>例如发送方发了序号为1、2、3、4、5、6的报文，接收方收到了1、2、4、5、6，唯独为没有收到3（3可能卡在某个网络节点上），在接收到1后回应ACK 2，接收2后回应ACK 3，接收到4、5、6，也是回应ACK 3，此时发送方对3、4、5、6的定时器都会超时，然后都会重发3、4、5、6，但实际4、5、6已经接收到了，重发4、5、6其实是浪费带宽，也增加了整体传输时长。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
        <tag>超时重传</tag>
        <tag>RTO</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP与TCP区别</title>
    <url>/%E7%BD%91%E7%BB%9C/UDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="UDP报文头"><a href="#UDP报文头" class="headerlink" title="UDP报文头"></a>UDP报文头</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827230610.png"></p>
<p>UDP 协议头中只包含 4 个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占 16 比特，即 2 字节，这 4 个字段的作用如下：</p>
<ul>
<li>源端口是一个可选字段，它表示发送方进程的端口号，接收方可以使用该字段（不一定准确）向发送方发送信息；</li>
<li>目的端口是数据报接收方的端口号，它只在目标的 IP 地址下才有意义；</li>
<li>长度是协议头和数据报中数据长度的总和，表示整个数据报的大小；</li>
<li>  校验码使用 IP 首部、UDP 首部和数据报中的数据进行计算，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题。</li>
</ul>
<h1 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h1><p>简单高效：</p>
<ol>
<li> 面向无连接</li>
<li> 报文头简单，只有8字节</li>
<li> 对应用层数据不分段</li>
</ol>
<p>关于分段：</p>
<p>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。若报文太长，则到达IP层需要分片，降低效率。若太短，则传输效率会下降（举个例子，1字节的数据，加上20字节的UDP首部，再加上20字节的IP层首部，结果发了41字节的包只完成了1字节有用数据的交付）。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<h1 id="UDP和TCP区别？"><a href="#UDP和TCP区别？" class="headerlink" title="UDP和TCP区别？"></a>UDP和TCP区别？</h1><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>http2、quic</title>
    <url>/%E7%BD%91%E7%BB%9C/http2%E3%80%81quic/</url>
    <content><![CDATA[<h1 id="tcp队头阻塞是什么？"><a href="#tcp队头阻塞是什么？" class="headerlink" title="tcp队头阻塞是什么？"></a>tcp队头阻塞是什么？</h1><p>tcp是按字节有序传输的，如果发送方发送了一连串的报文，中间有个报文没有收到ACK确认，会一直等待超时然后重传报文，发送方的滑动窗口一直不能移动，导致不能发送更多的报文。</p>
<p>这样http请求之间就不是独立的，会互相影响。</p>
<h1 id="http队头阻塞是什么？"><a href="#http队头阻塞是什么？" class="headerlink" title="http队头阻塞是什么？"></a>http队头阻塞是什么？</h1><p>多个http请求只能顺序请求，因为http请求和响应没有编号，同时执行多个请求，不按顺序返回响应，客户端无法分辨是哪个响应对应哪个请求，这样如果前面的请求处理较慢，后面的请求都会被阻塞。</p>
<h1 id="http2解决了什么？"><a href="#http2解决了什么？" class="headerlink" title="http2解决了什么？"></a>http2解决了什么？</h1><ol>
<li> http报文分片</li>
<li> http header压缩</li>
<li> 支持服务端推送</li>
<li> 基于TLS实现安全传输（与https相同）</li>
</ol>
<h2 id="报文分片"><a href="#报文分片" class="headerlink" title="报文分片"></a>报文分片</h2><p>http报文是纯文本的，http2报文是二进制字节流，对报文进行了分片并编号，相当于把tcp的报文分段编号实现搬到应用层。</p>
<p>同一个tcp连接可以同时传输多个http报文分片，实现多路复用，解决http请求对头阻塞问题。</p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>客户端请求一个html，服务端可以把相关的css、png等资源一同返回给客户端，减少客户端请求次数。</p>
<h1 id="QUIC解决了什么？"><a href="#QUIC解决了什么？" class="headerlink" title="QUIC解决了什么？"></a>QUIC解决了什么？</h1><p>Quick UDP Internet Connection</p>
<p>基于udp实现，在应用层实现传输可靠性，非常的自由灵活。</p>
<p>主要改进：</p>
<ol>
<li> 快速握手</li>
<li> 避免对头阻塞的多路复用</li>
<li> 连接迁移</li>
</ol>
<h2 id="快速握手"><a href="#快速握手" class="headerlink" title="快速握手"></a>快速握手</h2><p>在HTTPS协议中，由于TCP和TLS都各需要自3次握手，导致连接建立过程较为复杂和耗时，降低了HTTPS的效率。</p>
<p>QUIC选择UDP来作为其底层协议，就可以将连接建立和密钥协商的过程合二为一，简化操作流程，提高连接效率。</p>
<p>在连接建立成功后， 客户端会缓存起来原始的连接信息等。 在接下来与相同的服务器建立连接的过程中， 客户端能够在不增加额外RTT的情况下建立一个加密的连接，数据要发送的数据可以在握手的包中捎带着发送过去，而不用等待服务器的回复，从而实现0RTT。</p>
<p>所以，所谓QUIC的0RTT是指在建立连接之后，后续发送数据都不需要增加额外的RTT时间，最开始的握手还是需要1RTT的时间消耗的。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h3 id="为什么quic能解决队头阻塞？"><a href="#为什么quic能解决队头阻塞？" class="headerlink" title="为什么quic能解决队头阻塞？"></a>为什么quic能解决队头阻塞？</h3><ul>
<li>http队头阻塞用http分片解决。</li>
<li>tcp队头阻塞用udp协议代替，在应用层重新实现可靠传输机制，http请求之间是独立互不影响的。</li>
</ul>
<h3 id="为什么不修改tcp协议解决队头阻塞？"><a href="#为什么不修改tcp协议解决队头阻塞？" class="headerlink" title="为什么不修改tcp协议解决队头阻塞？"></a>为什么不修改tcp协议解决队头阻塞？</h3><ol>
<li> tcp在操作系统层面实现，普及比较麻烦。</li>
<li> 各种网络中间设备（如网关、防火墙、代理服务器）为了效率最优化，保持了约定俗成的潜规则，如某些防火墙只允许特定端口，中间代理会删除报头中不认识的选项字段</li>
</ol>
<h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>一个TCP连接由四元组确定：源ip、源端口号、目标ip、目标端口号。</p>
<p>任何一个元素变化了，tcp就要重新建立连接，例如移动手机在移动网络和WiFi切换，重新建立连接会带来数据传输时延。</p>
<p>而QUIC的连接不依赖于四元组，以一个随机ID作为标识，这样IP或端口发生变化，只要连接ID不变，还是认为是一个连接，应用层感知不到底层tcp连接的变化，这样把影响就降到最低。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>队头阻塞</tag>
        <tag>http2</tag>
        <tag>quic</tag>
      </tags>
  </entry>
  <entry>
    <title>https、TLS握手</title>
    <url>/%E7%BD%91%E7%BB%9C/https%E3%80%81TLS%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h1 id="http传输数据存在哪些问题？"><a href="#http传输数据存在哪些问题？" class="headerlink" title="http传输数据存在哪些问题？"></a>http传输数据存在哪些问题？</h1><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。<br>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>Charles抓包就是中间人拦截监听。</p>
<h1 id="https新引入了什么？解决了什么问题？"><a href="#https新引入了什么？解决了什么问题？" class="headerlink" title="https新引入了什么？解决了什么问题？"></a>https新引入了什么？解决了什么问题？</h1><ol>
<li> 数据加密传输，防止窃听</li>
<li> 校验数据，防止篡改</li>
<li> 使用数字证书验证身份，防止身份被冒充</li>
</ol>
<h1 id="https缺点是什么？"><a href="#https缺点是什么？" class="headerlink" title="https缺点是什么？"></a>https缺点是什么？</h1><ol>
<li> TLS握手增加了建立连接的时间</li>
<li> 每次加密解密数据需要占用额外的时间和CPU资源</li>
</ol>
<h1 id="https如何保证数据的完整性？"><a href="#https如何保证数据的完整性？" class="headerlink" title="https如何保证数据的完整性？"></a>https如何保证数据的完整性？</h1><p>http验证数据完整性存在的问题：</p>
<p>http通信是不加密的，即使对报文做了哈希摘要，并放在报文中传输，http通信内容被拦截篡改后，一并把哈希摘要也改掉，客户端是没办法识别报文是否被篡改。</p>
<p>https改进：</p>
<p>对报文的哈希摘要进行加密，另一方接受到报文并重新计算报文的哈希摘要，再对比解密后的摘要，检查是否一致。</p>
<p>对摘要的加密用对称加密，对称加密的秘钥用非对称加密方式加解密。</p>
<h1 id="https加密过程是怎样的？"><a href="#https加密过程是怎样的？" class="headerlink" title="https加密过程是怎样的？"></a>https加密过程是怎样的？</h1><p>采用对称加密方式加密报文，对称加密的秘钥用非对称加密方式加密后传递给通信双方。</p>
<p>因为：</p>
<ol>
<li> 对称加密速度快，但是通信双方都需要同一个密钥，密钥在传输过程中被窃取泄露后就不安全了</li>
<li> 非对称加密速度慢，但私钥不公开，只传递公钥出去，可以保证安全性</li>
</ol>
<h1 id="https通信过程是怎样的？"><a href="#https通信过程是怎样的？" class="headerlink" title="https通信过程是怎样的？"></a>https通信过程是怎样的？</h1><ol>
<li> 客户端发起SSL/TLS连接</li>
<li> 客户端获取服务端数字证书，验证服务端身份</li>
<li> 两端生成随机数，由服务端根据随机数，用私钥加密得到对称加密密钥</li>
<li> http的请求和响应报文都用对称加密密钥加密后再传输</li>
</ol>
<h1 id="SSL-TLS握手过程是怎样的？"><a href="#SSL-TLS握手过程是怎样的？" class="headerlink" title="SSL/TLS握手过程是怎样的？"></a>SSL/TLS握手过程是怎样的？</h1><p>有四次握手</p>
<ol>
<li> 客户端请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA公钥加密，此时是明文传输。</li>
<li> 服务端回复一种客户端支持的加密方法、一个随机数–Server random、授信的服务器证书和非对称加密的公钥。</li>
<li> 客户端收到服务端的回复后利用服务端的公钥，加上新的随机数–Premaster secret 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li>
<li> 服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li>
</ol>
<p>此后的HTTP链接数据传输即通过对称加密方式进行加密传输。</p>
<h2 id="为什么需要3个随机数作为对称加密的密钥？"><a href="#为什么需要3个随机数作为对称加密的密钥？" class="headerlink" title="为什么需要3个随机数作为对称加密的密钥？"></a>为什么需要3个随机数作为对称加密的密钥？</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在，在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。</p>
<h1 id="还有什么密钥交换算法？"><a href="#还有什么密钥交换算法？" class="headerlink" title="还有什么密钥交换算法？"></a>还有什么密钥交换算法？</h1><p>ECDHE ：“短暂 - 椭圆曲线 - 迪菲 - 赫尔曼”算法（ephemeral Elliptic Curve Diffie–Hellman）。</p>
<p>RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。</p>
<p>客户端和服务端双方在一个可以被窥探的信道下给双方建立起一个相同的密钥。</p>
<p>发送公有的参数，保留私有的参数，双方经过计算可以得到一个一致的结果，一致的结果可以用作会话密钥，这个运算的逆运算复杂度很高，所以不会泄露。</p>
<p><strong>为什么参数被窥探后还能够达到保密的效果?</strong></p>
<p>Deffie-Hellman算法的有效性依赖于计算离散对数的难度。</p>
<h1 id="https总共有多少次握手了？"><a href="#https总共有多少次握手了？" class="headerlink" title="https总共有多少次握手了？"></a>https总共有多少次握手了？</h1><p>SSL是在TCP之上，在HTTP之下。</p>
<p>TCP先三次握手建立连接，然后SSL四次握手，最后进行HTTP通信。</p>
<h1 id="https的身份认证是如何实现的？"><a href="#https的身份认证是如何实现的？" class="headerlink" title="https的身份认证是如何实现的？"></a>https的身份认证是如何实现的？</h1><p>通过数字证书验证通信方身份。</p>
<h2 id="如何验证证书是否可信？"><a href="#如何验证证书是否可信？" class="headerlink" title="如何验证证书是否可信？"></a>如何验证证书是否可信？</h2><p>服务端证书都是向CA这类的权威机构申请的，CA颁发证书时会用根证书的私钥去给申请的证书的哈希摘要做加密作为申请的证书的签名。</p>
<p>客户端收到服务端的证书后，查询证书的颁发者，一直寻找到根证书，然后用根证书里的公钥去解密其颁发的证书的签名，对比证书文件的哈希摘要是否一致，这样就验证了身份没有被篡改。</p>
<h2 id="数字证书验证身份的过程是怎样的？"><a href="#数字证书验证身份的过程是怎样的？" class="headerlink" title="数字证书验证身份的过程是怎样的？"></a>数字证书验证身份的过程是怎样的？</h2><p>服务端向CA（数字证书认证机构）提交自己的公钥申请数字证书，CA颁发证书，并把服务端的公钥内嵌在颁发的证书中，再对整个证书计算哈希摘要，用一个私钥加密这个哈希摘要，确保了申请到的证书在传输过程中可以校验证书是否被篡改，校验是通过CA提供的根证书里的公钥解密服务端证书中的哈希摘要，再计算服务端证书文件的哈希摘要，对比两者是否一致，根证书一般已事先内嵌客户端。</p>
<p>证书可以有信任链。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210827203913.png"></p>
<h1 id="https单向认证是什么？"><a href="#https单向认证是什么？" class="headerlink" title="https单向认证是什么？"></a>https单向认证是什么？</h1><ol>
<li> 客户端发起请求，传送支持的TLS版本、摘要算法、随机数等信息</li>
<li> 服务端返回确认的TLS版本、摘要算法，并再发送生成的随机数、服务端的证书</li>
<li> 客户端验证证书是否可信，不可信则弹窗警告，可信则用随机数生成一个用于对称加密的密钥，用于接下来加密报文，用服务端证书的公钥加密发送给服务端</li>
<li> 服务端接收到会话密钥，用私钥解密，得到会话密钥，返回ACK确认消息</li>
</ol>
<h1 id="https双向认证是什么？"><a href="#https双向认证是什么？" class="headerlink" title="https双向认证是什么？"></a>https双向认证是什么？</h1><p>单向认证是客户端验证服务端的证书来检验服务端身份是否合法。</p>
<p>双向认证是服务端也要求验证客户端的证书来检验客户端的身份是否合法。服务端会在发送证书给客户端时，要求客户端也发送证书给服务端。</p>
<p>双向认证使用场景：</p>
<p>使用网上银行可能需要在电脑上插U盾之类的东西，就是生成客户端证书的。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>https</tag>
        <tag>TLS握手</tag>
        <tag>单向认证</tag>
        <tag>双向认证</tag>
      </tags>
  </entry>
  <entry>
    <title>最大报文长度（MSS）与最大传输单元（MTU）</title>
    <url>/%E7%BD%91%E7%BB%9C/%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%88MSS%EF%BC%89%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%EF%BC%88MTU%EF%BC%89/</url>
    <content><![CDATA[<h1 id="最大报文长度（Maximum-Segment-Size）是什么？"><a href="#最大报文长度（Maximum-Segment-Size）是什么？" class="headerlink" title="最大报文长度（Maximum Segment Size）是什么？"></a>最大报文长度（Maximum Segment Size）是什么？</h1><p>TCP报文数据部分的最大长度，不包含TCP头。</p>
<p>这个MSS指的是TCP报文段中数据部分的最大长度，并不是整个TCP报文段长度。整个TCP报文段长度 = TCP首部长度 + TCP数据部分长度。</p>
<p>如果上层交付下来的数据太大，就对其进行数据分块。这个分块过程是在传输层完成的，在接收端的传输层对分块的TCP报文段的数据部分进行重组。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）存储在什么地方？"><a href="#最大报文长度（Maximum-Segment-Size）存储在什么地方？" class="headerlink" title="最大报文长度（Maximum Segment Size）存储在什么地方？"></a>最大报文长度（Maximum Segment Size）存储在什么地方？</h1><p>TCP首部中的Options字段</p>
<h1 id="为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？"><a href="#为什么要搞一个最大报文长度（Maximum-Segment-Size）来限制TCP报文数据长度？" class="headerlink" title="为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？"></a>为什么要搞一个最大报文长度（Maximum Segment Size）来限制TCP报文数据长度？</h1><p>当TCP数据长度超过MSS的时候，TCP会做分段。</p>
<p>这样是为了防止IP层对TCP报文分片。</p>
<h1 id="IP层对TCP报文进行分片会产生什么问题？"><a href="#IP层对TCP报文进行分片会产生什么问题？" class="headerlink" title="IP层对TCP报文进行分片会产生什么问题？"></a>IP层对TCP报文进行分片会产生什么问题？</h1><p>IP分片后，接收端需要等到所有IP包到达后，才能确定整个TCP报文收到了，然后发送ACK报文，这样比较低效，也增加了控制的复杂性。</p>
<p>IP分片后，如果有几个分片丢失了，只能重传所有分片，这样是很浪费流量的。</p>
<p>首先因为IP层没有超时重传机制，IP层是面向无连接的，所以IP层没有办法只重传丢失的分片。</p>
<p>其次IP分片后，只有第一片有TCP的报文头，后面的IP分片没有TCP报文头，所以TCP也没办法识别到底是哪一段丢失了，也就没办法做超时重传，也没办法确定顺序，如果TCP对报文分段，每段都有TCP报文头，报文丢失就知道丢失的是哪一个。</p>
<h1 id="为什么IP数据长度过长要分片？"><a href="#为什么IP数据长度过长要分片？" class="headerlink" title="为什么IP数据长度过长要分片？"></a>为什么IP数据长度过长要分片？</h1><p>IP分组达到数据链路层，整个IP分组被作为数据链路层以太网帧的数据部分。</p>
<p>以太网帧对数据部分有最大长度的限制，所以IP数据数据过长要分片。</p>
<p>数据链路层的以太网帧的数据部分的最大长度（最大IP包长）称为最大传输单元（Maximum Transmit Unit）</p>
<p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p>
<h1 id="TCP拆分数据的意义？"><a href="#TCP拆分数据的意义？" class="headerlink" title="TCP拆分数据的意义？"></a>TCP拆分数据的意义？</h1><p>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</p>
<h1 id="最大传输单元（Maximum-Transmit-Unit）是什么？"><a href="#最大传输单元（Maximum-Transmit-Unit）是什么？" class="headerlink" title="最大传输单元（Maximum Transmit Unit）是什么？"></a>最大传输单元（Maximum Transmit Unit）是什么？</h1><p>数据链路层的以太网帧的数据部分的最大长度（IP包长）</p>
<h1 id="为什么以太网MTU默认值被设定为1500？"><a href="#为什么以太网MTU默认值被设定为1500？" class="headerlink" title="为什么以太网MTU默认值被设定为1500？"></a>为什么以太网MTU默认值被设定为1500？</h1><p>MTU为什么不能太大呢？</p>
<p>以太网早期的拓扑结构是总线型结构，总线型传输有个特点就是，同一时刻只能有一个主机占用总线传输，如果一个以太网帧过长，这个主机就会一直占用总线，其他主机只能干等着，对于其他主机来说数据延迟就变大了。</p>
<p>而且传输的数据包越大，数据位出错的可能性越大，出错了就要重传，重传又要占用很长时间的带宽，降低了整体吞吐量。</p>
<p>所以MTU不能太大。</p>
<p>如果MTU太小，各种协议头也要占用数据包大小的，这样每个报文的实际有效传输效率也会很低。</p>
<p>所以MTU要搞一个适中值。</p>
<p>1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致丢包无法发送。</p>
<h1 id="为什么MTU最小为64字节？"><a href="#为什么MTU最小为64字节？" class="headerlink" title="为什么MTU最小为64字节？"></a>为什么MTU最小为64字节？</h1><p>以CSMA/CD作为MAC<a href="http://lib.csdn.net/base/datastructure">算法</a>的一类LAN称为以太网。CSMA/CD冲突避免的方法：先听后发、边听边发、随机延迟后重发。一旦发生冲突，必须让每台主机都能检测到。关于最小发送间隙和最小帧长的规定也是为了避免冲突。</p>
<p>考虑如下的情况，主机发送的帧很小，而两台冲突主机相距很远。在主机A发送的帧传输到B的前一刻，B开始发送帧。这样，当A的帧到达B时，B检测到冲突，于是发送冲突信号。假如在B的冲突信号传输到A之前，A的帧已经发送完毕，那么A将检测不到冲突而误认为已发送成功。由于信号传播是有时延的，因此检测冲突也需要一定的时间。这也是为什么必须有个最小帧长的限制。</p>
<p>按照标准，10Mbps以太网采用中继器时，连接的最大长度是2500米，最多经过4个中继器，因此规定对10Mbps以太网一帧的最小发送时间为51.2微秒。这段时间所能传输的数据为512位，因此也称该时间为512位时。这个时间定义为以太网时隙，或冲突时槽。512位＝64字节，这就是以太网帧最小64字节的原因。</p>
<p>512位时是主机捕获信道的时间。如果某主机发送一个帧的64字节仍无冲突，以后也就不会再发生冲突了，称此主机捕获了信道。</p>
<p>由于信道是所有主机共享的，如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的最大帧长为1500。</p>
<p>100Mbps以太网的时隙仍为512位时，以太网规定一帧的最小发送时间必须为5.12μs。</p>
<p>1000Mbps以太网的时隙增至512字节，即4096位时，4.096μs。</p>
<p>以太网数据帧（802.3）最大与最小长度。</p>
<h1 id="最大报文长度（Maximum-Segment-Size）是怎么确定的？"><a href="#最大报文长度（Maximum-Segment-Size）是怎么确定的？" class="headerlink" title="最大报文长度（Maximum Segment Size）是怎么确定的？"></a>最大报文长度（Maximum Segment Size）是怎么确定的？</h1><p>MSS由设备的MTU确定，不能超过MTU，否则TCP报文会被IP层分片  </p>
<h1 id="TCP报文的长度在TCP三次握手中那一次确定的？"><a href="#TCP报文的长度在TCP三次握手中那一次确定的？" class="headerlink" title="TCP报文的长度在TCP三次握手中那一次确定的？"></a>TCP报文的长度在TCP三次握手中那一次确定的？</h1><p>MSS值只会出现在SYN报文中（不要问我为什么，我也不知道为什么只出现SYN报文中），即SYN=1时，才会有MSS字段值。</p>
<p>当客户端想要以TCP方式从服务器端下载数据时，</p>
<p>（1）首先客户端会发送一个SYN请求报文，这个SYN报文的“选项”字段中会有MSS值（MSS = MTU - IP首部长度 - TCP首部长度）。该MSS值是为了告知对方最大的发送数据大小。</p>
<p>（2）当服务器端收到SYN报文后，会向请求端返回SYN+ACK（同步确认报文）报文，其中的“选项”字段也会有MSS值。</p>
<p>（3）通信双方选择SYN和SYN+ACK报文中最小的MSS最为此次TCP连接的MSS，从而达到通信双发协商MSS的效果。</p>
<p>在第二次握手后就可以确定TCP中最大传输报文（MSS）大小。</p>
<h1 id="MTU是怎么确定的？"><a href="#MTU是怎么确定的？" class="headerlink" title="MTU是怎么确定的？"></a>MTU是怎么确定的？</h1><p>每一个物理设备都有自己的 MTU，最终的MTU由整个链路上 MTU 最小的物理设备决定。</p>
<p>路径MTU发现（PMTUD： Path MTU Discovery ）。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>MSS</tag>
        <tag>MTU</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器请求url完整解析的过程</title>
    <url>/%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E7%BD%91%E5%9D%80%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h1><ol>
<li> 域名解析</li>
<li> tcp连接</li>
<li> tls握手</li>
<li> 发送http请求</li>
<li> ARP寻找路由器</li>
<li> 以太网传输数据帧</li>
<li> 路由转发</li>
<li> 服务器返回http响应</li>
<li> 浏览器解析http响应体渲染页面</li>
<li>TCP四次挥手断开连接</li>
</ol>
<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>主流网络通信协议是TCP/IP，数据在网络中的传输是通过IP协议在各个路由器之间传输，找到服务端机器的，IP协议只认IP地址，IP地址全是数字，对于人来说不方便记忆，所以搞了域名，全是英文。所以第一步要先解析域名为IP地址。</p>
<ol>
<li> 先看浏览器缓存有没有对应IP。</li>
<li> 没有则查询操作系统hosts文件里是否有对应IP。</li>
<li> 没有则向本地DNS服务器发起域名解析。</li>
<li> 如果本地DNS服务器有对应IP缓存，则直接返回。</li>
<li> 没有则向根域名服务器请求解析域名，根域名服务器无法解析域名，给出下一级域名服务器地址，本地DNS服务器继续请求，这样一级一级的直到解析出IP地址。</li>
</ol>
<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><p>浏览器使用HTTP协议传输数据，HTTP要求传输要可靠，所以HTTP底层是基于TCP协议的。</p>
<p>TCP协议为了可靠性，一开始是要通过三次握手建立连接，验证通信双方的发送数据和接受数据是正常。</p>
<p>采用三次握手而不是两次握手，是为了防止已失效的连接请求报文突然又传送到了服务端，因而产生错误。</p>
<p>三次握手还会交换报文初始序号、滑动窗口大小、最大报文长度等信息，这些都是用来保证传输的可靠性的。</p>
<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>HTTP请求分为请求行、请求头、请求体。</p>
<ul>
<li>请求行规定了  请求方法类型、url、http协议版本。</li>
<li>请求头的功能很多，比如说缓存、压缩、支持的编码等，看实际的需求。</li>
<li>请求体是详细的数据部分。</li>
</ul>
<p>浏览器输入一个url访问，都是get请求。</p>
<p>数据到达传输层，这里使用的是TCP协议，给数据加上TCP报文头，在报文头中填充源端口号、目的端口号、数据字节数编号、接受窗口大小等数据。</p>
<p>其中端口号的目的是为了把数据交给特定的应用程序做处理，端口号是为了区分同一台主机上不同的应用程序。</p>
<p>TCP协议还有报文编号、超时重传、流量控制、拥塞控制等机制，都是为了保证  传输的可靠性，保证数据传输到位。这些机制对于HTTP协议是无感的。</p>
<h2 id="TCP分段"><a href="#TCP分段" class="headerlink" title="TCP分段"></a>TCP分段</h2><p>如果HTTP报文过长，超过TCP规定的最大报文长度，就会分为多个TCP报文传输，TCP分段是为了防止IP层对数据进行分片，因为IP层分片后，除了第一个分片有TCP报文头，其他IP分片  没有TCP报文头，这样如果一个IP分片丢失，就要重传所有的IP分片，因为没办法定位哪个分片丢失，不方便做超时重传，降低了传输吞吐量。</p>
<p>IP层对数据进行分片是为了防止IP报文大小超过数据链路层的最大传输单元大小，IP数据过长，到数据链路层就无法传输  。</p>
<h1 id="ARP寻址"><a href="#ARP寻址" class="headerlink" title="ARP寻址"></a>ARP寻址</h1><p>TCP报文到IP层后，会加上IP协议报文头，添加源主机IP地址，目的主机IP地址。IP地址是用来定位网络中的主机的。</p>
<p>源主机先检查源主机IP地址和目的主机IP地址是否在同一个网络中。</p>
<h2 id="局域网传输"><a href="#局域网传输" class="headerlink" title="局域网传输"></a>局域网传输</h2><p>如果在同一个网络中，接下来就是局域网通信了。局域网通信识别主机是通过MAC地址来识别的  ，而不是IP地址，所以第一步要先获取主机的MAC地址。这就要用到ARP协议，ARP叫地址解析协议，是用来做IP地址到MAC地址的映射。</p>
<p>首先源主机在本地局域网中发送一个ARP广播请求，目的主机收到广播请求后对比IP地址是自己的，就返回一个ARP响应包，把目的主机的MAC地址告诉源主机。ARP协议会缓存IP地址和MAC地址的映射关系，下一次就不用发广播来获取MAC地址了，节省通信时间。接下来源主机就把IP数据包加上数据链路层的帧首部，填充源主机和目的主机的MAC地址，通过以太网等局域网手段跟目的主机通信。</p>
<h2 id="广域网传输"><a href="#广域网传输" class="headerlink" title="广域网传输"></a>广域网传输</h2><p>如果不在同一个网络中，要将数据发送到网络中，也要先通过ARP获取到网关路由器的MAC地址，源主机把数据传递给网关路由器，网关路由器把数据帧首部去掉，发送IP数据报。</p>
<h1 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h1><p>路由器转发数据，要在路由表中查询是否有能与目的IP地址匹配的条目，如果匹配了主机地址，则发送数据给目的主机  ，否则转发给下一个网络的网关路由器。</p>
<p>数据应该转发给哪个路由器，是根据路由算法来决定的，路由算法会计算得出一个传输代价最小的路径。</p>
<p>在大型、易变的网络中，会用到动态路由算法，一般使用链路状态路由算法，因为传播的数据量小，节省CPU、内存和网络带宽。</p>
<p>每个路由器都会将自己与邻居节点之间的链路状态广播出去，发送到整个网络，这样每个路由器都会有网络中所有路由器的状态，形成全网的拓扑视图，然后可以用迪杰斯特拉最短路径算法求出最短路径，就知道路由转发的时候要发给哪个路由器了。当某台路由器链路状态发生变化，采用洪泛法向所有路由器发送状态信息，使其他路由器重新计算最佳路径重新生成路由表。</p>
<p>路由器之间的通信，也是要走局域网通信的那一套流程，即获得下一跳路由器的MAC地址，然后通过以太网传输数据帧。</p>
<p>服务端收到消息后也是同样的反向操作流程。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ASM字节码插桩</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/</url>
    <content><![CDATA[<h1 id="ASM是干什么的？"><a href="#ASM是干什么的？" class="headerlink" title="ASM是干什么的？"></a>ASM是干什么的？</h1><p>ASM 是一个 Java 字节码操控框架。</p>
<p>ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。</p>
<p>Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。</p>
<p>ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p>
<p>ASM的应用场景有AOP（CGLIB就是基于ASM）、热部署、修改其他jar包中的类等。</p>
<h1 id="用ASM修改类的好处？"><a href="#用ASM修改类的好处？" class="headerlink" title="用ASM修改类的好处？"></a>用ASM修改类的好处？</h1><ul>
<li>类的修改是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。</li>
<li>越过Java常规语法限制，做出代码编写无法实现的事情。</li>
</ul>
<h1 id="字节码操纵操作工具很多，ASM有什么优势？"><a href="#字节码操纵操作工具很多，ASM有什么优势？" class="headerlink" title="字节码操纵操作工具很多，ASM有什么优势？"></a>字节码操纵操作工具很多，ASM有什么优势？</h1><p>常见的字节码操作工具有：</p>
<ul>
<li>ASM</li>
<li>JavaAssist</li>
<li>AspectJ（基于BCEL）</li>
<li>CGLIB（基于ASM）</li>
<li>ByteBuddy（基于ASM）</li>
</ul>
<p>ASM优势：</p>
<ul>
<li>体积小</li>
<li>性能高</li>
</ul>
<p>ASM劣势：</p>
<ul>
<li>需要熟悉字节码原理，API易用性低</li>
</ul>
<p>JavaAssist优势：</p>
<ul>
<li>不需要熟悉字节码原理，API易用性高</li>
</ul>
<p>JavaAssist劣势：</p>
<ul>
<li>体积大</li>
<li>性能差</li>
</ul>
<p>所以ASM适用于对性能和体积敏感的场景。</p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/9167436/dynamic-java-bytecode-manipulation-framework-comparison">Dynamic Java Bytecode Manipulation Framework Comparison</a></li>
</ul>
<h1 id="Visitor模式怎么理解？"><a href="#Visitor模式怎么理解？" class="headerlink" title="Visitor模式怎么理解？"></a>Visitor模式怎么理解？</h1><p>把可变的和不变的分离。</p>
<p>具体而言，被访问者是不变的，而访问者是可变的。举个例子来说，我是不变的，而不同的人看我会有不同的眼光，这个看我的眼光是可变的。</p>
<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。</p>
<p>访问者模式适用于数据结构相对稳定，算法又易变化的系统。<br>因为访问者模式使得算法操作增加变得容易。</p>
<p>若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。</p>
<p>访问者模式的优点：</p>
<p>增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。</p>
<p>访问者模式的缺点：</p>
<p>增加新的数据结构很困难。</p>
<p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。</p>
<p>参考：</p>
<ul>
<li><a href="https://codeleading.com/article/42914263436/">设计模式之 Visitor（访问者模式）通俗理解</a></li>
<li><a href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a></li>
<li><a href="https://www.iteye.com/blog/mybeautiful-1160374">Visitor模式通俗化</a></li>
</ul>
<h1 id="ASM为什么用Visitor模式？"><a href="#ASM为什么用Visitor模式？" class="headerlink" title="ASM为什么用Visitor模式？"></a>ASM为什么用Visitor模式？</h1><p>.class 文件的结构是固定的，主要有常量池、字段表、方法表、属性表等内容，通过使用访问者模式在扫描 .class 文件中各个表的内容时，就可以修改这些内容了。</p>
<h1 id="ASM的思想是什么？"><a href="#ASM的思想是什么？" class="headerlink" title="ASM的思想是什么？"></a>ASM的思想是什么？</h1><p>ClassReader 的 accept 方法中传进来了一个参数ClassVisitor。在内部，ClassVisitor会不断的读取ClassReader的二进制byte[]，然后在解析后通过参数classVisitor的抽象visitXXX方法将属性全部转发出去。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825235523.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825235623.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/CSqingchen/article/details/106483693">Android 中使用ASM，对Activity生命周期打点统计</a></li>
</ul>
<h1 id="ASM-API"><a href="#ASM-API" class="headerlink" title="ASM API"></a>ASM API</h1><p>分为核心API和树形API</p>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：</p>
<ul>
<li>ClassReader：用于读取已经编译好的.class文件。</li>
<li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li>
<li>  各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。</li>
</ul>
<h2 id="树形API"><a href="#树形API" class="headerlink" title="树形API"></a>树形API</h2><p>ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</p>
<h1 id="Intellij-Idea-中-ASM-Bytecode-Outline-插件"><a href="#Intellij-Idea-中-ASM-Bytecode-Outline-插件" class="headerlink" title="Intellij Idea 中 ASM Bytecode Outline 插件"></a>Intellij Idea 中 ASM Bytecode Outline 插件</h1><p>可以把java代码转为ASM框架的代码。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ForwardSailing/article/details/106494116">Android Studio 使用 ASM Bytecode Outline 插件来研究Java字节码</a></li>
</ul>
<h1 id="ASM如何使用？"><a href="#ASM如何使用？" class="headerlink" title="ASM如何使用？"></a>ASM如何使用？</h1><p>ClassWriter是ClassVistor的实现类。</p>
<p>处理逻辑都写自定义ClassVisitor里。</p>
<p>模板的拦截代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">&quot;meituan/bytecode/asm/Base&quot;</span>);</span><br><span class="line">ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理</span></span><br><span class="line">ClassVisitor classVisitor = <span class="keyword">new</span> MyClassVisitor(classWriter);</span><br><span class="line">classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"><span class="keyword">byte</span>[] data = classWriter.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;/classes/meituan/bytecode/asm/Base.class&quot;</span>);</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">fout.write(data);</span><br><span class="line">fout.close();</span><br></pre></td></tr></table></figure>

<p>代码示例：在一个方法前后分别插入方法</p>
<p>例如有一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">halloAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AopInterceptor.beforeInvoke();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Aop&quot;</span>);</span><br><span class="line">        AopInterceptor.afterInvoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要插入AopInterceptor的beforeInvoke()和afterInvoke()在TestBean的halloAop()的执行前后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义ClassVisitor的visitMethod方法中拦截halloAop方法，对不是halloAop的方法返回null表示不处理，对halloAop的拦截处理交给AopMethod类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopClassAdapter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopClassAdapter</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">    String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&lt;init&gt;&quot;</span>.equals(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//放弃原有类中所有构造方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;halloAop&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 只对halloAop方法执行代理</span></span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AopMethod(<span class="keyword">this</span>.api, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodVisitor中</p>
<p>visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，重写visitCode方法，将AOP中的前置逻辑就放在这里。</p>
<p>每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法。我们判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将AOP的后置逻辑放在该方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopMethod</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopMethod</span><span class="params">(<span class="keyword">int</span> api, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitCode();    </span><br><span class="line">        <span class="keyword">this</span>.visitMethodInsn(INVOKESTATIC,<span class="string">&quot;org/more/test/asm/AopInterceptor&quot;</span>, <span class="string">&quot;beforeInvoke&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == RETURN) &#123;<span class="comment">//在返回之前安插after 代码。</span></span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;org/more/test/asm/AopInterceptor&quot;</span>, <span class="string">&quot;afterInvoke&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
<li><a href="https://my.oschina.net/ta8210/blog/162796">深入字节码 – 使用 ASM 实现 AOP</a></li>
<li><a href="https://blog.csdn.net/s127838498/article/details/107968840">Android 通过ASM实现多次点击拦截</a></li>
</ul>
<h1 id="invokevirtual指令执行方法后，方法的返回值存放在哪？"><a href="#invokevirtual指令执行方法后，方法的返回值存放在哪？" class="headerlink" title="invokevirtual指令执行方法后，方法的返回值存放在哪？"></a>invokevirtual指令执行方法后，方法的返回值存放在哪？</h1><p>存放在栈帧的操作栈中。</p>
<blockquote>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p>
<p>举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p>
</blockquote>
<p>参考</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode instruction listings 中对指令的descrpitoin</a></li>
<li><a href="http://gityuan.com/2015/10/24/jvm-bytecode-grammar/">Jvm系列3—字节码指令</a></li>
</ul>
<h1 id="局部变量表的执行过程？"><a href="#局部变量表的执行过程？" class="headerlink" title="局部变量表的执行过程？"></a>局部变量表的执行过程？</h1><p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎</a></li>
<li>深入理解Java虚拟机（第2版）第8章  虚拟机字节码执行引擎<ul>
<li>8.2.1 局部变量表</li>
<li>8.4.3 基于栈的解释器的执行过程</li>
</ul>
</li>
</ul>
<h1 id="MethodNode有什么作用？"><a href="#MethodNode有什么作用？" class="headerlink" title="MethodNode有什么作用？"></a>MethodNode有什么作用？</h1><p>可以获取方法体内部的字节码指令等方法的一切信息</p>
<h1 id="MethodNode有什么使用场景？"><a href="#MethodNode有什么使用场景？" class="headerlink" title="MethodNode有什么使用场景？"></a>MethodNode有什么使用场景？</h1><p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">微信Android客户端卡顿检测工具：Matrix-Android-TraceCanary</a></p>
<h2 id="判断一个方法是空方法？"><a href="#判断一个方法是空方法？" class="headerlink" title="判断一个方法是空方法？"></a>判断一个方法是空方法？</h2><p>遍历字节码指令，没有有效的字节码指令就是空</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmptyMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();  </span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();  </span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断扫描的函数是否只含有-PUT-READ-FIELD-等简单的指令"><a href="#判断扫描的函数是否只含有-PUT-READ-FIELD-等简单的指令" class="headerlink" title="判断扫描的函数是否只含有 PUT/READ FIELD 等简单的指令"></a>判断扫描的函数是否只含有 PUT/READ FIELD 等简单的指令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGetSetMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ignoreCount = <span class="number">0</span>;</span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();</span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opcode != Opcodes.GETFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.GETSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_GETFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_GETSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.RETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.ARETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.DRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.FRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.LRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.IRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.PUTFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.PUTSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_PUTFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_PUTSTATIC</span><br><span class="line">                &amp;&amp; opcode &gt; Opcodes.SALOAD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConstructor &amp;&amp; opcode == Opcodes.INVOKESPECIAL) &#123;</span><br><span class="line">                ignoreCount++;</span><br><span class="line">                <span class="keyword">if</span> (ignoreCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="判断一个方法是不是仅调用另外一个方法"><a href="#判断一个方法是不是仅调用另外一个方法" class="headerlink" title="判断一个方法是不是仅调用另外一个方法"></a>判断一个方法是不是仅调用另外一个方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSingleMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();</span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Opcodes.INVOKEVIRTUAL &lt;= opcode &amp;&amp; opcode &lt;= Opcodes.INVOKEDYNAMIC) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索（付ASM简易教程）</a></li>
<li><a href="https://juejin.im/post/6844903721789292558">从 Java 字节码到 ASM 实践</a></li>
<li><a href="https://juejin.im/post/6844903831646502920">Android Transform + ASM 初探</a></li>
<li><a href="https://juejin.im/post/6844903725937475592">自定义 gradle plugin，教你如何 hook 系统 task 和字节码</a></li>
<li><a href="https://juejin.im/post/6844904029886087181">详解Android Gradle生成字节码流程</a></li>
<li><a href="http://quinnchen.cn/2018/09/13/2018-09-13-asm-transform/">一起玩转Android项目中的字节码</a></li>
<li><a href="https://blog.csdn.net/CSqingchen/article/details/106483693">Android 中使用ASM，对Activity生命周期打点统计</a></li>
<li><a href="https://www.jianshu.com/p/e5062d62a3d1">认识 .class 文件的字节码结构</a></li>
<li><a href="https://www.jianshu.com/p/0cf9aa251921">理解 JVM 中的类加载机制</a></li>
<li><a href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎</a></li>
<li><a href="https://www.baeldung.com/java-asm">asm官网（内附教程）</a></li>
<li><a href="https://developer.ibm.com/zh/articles/j-lo-asm30/">AOP 的利器：ASM 3.0 介绍</a></li>
<li><a href="https://www.jianshu.com/p/905be2a9a700">ASM 库的介绍和使用</a></li>
<li><a href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a></li>
<li><a href="https://www.jianshu.com/p/905be2a9a700">ASM 库的介绍和使用</a></li>
<li><a href="https://www.jianshu.com/p/c2c1d350d245">从 Java 字节码到 ASM 实践</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>虚拟机</tag>
        <tag>ASM</tag>
        <tag>字节码</tag>
        <tag>插桩</tag>
      </tags>
  </entry>
  <entry>
    <title>JIT编译、HotSpot虚拟机</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/JIT%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="静态编译和动态编译分别是什么？"><a href="#静态编译和动态编译分别是什么？" class="headerlink" title="静态编译和动态编译分别是什么？"></a>静态编译和动态编译分别是什么？</h1><p>动态编译（dynamic compilation），指的是“在运行时进行编译”；</p>
<p>与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation），程序运行前就把代码全部翻译成机器码</p>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/19977592">JIT编译，动态编译与自适应动态编译 - RednaxelaFX的文章 - 知乎</a></li>
</ul>
<h1 id="JIT编译是什么？"><a href="#JIT编译是什么？" class="headerlink" title="JIT编译是什么？"></a>JIT编译是什么？</h1><p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。</p>
<p>JIT编译一词后来被泛化，时常与动态编译等价；但要注意宽泛与狭义的JIT编译所指的区别。</p>
<p>JIT编译，全称 just-in-time compilation，按照其原始的、严格的定义，是每当一部分代码准备要第一次执行的时候，将这部分代码编译，然后跳进编译好的代码里执行。这样，所有执行过的代码都必然会被编译过。早期的JIT编译系统对同一个块代码只会编译一次。JIT编译的单元也可以选择是方法/函数级别，或者别的，例如trace。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824238546.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/26913901/answer/35303563">HotSpot是较新的Java虚拟机技术，用来代替JIT技术, 那么HotSpot和JIT是共存的吗？ - RednaxelaFX的回答 - 知乎</a></li>
<li><a href="https://juejin.im/post/5b3782b1e51d4558dc4ae4a7">你了解JVM中的 JIT 即时编译及优化技术吗？</a></li>
</ul>
<h1 id="解释执行是什么意思？"><a href="#解释执行是什么意思？" class="headerlink" title="解释执行是什么意思？"></a>解释执行是什么意思？</h1><p>解释器：只在执行程序时，才一条一条把字节码解释成机器语言给计算机来执行</p>
<p>Java需要将字节码逐条翻译成对应的机器指令并且执行，这就是传统的JVM的解释器的功能，正是由于解释器逐条翻译并执行这个过程的效率低，引入了JIT即时编译技术。</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1488067">有关JIT你需要知道的</a></li>
</ul>
<h1 id="为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？"><a href="#为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？" class="headerlink" title="为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？"></a>为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？</h1><p>因为有些代码在将来只执行一次也有可能不执行，全部编译占用空间也浪费时间。</p>
<h1 id="JIT编译器有什么好处？"><a href="#JIT编译器有什么好处？" class="headerlink" title="JIT编译器有什么好处？"></a>JIT编译器有什么好处？</h1><p>在运行时编译，可以实时的获取运行时的信息，更好的做编译优化；静态编译是无法做这种优化的。</p>
<p>A JIT compiler runs after the program has started and compiles the code (usually bytecode or some kind of VM instructions) on the fly (or just-in-time, as it’s called) into a form that’s usually faster, typically the host CPU’s native instruction set. A JIT has access to dynamic runtime information whereas a standard compiler doesn’t and can make better optimizations like inlining functions that are used frequently.</p>
<ul>
<li><a href="https://www.zhihu.com/question/21093419/answer/112968115">如何通俗易懂地介绍「即时编译」（JIT），它的优点和缺点是什么？ - lcksuper的回答 - 知乎  </a></li>
</ul>
<h1 id="为何-HotSpot-虚拟机要使用解释器与编译器并存的架构？"><a href="#为何-HotSpot-虚拟机要使用解释器与编译器并存的架构？" class="headerlink" title="为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？"></a>为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？</h1><p>解释器与编译器两者各有优势。</p>
<p>解释器：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。</p>
<p>编译器：在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</p>
<p>两者的协作：在程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。当通过编译器优化时，发现并没有起到优化作用，，可以通过逆优化退回到解释状态继续执行。</p>
<ul>
<li><a href="https://juejin.cn/post/6844903630408155150">你了解JVM中的 JIT 即时编译及优化技术吗？</a></li>
</ul>
<p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。此外，如果编译后出现“罕见陷阱”，可以通过逆优化退回到解释执行。</p>
<p>解释器的执行，抽象的看是这样的：输入的代码 -&gt; [ 解释器 解释执行 ] -&gt; 执行结果</p>
<p>而要JIT编译然后再执行的话，抽象的看则是：输入的代码 -&gt; [ 编译器 编译 ] -&gt; 编译后的代码 -&gt; [ 执行 ] -&gt; 执行结果</p>
<p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快。怎么算是“只执行一次的代码”呢？粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p>
<p>1、只被调用一次，例如类的构造器（class initializer，<clinit>()）</p>
<p>2、没有循环</p>
<p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。只有对频繁执行的代码，JIT编译才能保证有正面的收益。</p>
<p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”。这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/guanghe/p/11880577.html">Java虚拟机解释器与JIT编译器</a></li>
</ul>
<h1 id="HotSpot虚拟机为什么叫Hotspot？"><a href="#HotSpot虚拟机为什么叫Hotspot？" class="headerlink" title="HotSpot虚拟机为什么叫Hotspot？"></a>HotSpot虚拟机为什么叫Hotspot？</h1><p>通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。</p>
<p>HotSpot VM得名于它得混合模式执行引擎：这个执行引擎包括解释器和自适应编译器（adaptive compiler）。默认配置下，一开始所有Java方法都由解释器执行。解释器记录着每个方法得调用次数和循环次数，并以这两个数值为指标去判断一个方法的“热度”。显然，HotSpot VM是以“方法”为单位来寻找热点代码。等到一个方法足够“热”的时候，HotSpot VM就会启动对该方法的编译。这种在所有执行过的代码里只寻找一部分来编译的做法，就叫做自适应编译（adaptive compilation）。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824335546.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/26913901/answer/35303563">HotSpot是较新的Java虚拟机技术，用来代替JIT技术,那么HotSpot和JIT是共存的吗？ - RednaxelaFX的回答 - 知乎</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html">深入浅出 JIT 编译器</a></li>
</ul>
<h1 id="JIT编译与HotSpot虚拟机有什么关系？"><a href="#JIT编译与HotSpot虚拟机有什么关系？" class="headerlink" title="JIT编译与HotSpot虚拟机有什么关系？"></a>JIT编译与HotSpot虚拟机有什么关系？</h1><p>首先，如果一段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。</p>
<p>当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。</p>
<p>在部分的商用虚拟机（Sun HotSpot、IBM J9）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，本文中简称JIT编译器）。</p>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1488067">有关JIT你需要知道的</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>JIT编译</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中创建对象内存分配的过程</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="指针碰撞和空闲列表"><a href="#指针碰撞和空闲列表" class="headerlink" title="指针碰撞和空闲列表"></a>指针碰撞和空闲列表</h1><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump thePointer）。</p>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（FreeList）。</p>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/yun_ld/article/details/105103011">指针碰撞和空闲列表</a></li>
</ul>
<h1 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824235546.png"></p>
<ul>
<li>  当虚拟机收到new指令后，检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，必须先执行类加载过程。</li>
<li>  在类加载完成后可以确定对象分配所需要的空间。如果Java堆中内存是绝对规整的，用过的内存放一边，空闲的内存放另一边，中间放着一个指针作为分界点的指示器，那分配内存就只是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为”指针碰撞”。如果Java堆中内存不是规整的，空闲内存与使用过的内存是相互交错的，虚拟机必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找出足够的空间分配给对象实例，并更新列表上的记录，这种分配方式称为”空闲列表”。采用哪种分配方式通常由虚拟机的垃圾收集器是否带有压缩整理功能决定。</li>
<li>  划分可用空间时，还需考虑为对象实例分配空间时是否是线程安全的。要保证线程安全，有两种方案。一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种是把内存分配的动作按照线程划分在不同空间中进行，每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer , TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</li>
<li>  内存分配完成后，虚拟机对分配到的内存空间都初始化为零值(不包括对象头)，保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用。</li>
<li>  虚拟机将对象的信息放入对象的对象头中。</li>
<li>  执行构造函数</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a9ff882337d4">Java内存分配与回收机制</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收器</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="常见的垃圾回收器有哪些？"><a href="#常见的垃圾回收器有哪些？" class="headerlink" title="常见的垃圾回收器有哪些？"></a>常见的垃圾回收器有哪些？</h1><ol>
<li><p>串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。</p>
</li>
<li><p>并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。</p>
</li>
<li><p>吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。</p>
</li>
<li><p> 并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。</p>
</li>
<li><p>G1（Garbage First）收集器是一款在server端运行的垃圾收集器，专门针对于拥有多核处理器和大内存的机器，在JDK 7u4版本发行时被正式推出，在JDK9中更被指定为官方GC收集器。它满足高吞吐量的同时满足GC停顿的时间尽可能短。</p>
</li>
</ol>
<p>参考《深入理解Java虚拟机（第2版）》 76页 3.5 垃圾收集器。</p>
<h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>新生代收集器，单线程收集，收集时Stop the world（暂停所有线程），采取复制算法</p>
<p>客户端新生代默认收集器，因为用户桌面应用场景中，分配给虚拟机的内存不会很大，停顿时间较短，只要不是频繁发生，可以接受，这样就发挥出Serial收集器简单而高效的优点。</p>
<h1 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h1><p>老生代收集器，单线程收集，收集时Stop the world（暂停所有线程），采取标记整理算法</p>
<h1 id="Parallel-New收集器"><a href="#Parallel-New收集器" class="headerlink" title="Parallel New收集器"></a>Parallel New收集器</h1><p>新生代收集器，Serial收集器的多线程版本，多个GC线程同时进行回收</p>
<h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><p>新生代收集器，采用复制算法多线程收集</p>
<p>目标是达到一个可控的吞吐量，吞吐量优先的收集器</p>
<p>吞吐量=程序运行时间/(程序运行时间+垃圾回收时间)</p>
<p>适合后台运算不需要太多实时交互响应的场景</p>
<p>适合对吞吐量和CPU资源很在意，对交互响应不敏感的的场景，例如后台服务，可以尽可能的多执行任务</p>
<p>可以开启自适应调解策略，让虚拟机根据系统运行情况动态调节内存分配的参数（如新生代大小、Eden与Survivor比例、晋升到老年代的年龄阈值等），以达到最佳的吞吐量，这是与Parallel New的重要区别。</p>
<p>还可以设置最大GC停顿时间和吞吐量给虚拟机设定优化的目标，由虚拟机自动调解最适合的参数来进行内存分配管理。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/764f93fac5f3">GC之Parallel Scavenge收集器</a></li>
<li><a href="https://www.sohu.com/a/217647656_812245">详细介绍JVM吞吐量优先收集器以及各种可以配置的参数</a></li>
</ul>
<h1 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h1><p>老年代收集器，Parallel Scavenge的老年代版本，使用多线程和标记整理，吞吐量优先</p>
<h1 id="Concurrent-Mark-Sweep收集器"><a href="#Concurrent-Mark-Sweep收集器" class="headerlink" title="Concurrent Mark Sweep收集器"></a>Concurrent Mark Sweep收集器</h1><p>老年代收集器，以获得最短的GC停顿时间为目标的收集器，适合卡顿容忍度低的场景，例如有用户交互的情景（如Android手机交互）</p>
<p>收集过程为：</p>
<ol>
<li> 初始标记</li>
<li> 并发标记</li>
<li> 重新标记</li>
<li> 并发清除</li>
</ol>
<p>初始标记和重新标记需要Stop the world（暂停所有线程）。初始标记仅标记跟GC Roots直接关联的对象，速度很快；并发标记就是进行完整的可达性分析（GC Roots Tracing）；重新标记是为了修正并发标记期间进程继续运行而导致对象关系变动而重新标记这些变动的对象关系，运行时间比初始标记稍长，但是远比并发标记时间短，要扫描全堆。</p>
<p>缺点：</p>
<ol>
<li> 并发标记和并发清除所启用的多个GC线程占用了CPU资源，降低系统吞吐量。</li>
<li> 无法处理并发清除期间程序继续运行而产生的浮动垃圾，不能等待老年代满了才收集，等到老年代占用的空间达到一个阈值，就要启用CMS清理，这样就预留了一定的空间来容纳并发清除期间产生的浮动垃圾，如果预留的空间无法满足程序继续运行的需要，则改用Serial Old执行清理。</li>
<li>标记清除算法会产生大量不连续的内存碎片，整理碎片只能串行执行，所以比较耗时，采用标记清除也是因为老年代的回收次数比较少，每次回收都标记整理性价比不高，可以在几次标记清除后再执行一次标记整理，调节一个可控的执行频率。</li>
</ol>
<p>参考</p>
<ul>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
<li><a href="https://www.zhihu.com/question/29114369/answer/387208380">minor gc 会发生stop the world 现象吗？ - wuxinliulei的回答 - 知乎</a></li>
</ul>
<h2 id="为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？"><a href="#为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？" class="headerlink" title="为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？"></a>为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？</h2><p>因为要并发清除，所以用的是标记清理算法，而标记清理算法会产生大量内存碎片，对新生代难以接受，新生代适合用复制算法，或者需要整理内存，以腾出连续的空间以供分配大对象。</p>
<p>因此新生代的收集器并未提供CMS版本。</p>
<h2 id="为什么CMS不能用标记整理而要用标记清理？"><a href="#为什么CMS不能用标记整理而要用标记清理？" class="headerlink" title="为什么CMS不能用标记整理而要用标记清理？"></a>为什么CMS不能用标记整理而要用标记清理？</h2><p>因为老年代存活时间长，每次清理后，要整理的存活的对象太多了，比较耗时。</p>
<p>CMS主要关注低延迟，如果采用压缩算法，则涉及到要移动应用程序的存活对象，此时不停顿，是很难处理的，通常须要停顿下，移动存活对象，再让应用程序继续运行，但这样停顿时间变长，延迟变大。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.shangmayuan.com/a/b18e72c952e749e0a8a21664.html">CMS为何采用标记-清除算法</a></li>
<li><a href="https://hllvm-group.iteye.com/group/forum?tag_id=690">[讨论]</a>  <a href="https://hllvm-group.iteye.com/group/topic/38223">并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a></li>
</ul>
<h1 id="Garbage-First（G1）收集器"><a href="#Garbage-First（G1）收集器" class="headerlink" title="Garbage First（G1）收集器"></a>Garbage First（G1）收集器</h1><p>JVM内部知道，哪些region的对象最少（即：该区域最空），总是会优先收集这些region(因为对象少，内存相对较空，肯定快），这也是Garbage-First得名的由来，G即是Garbage的缩写， 1即First(第1)。</p>
<p>G1 根据存活对象的字节数统计每个区域的 活跃度liveness，然后根据期望停顿时间来确定该 CSet 的大小，并保证那些垃圾多（活跃度低）的区域会被优先回收，故此得名 垃圾优先。</p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>G1 能够在大内存、多处理器计算机上，保证 GC 暂停时间可控，并实现高吞吐量。</p>
<p>其最终目的是取代 CMS 成为服务端 GC 更好的解决方案：</p>
<ol>
<li> 采用 标记-整理 算法，可以避免使用细粒度的空闲列表进行分配。简化了收集器设计并消除了潜在的碎片问题。</li>
<li>提供可预测的GC暂停时间，无需牺牲很多吞吐量。</li>
</ol>
<h2 id="G1相对于CMS的优势"><a href="#G1相对于CMS的优势" class="headerlink" title="G1相对于CMS的优势"></a>G1相对于CMS的优势</h2><ol>
<li>CMS是标记清理，回收过后有大量内存碎片；G1从整体来看是基于标记-整理算法实现的，从局部（两=08u ym,ghvtbfrcRegion之间）上来看是基于“复制”算法实现的，避免了过多的内存碎片</li>
<li>G1在逻辑上虽然也Eden、Survivor、Old区，但是都是以Region为单位，不需要扫描整个内存空间，只要扫描有存活对象的Region，减少了扫描的时间</li>
<li>G1可以通过设置预期停顿时间( Pause Time) 来控制垃圾收集时间，在垃圾回收时尽量满足设置的停顿时间。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</li>
<li>G1会在Young GC中使用，而CMS只能在Old区使用，因为年轻代需要用复制算法以腾出大量连续内存空间，CMS是标记清理算法会产生大量内存碎片</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></li>
</ul>
<h2 id="G1的适合场景"><a href="#G1的适合场景" class="headerlink" title="G1的适合场景"></a>G1的适合场景</h2><ol>
<li> 服务端多核CPU、JVM内存占用较大的应用。</li>
<li> 应用在运行过程中会产生大量内存碎片、需要经常压缩空间。</li>
<li> 想要更可控、可预期的GC停顿周期:防止高并发下应用的雪崩现象，实现高吞吐量。 </li>
</ol>
<p>一句话总结：实现高吞吐、没有内存碎片、收集时间可控。</p>
<p>G1收集器是server-style的垃圾收集器，适用于具有大内存的多处理器计算机。它极有可能满足垃圾回收（GC）暂停时间目标，同时实现高吞吐量。</p>
<p>对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照<a href="https://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html">官方</a> 的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：</p>
<ol>
<li> 实时数据占用了超过半数的堆空间；</li>
<li> 对象分配率或“晋升”的速度变化明显； </li>
<li> 期望消除耗时较长的GC或停顿（超过0.5——1秒）。</li>
</ol>
<h2 id="G1内存划分"><a href="#G1内存划分" class="headerlink" title="G1内存划分"></a>G1内存划分</h2><p>G1把内存分为大约2000个左右的一个个大小固定的小块，小块叫Region，每个Region被标记为分代标志，如Eden、Survivor、Old、Humongous，每个Region在物理内存中可以不连续</p>
<h3 id="G1把内存划分为Region区域有什么好处？"><a href="#G1把内存划分为Region区域有什么好处？" class="headerlink" title="G1把内存划分为Region区域有什么好处？"></a>G1把内存划分为Region区域有什么好处？</h3><ol>
<li>其他收集器会在全堆做扫描，导致gc停顿时间会比较长，而G1只是整理特定几个region，不必扫描全堆</li>
<li>在物理，上不需要连续，则带来了额外的好处有的分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾；停顿时间可预测，用户可以指定收集操作在多长时间内完成</li>
<li> G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩，避免了内存碎片。</li>
</ol>
<h3 id="G1收集器中大对象怎么分配"><a href="#G1收集器中大对象怎么分配" class="headerlink" title="G1收集器中大对象怎么分配"></a>G1收集器中大对象怎么分配</h3><ol>
<li>对象的大小&lt;0.5个RegionSize直接存在新生代Eden Region区</li>
<li>对象的大小&gt;=0.5个RegionSize且对象的大小&lt;1个RegionSize,存到大对象区Humongous Region</li>
<li> 对象的大小&gt;=1个RegionSize存到连续的大对象区Humongous Region</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000038430433">总结G1垃圾收集器面试题</a></li>
</ul>
<h2 id="G1预测停顿时间是怎么做到的？"><a href="#G1预测停顿时间是怎么做到的？" class="headerlink" title="G1预测停顿时间是怎么做到的？"></a>G1预测停顿时间是怎么做到的？</h2><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p>G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p>
<h2 id="G1为什么高效？"><a href="#G1为什么高效？" class="headerlink" title="G1为什么高效？"></a>G1为什么高效？</h2><p>为了提高扫描根对象和标记的效率，G1使用了二个新的辅助存储结构：</p>
<ul>
<li>Remembered Sets：简称RSets，用于根据每个region里的对象，是从哪指向过来的(即：谁引用了我)，每个Region都有独立的RSets。（Other Region -&gt; Self Region)</li>
<li>Collection Sets ：简称CSets，记录了等待回收的Region集合，GC时这些Region中的对象会被回收(copied or moved)。</li>
</ul>
<h3 id="Rememberred-Set是什么？"><a href="#Rememberred-Set是什么？" class="headerlink" title="Rememberred Set是什么？"></a>Rememberred Set是什么？</h3><p>记录哪些分区引用了当前的Region。</p>
<p>使得垃圾回收器不需要扫描整个堆，就可以找到谁引用了当前分区的对象，扫描RSet就行了。</p>
<p>Young区到Old区的引用则不需要单独处理，因为Young区中的对象本身变化比较大，没必要浪费空间去记录下来。</p>
<ol>
<li> RSet：全称Remembered Sets, 用来记录外部指向本Region的所有引用，每个Region维护一个RSet。    </li>
<li> Card: JVM将内存划分成了固定大小的Card。这里可以类比物理内存上page的概念。</li>
</ol>
<p>每个Region初始化时，会初始化一个remembered set（已记忆集合），这个翻译有点拗口，以下简称RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的 xx Card。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/luzhensmart/article/details/106052574">G1-Card Table和Remember Set</a></li>
<li><a href="https://club.perfma.com/article/1933770">CardTable和Remeberred Set区别？</a></li>
<li><a href="https://segmentfault.com/a/1190000021878102">“对象消失”、“三色标记”、“增量更新”</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></li>
<li><a href="https://www.cnblogs.com/GrimMjx/p/12234564.html">搞懂G1垃圾收集器</a></li>
<li><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/94477796">JVM G1收集器</a></li>
<li><a href="https://www.cnblogs.com/buttercup/p/13829881.html#g1-%E7%AE%97%E6%B3%95">G1收集器</a></li>
<li><a href="https://segmentfault.com/a/1190000021878102">面试官问我G1回收器怎么知道你是什么时候的垃圾？</a></li>
</ul>
<h1 id="JDK8默认垃圾回收器是什么？"><a href="#JDK8默认垃圾回收器是什么？" class="headerlink" title="JDK8默认垃圾回收器是什么？"></a>JDK8默认垃圾回收器是什么？</h1><p>Parallel Scavenge + Parallel Old</p>
<p>Parallel Scavenge是吞吐量优先的垃圾收集器，采用复制算法，多线程收集。</p>
<p>Parallel Old是Parallel Scavenge的老年代版本，采用标记整理算法，多线程收集。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/huanxianglove/article/details/90247994">JDK8默认垃圾回收器详解</a></li>
</ul>
<h1 id="JDK9默认垃圾收集器是什么？"><a href="#JDK9默认垃圾收集器是什么？" class="headerlink" title="JDK9默认垃圾收集器是什么？"></a>JDK9默认垃圾收集器是什么？</h1><p>G1。</p>
<p>采用G1因为性能优越。</p>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1429131">为什么G1 GC从JDK 9之后成为默认的垃圾回收器？</a></li>
</ul>
<h1 id="Android-ART虚拟机垃圾回收机制是怎样的？"><a href="#Android-ART虚拟机垃圾回收机制是怎样的？" class="headerlink" title="Android  ART虚拟机垃圾回收机制是怎样的？"></a>Android  ART虚拟机垃圾回收机制是怎样的？</h1><p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/89536376">Android ART 并行拷贝垃圾回收
</a></li>
<li><a href="https://www.kancloud.cn/alex_wsc/androids/473625">老罗的Android之旅：ART运行时垃圾收集机制简要介绍和学习计划
</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
        <tag>CMS</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收算法</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="如何判定一个对象是否可以被垃圾回收？"><a href="#如何判定一个对象是否可以被垃圾回收？" class="headerlink" title="如何判定一个对象是否可以被垃圾回收？"></a>如何判定一个对象是否可以被垃圾回收？</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>记录每个对象被引用数量，产生新引用计数加1，引用失效计数减1</p>
<p>优点：实现简单<br>缺点：无法解决环形依赖引用</p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>一个对象到GC Roots对象没有引用链，表示此对象是没有地方使用，可以被回收。</p>
<h3 id="可以作为GC-Roots的对象"><a href="#可以作为GC-Roots的对象" class="headerlink" title="可以作为GC Roots的对象"></a>可以作为GC Roots的对象</h3><ol>
<li> 虚拟机栈中的引用的对象，即栈帧中的局部变量表中引用的对象</li>
<li> 本地方法栈中引用的对象，即native方法中引用的对象</li>
<li> 方法区中类的静态属性引用的对象</li>
<li> 方法区中常量引用的对象</li>
</ol>
<p>优点：</p>
<ul>
<li>分析更加精确，解决了环形引用的问题</li>
</ul>
<p>缺点：</p>
<ul>
<li> 实现复杂，分析时间长</li>
<li>分析过程需要保证引用关系不能发生变化，需要GC停顿，即让所有线程的执行都暂停（Stop the world）</li>
</ul>
<p>参考《深入理解Java虚拟机（第2版）》3.2 对象已死吗</p>
<h1 id="GC停顿是什么？"><a href="#GC停顿是什么？" class="headerlink" title="GC停顿是什么？"></a>GC停顿是什么？</h1><p>对象的可达性分析需要枚举GC Roots节点对象，必须要保证对象之间的引用关系不能一直变化，必须要停顿所有线程的执行，这就是Stop the world，也是垃圾回收的性能瓶颈所在。暂停线程的工作，需要等到安全点才能暂停。</p>
<h1 id="怎么让线程在安全点暂停？"><a href="#怎么让线程在安全点暂停？" class="headerlink" title="怎么让线程在安全点暂停？"></a>怎么让线程在安全点暂停？</h1><p>主动式中断（Voluntary  Suspension），GC需要中断线程时，不直接中断线程，仅仅给每个线程设置一个标志，各线程主动轮询这个标志，发现中断标志为true就自己中断挂起。</p>
<h1 id="线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？"><a href="#线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？" class="headerlink" title="线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？"></a>线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？</h1><p>如果一段代码中引用关系不会变化，称为这一段为安全区域，线程执行到安全区域的代码时，会标记自己已经进入了安全区域；虚拟机发起垃圾回收时，就不用管已经位于安全区域的线程了。</p>
<p>线程离开安全区域时，要检查系统是否已经完成了GC Roots的枚举（或者是检查整个垃圾回收是否已结束），如果还没有完成，就必须要等待，直到收到可以安全离开安全区域的信号为止。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h1 id="垃圾回收算法有哪些？分别有什么优缺点-？"><a href="#垃圾回收算法有哪些？分别有什么优缺点-？" class="headerlink" title="垃圾回收算法有哪些？分别有什么优缺点  ？"></a>垃圾回收算法有哪些？分别有什么优缺点  ？</h1><p>垃圾回收算法主要有：</p>
<ol>
<li> 标记-清除（Mark-Sweep）</li>
<li> 复制（Copying）</li>
<li> 标记-整理（Mark-Compact）</li>
<li> 分代收集</li>
</ol>
<h2 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记-清除（Mark-Sweep）"></a>标记-清除（Mark-Sweep）</h2><p>先标记出内存中所有需要回收的对象，再统一回收所有被标记的对象。标记过程就是对象到GC Roots对象的可达性分析。</p>
<p>缺点：</p>
<ol>
<li>记和清除两个过程都不高效。</li>
<li>容易产生大量不连续的空间碎片，分配大对象的时候无法找到连续的内存空间时会再次触发垃圾回收。</li>
</ol>
<h2 id="复制（Copying）"><a href="#复制（Copying）" class="headerlink" title="复制（Copying）"></a>复制（Copying）</h2><p>将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完后，将还存活的对象复制到另外一块内存上，再把已使用过的那块内存一次清理掉。</p>
<p>优点：</p>
<ol>
<li> 每次对整半块的内存清理，实现简单</li>
<li> 内存分配时也没有内存碎片的问题，整体上更高效</li>
</ol>
<p>缺点：</p>
<ol>
<li> 有一半的内存空间闲置不用浪费了</li>
<li> 对象存活率较高时，就要进行较多的复制操作，效率降低</li>
</ol>
<h2 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记-整理（Mark-Compact）"></a>标记-整理（Mark-Compact）</h2><p>先标记出内存中所有存活的对象，再统一向内存的一端移动，最后直接清理掉边界以外的内存</p>
<p>优点：</p>
<ol>
<li> 不会产生不连续的内存碎片</li>
</ol>
<p>缺点：</p>
<ol>
<li> 标记和整理的速度较慢</li>
</ol>
<h2 id="分代收集（Generational-Collection）"><a href="#分代收集（Generational-Collection）" class="headerlink" title="分代收集（Generational Collection）"></a>分代收集（Generational Collection）</h2><p>根据对象的存活周期将堆内存划分为几块，这样可以针对不同的区域的特性使用最合适最高效的垃圾回收算法，一般把堆划分为新生代和老年代，默认新生代占堆的三分之一空间，老年代占堆的三分之二空间。</p>
<p>新生代又被划分为一块较大的Eden区域和两个较小的Survivor区域，每次使用Eden区和其中一个Survivor区。</p>
<p>在新生代中每次垃圾回收时都有大量的对象死去，只有少量对象存活，采用复制算法，当开始垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间，只要付出少量存活对象的复制成本就可以完成内存回收。在HotSpot虚拟机中Eden区和Survivor区大小比值默认为8:1，新生代只有10%的内存空间被浪费。当新生代空间不够时，需要老年代空间做分配担保，大对象直接存入老年代。</p>
<p>老年代中对象存活率高，必须使用标记清除或标记整理来进行回收。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824235449.png"></p>
<p>参考《深入理解Java虚拟机（第2版）》 3.3 垃圾收集算法</p>
<h1 id="分代收集有什么好处？"><a href="#分代收集有什么好处？" class="headerlink" title="分代收集有什么好处？"></a>分代收集有什么好处？</h1><p>对传统的、基本的GC实现来说，由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？<br>于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。</p>
<p>这个思路所基于的基本假设大家都很熟悉了：weak generational hypothesis——大部分对象的生命期很短（die young），而没有die young的对象则很可能会存活很长时间（live long）。</p>
<p>这是对过往的很多应用行为分析之后得出的一个假设。基于这个假设，如果让新创建的对象都在young gen里创建，然后频繁收集young gen，则大部分垃圾都能在young GC中被收集掉。由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/53613423/answer/135743258">java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎 </a></li>
</ul>
<h1 id="基于分代收集回收算法，堆上的内存分配策略是怎样的？"><a href="#基于分代收集回收算法，堆上的内存分配策略是怎样的？" class="headerlink" title="基于分代收集回收算法，堆上的内存分配策略是怎样的？"></a>基于分代收集回收算法，堆上的内存分配策略是怎样的？</h1><p>参考《深入理解Java虚拟机（第2版）》 3.6 内存分配与回收策略</p>
<h2 id="对象优先在新生代Eden区分配"><a href="#对象优先在新生代Eden区分配" class="headerlink" title="对象优先在新生代Eden区分配"></a>对象优先在新生代Eden区分配</h2><p>当Eden区没有足够的空间分配时，虚拟机发起一次Minor GC。</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>例如很长的字符串或很长的数组。</p>
<h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>每个对象都有一个年龄计数器，对象在Eden区出生，经过一次Minor GC仍然存活，并能被Survivor容纳，年龄就增加1岁，年龄增加到一定程度（默认为15），就会晋升到老年代。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>因为Eden区不足时会触发Minor GC，如果Minor GC后新生代空间仍然不足，需要老年代做分配担保，将存活的对象移动到老年代，如果老年代也没空间了，就要进行Full  GC了，清理整个堆（包括老年代和新生代）。</p>
<p>Minor  GC  前检查老年代剩余空间是否大于新生代所有对象的大小总和，如果大于，说明进行Minor  GC是安全的，因为最坏情况下新生代对象全部存活并且达到年龄上限，可以安全的移动到老年代；如果老年代剩余空间小于新生代所有对象大小总和，最坏情况下老年代容纳不了新生代所有对象，新的对象也没有办法分配在Eden区了，这个时候按道理就要触发Full  GC了，清理整个堆（包括老年代和新生代）。</p>
<h1 id="Minor-GC、Full-GC分别是什么？有什么区别？分别在什么时候触发？"><a href="#Minor-GC、Full-GC分别是什么？有什么区别？分别在什么时候触发？" class="headerlink" title="Minor  GC、Full GC分别是什么？有什么区别？分别在什么时候触发？"></a>Minor  GC、Full GC分别是什么？有什么区别？分别在什么时候触发？</h1><ul>
<li>Minor GC 回收新生代</li>
<li>Full GC 回收整个堆，包括新生代、老年代、元空间（Java8新增）</li>
</ul>
<p>Eden区不足时会触发Minor GC，如果Minor GC后新生代空间仍然不足，需要老年代做分配担保，将存活的对象移动到老年代，如果老年代也没空间了，就要进行Full  GC了，清理整个堆（包括老年代和新生代）。</p>
<p>如果一开始就能知道老年代空间不足，就不需要先Minor  GC再Full  GC，直接进行Full  GC更省事，所以Minor GC前会判断老年代剩余空间是否大于新生代所有对象大小总和，如果大于，最坏情况下新生代对象全部存活，全部放到老年代还是可以放得下的，如果小于，最坏情况下肯定是放不下，但也有可能经过Minor  GC后，剩余存活对象Survivor放不下但老年代可以放的下，这是不确定的，此时如果设置了允许分配担保失败，会检查老年代剩余空间是否大于历次新生代晋升到老年代的对象的平均总大小，如果大于说明Minor  GC应该是安全，这样也不会频繁触发Full GC，如果小于就直接进行Full GC了。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/41922036/answer/93079526">Major GC和Full GC的区别是什么？触发条件呢？ - RednaxelaFX的回答 - 知乎 </a></li>
<li>参考《深入理解Java虚拟机（第2版）》 3.6 内存分配与回收策略</li>
</ul>
<h1 id="JVM是如何避免Minor-GC时扫描全堆的？"><a href="#JVM是如何避免Minor-GC时扫描全堆的？" class="headerlink" title="JVM是如何避免Minor GC时扫描全堆的？"></a>JVM是如何避免Minor GC时扫描全堆的？</h1><p>垃圾回收时要判断哪些对象可以被回收，要做可达性分析，跟GC Root有引用关系的对象是存活对象，分析引用关系的时候，是不知道一个类被谁引用的，但是反过来可以知道一个类引用了别的什么类。</p>
<p>这就带来了一个问题，年轻代的Minor GC很频繁，做可达性分析的时候，如果有老年代的对象引用了年轻代的对象，为了找出这个引用关系，你得去扫描整个老年代，一个个检查老年代的对象是否对年轻代的对象有引用，这样效率太低了，扫描了全堆。</p>
<p>如果能记录下老年代有哪些类引用了年轻代类，那就不用扫描整个老年代了。这就是卡表（Card Table）的作用。</p>
<p>参考：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></p>
<h1 id="Minor-GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？"><a href="#Minor-GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？" class="headerlink" title="Minor GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？"></a>Minor GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？</h1><p>Minor GC时检查老年代中有没有引用新生代对象是通过检查卡表来完成的，老年代内存被划分为等长的卡页，每个卡页有一个编号，卡表中每一项代表某个卡页是否有对象引用新生代对象，这样Minor GC时就不用扫描整个老年代了，保证频繁进行Minor  GC不会占用太多CPU时间，提高了CPU的吞吐量。</p>
<p>虚拟机在对老年代中的对象更新引用时，会加入写屏障，暂时中断写操作，检查老年代的对象是否引用了新生代的对象，如果是的话，便更新CardTable，标记这一块卡页为脏。</p>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/post/5c39920b6fb9a049e82bbf94">JVM之卡表（Card Table）</a></li>
<li><a href="https://segmentfault.com/a/1190000004682407">jvm的card table数据结构</a></li>
</ul>
<hr>
<h1 id="卡表（CardTable）是什么？"><a href="#卡表（CardTable）是什么？" class="headerlink" title="卡表（CardTable）是什么？"></a>卡表（CardTable）是什么？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825001223.png"></p>
<p>讲老年代的空间划分为大小为512B的若干张卡。</p>
<p>卡表是单字节的数组，数组中每个元素对应着一张卡，当发生老年代对象引用新生代时，虚拟机将该卡对应的卡片元素设置为适当的值。之后Minor GC时通过扫描卡表就可以很快识别出哪些卡中存在老年代指向新生代的引用。用空间换时间，避免了全堆扫描。</p>
<p>参考：</p>
<ul>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
</ul>
<h1 id="System-gc-是什么使用场景？"><a href="#System-gc-是什么使用场景？" class="headerlink" title="System.gc()是什么使用场景？"></a>System.gc()是什么使用场景？</h1><p>调用此方法只会建议虚拟机进行垃圾回收，并不会强制执行垃圾回收。</p>
<p>由于频繁垃圾回收会导致频繁的线程暂停导致性能下降，因此应当尽量让虚拟机自动管理垃圾回收，对不用的对象置为null。</p>
<p>所以System.gc()可以当作不存在，需要测试垃圾回收时可能需要，平时不应当主动依赖这个方法做垃圾回收。</p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/66540/when-does-system-gc-do-something">When does System.gc() do something?</a></li>
<li><a href="https://blog.csdn.net/qq_36761831/article/details/81211540">Java中 System.gc() 调用垃圾收集器与 finalize() 函数</a></li>
</ul>
<h1 id="垃圾回收的性能瓶颈在哪"><a href="#垃圾回收的性能瓶颈在哪" class="headerlink" title="垃圾回收的性能瓶颈在哪"></a>垃圾回收的性能瓶颈在哪</h1><p>性能瓶颈在于需要暂停所有的线程，影响程序正常运行。</p>
<p>根据程序特性合理配置各个区域大小，减少垃圾回收触发次数，可以提高性能，因为每次垃圾回收都要暂停所有线程的工作。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《深入理解Java虚拟机（第2版）》第3章  垃圾回收器与内存分配策略</li>
<li><a href="https://www.zhihu.com/question/53613423/answer/135743258">java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎 </a></li>
<li><a href="https://www.cnblogs.com/zhxiansheng/p/11294529.html">新生代和老年代垃圾回收的细节
</a></li>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
        <tag>分代收集</tag>
        <tag>CardTable</tag>
        <tag>System.gc()</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Class结构</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%9A%84Class%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="如何方便的查看class结构？"><a href="#如何方便的查看class结构？" class="headerlink" title="如何方便的查看class结构？"></a>如何方便的查看class结构？</h1><ul>
<li><p>方法一<br>javap -verbose xxx.class</p>
</li>
<li><p>方法二<br>Intellij Idea装 jclasslib 插件<br>代码编译后在菜单栏”View”中选择”Show Bytecode With jclasslib”</p>
</li>
</ul>
<h1 id="Class文件的整体结构是怎样的"><a href="#Class文件的整体结构是怎样的" class="headerlink" title="Class文件的整体结构是怎样的?"></a>Class文件的整体结构是怎样的?</h1><p>JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210125335546.png"></p>
<p>class文件各数据项之间没有分隔符。</p>
<p>class文件采用类似于C语言的伪结构存储数据，这种伪结构只有两种数据类型：无符号数和表。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210125335542.png"></p>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》第6章  类文件结构</li>
</ul>
<h1 id="方法表的具体存储格式是怎样的？"><a href="#方法表的具体存储格式是怎样的？" class="headerlink" title="方法表的具体存储格式是怎样的？"></a>方法表的具体存储格式是怎样的？</h1><p>方法表也是由两部分组成：</p>
<ul>
<li>第一部分为两个字节描述方法的个数。</li>
<li>第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性。</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210125235546.png"></p>
<p>方法名索引、描述符索引，这两个的索引指的是在常量池中的索引，方法名和描述符都存储在class的常量池中，可以通过索引值在常量池中找到。</p>
<p>属性包括以下3个部分：</p>
<ol>
<li> “Code区”：源代码对应的JVM指令操作码，在进行字节码增强时重点操作的就是“Code区”这一部分。</li>
<li> “LineNumberTable”：行号表，将Code区的操作码和源代码中的行号对应，Debug时会起到作用（源代码走一行，需要走多少个JVM指令操作码）。 </li>
<li> “LocalVariableTable”：本地变量表，包含This和局部变量，之所以可以在每一个方法内部都可以调用This，是因为JVM将This作为每一个方法的第一个参数隐式进行传入。当然，这是针对非Static方法而言。</li>
</ol>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》第6章  类文件结构 6.3.6 方法表集合</li>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
</ul>
<h1 id="class文件结构一个具体的案例"><a href="#class文件结构一个具体的案例" class="headerlink" title="class文件结构一个具体的案例?"></a>class文件结构一个具体的案例?</h1><p>参考《深入理解Java虚拟机（第2版）》第6章 类文件结构 6.3.7 属性表集合 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile ~/Demo.class </span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">9</span>-<span class="number">30</span>; size <span class="number">338</span> bytes </span><br><span class="line">  MD5 checksum d2cf9d824e949e4dcc98ac47657cba67 </span><br><span class="line">  Compiled from <span class="string">&quot;Demo.java&quot;</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0 </span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52 </span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span> </span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>: </span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V </span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">19</span>         <span class="comment">// Demo.m:I </span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">20</span>            <span class="comment">// Demo </span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object </span></span><br><span class="line">   #<span class="number">5</span> = Utf8               m </span><br><span class="line">   #<span class="number">6</span> = Utf8               I </span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt; </span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V </span><br><span class="line">   #<span class="number">9</span> = Utf8               Code </span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable </span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable </span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="keyword">this</span> </span><br><span class="line">  #<span class="number">13</span> = Utf8               LDemo; </span><br><span class="line">  #<span class="number">14</span> = Utf8               inc </span><br><span class="line">  #<span class="number">15</span> = Utf8               ()I </span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile </span><br><span class="line">  #<span class="number">17</span> = Utf8               Demo.java </span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V </span></span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// m:I </span></span><br><span class="line">  #<span class="number">20</span> = Utf8               Demo </span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/Object </span><br><span class="line">&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>; </span><br><span class="line">    descriptor: ()V </span><br><span class="line">    flags: ACC_PUBLIC </span><br><span class="line">    Code: </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span> </span><br><span class="line">         <span class="number">0</span>: aload_0 </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span> </span><br><span class="line">      LineNumberTable: </span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span> </span><br><span class="line">      LocalVariableTable: </span><br><span class="line">        Start  Length  Slot  Name   Signature </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LDemo; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>; </span><br><span class="line">    descriptor: ()I </span><br><span class="line">    flags: ACC_PUBLIC </span><br><span class="line">    Code: </span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span> </span><br><span class="line">         <span class="number">0</span>: aload_0 </span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field m:I </span></span><br><span class="line">         <span class="number">4</span>: iconst_1 </span><br><span class="line">         <span class="number">5</span>: iadd </span><br><span class="line">         <span class="number">6</span>: ireturn </span><br><span class="line">      LineNumberTable: </span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span> </span><br><span class="line">      LocalVariableTable: </span><br><span class="line">        Start  Length  Slot  Name   Signature </span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   LDemo; </span><br><span class="line">&#125; </span><br><span class="line">SourceFile: <span class="string">&quot;Demo.java&quot;</span> </span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《深入理解Java虚拟机（第2版）》第6章  类文件结构</li>
<li><a href="https://www.cnblogs.com/webor2006/p/9459681.html">Java字节码方法表与属性表深度剖析</a></li>
<li><a href="https://www.cnblogs.com/webor2006/p/9459681.html">Java字节码方法表与属性表深度剖析</a></li>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Class结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器（ClassLoader）</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89/</url>
    <content><![CDATA[<h1 id="类加载器是干什么的"><a href="#类加载器是干什么的" class="headerlink" title="类加载器是干什么的?"></a>类加载器是干什么的?</h1><p>负责将class文件（Java编译后的字节码文件）读取到内存，并转换为java.lang.Class的一个实例。</p>
<h1 id="常见类加载器有哪些？分别是什么作用？"><a href="#常见类加载器有哪些？分别是什么作用？" class="headerlink" title="常见类加载器有哪些？分别是什么作用？"></a>常见类加载器有哪些？分别是什么作用？</h1><p>从虚拟机角度，分为启动类加载器和非启动类加载器。</p>
<ol>
<li> 启动类加载器（BootstrapClassLoader）是由C++实现，是虚拟机的一部分</li>
<li> 其他的类加载器，都是由Java实现，全部继承自ClassLoader。</li>
</ol>
<p>Java系统提供的类加载器主要有如下三种：</p>
<ol>
<li> BootstrapClassLoader（启动类加载器）：加载 ${JAVA_HOME}\lib 或 -Xbootclasspath指定的目录下的类。</li>
<li> ExtClassLoader（扩展类加载器）：加载${JAVA_HOME}\lib\ext或环境变量java.ext.dir指定目录的类。</li>
<li> AppClassLoader（应用程序类加载器）：加载用户项目指定的classpath里的类，可通过ClassLoader的getSystemClassLoader()方法获得，所以也会称为系统类加载器。</li>
</ol>
<h1 id="如何确定类的唯一性？"><a href="#如何确定类的唯一性？" class="headerlink" title="如何确定类的唯一性？"></a>如何确定类的唯一性？</h1><p>问题等同于：如何判断两个类是否是同一个类？</p>
<p>对于任何一个类，由类加载器和类本身确立其在虚拟机中的唯一性。</p>
<ul>
<li>首先类本身信息要相同，如类的全限定名。</li>
<li>其次必须是同一个类加载器加载的。</li>
</ul>
<p>相同的类，被不同的类加载器加载，会被视为不同的类。</p>
<p>为什么要这样设计？</p>
<p>涉及到安全性问题，要配合双亲委派模型的机制来解释。</p>
<h1 id="双亲委派（Parents-Delegation）模型是什么"><a href="#双亲委派（Parents-Delegation）模型是什么" class="headerlink" title="双亲委派（Parents Delegation）模型是什么?"></a>双亲委派（Parents Delegation）模型是什么?</h1><p>直接看ClassLoader的loadClass()方法的源码就很直白。</p>
<ul>
<li>除了启动类加载器，其他每个类加载器都有一个父类加载器（在ClassLoader源码中体现为类型为ClassLoader的parent成员变量，是组合关系而非继承关系）。</li>
<li>加载类时（ClassLoader的loadClass方法）会先通过父类加载器加载类，层层传递到顶层的启动类加载器（parent为null就通过native方法调用启动类加载器加载类）。</li>
<li>只有当父类加载器无法加载类，才会用当前的类加载器尝试加载类。</li>
</ul>
<p>这个逻辑是Java设计者推荐的加载方式，并不是强制约束，开发者可以自定义类加载器复写loadClass()方法来改变这一流程。</p>
<h1 id="双亲委派解决了什么问题？为何要这样设计？"><a href="#双亲委派解决了什么问题？为何要这样设计？" class="headerlink" title="双亲委派解决了什么问题？为何要这样设计？"></a>双亲委派解决了什么问题？为何要这样设计？</h1><p>是为了基础核心类加载的安全性考虑。</p>
<p>像<code>java.lang.Object</code>这种系统是存放在rt.jar中的，无论哪个类加载器要加载这个类，都会委派启动类加载器加载Object，这样可以保证在各种环境下，加载出的Object都是<code>&lt;JAVA_HOME&gt;\lib\rt.jar</code>的。</p>
<p>如果没有双亲委派机制，用户自己也定义了一个<code>java.lang.Object</code>，写了有问题的代码，放在用户项目的Classpath，那就会影响所有类的基础行为，因为Object是所有类的父类。所以也会要求不同的类加载器加载同一个类属于不同的类。</p>
<p>双亲委派模型很好的解决了各个类加载器的基础类统一问题，越基础越公共的类越是由上层的类加载器加载。同时保证了基础类的不会被随意的篡改，保证安全感。</p>
<h1 id="双亲委派会有哪些无法解决的问题？应该怎么解决？"><a href="#双亲委派会有哪些无法解决的问题？应该怎么解决？" class="headerlink" title="双亲委派会有哪些无法解决的问题？应该怎么解决？"></a>双亲委派会有哪些无法解决的问题？应该怎么解决？</h1><p>当基础类是接口，需要加载不同的接口实现类，实现类并不在当前类加载器管控的类的范围里，双亲委派的类加载顺序就要反过来，由父类加载器去请求子类加载器加载接口实现类。</p>
<p>典型的场景是SPI(Service Provider Interface)依赖注入框架。</p>
<p>SPI约定为：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p>
<p>SPI的核心类ServiceLoader是jdk的类，位于rt.jar中，由BootstrapClassLoader加载，接口实现类肯定是不能由BootstrapClassLoader加载，BootstrapClassLoader只加载jdk核心类，只能由AppClassLoader或用户自定义的ClassLoader来加载，按照双亲委派机制的话，这样就无法完成了，只能逆向请求加载。</p>
<p>解决之道就是使用<strong>线程上下文加载器（ContextClassLoader）</strong>，SPI在加载服务接口实现类时，调用Thread的getContextClassLoader()来加载实现类，可以通过Thread的setContextClassLoader(ClassLoader cl)方法来设置线程上下文类加载器，如果没有手动设置过，默认会继承父线程的上下文类加载器，如果父线程也没有设置过，则默认采用AppClassLoader</p>
<p>ServiceLoader.load()方法中要去加载实现类，需要用一个ClassLoader来加载，但是ServiceLoader是系统类，获取到的ClassLoader是BootstrapClassLoader，所以需要从一个地方获取实现类所处位置的ClassLoader，通过Thread的contextClassLoader就可以实现这个效果。</p>
<h1 id="一个类加载器明明只有一个parent，Parents-Delegation为什么被翻译为双亲委派？"><a href="#一个类加载器明明只有一个parent，Parents-Delegation为什么被翻译为双亲委派？" class="headerlink" title="一个类加载器明明只有一个parent，Parents Delegation为什么被翻译为双亲委派？"></a>一个类加载器明明只有一个parent，Parents Delegation为什么被翻译为双亲委派？</h1><p>翻译错误，以讹传讹。</p>
<p>由于除了启动类加载器其他类加载器都有parent，也就是每个非启动类加载器都有多个祖先，所以应该翻译为祖先委派更妥当</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/288949359/answer/468524259">Java 中的双亲委派的“双”怎么理解 ？ - 大宽宽的回答 - 知乎 </a></li>
</ul>
<h1 id="Class-forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？"><a href="#Class-forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？" class="headerlink" title="Class.forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？"></a>Class.forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？</h1><p>ClassLoader在loadClass后仅将字节码加载到内存，不会对类进行初始化。</p>
<p>Class.forName()在加载类到内存后后，会对类进行初始化，即执行类的static代码块和static变量的赋值，也可以传参控制不初始化。底层也是用ClassLoader来loadClass的。</p>
<p>Class.forName()用的调用者类的类加载器加载类，也可以手动传递classLoader参数</p>
<p>如果期望一个类加载后要执行static代码块做初始化操作，应该使用Class.forName()，如jdbc里的初始化。</p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/8100376/class-forname-vs-classloader-loadclass-which-to-use-for-dynamic-loading">Class.forName() vs ClassLoader.loadClass() - which to use for dynamic loading? </a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/javazejian/article/details/73413292">深入理解Java类加载器(ClassLoader)</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
        <tag>ClassLoader</tag>
        <tag>双亲委派</tag>
        <tag>ContextClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载流程</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h1><p>类从被加载到虚拟机内存，到卸载出内存为止，常规的生命周期如下：</p>
<ol>
<li> 加载（Loading）</li>
<li> 链接（Linking）</li>
<li> 初始化（Initialization）</li>
<li> 使用（Using）</li>
<li> 卸载（Unloading）</li>
</ol>
<p>其中链接（Linking）又可以分为：</p>
<ol>
<li> 验证（Verification）</li>
<li> 准备（Preparation）</li>
<li> 解析（Resolution）</li>
</ol>
<p>加载、验证、准备、初始化，这几个顺序是确定的，解析某些情况下发生在初始化之后，这是为了支持Java语言的运行时绑定（动态绑定）。</p>
<p>参考</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》7.3节  类加载的过程</li>
</ul>
<h1 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h1><p>加载:</p>
<ol>
<li> 通过类的全限定名来获取类的二进制字节流。</li>
<li> 将字节流代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li> 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>第1条，通过类的全限定名来获取类的二进制字节流，jvm没有限制具体的实现，历史上的典型实现有：</p>
<ol>
<li> 从zip包中读取，如jar。</li>
<li> 从网络中获取。</li>
<li> 运行时动态生成，如动态代理，在java.lang.reflect.Proxy中用了ProxyGenerator.generateProxyClass为特定接口生成形式。为“*$Proxy”的代理类二进制字节流。</li>
<li> 从其他文件生成，如由文件生成class。</li>
<li> 通过数据库读取。</li>
</ol>
<p>非数组类加载类中获取类的二进制字节流的动作自定义性最强，既可以用系统提供的引导类加载器完成，也可以用用户自定义类加载器完成，开发者可以自定义一个ClassLoader并重写findClass方法来控制字节流的获取。</p>
<p>数组类的加载由虚拟机直接创建。<br>数组元素类是基本类型，虚拟机会把数组类标记为与BootstrapClassLoader关联。</p>
<h1 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h1><h2 id="类加载后为什么需要验证？"><a href="#类加载后为什么需要验证？" class="headerlink" title="类加载后为什么需要验证？"></a>类加载后为什么需要验证？</h2><p>由于类加载过程不要求class一定从Java源代码编译而来，可以通过任何途径产生，在字节码可以做到Java语法层面做不到的事情，也有可能不符合正常的Java语法规范，所以如果不对class字节流进行验证，可能会使系统遭受攻击。</p>
<h2 id="类的验证过程是怎样的？"><a href="#类的验证过程是怎样的？" class="headerlink" title="类的验证过程是怎样的？"></a>类的验证过程是怎样的？</h2><p>大致会完成以下验证动作：</p>
<ol>
<li> 文件格式验证</li>
<li> 元数据验证</li>
<li> 字节码验证</li>
<li> 符号引用验证</li>
</ol>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>例如：</p>
<ol>
<li> 是否以magic number 0xCAFEBABE开头</li>
<li> 主次版本号是否在当前虚拟机处理范围</li>
<li> 常量池中的常量是否有不被支持的的常量类型</li>
</ol>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>是对字节码描述的元数据信息进行语义分析，保证元数据信息符合Java语言规范，如：</p>
<ol>
<li> 这个类是否有父类。</li>
<li> 这个类是否继承了不允许被继承的类（被final关键字修饰的类）。</li>
<li> 如果这个类不是抽象类，是否实现了父类或接口之中的要求实现的方法。</li>
</ol>
<h4 id="类的元数据指什么？"><a href="#类的元数据指什么？" class="headerlink" title="类的元数据指什么？"></a>类的元数据指什么？</h4><p>一个class文件中的信息分为代码和元数据两部分，其中代码是指方法体里的java代码，在class文件中表现为Code属性，其他所有数据项都用于描述元数据，包括类、字段、方法定义等。</p>
<p>参考《深入理解Java虚拟机（第2版）》183页 6.3.7 属性表集合</p>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>对方法体做校验分析，通过数据流和控制流分析，确定程序语义是否是合法的、符合逻辑的，如：</p>
<ol>
<li> 保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li> 保证方法体内类型转换是有效的。</li>
</ol>
<p>通过了字节码验证，也无法保证程序就是没有错误的，无法通过程序准确的检查出代码是否在有限的时间内结束运行，即离散数学中的Halting Problem。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20081359/answer/162329455">如何通俗地解释停机问题（Halting Problem）？ - 张皓的回答 - 知乎</a></li>
</ul>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>发生在虚拟机将符号转为直接引用的时候，这个动作将在连接的第三个阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，内容如根据名能否找到类、方法字段等。</p>
<p>这阶段目的是确保解析动作的正常执行，如果无法通过符号验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethdError等。</p>
<h1 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h1><p>类的准备阶段会完成：</p>
<ol>
<li> 为类的静态变量分配内存</li>
<li> 设置变量初始值</li>
</ol>
<p>如果是常量，则编译时存放进引用其的class的常量池中，加载时存入方法区的运行时常量池。</p>
<p>类变量是指static修饰过的变量。</p>
<p>在类变量未被final修饰时，变量的初始值是数据类型的零值。</p>
<p>例如 public static int value = 123; 语句，在准备阶段赋值是0（int类型的零值）而不是123。</p>
<h1 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h1><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用（Symbolic References）<br>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li>
<li>直接引用（Direct References）<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在内存地址中。</li>
</ul>
<p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。  </p>
<p>在Java语言中符合“编译器可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们都不可能通过继承而别的方式重写其他版本，因此他们都适合在类加载阶段进行解析。<br>与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。</p>
<ul>
<li>  invokestatic：调用静态方法。</li>
<li>  invokespecial：调用实例构造器<init>方法、私有方法和父类方法。</li>
<li>  invokevirtual：调用所有的虚方法。</li>
<li>  invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li>  invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，他们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法。</p>
<p>方法调用并不等于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本(即调用哪一方法)，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作。Class文件的编译过程不包含编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h1 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h1><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 代码。</p>
<p>在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则根据程序员自己设置的变量赋值。初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。</p>
<h2 id="lt-clinit-gt-方法生成的细节"><a href="#lt-clinit-gt-方法生成的细节" class="headerlink" title="&lt;clinit&gt;() 方法生成的细节"></a><code>&lt;clinit&gt;()</code> 方法生成的细节</h2><ul>
<li><code>&lt;clinit&gt;()</code>  方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的前后顺序决定的，静态语句块中只能访问定义在它之前的变量，定义在它后面的变量，可以赋值，但是不能访问。</li>
<li><code>&lt;clinit&gt;()</code> 方法与类的构造函数 <code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code> 方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code> 方法肯定是 Object 的。</li>
<li><code>&lt;clinit&gt;()</code>方法对类或接口来说不是必需的，如果一个类中没有静态语句块也没有对变量赋值的操作，那么编译器不为这个类生成<code>&lt;clinit&gt;()</code> 方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，接口不需要首先执行父类的<code>&lt;clinit&gt;()</code> 方法。只有当用到父类中的变量时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code> 方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code> 方法在多线程中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code> 方法，其它线程被阻塞。</li>
</ul>
<p>另外就是在同一个类加载器下，<code>&lt;clinit&gt;()</code> 方法只会被执行一次，也就是说一个类型只会被初始化一次。</p>
<h2 id="类什么情况下会触发初始化"><a href="#类什么情况下会触发初始化" class="headerlink" title="类什么情况下会触发初始化?"></a>类什么情况下会触发初始化?</h2><p>以下五种情况必须对类进行初始化（加载、验证、准备自然必须在初始化之前完成）：</p>
<ol>
<li> 遇到new、putstatic、getstatic、invokestatic这几条字节指令；生成这 4 条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入到常量池的静态字段除外）以及调用一个类的静态方法的时候。</li>
<li> 被final修饰的静态字段在编译期已经被把结果存入从常量池了，会触发static的指令吗，需要调研试验一下。</li>
<li> 通过Class.forName反射调用一个类，参数中初始化选项默认为true。</li>
<li> 初始化一个类，要先触发父类的初始化；初始化一个接口时只有在真正使用到父接口的时候（如引用接口中定义的常量）才初始化。</li>
<li> 虚拟机启动时，会先初始化主类，即含有main方法的类。</li>
<li>使用jdk7的动态语言机制时，一个MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，需要初始化这些方法句柄对应的类。</li>
</ol>
<h2 id="不会触发类初始化的典型场景"><a href="#不会触发类初始化的典型场景" class="headerlink" title="不会触发类初始化的典型场景"></a>不会触发类初始化的典型场景</h2><ol>
<li> 调用父类的静态成员变量，只会执行父类的static代码块，不会执行子类的static代码块，即子类没有初始化。</li>
<li> 创建一个类的数组，不会触发数组元素类初始化（元素类的static代码块不会执行）。</li>
<li> A类只引用了B类中定义的常量（static final定义的基本类型字面量或字符串字面量的属性），不会触发该B类的初始化，因为在编译阶段通过常量池传播优化，已经将B类的常量值存储到了A类常量池中，以后A类对B类中常量的引用都转换为对A类自身常量池中的引用。</li>
</ol>
<h1 id="卸载（Unloading）"><a href="#卸载（Unloading）" class="headerlink" title="卸载（Unloading）"></a>卸载（Unloading）</h1><h2 id="类卸载时机"><a href="#类卸载时机" class="headerlink" title="类卸载时机"></a>类卸载时机</h2><p>类的卸载就从虚拟机中移除类，这个由虚拟机的垃圾回收机制决定，一般要满足下面的条件：</p>
<ol>
<li> 该类所有的实例对象都已被回收。</li>
<li> 该类的类加载器对象已被回收。</li>
<li> 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《深入理解Java虚拟机（第2版）》第7章  虚拟机类加载机制</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载流程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行时内存结构</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Java运行时数据区域有哪些？"><a href="#Java运行时数据区域有哪些？" class="headerlink" title="Java运行时数据区域有哪些？"></a>Java运行时数据区域有哪些？</h1><ol>
<li> 程序计数器</li>
<li> 虚拟机栈</li>
<li> 本地方法栈</li>
<li> 方法区</li>
<li> 堆</li>
</ol>
<p>其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的，方法区和堆是线程间共享的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824234546.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20200325265523.png"></p>
<h1 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h1><p>可以看作是当前线程所执行的字节码的行号指示器。</p>
<h2 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h2><ol>
<li> 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li> 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<h2 id="为什么必须每个线程都要单独弄一个程序计数器？"><a href="#为什么必须每个线程都要单独弄一个程序计数器？" class="headerlink" title="为什么必须每个线程都要单独弄一个程序计数器？"></a>为什么必须每个线程都要单独弄一个程序计数器？</h2><p>因为多线程是通过轮流切换占用CPU时间片来实现的，线程数量大于CPU数量时，就会有线程处于等待状态，等到可以占用CPU时间片了，会恢复线程的执行，这时就必须要回到线程等待前的指令执行位置，以便接下来继续执行后面的指令，每个线程运行的指令又不一样，所以必须对每个线程都要保存当前执行的指令位置。</p>
<h1 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h1><p>虚拟机栈对应Java中的方法执行的内存模型。</p>
<p>栈中的每个元素称为栈帧，每个方法执行的时候都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从开始执行到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824234622.png"></p>
<h2 id="局部变量表（Local-Variable-Table）"><a href="#局部变量表（Local-Variable-Table）" class="headerlink" title="局部变量表（Local Variable Table）"></a>局部变量表（Local Variable Table）</h2><p>存放方法参数和方法内的局部变量。</p>
<p>局部变量表中存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型，可能指向一个对象的起始地址的指针，也可能是指向一个对象的句柄）和returnAddress类型（指向一条字节码指令的地址）</p>
<p>局部变量表的基本存储单位是变量槽（Variable Slot），每个槽的大小是4个字节，64位的long和double会占用局部变量表的两个槽位（slot），其余数据类型占用一个槽位。</p>
<p>局部变量表所需的内存空间在编译阶段完全确定，因为数据类型的大小是确定的，方法运行期间不会改变局部变量表的大小。字节码中方法的Code属性的max_locals数据项中确定了需要分配的局部变量表的最大容量，在编译时写入。</p>
<p>局部变量表存储顺序：变量表从索引0开始，依次存放方法所属的对象引用（如果为静态方法则没有）、方法参数变量（按照顺序声明）、方法内局部变量（按照顺序声明）。对于byte、short、char这三种数据类型需要转换为int类型存储在局部变量表中。</p>
<p>一个代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IntegerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        Integer c = 3;</span><br><span class="line">        Integer d = 3;</span><br><span class="line">        Integer e = 321;</span><br><span class="line">        Integer f = 321;</span><br><span class="line">        Long g = 3L;</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == a + b);</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalVariableTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">      0     183     0  args   [Ljava/lang/String;</span><br><span class="line">      5     178     1     a   Ljava/lang/Integer;</span><br><span class="line">     10     173     2     b   Ljava/lang/Integer;</span><br><span class="line">     15     168     3     c   Ljava/lang/Integer;</span><br><span class="line">     21     162     4     d   Ljava/lang/Integer;</span><br><span class="line">     29     154     5     e   Ljava/lang/Integer;</span><br><span class="line">     37     146     6     f   Ljava/lang/Integer;</span><br><span class="line">     45     138     7     g   Ljava/lang/Long;</span><br></pre></td></tr></table></figure>

<h3 id="没有局部变量表会怎么样？"><a href="#没有局部变量表会怎么样？" class="headerlink" title="没有局部变量表会怎么样？"></a>没有局部变量表会怎么样？</h3><p>参考《深入理解Java虚拟机（第2版）》190页 6.3.7 属性表集合。</p>
<blockquote>
<p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间关系。<br>注：LocalVariableTable属性不是必须的，在javac编译时，可通过-g：none或-h：vars来取消或关闭这项信息。如果没有生成这项信息，最大的影响就是当别人引用这个方法时，所有的参数名称都将失去，IDE将会使用诸如arg0、arg1之类的占位符来代替原有的参数名，这对程序没什么影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获取参数值。</p>
</blockquote>
<h2 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h2><p>用于保存计算过程中的中间结果，作为计算的临时数据存储区。</p>
<p>大多数指令都要从这里弹出数据，执行运算后将结果再压回操作数栈。</p>
<p>操作数栈最大深度在编译时也是写入到字节码中方法的Code属性的max_stacks数据项中。</p>
<p>操作数栈的基本单位是4个字节，32位数据类型占用一个单位，64位数据类型占用两个单位，对于byte、short、char这三种数据类型需要转换为int类型再存入栈中。</p>
<p><a href="https://www.jianshu.com/p/0333144544e2">操作数栈的特点</a></p>
<p>java的指令是基于栈的指令集架构（Instruction Set Architecture，ISA），指令流中的指令大部分都是零地址指令，指令依赖操作数栈进行工作。</p>
<p>另外一种常用的指令集架构是基于寄存器的指令集。</p>
<p>基于栈的指令集  优点（反过来就是  基于寄存器的指令集  缺点）：</p>
<ol>
<li> 可移植性强，直接依赖硬件寄存器将会受到硬件条件的约束</li>
<li> 代码相对紧凑，因为指令没有操作数</li>
<li> 编译器实现更简单，因为不用考虑空间分配，栈大小固定，编译时可知</li>
</ol>
<p>基于栈的指令集  缺点（反过来就是  基于寄存器的指令集  优点）：</p>
<ol>
<li> 速度稍慢，因为栈实现在内存中，频繁访问栈意味着频繁访问内存，访问内存是比访问寄存器慢很多的</li>
<li> 指令数量多，因为访问数据频繁，入栈和出栈这两个指令就很多</li>
</ol>
<p>参考《深入理解Java虚拟机（第2版）》270页 8.4.2 <a href="https://www.jianshu.com/p/20c2b6f5fe59">基于栈的指令集与基于寄存器的指令集</a>。</p>
<h2 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h2><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p>
<p>Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>
<p>动态连接是一个将符号引用解析为直接引用的过程。当java虚拟机执行字节码时，如果它遇到一个操作码，这个操作码第一次使用一个指向另一个类的符号引用，那么虚拟机就必须解析这个符号引用。<br>在解析时，虚拟机执行两个基本任务：</p>
<ol>
<li>查找被引用的类（如果必要的话就装载它）。</li>
<li>将符号引用替换为直接引用，这样当它以后再次遇到相同的引用时，它就可以立即使用这个直接引用，而不必花时间再次解析这个符号引用了。</li>
</ol>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》8.2.3 动态链接</li>
</ul>
<h2 id="方法返回地址（Return-Address）"><a href="#方法返回地址（Return-Address）" class="headerlink" title="方法返回地址（Return Address）"></a>方法返回地址（Return Address）</h2><p>方法退出的过程实际上等同于把当前栈帧出栈。</p>
<p>因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令</p>
<p>参考《深入理解Java虚拟机（第2版）》 8.2.4 方法返回地址</p>
<h2 id="虚拟机栈会有什么潜在的问题？"><a href="#虚拟机栈会有什么潜在的问题？" class="headerlink" title="虚拟机栈会有什么潜在的问题？"></a>虚拟机栈会有什么潜在的问题？</h2><ul>
<li>某个线程中方法嵌套执行的太多了，超过虚拟机栈允许的最大深度，将会抛出StackOverflow（栈溢出）异常。<ul>
<li>一个典型的场景是递归方法，递归深度过大，会引起栈溢出，某些语言下可以采用尾递归优化。</li>
</ul>
</li>
<li>当线程不断增多，不停的申请虚拟机栈，内存可能不够用了，会引发OutOfMemoryError异常，即内存溢出。<ul>
<li>一个典型的场景是，程序中的同时运行的线程不停的增多。</li>
</ul>
</li>
</ul>
<h1 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h1><p>虚拟机栈对应的是java方法的执行过程，本地方法栈对应native方法的执行过程。</p>
<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p>创建一个对象实例便存储在堆，所有线程共享。</p>
<p>物理上可以不连续，逻辑上是连续的即可。</p>
<p>是虚拟机管理的内存区域最大的一块，是虚拟机垃圾回收的主要区域。</p>
<p>现代垃圾回收收集器基本都采用分代回收，堆被划分为新生代和老年代，新生代又分为Eden区、From Survivor区、To Survivor区。划分特定区域是为了更高效的进行垃圾回收。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824235449.png"></p>
<h2 id="对象都是在堆上分配的吗？"><a href="#对象都是在堆上分配的吗？" class="headerlink" title="对象都是在堆上分配的吗？"></a>对象都是在堆上分配的吗？</h2><p>创建新对象实例也可能分配在TLAB和栈上。</p>
<p>对象不在堆上分配主要的原因还是堆是共享的，在堆上分配有锁的开销。无论是TLAB还是栈都是线程私有的，私有即避免了竞争（当然也可能产生额外的问题例如可见性问题），这是典型的用空间换效率的做法。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/yangzl2008/java/article/details/43202969">Java中的逃逸分析和TLAB以及Java对象分配</a></li>
<li><a href="https://hesey.wang/2011/07/object-allocation-on-non-heap.html">对象都是在堆上分配的吗</a></li>
</ul>
<h1 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h1><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>各线程共享的区域。</p>
<h2 id="方法区里的东西放在堆里不行吗？"><a href="#方法区里的东西放在堆里不行吗？" class="headerlink" title="方法区里的东西放在堆里不行吗？"></a>方法区里的东西放在堆里不行吗？</h2><p>因为方法区存储的类信息、常量等数据都是生命周期比较长的，要放在堆，也只能放在老年代，但可能生命周期比老年代的对象还要长。</p>
<p>故而单独开辟一个空间，单独管理，提高垃圾回收的效率。</p>
<h2 id="方法区什么时候垃圾回收？"><a href="#方法区什么时候垃圾回收？" class="headerlink" title="方法区什么时候垃圾回收？"></a>方法区什么时候垃圾回收？</h2><p>回收废弃常量和无用的类。</p>
<p>无用类三条判断方法：</p>
<ol>
<li> 堆中没有该类的实例</li>
<li> 该类的类加载器已被回收</li>
<li> 没有任何地方引用Class对象，也没有反射调用</li>
</ol>
<p>这也是类卸载的判断。</p>
<p>参考《深入理解Java虚拟机》3.2.5 回收方法区 68页。</p>
<p>大量使用反射，动态代理，cglib等字节码框架都需要类卸载机制，保证方法区不溢出。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>《深入理解 Java 虚拟机 第三版》2.2.7 小节 关于 Java 直接内存的描述。</p>
<blockquote>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。  </p>
<p>在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。  </p>
<p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 <code>-Xmx</code> 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>内存结构</tag>
        <tag>程序计数器</tag>
        <tag>虚拟机栈</tag>
        <tag>局部变量表</tag>
        <tag>操作数栈</tag>
        <tag>方法区</tag>
        <tag>内存堆</tag>
        <tag>直接内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java静态分派、动态分派</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</url>
    <content><![CDATA[<p>静态类型：变量被声明时的类型；例如，Animal a = new Dog(), 静态类型为Animal, 实际类型为Dog</p>
<p>实际类型：变量所引用的对象的真实类型</p>
<p>重载方法是静态分派，即编译时多态</p>
<p>重写方法是动态分派，即运行时多态</p>
<h1 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h1><p>方法的接收者：一个方法所属的对象</p>
<p>宗量：方法的接收者和方法的参数，只有这两种宗量</p>
<p>单分派：根据一个宗量进行对方法的选择</p>
<p>多分派：根据多于一个的宗量对方法进行选择</p>
<p>单分派和多分派取决于宗量,  方法调用者和方法参数都是宗量.</p>
<p>静态分派的方法调用：首先确定调用者的静态类型是什么,然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个, 需要根据这两个宗量来编译, 所以是静态多分派(多个宗量确定).</p>
<p>动态分派的方法调用：在运行期间,虚拟机会根据调用者的实际类型调用对应的方法, 只需根据这一个宗量就可以确定要调用的方法,所以是动态单分派(一个宗量)</p>
<p>到目前为止，Java 语言还是一门 “静态多分派、动态单分派” 的语言，也就是说在执行静态分派时是根据多个宗量判断调用哪个方法的，因为在静态分派时要根据不同的静态类型和不同的方法描述符选择目标方法，在动态分派的时候，是根据单宗量选择目标方法的，因为在运行期，方法的描述符已经确定好，invokevirtual 字节码指令根据变量的实际类型选择目标方法。</p>
<p>方法的描述符：方法参数类型+返回值类型</p>
<h1 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h1> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classStaticDispatch &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Humanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Manguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,man&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Womanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,woman&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123; </span><br><span class="line">        Humanman=newMan(); </span><br><span class="line">        Humanwoman=newWoman(); </span><br><span class="line">        StaticDispatchdispatch=newStaticDispatch(); </span><br><span class="line">        dispatch.sayHello(man); </span><br><span class="line">        dispatch.sayHello(woman); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>静态类型：是指对象 man 的 Human 类型， 静态类型本身是不会发送变化的，只有在使用时才会发送变化，静态类型在编译期间就可以确定一个变量的静态类型 </p>
<p>实际类型：是指对象 man 的 Man 类型，实际类型在编译期间是不可确定的，只有在运行期才可确定 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化 </span></span><br><span class="line">Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">man = <span class="keyword">new</span> Woman(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态类型变化 </span></span><br><span class="line">dispatch.sayHello((Man) man); </span><br><span class="line">dispatch.sayHello((Woman) man); </span><br></pre></td></tr></table></figure>

<p>所以第一段代码中，方法接收者是 StaticDispatch 对象，虽然两个变量的实际类型不同，但是静态类型是相同的都是 Human，虚拟机（准确的说是编译器）在实现重载时是通过参数的静态类型而不是实际类型做出判定的，并且在编译阶段，变量的静态类型是可以确定的，所以编译器会根据变量的静态类型决定使用哪个重载方法。 </p>
<p>所有依赖静态类型定位目标方法的分派动作称为静态分派，静态分派典型的应用就是方法的重载。静态分派发生在编译阶段，所以方法的静态分派动作是由编译器执行的。 </p>
<h1 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, man&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, woman&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/picportal/pic/raw/master/img/20200325235523.png"></p>
<p>从上图中，我们可以看到 main() 方法的字节码指令执行过程：</p>
<ul>
<li>0 ~ 7 句是调用 Man 类的实例构造器创建一个 Man 类的对象，并将对象的引用压入到局部变量表的第 1 个 Slot 中</li>
<li>8 ~ 15 句是调用 Woman 类的实例构造器创建一个 Woman 类的对象，并将对象的引用压入到局部变量表的第 2 个 Slot 中</li>
<li>16 ~ 17 句是将第 1 个 Slot 中的变量（也就是 man）加载到局部变量表中，并调用 sayHello() 方法，关键的就是第 17 句指令 invokevirtual</li>
</ul>
<p>虽然第 17 句指令调用的常量池中的 Human.sayHello() 方法，但是最终执行的却是 Man.sayHello() 方法，这就要从 invokevirtual 指令的多态查找说起，invokevirtual 的查找过程如下所示：</p>
<ul>
<li>找到操作数栈顶的引用所指的对象的实际类型，记做 C</li>
<li>在类型 C 中查找与常量中的描述符和简单名称相同的方法，如果找到则进行访问权限的判断，如果通过则返回这个方法的直接引用，查找结束；如果权限不通过，则返回 java.lang.IllegalAccessError 的异常</li>
<li>如果在 C 中没有找到描述符和简单名称都符合的方法，则按照继承关系从下往上依次在 C 的父类中进行查找和验证过程</li>
<li>如果最终还是没有找到该方法，则抛出 java.lang.AbstractMethodError 的异常</li>
</ul>
<p>在上述 invokespecial 查找方法的过程中，最重要的就是第一步，根据对象的引用确定对象的实际类型，这个方法重写的本质。如上所述，在运行期内，根据对象的实际类型确定方法执行版本的分派过程叫做动态分派。</p>
<h1 id="如何理解Java是静态多分派、动态单分派？"><a href="#如何理解Java是静态多分派、动态单分派？" class="headerlink" title="如何理解Java是静态多分派、动态单分派？"></a>如何理解Java是静态多分派、动态单分派？</h1><p>编译时期确定方法有两点依据：</p>
<ol>
<li>调用方法的静态类型</li>
<li>方法的参数</li>
</ol>
<p>所以说是静态多分派。</p>
<p>运行时期再确定方法只有一点依据,就是调用方法的实际类型,所以说是动态单分派。</p>
<p>所以最后实际的方法调用是编译和运行的结合,即调用方法的实际类型和参数(运行时期直接引用会根据调用方法的实际类型确定,编译时期调用方法的静态类型只不过是虚引用),按书上说法,在编译时期,方法名和参数就被确定了,运行时只需要确定调用者即可;所以方法选择上,编译时期缩小了范围,运行时期确定了具体的方法。</p>
<p>对于静态分派（重载），肯定会依赖接收者的静态类型与参数的静态类型（参数肯定存在，同名无参的方法只会有一个，不存在分派）。</p>
<p>对于动态分派（重写），虚拟机只会根据接收者的实际类型选择，而不会理睬参数的实际类型。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li>深入理解Java虚拟机（第2版）  第8章  虚拟机字节码执行引擎 8.3.2 分派</li>
<li><a href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎（读书笔记）</a></li>
<li><a href="https://www.zhihu.com/question/28462483/answer/398040520">如何理解java是一门静态多分派且动态单分派的语言？</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>静态分派</tag>
        <tag>动态分派</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.finalize()</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Object.finalize()/</url>
    <content><![CDATA[<h1 id="Object的finalize-方法什么时候被执行？"><a href="#Object的finalize-方法什么时候被执行？" class="headerlink" title="Object的finalize()方法什么时候被执行？"></a>Object的finalize()方法什么时候被执行？</h1><p>当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：</p>
<p>如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记。</p>
<p>GC会再判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。</p>
<p>如果对象覆盖finalize()方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalize()方法，但不承诺等待其运行结束。</p>
<p>执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<h1 id="Object-finalize-设计目的？"><a href="#Object-finalize-设计目的？" class="headerlink" title="Object.finalize()设计目的？"></a>Object.finalize()设计目的？</h1><p>f对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。</p>
<h1 id="Object-finalize-使用场景"><a href="#Object-finalize-使用场景" class="headerlink" title="Object.finalize()使用场景"></a>Object.finalize()使用场景</h1><p>由于发生垃圾回收就会调用finalize()，所以它可以作为垃圾回收的监听回调。</p>
<p>在Android framework源码中BinderInternal实现了gc监听的功能，ActivityThread在gc发生时，如果当前内存不足时，则清理一些不必要的activity以释放内存。</p>
<p>再比如你调用了一些native的方法，可以要在finalize()里去调用C的释放函数。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/qq_36761831/article/details/81211540">Java中 System.gc() 调用垃圾收集器与 finalize() 函数
</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1082673">是时候忘掉finalize方法了</a></li>
<li><a href="https://www.nowcoder.com/questionTerminal/d8eab06913084e42b515633604eef7cd">finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</a></li>
<li>《深入理解Java虚拟机》</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Object.finalize()</tag>
      </tags>
  </entry>
  <entry>
    <title>TLAB（线程本地分配缓存 ）</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/TLAB%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E9%85%8D%E7%BC%93%E5%AD%98%20%EF%BC%89/</url>
    <content><![CDATA[<h1 id="TLAB全称"><a href="#TLAB全称" class="headerlink" title="TLAB全称"></a>TLAB全称</h1><p>Thread Local Allocation Buffer</p>
<p>线程本地分配缓存</p>
<h1 id="TLAB作用"><a href="#TLAB作用" class="headerlink" title="TLAB作用"></a>TLAB作用</h1><p>线程私有的内存分配区域，默认占Eden区1%，是为了避免多线程间在堆上分配内存时发生指针碰撞而降低性能。</p>
<p>Java中很多对象都是小对象，并且即用即丢，小对象分配在TLAB上，没有锁的开销，效率比分配在堆上要高。</p>
<h1 id="Java对象分配的过程"><a href="#Java对象分配的过程" class="headerlink" title="Java对象分配的过程"></a>Java对象分配的过程</h1><ol>
<li>编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.</li>
<li>如果tlab_top + size &lt;= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.</li>
<li>重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4.</li>
<li>在Eden区加锁（这个区是多线程共享的），如果eden_top + size &lt;= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5.</li>
<li>执行一次Young GC（minor collection）。</li>
<li>经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。</li>
</ol>
<p>对象不在堆上分配主要的原因还是堆是共享的，在堆上分配有锁的开销。无论是TLAB还是栈都是线程私有的，私有即避免了竞争（当然也可能产生额外的问题例如可见性问题），这是典型的用空间换效率的做法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/yangzl2008/java/article/details/43202969">Java中的逃逸分析和TLAB以及Java对象分配</a></li>
<li><a href="https://www.jianshu.com/p/8be816cbb5ed">浅析java中的TLAB
</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>TLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>句柄、直接指针</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="句柄是什么？"><a href="#句柄是什么？" class="headerlink" title="句柄是什么？"></a>句柄是什么？</h1><p>指针的指针。</p>
<p>jvm中内存里的对象都有一个指针指向对象的开始地址，句柄就是指向对象的指针。</p>
<h1 id="句柄解决了什么问题"><a href="#句柄解决了什么问题" class="headerlink" title="句柄解决了什么问题?"></a>句柄解决了什么问题?</h1><p>对实际的对象资源做了一层代理，屏蔽细节，避免了直接操控资源可能的危险。</p>
<p>弄了句柄，对象实际位置在内存中可以随意变化，比如标记整理垃圾回收后对象被移动到其他地方。</p>
<p>虚拟内存机制，可能会将已经载入内存的数据换到外存硬盘上，这样对象的地址就会变动，其他地方引用这块被换走的地址也要更新，如果使用这块数据的地方引用的是句柄，这样实际数据在内存的位置可以随意变化，使用数据的地方还是引用固定的地址，不用更新。</p>
<p>Windows系统中有许多内核对象（这里的对象不完全等价于”面向对象程序设计”一词中的”对象”，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个”对象”的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p>
<ol>
<li><p>暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p>
</li>
<li><p>操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p>
</li>
</ol>
<p>所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p>
<p>在Windows系统中，这个编号就叫做”句柄”。</p>
<p>参考：<br><a href="https://www.cnblogs.com/klb561/p/10555571.html">句柄的概念</a></p>
<h1 id="为什么叫句柄这个名字？"><a href="#为什么叫句柄这个名字？" class="headerlink" title="为什么叫句柄这个名字？"></a>为什么叫句柄这个名字？</h1><p>从名字上说，handle是指中间媒介，例如门把手是door handle，刀柄是knife handle。</p>
<p>所以文件句柄file handle以即其他资源句柄，也是这个中间媒介的意思，通过这个媒介操作资源。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/27656256/answer/943130123">句柄是什么？ - 黄兢成的回答 - 知乎 解释句柄这个词语的表面含义</a></li>
</ul>
<h1 id="JVM对象访问定位"><a href="#JVM对象访问定位" class="headerlink" title="JVM对象访问定位"></a>JVM对象访问定位</h1><p>JVM通过栈上的reference类型数据来操作堆上的具体对象。</p>
<p>由于reference数据只是规定了一个指向对象的引用，没有定义如何去定位访问对象的具体位置。</p>
<p>主流的实现方式有两种：</p>
<ul>
<li>句柄<br>  在堆中划分句柄池，reference存储对象的句柄地址，句柄包含对象实例数据和类型数据的各自具体地址信息。<ul>
<li>好处：reference中的数据是稳定的句柄地址 对象被移动只会改变句柄中的信息 不会改变句柄的地址 reference不需要变化。</li>
<li>坏处：增加了指针定位的开销。</li>
</ul>
</li>
<li>直接指针<br>  栈上reference类型数据槽中直接存储堆对象的地址。<ul>
<li>好处：直接访问对象 减少指针定位开销。</li>
<li>坏处：当对象内存地址发生变化 reference中数据也需要调整。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》 2.3.3 对象的访问定位 48页</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>句柄</tag>
        <tag>直接指针</tag>
      </tags>
  </entry>
  <entry>
    <title>强引用、软引用、弱引用、虚引用</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h1><p>正常的赋值语句生成的引用，只要强引用存在，与GC Roots对象有引用链，就不会被垃圾回收。</p>
<h1 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h1><p>虚拟机内存不够用时才会尝试回收软引用链接的对象，此次回收后还是不够用，才会抛出内存溢出的异常。</p>
<h1 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h1><p>发生垃圾回收时，不论当前内存是否足够，都会回收弱引用链接的对象。</p>
<h2 id="弱引用应用场景"><a href="#弱引用应用场景" class="headerlink" title="弱引用应用场景"></a>弱引用应用场景</h2><p>官方文档：</p>
<blockquote>
<p>假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后垃圾收集器会把这个弱可达对象标记为可终结(finalizable)的，这样它们随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所登记到的引用队列(Reference Queue)中。</p>
</blockquote>
<p>实际上，WeakReference类有两个构造函数：</p>
<ul>
<li>WeakReference(T referent) //创建一个指向给定对象的弱引用</li>
<li>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) //创建一个指向给定对象并且登记到给定引用队列的弱引用</li>
</ul>
<p>我们可以看到第二个构造方法中提供了一个ReferenceQueue类型的参数，通过提供这个参数，我们便把创建的弱引用对象注册到了一个引用队列上，这样当它被垃圾回收器清除时，就会把它送入这个引用队列中，我们便可以对这些被清除的弱引用对象进行统一管理。</p>
<p>参考：<a href="https://www.jianshu.com/p/dac0958778e0">WeakReference才是LeakCanary真正的核心</a></p>
<h1 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h1><p>在虚引用链接的对象被垃圾回收后，虚引用会受到虚拟机的通知，并不能通过虚引用直接获得对象的实例，虚引用也不会影响对象的生命周期。</p>
<h2 id="虚引用应用场景"><a href="#虚引用应用场景" class="headerlink" title="虚引用应用场景"></a>虚引用应用场景</h2><p>DirectByteBuffer中对堆外内存的释放，通过虚引用监听DirectByteBuffer对象被GC回收后，再调用释放堆外内存的方法。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>StrongReference</tag>
        <tag>SoftReference</tag>
        <tag>WeakReference</tag>
        <tag>PhantomReference</tag>
      </tags>
  </entry>
  <entry>
    <title>Android集合类-ArrayMap原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-ArrayMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="ArrayMap、SparseArray、HashMap的区别？"><a href="#ArrayMap、SparseArray、HashMap的区别？" class="headerlink" title="ArrayMap、SparseArray、HashMap的区别？"></a>ArrayMap、SparseArray、HashMap的区别？</h1><ul>
<li><p>数据结构</p>
<ul>
<li>  ArrayMap和SparseArray采用的都是两个数组，Android专门针对内存优化而设计的</li>
<li>  HashMap采用的是数据+链表+红黑树</li>
</ul>
</li>
<li><p>内存优化</p>
<ul>
<li>  ArrayMap比HashMap更节省内存，综合性能方面在数据量不大的情况下，推荐使用ArrayMap；</li>
<li>  Hash需要创建一个额外对象来保存每一个放入map的entry，且容量的利用率比ArrayMap低，整体更消耗内存</li>
<li>  SparseArray比ArrayMap节省1/3的内存，但SparseArray只能用于key为int类型的Map，所以int类型的Map数据推荐使用SparseArray；</li>
</ul>
</li>
<li><p>性能方面：</p>
<ul>
<li>  ArrayMap查找时间复杂度O(logN)；ArrayMap增加、删除操作需要移动成员，速度相比较慢，对于个数小于1000的情况下，性能基本没有明显差异</li>
<li>  HashMap查找、修改的时间复杂度为O(1)；</li>
<li>  SparseArray适合频繁删除和插入来回执行的场景，性能比较好</li>
</ul>
</li>
<li><p>缓存机制</p>
<ul>
<li>  ArrayMap针对容量为4和8的对象进行缓存，可避免频繁创建对象而分配内存与GC操作，这两个缓存池大小的上限为10个，防止缓存池无限增大；</li>
<li>  HashMap没有缓存机制</li>
<li>  SparseArray有延迟回收机制，提供删除效率，同时减少数组成员来回拷贝的次数</li>
</ul>
</li>
<li><p>扩容机制</p>
<ul>
<li>  ArrayMap是在容量满的时机触发容量扩大至原来的1.5倍，在容量不足1/3时触发内存收缩至原来的0.5倍，更节省的内存扩容机制</li>
<li>  HashMap是在容量的0.75倍时触发容量扩大至原来的2倍，且没有内存收缩机制。HashMap扩容过程有hash重建，相对耗时。所以能大致知道数据量，可指定创建指定容量的对象，能减少性能浪费。</li>
</ul>
</li>
<li><p>并发问题</p>
<ul>
<li>  ArrayMap是非线程安全的类，大量方法中通过对mSize判断是否发生并发，来决定抛出异常。但没有覆盖到所有并发场景，比如大小没有改变而成员内容改变的情况就没有覆盖</li>
<li>  HashMap是在每次增加、删除、清空操作的过程将modCount加1，在关键方法内进入时记录当前mCount，执行完核心逻辑后，再检测mCount是否被其他线程修改，来决定抛出异常。这一点的处理比ArrayMap更有全面。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>HashMap的查找和插入时间复杂度为O(1)的代价是牺牲大量的内存来实现的。</li>
<li>而SparseArray和ArrayMap性能略逊于HashMap，但更节省内存。</li>
<li>SparseArray的key是int类型，ArrayMap的key是任意类型。</li>
<li>SparseArray删除元素是延迟删除，减少数组拷贝的频次。</li>
<li>ArrayMap有对容量4和8的缓存机制，避免频繁的内存分配和垃圾回收。</li>
</ul>
<p>Android中的小数据量的哈希表，Google推荐数据量小于1000使用ArrayMap，大于1000使用HashMap。</p>
<h1 id="为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？"><a href="#为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？" class="headerlink" title="为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？"></a>为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？</h1><p>ArrayMap中的 mHashs 数组以升序的方式保存了所有的 hash code，在查找数据时则通过二分查找 hash code 所对应的 index。这也是它的 get() 比 HashMap 慢的根据原因所在。</p>
<p>插入、删除需要移动数组的元素，数据多了的话，速度也相对较慢，数据少了影响较小。</p>
<h1 id="ArrayMap底层存储结构是怎样的？"><a href="#ArrayMap底层存储结构是怎样的？" class="headerlink" title="ArrayMap底层存储结构是怎样的？"></a>ArrayMap底层存储结构是怎样的？</h1><ul>
<li>  mHashes是一个记录所有key的hashcode值组成的数组，是从小到大的排序方式；</li>
<li>  mArray是一个记录着key-value键值对所组成的数组，是mHashes大小的2倍；</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214641.png"></p>
<p>为什么mArray的大小是mHahses的2倍？</p>
<p>因为mArray存储了key和value，所以需要2倍于mHashes的容量。</p>
<p>mHashes 在 index 处存储了 key 的 hash code，而 mArray 则在 hash code 的 index&lt;&lt;1 处存储 key，在 index&lt;&lt;1 + 1 处存储 value。简单点说就是偶数处存储 key，相邻奇数处存储 value。</p>
<h1 id="多个key的hashCode发生冲突时是怎么存储数据的？"><a href="#多个key的hashCode发生冲突时是怎么存储数据的？" class="headerlink" title="多个key的hashCode发生冲突时是怎么存储数据的？"></a>多个key的hashCode发生冲突时是怎么存储数据的？</h1><p>HashMap用的是拉链法把同一个hashCode元素放在一个桶中</p>
<p>ArrayMap用的是开放定址法之线性探测法</p>
<p>相同的hashCode存储在mHashes数组中相邻的位置，把原来数组中该位置之后的元素全部后移一位</p>
<p>例子：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214729.png"></p>
<p>index == 0 时 和 index == 1时的 hash code 是一样的，说明 key1 与 key2 的 hash code 是一样的，也就是存在 hash 冲突了。那么，如上，这里的解决办法就是 hash code 存储了 2 份，而 key-value 分别存储一份。</p>
<h1 id="ArrayMap-indexOf-key-hash-原理"><a href="#ArrayMap-indexOf-key-hash-原理" class="headerlink" title="ArrayMap.indexOf(key, hash)原理?"></a>ArrayMap.indexOf(key, hash)原理?</h1><p>源码的注释已经说的很明白</p>
<ol>
<li> 在mHashes中二分查找hash的索引</li>
<li> 如果mHashes中没找到hash，说明不存在这个元素，返回二分查找得出的应该插入的位置，以保障mHashes存储的hash保持升序</li>
<li> 如果mHashes中找到了hash，有两种情况：找到元素了  或  存在哈希冲突，这一点通过mArray存储的key和方法传入的key是否相等来判断，如果相等说明找到元素了，不相等则没有找到，没有找到要返回待插入的位置</li>
<li> 由于相同的hash在mHashes中存储在相邻的位置，如果mHashes中找到了hash，但是mArray中存储的key不相等，则往右往左分别寻找相同hash对应的mArray中的key是否相等</li>
</ol>
<h1 id="ArrayMap-put-key-value-原理"><a href="#ArrayMap-put-key-value-原理" class="headerlink" title="ArrayMap.put(key, value)原理?"></a>ArrayMap.put(key, value)原理?</h1><ol>
<li> 求key的hashCode</li>
<li> 通过indexOf(key, hash)计算新的hash应该插入mHashes数组中什么位置</li>
<li> 如果index &gt; 0 说明之前这个key已经存了值，替换为新的value就结束put流程</li>
<li> index &lt; 0 说明mHashes里不存在这个hash，index为待插入的位置</li>
<li> 如果容量不够了，就申请新的数组，容量为之前的1.5倍，把旧数组的值全部拷贝到新的数组</li>
<li> index后面的元素全部后移一位，给index的位置腾出空间</li>
<li> 存储hash到mHashes[index]，存储key、value到mArray的index * 2和index * 2 + 1的位置</li>
</ol>
<h1 id="为什么通过key求得index后要左移1位？"><a href="#为什么通过key求得index后要左移1位？" class="headerlink" title="为什么通过key求得index后要左移1位？"></a>为什么通过key求得index后要左移1位？</h1><p>因为这个index是mHashes的索引，mHashes数组长度是mArray数组长度的一半，索引乘以2，就是作为mArray的索引</p>
<h1 id="ArrayMap-remove-原理？"><a href="#ArrayMap-remove-原理？" class="headerlink" title="ArrayMap.remove()原理？"></a>ArrayMap.remove()原理？</h1><p>一般情况下删除一个数据，只需要将 index 后面的数据都往 index 方向移一位，然后删除末位数即可。</p>
<p>如果再满足缩容的条件就进行缩容，条件是mHashs长度大于 2 * BASE_SIZE 且  实际元素个数小于mHashs长度的1/3，就把容量压缩为实际元素大小的1.5倍</p>
<p>为什么是1.5倍，这样保证不会频繁的创建数组，也不会浪费太多的空间，平衡了性能</p>
<h1 id="mHashes里存的hashcode为什么要升序？"><a href="#mHashes里存的hashcode为什么要升序？" class="headerlink" title="mHashes里存的hashcode为什么要升序？"></a>mHashes里存的hashcode为什么要升序？</h1><p>因为要二分查找获取插入位置。</p>
<h1 id="为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？"><a href="#为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？" class="headerlink" title="为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？"></a>为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？</h1><h2 id="HashMap是怎么计算索引位置的？"><a href="#HashMap是怎么计算索引位置的？" class="headerlink" title="HashMap是怎么计算索引位置的？"></a>HashMap是怎么计算索引位置的？</h2><p>HashMap是直接用数组大小与key的hashCode做与操作得到数组索引。</p>
<h2 id="为什么ArrayMap不按照HashMap计算索引的方式来做呢？"><a href="#为什么ArrayMap不按照HashMap计算索引的方式来做呢？" class="headerlink" title="为什么ArrayMap不按照HashMap计算索引的方式来做呢？"></a>为什么ArrayMap不按照HashMap计算索引的方式来做呢？</h2><p>因为扩容后会重新hash，让元素分布的更均匀以较少哈希冲突，重新hash过程比较耗时，实现起来也比较复杂。</p>
<p>数据量小的情况下，用二分查找足够应付。</p>
<h1 id="ArrayMap为什么要设计一个缓存机制？"><a href="#ArrayMap为什么要设计一个缓存机制？" class="headerlink" title="ArrayMap为什么要设计一个缓存机制？"></a>ArrayMap为什么要设计一个缓存机制？</h1><p>很多场景可能起初都是数据很少，为了减少频繁地创建和回收数组，特意设计了两个缓存池，分别缓存大小为4和8的ArrayMap对象，这两个长度的Map根据统计信息应该用的很多。</p>
<h1 id="ArrayMap缓存机制实现原理？"><a href="#ArrayMap缓存机制实现原理？" class="headerlink" title="ArrayMap缓存机制实现原理？"></a>ArrayMap缓存机制实现原理？</h1><p>freeArrays(hashes, array, size) 会把hashes数组和array数组用链表的形式存储下来，头结点用mBaseCache、mTwiceBaseCache存储，分别表示数组长度为4和8的缓存<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214932.png"></p>
<p>freeArrays()触发时机:</p>
<ul>
<li>  当执行removeAt()移除最后一个元素的情况</li>
<li>  当执行clear()清理的情况</li>
<li>  当执行ensureCapacity()在当前容量小于预期容量的情况下, 先执行allocArrays,再执行freeArrays</li>
<li>  当执行put()在容量满的情况下, 先执行allocArrays, 再执行freeArrays</li>
</ul>
<p>当allocArrays分配内存时，如果所需要分配的大小等于4或者8，且相对应的缓冲池不为空，则会从相应缓存池中取出缓存的mArray和mHashes。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214947.png"></p>
<p>这里需要注意的是只有大小为4或者8的内存分配才有可能从缓存池取数据，因为freeArrays过程放入缓存池的大小只有4或8，对于其他大小的内存分配则需要创建新的数组。</p>
<p>优化小技巧，对于分配数据不超过8的对象的情况下，一定要创建4或者8大小，否则浪费了缓存机制。比如ArrayMap[7]就是不友好的写法，建议写成ArrayMap[8]。</p>
<p>两个缓存池大小上限为10个。</p>
<h1 id="扩容的条件？"><a href="#扩容的条件？" class="headerlink" title="扩容的条件？"></a>扩容的条件？</h1><p>mSize是实际存储的元素的个数</p>
<p>当mSize大于或等于mHashes数组长度时需要扩容，新容量的规则如下：</p>
<ul>
<li>  当map个数满足条件 osize&lt;4时，则扩容后的大小为4；</li>
<li>  当map个数满足条件 4&lt;= osize &lt; 8时，则扩容后的大小为8；</li>
<li>  当map个数满足条件 osize&gt;=8时，则扩容后的大小为原来的1.5倍；</li>
</ul>
<h1 id="缩容的条件？"><a href="#缩容的条件？" class="headerlink" title="缩容的条件？"></a>缩容的条件？</h1><p>当数组内存的大小大于8，且已存储数据的个数mSize小于数组空间大小的1/3的情况下，需要收紧数据的内容容量，分配新的数组，老的内存靠虚拟机自动回收。</p>
<ul>
<li>  如果mSize&lt;=8，则设置新大小为8；</li>
<li>  如果mSize&gt; 8，则设置新大小为mSize的1.5倍。</li>
</ul>
<p>也就是说在数据较大的情况下，当内存使用量不足1/3的情况下，内存数组会收紧50%</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a></li>
<li><a href="https://juejin.im/post/6844903762470060045">ArrayMap详解及源码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>ArrayMap</tag>
        <tag>SparseArray</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Android集合类-SparseArray原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-SparseArray%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="稀疏表是什么？"><a href="#稀疏表是什么？" class="headerlink" title="稀疏表是什么？"></a>稀疏表是什么？</h1><p>key为整数的哈希表</p>
<h1 id="稀疏表特点"><a href="#稀疏表特点" class="headerlink" title="稀疏表特点"></a>稀疏表特点</h1><ul>
<li>Key为int类型的哈希表，避免了Integer自动装箱。</li>
<li>底层用数组存储元素，一个数组存储key，一个数组存储value，key是有序的，通过二分查找来定位元素。</li>
<li>插入元素会移动数组，remove的时候只设置了一个removed标记位，避免频繁移动数组元素。</li>
<li>数据量大的时候，复制数组时间就长了，查找时间也长了。</li>
<li>好处是不需要额外的结构体，比较节约空间，数据量较小情况下访问想效率比较高。</li>
</ul>
<h1 id="SparseArray相比HashMap解决了什么？"><a href="#SparseArray相比HashMap解决了什么？" class="headerlink" title="SparseArray相比HashMap解决了什么？"></a>SparseArray相比HashMap解决了什么？</h1><p>优点：</p>
<ol>
<li> 避免了基本数据类型的装箱操作</li>
<li> 不需要额外的结构体，单个元素的存储成本更低</li>
<li> 数据量小的情况下，随机访问的效率更高，因为不需要额外复杂操作、删除元素也是延迟的</li>
</ol>
<p>缺点：</p>
<ol>
<li> 插入操作需要复制数组，增删效率降低</li>
<li> 数据量巨大时，复制数组成本巨大，gc()成本也巨大</li>
<li> 数据量巨大时，查询效率也会明显下降，因为需要二分查找，而不是直接哈希命中</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/6844903442901630983">SparseArray 的使用及实现原理</a></li>
</ul>
<h1 id="SparseArray适用场景？"><a href="#SparseArray适用场景？" class="headerlink" title="SparseArray适用场景？"></a>SparseArray适用场景？</h1><p>原则：</p>
<ol>
<li> 数据量不大（千这个数量级以内）。</li>
<li> 空间比时间重要，例如移动端对内存使用量敏感。</li>
<li> 需要使用Map，且key为int类型。</li>
</ol>
<p>例如：<br>如果有一个ViewPager的每个页面都有一个图表，并且图表的点有上千个，而ViewPager会缓存左右两页，至少要开3个图表，用HashMap明显占用内存更多，容易引发内存溢出，而且自动装箱的消耗更多，用SparseArray肯定更快，内存占用更小。</p>
<h1 id="SparseArray-put-int-key-E-value-原理？"><a href="#SparseArray-put-int-key-E-value-原理？" class="headerlink" title="SparseArray.put(int key, E value)原理？"></a>SparseArray.put(int key, E value)原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a mapping from the specified key to the specified value,</span></span><br><span class="line"><span class="comment"> * replacing the previous mapping from the specified key if there</span></span><br><span class="line"><span class="comment"> * was one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是一次插入数据的操作，单看的话有些难懂，因为插入跟删除之间有一定的关系，所以要看懂这段代码，还必须搞懂删除的逻辑。在看删除之前，还是先大体梳理一下插入的几个特点：</p>
<ul>
<li>  <strong>存放<code>key</code>的数组是有序的（二分查找的前提条件）</strong></li>
<li>  <strong>如果冲突，新值直接覆盖原值，并且不会返回原值（<code>HashMap</code>会返回原值）</strong></li>
<li>  <strong>如果当前要插入的 key 的索引上的值为DELETE，直接覆盖</strong></li>
<li>  <strong>前几步都失败了，检查是否需要<code>gc()</code>并且在该索引上插入数据</strong></li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/6844903442901630983">SparseArray 的使用及实现原理</a></li>
</ul>
<h1 id="GrowingArrayUtils-insert-的原理？"><a href="#GrowingArrayUtils-insert-的原理？" class="headerlink" title="GrowingArrayUtils.insert()的原理？"></a>GrowingArrayUtils.insert()的原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts an element into the array at the specified index, growing the array if there is no</span></span><br><span class="line"><span class="comment"> * more room.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array The array to which to append the element. Must NOT be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentSize The number of elements in the array. Must be less than or equal to</span></span><br><span class="line"><span class="comment"> *                    array.length.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element The element to insert.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array to which the element was appended. This may be different than the given</span></span><br><span class="line"><span class="comment"> *         array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] insert(T[] array, <span class="keyword">int</span> currentSize, <span class="keyword">int</span> index, T element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentSize + <span class="number">1</span> &lt;= array.length) &#123;</span><br><span class="line">        System.arraycopy(array, index, array, index + <span class="number">1</span>, currentSize - index);</span><br><span class="line">        array[index] = element;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(),</span><br><span class="line">            growSize(currentSize));</span><br><span class="line">    System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, index);</span><br><span class="line">    newArray[index] = element;</span><br><span class="line">    System.arraycopy(array, index, newArray, index + <span class="number">1</span>, array.length - index);</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前数据个数并不超过数组长度，直接把待插入位置后面的元素全部后移一位，腾出空间给新元素。</p>
<p>如果数据总个数超过了数组容纳的长度，需要扩容，扩容大小为growSize(currentSize)求得，为原大小的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given the current size of an array, returns an ideal size to which the array should grow.</span></span><br><span class="line"><span class="comment"> * This is typically double the given size, but should not be relied upon to do so in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">growSize</span><span class="params">(<span class="keyword">int</span> currentSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize &lt;= <span class="number">4</span> ? <span class="number">8</span> : currentSize * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据新大小创建新的数组，然后：</p>
<ol>
<li> 把原数组中待插入位置前面的元素都复制到新数组的前面</li>
<li> 新数组中指定位置插入新元素</li>
<li> 把原数组中待插入位置后面的元素都复制到新数组中插入元素的后面</li>
</ol>
<h1 id="SparseArray-remove-int-key-原理"><a href="#SparseArray-remove-int-key-原理" class="headerlink" title="SparseArray.remove(int key)原理?"></a>SparseArray.remove(int key)原理?</h1><p>通过key二分查找到index，然后讲DELETED赋值给mValues[index]，标记这个位置会删除</p>
<p>为什么删除标记位DELETED？而不是直接删除元素？</p>
<p>直接删除元素会复制数组，如果删除比较频繁，就会降低性能，这里是为了避免频繁进行数组拷贝调整</p>
<h1 id="什么时候会清理掉DELETED的元素？"><a href="#什么时候会清理掉DELETED的元素？" class="headerlink" title="什么时候会清理掉DELETED的元素？"></a>什么时候会清理掉DELETED的元素？</h1><p>SparseArray.gc()里会清理</p>
<h1 id="SparseArray-gc-的原理？"><a href="#SparseArray-gc-的原理？" class="headerlink" title="SparseArray.gc()的原理？"></a>SparseArray.gc()的原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mValues里如果没有DELETED，那么i和o应该是相等的，但是如果有DELETED，o就会小于i，然后就可以把元素全部前移到数组头部，把空位留在数组尾部，相当于碎片整理了一下，留下了尾部整块的空闲空间。</p>
<h1 id="什么时候触发GC-？"><a href="#什么时候触发GC-？" class="headerlink" title="什么时候触发GC()？"></a>什么时候触发GC()？</h1><p>以下方法会调用gc()：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214148.png"></p>
<p>put的时候如果发现数组大小不够，就清理。</p>
<p>size()求大小需要求得正确的大小。</p>
<h1 id="SparseArray使用过程有什么坑？"><a href="#SparseArray使用过程有什么坑？" class="headerlink" title="SparseArray使用过程有什么坑？"></a>SparseArray使用过程有什么坑？</h1><p>indexOfValue比较的是value的指针，而并没有调用equals方法。</p>
<p>如果value是String就有问题。</p>
<p>如果是Integer，在Integer的缓存范围内也有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an index for which &#123;<span class="doctag">@link</span> #valueAt&#125; would return the</span></span><br><span class="line"><span class="comment"> * specified value, or a negative number if no keys map to the</span></span><br><span class="line"><span class="comment"> * specified value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Beware that this is a linear search, unlike lookups by key,</span></span><br><span class="line"><span class="comment"> * and that multiple keys can map to the same value and this will</span></span><br><span class="line"><span class="comment"> * find only one of them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note also that unlike most collections&#x27; &#123;<span class="doctag">@code</span> indexOf&#125; methods,</span></span><br><span class="line"><span class="comment"> * this method compares values using &#123;<span class="doctag">@code</span> ==&#125; rather than &#123;<span class="doctag">@code</span> equals&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfValue</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/hapoy9/article/details/75554539">安卓SparseArray的indexOfValue方法遇到的坑</a></li>
<li><a href="https://blog.csdn.net/brehrehr/article/details/100118779">记录SparseArray的使用方法和使用过程遇到的问题</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>SparseArray</tag>
        <tag>稀疏表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-ArrayDeque</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayDeque/</url>
    <content><![CDATA[<h1 id="ArrayDeque特点"><a href="#ArrayDeque特点" class="headerlink" title="ArrayDeque特点"></a>ArrayDeque特点</h1><p>基于数组的双端队列。</p>
<p>分别用两个索引指针指示头尾元素位置，循环访问数组元素，访问头尾元素时间复杂度为O(1)</p>
<p>容量不够时扩容，容量增加一倍。</p>
<p>也可以当栈使用。</p>
<h1 id="有了LinkedList实现双端队列，为什么还要用ArrayDeque？"><a href="#有了LinkedList实现双端队列，为什么还要用ArrayDeque？" class="headerlink" title="有了LinkedList实现双端队列，为什么还要用ArrayDeque？"></a>有了LinkedList实现双端队列，为什么还要用ArrayDeque？</h1><p>数组在内存中是连续存储的，CPU访问内存数据具有空间局部性特点，数组对CPU缓存很友好，可以大大提升访问速度。</p>
<p>链表每个节点存储位置是分散不连续的，CPU缓存命中率低，CPU访问主存次数增加，速度慢。</p>
<p>所以需要栈和队列时，优先选择用ArrayDeque。</p>
<h1 id="ArrayDeque缺点"><a href="#ArrayDeque缺点" class="headerlink" title="ArrayDeque缺点"></a>ArrayDeque缺点</h1><ol>
<li> ArrayDeque较于链表的方式的缺点就是容量不够时需要扩容，耗费O(n)的时间</li>
<li> 删除元素后不会缩容，所以不适合数据量变化大且长期处于少数据状态的情况，会浪费空间</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist">Why is ArrayDeque better than LinkedList</a></li>
<li><a href="https://mp.weixin.qq.com/s/PG6NOMgXS6Slh0aXRv9W-g">死磕 java集合之ArrayDeque源码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>集合类</tag>
        <tag>ArrayDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-ArrayList</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/</url>
    <content><![CDATA[<h1 id="ArrayList如何扩容的？"><a href="#ArrayList如何扩容的？" class="headerlink" title="ArrayList如何扩容的？"></a>ArrayList如何扩容的？</h1><p>无参构造函数中初始化一个空数组</p>
<p>调用add，往数组末尾添加元素前，会调用ensureCapacityInternal(size+1)，第一次会创建DEFAULT_CAPACITY（值为10）长度的数组，再会调用grow()，新的数组长度为之前长度的1.5倍，接着调用Arrays.copyOf()将旧的数组元素复制到新数组中，底层实现是System.arraycopy()。</p>
<p>以上是自动扩容，也可以调用ensureCapacity(minCapacity)来手动扩容，需要手动扩容因为，如果提前知道数据量很大，就可以直接扩容到指定容量，自动扩容每次都会扩容原来的1.5倍，避免频繁拷贝数组的开销。</p>
<p>remove和clear后没有缩容，只会把数组中不需要的元素对应的位置设置为null，以便垃圾回收。</p>
<h1 id="ArrayList查询元素的时间复杂度是多少？"><a href="#ArrayList查询元素的时间复杂度是多少？" class="headerlink" title="ArrayList查询元素的时间复杂度是多少？"></a>ArrayList查询元素的时间复杂度是多少？</h1><p>数组访问任意位置元素的时间复杂度为O(1)</p>
<h1 id="ArrayList插入元素的时间复杂度是多少？"><a href="#ArrayList插入元素的时间复杂度是多少？" class="headerlink" title="ArrayList插入元素的时间复杂度是多少？"></a>ArrayList插入元素的时间复杂度是多少？</h1><p>插入末尾时间复杂度为O(1)，因为有指针记录末尾的位置，有新元素直接填充末尾的空位，当末尾没有空位时，需要扩容，扩容为原来长度的1.5倍，扩容需要拷贝旧数组的数据到新数组，时间复杂度是O(n），所以插入元素到末尾的均摊时间复杂度是O(1)。</p>
<p>插入元素到中间位置的时间复杂度较高，因为要把插入位置后面所有元素后移一位，设数组长度为n，插入第1、2、3、… 、n-1、n个位置，分别需要移动元素的个数是n、n-1、n-2、… 、2、1，由等差数列求和公式得结果为n(n+1)/2，除以n得平均移动(n+1)/2个，所以插入到中间位置的平均时间复杂度是O(n)。</p>
<h1 id="ArrayList删除元素的时间复杂度是多少？"><a href="#ArrayList删除元素的时间复杂度是多少？" class="headerlink" title="ArrayList删除元素的时间复杂度是多少？"></a>ArrayList删除元素的时间复杂度是多少？</h1><p>与插入元素的情况一样，删除末尾元素时间复杂度为O(1)，删除中间位置的元素要把该位置后面的元素都前移一位，平均时间复杂度为O(n)</p>
<h1 id="ArrayList与LinkedList有何区别？"><a href="#ArrayList与LinkedList有何区别？" class="headerlink" title="ArrayList与LinkedList有何区别？"></a>ArrayList与LinkedList有何区别？</h1><ol>
<li> ArrayList基于数组实现，容量不够时会动态扩容；LinkedList基于链表实现，实际是是一个双向链表，同时可以作为队列、栈使用</li>
<li> ArrayList适合随机访问数据，时间复杂度O(1)；LinkedList不适合随机访问数据，因为这会遍历链表，最坏情况下访问最后一个元素，要遍历整个链表，时间复杂度O(n)</li>
<li> LinkedList适合插入和删除首尾元素，时间复杂度O(1)；ArrayList插入和删除尾元素，其实是在数组的末尾填充元素，时间复杂度O(1)，插入尾元素可能会触发扩容，扩容时会拷贝数组，时间复杂度会达到O(n)，ArrayList插入和删除非末尾元素，需要移动操作，时间复杂度O(n)</li>
<li> LinkedList需要占用更多的内存，因为每个结点除了存储元素数据外，还有额外的链表指针，ArrayList底层是数组，存储的直接是元素数据</li>
<li> ArrayList对于CPU缓存命中率友好，因为存储空间连续，符合数据访问的空间局部性特点</li>
</ol>
<h1 id="如何求两个ArrayList的交集、并集、差集？"><a href="#如何求两个ArrayList的交集、并集、差集？" class="headerlink" title="如何求两个ArrayList的交集、并集、差集？"></a>如何求两个ArrayList的交集、并集、差集？</h1><p>并集：addAll</p>
<p>交集：retainAll</p>
<p>差集：removeAll</p>
<h1 id="ArrayList序列化有什么注意事项？"><a href="#ArrayList序列化有什么注意事项？" class="headerlink" title="ArrayList序列化有什么注意事项？"></a>ArrayList序列化有什么注意事项？</h1><p>底层的elementData数组，可能没有填充满，所以不能直接序列化，会浪费空间，序列化时要先写入数组元素真实个数，再写入数组中实际存储的元素</p>
<h1 id="Arrays-asList-T…-a-有什么坑"><a href="#Arrays-asList-T…-a-有什么坑" class="headerlink" title="Arrays.asList(T… a)有什么坑"></a>Arrays.asList(T… a)有什么坑</h1><ol>
<li> 传递一个原始数据类型的数组，例如int[]，会只被当做一个元素，只能使用对象类型的数组</li>
<li> 得到的list无法add、remove、clear，会抛出异常</li>
</ol>
<h1 id="ArrayList有什么坑？"><a href="#ArrayList有什么坑？" class="headerlink" title="ArrayList有什么坑？"></a>ArrayList有什么坑？</h1><p>List.remove()有两个。</p>
<p>一个public E remove(int index)</p>
<p>一个是public boolean remove(Object o)</p>
<p>容易调用不是预期的重载方法。</p>
<h1 id="ArrayList单线程遍历然后删除元素会有什么问题？"><a href="#ArrayList单线程遍历然后删除元素会有什么问题？" class="headerlink" title="ArrayList单线程遍历然后删除元素会有什么问题？"></a>ArrayList单线程遍历然后删除元素会有什么问题？</h1><p>索引错位。</p>
<p>用Iterartor的next迭代列表的时候，通过ArrayList的remove方法移除元素会抛出ConcurrentModificationException，因为迭代器迭代的时候，内部也是用一个int类型指针记录位置的，要是外面删除了元素，位置就错位了，迭代就不准了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/5c66c47851882562e5443491">ArrayList的扩容机制</a></li>
<li><a href="https://www.nowcoder.com/questionTerminal/2a42d992a5d74435b625415ce511bb69">ArrayList和LinkedList有什么区别？</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>集合类</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-ConcurrentHashMap原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>高性能且线程安全的哈希表。</p>
<h1 id="线程安全是怎么实现的？"><a href="#线程安全是怎么实现的？" class="headerlink" title="线程安全是怎么实现的？"></a>线程安全是怎么实现的？</h1><p>Java7中ConcurrentHashMap将哈希表分割成为多个段（Segment），每一个段继承ReentrantLock，对每一段进行加锁。每个Segment里类似又有一个小的HashMap，等于是双重哈希表。</p>
<p>Java8中采用了自旋CAS和synchronzied保证线程安全，锁的粒度调整为对table数组中每个元素进行加锁；put元素时，定位到桶位置后，通过synchronzied给桶中链表首节点或红黑树根节点加锁。这样多线程竞争哈希表同一个桶位置的几率又降低了。</p>
<p>java8的ConcurrentHashMap的数据结构参考java8的HashMap，采用数组+链表+红黑树。</p>
<ul>
<li><p>put方法里，是一个无限循环，即自旋，修改table数组都是通过cas操作，自旋锁的机制避免了阻塞和恢复线程的上下文切换开销。</p>
</li>
<li><p>只要当前桶位置没有元素，就先自旋CAS进行更新。</p>
</li>
<li><p>存在hash冲突或修改已有的值时，需要进入桶内部的链表或红黑树进行操作时，才开始用synchronized真正加锁。</p>
</li>
</ul>
<p>get是不加锁的，所以与CopyOnWriteArrayList一样，不保证读数据的实时性，数据是弱一致性。</p>
<p>size的求法和LongAdder里的思路一样，将大小数据分段累加，避免多线程竞争，用自旋cas保证数据更新的原子性。</p>
<h1 id="不能解决什么问题？"><a href="#不能解决什么问题？" class="headerlink" title="不能解决什么问题？"></a>不能解决什么问题？</h1><p>因为数据是弱一致性的，get时并不加锁，所以对读数据实时性要求高的需求不能满足。</p>
<p>例如线程1在某一时刻执行了put(key, value)，先线程2随后立即get(key)不一定能读取到线程1刚put的，因为put可能正在进行中还没结束。</p>
<h1 id="扩容机制是怎样的？"><a href="#扩容机制是怎样的？" class="headerlink" title="扩容机制是怎样的？"></a>扩容机制是怎样的？</h1><p>本来一个线程扩容时，其他线程应该都阻塞等待这个线程扩容完成后才能对哈希表进行读写，这就成了并发的瓶颈。</p>
<p>ConcurrentHashMap具体实现是，反正你闲着也是闲着，不如一起来扩容。</p>
<p>扩容时nextTable会指向扩容后的数组，扩容方法transfer里通过自旋进行。</p>
<p>多个线程通过sizeCtl判断当前所处状态，再通过transferIndex协调各线程应该操作哪一些桶。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">ConcurrentHashMap1.8 - 扩容详解（图文并茂）</a></li>
<li><a href="https://www.cnblogs.com/lfs2640666960/p/9621461.html">深入理解HashMap+ConcurrentHashMap的扩容策略  </a></li>
<li><a href="https://www.jianshu.com/p/487d00afe6ca">ConcurrentHashMap源码分析（JDK8） 扩容实现机制</a></li>
</ul>
<h1 id="跟同样是线程安全的Hashtable有何区别？"><a href="#跟同样是线程安全的Hashtable有何区别？" class="headerlink" title="跟同样是线程安全的Hashtable有何区别？"></a>跟同样是线程安全的Hashtable有何区别？</h1><p>Hashtable的线程安全是对整个哈希表上锁（在多数方法上加上sychronized），其中一个线程访问哈希表时，其他线程只能等待，很多没有必要上锁的场景也上锁，因此在多线程竞争激烈的情况下整体访问速度会变慢。</p>
<p>ConcurrentHashMap把哈希表分割成若干个段，修改每一段时仅针对访问的段上锁，不同的线程访问不同的段时互不干扰，减少了多个线程争抢同一把锁的几率，减少了线程等待的时间，所以提高了性能。</p>
<p>分段锁是怎么实现的？</p>
<p>get方法不加锁，结点类里的value设置了volatile保证了value在多线程下的可见性，保证get到value最新的修改值。</p>
<p>总结：</p>
<ol>
<li> 循环+CAS实现自旋锁，减少线程阻塞恢复的上下文切换消耗</li>
<li> size更新采用LongAdder分段锁思想，减少竞争</li>
<li> LongAdder机制中的字节填充解决伪共享</li>
<li> 多线程协同分组扩容。</li>
</ol>
<h1 id="与Collections-synchronizedMap-的区别？"><a href="#与Collections-synchronizedMap-的区别？" class="headerlink" title="与Collections.synchronizedMap()的区别？"></a>与Collections.synchronizedMap()的区别？</h1><p>Collections.synchronizedMap()对HashMap做了一层装饰，用synchronized锁住整个哈希表，以保证各操作的线程安全，锁的粒度比较大。<br>性能比ConcurrentHashMap更差，但可以保证读的实时性。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li>
<li><a href="https://juejin.im/post/5dee05ac6fb9a0163f77beb6">深入解析 ConcurrentHashMap 实现内幕，吊打面试官？没问题</a></li>
<li><a href="https://www.cnblogs.com/heqiyoujing/p/11143525.html">ConcurrentHashMap面试题</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-CopyOnWriteArrayList</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-CopyOnWriteArrayList/</url>
    <content><![CDATA[<h1 id="ArrayList存在什么问题？"><a href="#ArrayList存在什么问题？" class="headerlink" title="ArrayList存在什么问题？"></a>ArrayList存在什么问题？</h1><p>ArrayList是线程不安全的。</p>
<p>可以用Collections.synchronizedList()加全局独占锁保证线程安全，但在读多写少的情况下，多线程读之间互斥降低了系统吞吐量。</p>
<p>如果读与读之间不互斥，写与写、写与读才互斥，这样可以保证最大的吞吐量，这就是CopyOnWriteArrayList。</p>
<h1 id="CopyOnWriteArrayList保证线程安全的原理？"><a href="#CopyOnWriteArrayList保证线程安全的原理？" class="headerlink" title="CopyOnWriteArrayList保证线程安全的原理？"></a>CopyOnWriteArrayList保证线程安全的原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用读写锁保证并发，可以保证读读之间没有阻塞等待，但有线程写数据时，读线程必须阻塞等待，这保证了每次都都可以读到最新修改的值。</p>
<p>CopyOnWriteArrayList牺牲了读的实时性，读操作不上锁，只在写数据时使用ReentrantLock上锁，写数据时会把原数组拷贝到新的数组中，写数据的同时再有线程读数据，读到的是之前数组的值，不保证数据实时性，只保证最终结果一致性，牺牲了数据实时性，换取了读操作没有阻塞等待。</p>
<p>对数据实时性要求很高的需求，不要使用CopyOnWriteArrayList。</p>
<p>线程1在add数据时，线程2随后get数据，不一定能获取到线程1刚add的的元素，因为线程1可能还没执行完。</p>
<h1 id="CopyOnWriteArrayList存在什么问题？"><a href="#CopyOnWriteArrayList存在什么问题？" class="headerlink" title="CopyOnWriteArrayList存在什么问题？"></a>CopyOnWriteArrayList存在什么问题？</h1><ol>
<li> 读数据不是实时的，读的时候可能正在写数据，读不到最新的值，也不会阻塞等待，适合读多写少的场景</li>
<li> 每次写数据都要复制整个数组，如果写操作频繁，会频繁触发垃圾回收，垃圾回收又会导致线程停顿，造成APP卡顿变多</li>
</ol>
<h1 id="CopyOnWriteArrayList适用场景？"><a href="#CopyOnWriteArrayList适用场景？" class="headerlink" title="CopyOnWriteArrayList适用场景？"></a>CopyOnWriteArrayList适用场景？</h1><ol>
<li> 高并发</li>
<li> 读多写少</li>
<li> 对读数据实时性要求不高</li>
</ol>
<h1 id="为什么没有扩容"><a href="#为什么没有扩容" class="headerlink" title="为什么没有扩容?"></a>为什么没有扩容?</h1><p>因为每次add元素都要拷贝数组，这个时间消耗是必须的，所以也没必要扩容了，拷贝数据到一个恰好比原数组多一个位置的新数组。</p>
<h1 id="Vector有什么问题"><a href="#Vector有什么问题" class="headerlink" title="Vector有什么问题?"></a>Vector有什么问题?</h1><ol>
<li> Vector是线程安全的列表，底层实现也是数组，但是几乎每一个方法都加上了synchonized，多线程读操作之间会互斥，读多写少的情况下，吞吐量不高</li>
<li> Vector扩容，容量是翻倍，指数增长，ArrayList只增长为原来的1.5倍，更节约空间。</li>
</ol>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>集合类</tag>
        <tag>CopyOnWriteArrayList</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-LinkedHashMap</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-LinkedHashMap/</url>
    <content><![CDATA[<h1 id="LinkedHashMap特点"><a href="#LinkedHashMap特点" class="headerlink" title="LinkedHashMap特点"></a>LinkedHashMap特点</h1><p>作用：记录HashMap插入元素的顺序或访问元素的顺序</p>
<p>原理：双向链表和哈希表的结合</p>
<p>使用场景：适用于实现缓存，用空间换时间，如LRU</p>
<p>继承HashMap，大部分操作和HashMap实现一致</p>
<h1 id="元素的顺序在访问时是怎样体现的？"><a href="#元素的顺序在访问时是怎样体现的？" class="headerlink" title="元素的顺序在访问时是怎样体现的？"></a>元素的顺序在访问时是怎样体现的？</h1><p>构造函数可以指定accessOrder：</p>
<ul>
<li>true表示记录元素访问顺序。</li>
<li>false表示记录元素插入的顺序，默认为false。</li>
</ul>
<p>创建一个记录元素访问顺序的LinkedHashMap：<br><code>new LinkedHashMap(16, 0.75f, true)</code></p>
<ul>
<li>记录元素插入顺序时，通过迭代器遍历时，先插入的元素会先访问到。</li>
<li>记录元素访问顺序时，刚访问过的元素会调整到链表末尾，通过迭代器遍历时，先遍历到的是最久没有被访问过的元素。</li>
</ul>
<h1 id="为什么最新插入和最后访问的要放在末尾？"><a href="#为什么最新插入和最后访问的要放在末尾？" class="headerlink" title="为什么最新插入和最后访问的要放在末尾？"></a>为什么最新插入和最后访问的要放在末尾？</h1><p>插入新元素默认就是在链表尾部插入，是符合常规逻辑的，最新访问的放在末尾也就是统一这个规则了。</p>
<h1 id="LinkedHashMap实现原理？"><a href="#LinkedHashMap实现原理？" class="headerlink" title="LinkedHashMap实现原理？"></a>LinkedHashMap实现原理？</h1><p>双向链表的结点类继承HashMap桶中链表的结点类，增加了前后指针，实际效果如下：</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825215429.png"></p>
<h1 id="LinkedHashMap有什么应用？"><a href="#LinkedHashMap有什么应用？" class="headerlink" title="LinkedHashMap有什么应用？"></a>LinkedHashMap有什么应用？</h1><p>LRU缓存。</p>
<p>用LinkedHashMap手撕 <a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode.146. LRU 缓存机制（难度：中等）</a></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> map = LinkedHashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map[key] ?: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size == capacity &amp;&amp; !map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">val</span> oldest = map.iterator().next()</span><br><span class="line">            map.remove(oldest.key)</span><br><span class="line">        &#125;</span><br><span class="line">        map[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-TreeMap、ConcurrentSkipListMap</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/</url>
    <content><![CDATA[<h1 id="TreeMap作用"><a href="#TreeMap作用" class="headerlink" title="TreeMap作用"></a>TreeMap作用</h1><ul>
<li> 元素可以按key保持顺序。</li>
<li> 因为有序，提供了很多范围查询的方法，非常方便。</li>
</ul>
<h1 id="TreeMap的实现"><a href="#TreeMap的实现" class="headerlink" title="TreeMap的实现"></a>TreeMap的实现</h1><p>TreeMap实现了NavigableMap接口，该接口又继承SortedMap接口，两个提供了很多范围查询的方法，非常方便。</p>
<p>用红黑树实现，插入、删除、查询的平均时间复杂度都是log(n)。</p>
<h1 id="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap"><a href="#TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap" class="headerlink" title="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?"></a>TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?</h1><ol>
<li> 因为红黑树的结构调整可能涉及整个树的结点，这样并发下就要锁住很多结点，使用跳表会更局部一点，只锁住局部的几个结点，并发性能更高。</li>
<li> 红黑树加锁实现起来比较复杂，跳表是链表加锁比较容易实现</li>
</ol>
<p>可以用过Collections.synchronizedSortedMap()保证线程安全，也可以改用ConcurrentSkipListMap并发性能更好。</p>
<h1 id="TreeMap为什么用红黑树不用AVL树？"><a href="#TreeMap为什么用红黑树不用AVL树？" class="headerlink" title="TreeMap为什么用红黑树不用AVL树？"></a>TreeMap为什么用红黑树不用AVL树？</h1><p>跟HashMap中的问题一样。</p>
<p>红黑树的3结点可以吸收变化，在多次使用中可以减少调整数据结构的次数，从而提升性能。</p>
<h1 id="ConcurrentSkipListMap是什么？"><a href="#ConcurrentSkipListMap是什么？" class="headerlink" title="ConcurrentSkipListMap是什么？"></a>ConcurrentSkipListMap是什么？</h1><p>跳表：链表+多级索引（多层链表）。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825212310.png"></p>
<ul>
<li>给有序链表再增加若干层额外的指针索引，用空间换时间。</li>
<li>每一层都是一个有序链表。</li>
<li>实际效果类似于平衡二叉搜索树。</li>
<li>插入、删除、查询的平均时间复杂度都是log(n)。</li>
<li>支持按key排序所有元素，也支持快速查找。</li>
</ul>
<h1 id="跳表的数据结构存在什么问题？"><a href="#跳表的数据结构存在什么问题？" class="headerlink" title="跳表的数据结构存在什么问题？"></a>跳表的数据结构存在什么问题？</h1><p>按照理想的生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。</p>
<h1 id="跳表与红黑树区别？"><a href="#跳表与红黑树区别？" class="headerlink" title="跳表与红黑树区别？"></a>跳表与红黑树区别？</h1><ol>
<li> 红黑树为了保持平衡有可能会调整很多结点甚至整个树，而跳表只要修改相邻结点更加的局部，跳表调整次数少性能也就高，同时并发加锁时，锁住的结点更少，可以减少竞争</li>
<li> 跳表的区间查询更高效，因为找到链表头结点顺序遍历就行了，红黑树需要中序遍历相对比较复杂</li>
<li> 跳表占用空间更少，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
</ol>
<h1 id="ConcurrentSkipListMap存在什么问题？"><a href="#ConcurrentSkipListMap存在什么问题？" class="headerlink" title="ConcurrentSkipListMap存在什么问题？"></a>ConcurrentSkipListMap存在什么问题？</h1><p>size方法求得链表长度要遍历整个链表，并且没有加锁，多线程高并发下这个方法返回值并不准确，高并发下使用size的意义不大。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/yd2sOhmVtZeEkJ06cTE7qA"> 死磕 java集合之ConcurrentSkipListMap源码分析——发现个bug</a></li>
<li><a href="https://stackoverflow.com/questions/1811782/when-should-i-use-concurrentskiplistmap">When should I use ConcurrentSkipListMap?</a></li>
<li><a href="https://www.zhihu.com/question/20202931/answer/16086538">为啥 redis 使用跳表(skiplist)而不是使用 red-black？ - 于康的回答 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>TreeMap</tag>
        <tag>ConcurrentSkipListMap</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（冒泡、选择、插入、希尔、快速、归并、堆、计数）</title>
    <url>/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>左侧无序区域中的最大数字交换到右侧已排序区域的最左侧。</p>
<h3 id="冒泡排序代码"><a href="#冒泡排序代码" class="headerlink" title="冒泡排序代码"></a>冒泡排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// nums[0, n - 1 - i]是无序区域，初始时整个数组无序</span></span><br><span class="line">            <span class="comment">// nums[n - i,n - 1]是有序区域，是数组中大的数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一趟冒泡是否有交换发生</span></span><br><span class="line">            <span class="keyword">var</span> isNotSwapped = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为要比较当前和下一个数大小，所以j只能取到n - 1 - i的前一个数</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span> - i) &#123;</span><br><span class="line">                <span class="comment">// 不是升序，就要交换一下</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换</span></span><br><span class="line">                    <span class="keyword">val</span> tmp = nums[j + <span class="number">1</span>]</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">                    nums[j] = tmp</span><br><span class="line">                    <span class="comment">// 标记有交换</span></span><br><span class="line">                    isNotSwapped = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有交换，说明无序区域已经有序，那么整个数组也是有序的了</span></span><br><span class="line">            <span class="keyword">if</span> (isNotSwapped) <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>冒泡排序是稳定的</strong>。</p>
<p>因为交换是当前数大于下一个数才会交换。</p>
<p>如果有<code>x1 == x2</code>，<code>x1</code>在<code>x2</code>左边，<code>x1</code>始终不会被交换到<code>x2</code>右边。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="一句话描述-1"><a href="#一句话描述-1" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>右侧未排序区域选取一个最小的数，交换到前面已排序区域的末尾。</p>
<h3 id="选择排序代码"><a href="#选择排序代码" class="headerlink" title="选择排序代码"></a>选择排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// s[0,i-1]为已排序区域，s[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序取一个最小的放入已排序区域的末尾  </span></span><br><span class="line">  <span class="keyword">var</span> minIndex = i  </span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;  </span><br><span class="line">                    minIndex = j  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 将未排序区域中最小值与已排序区域末尾的下一个位置的数字交换  </span></span><br><span class="line">  <span class="comment">// 已排序区域末尾的下一个位置就是i了，最小值索引是minIndex  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[minIndex]  </span><br><span class="line">            nums[minIndex] = nums[i]  </span><br><span class="line">            nums[i] = tmp  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>选择排序不稳定</strong>，因为发生了位置交换。</p>
<p>由于每次会在后面的未排序区域选择最小的数字与前面的已排序区域末尾元素交换，如果未排序区域交换的位置的前面有与已排序区域末尾元素相等的元素，这两个元素的相对位置就变了。</p>
<p>例如[2, 3, 4, 2, 1]，第一趟选择会把最小的1放到最前面，第一个2交换到最后面，这样两个2的相对顺序就变了。</p>
<p>如何不发生位置交换呢？</p>
<p>有两种做法：</p>
<ul>
<li>一个是开辟一个新数组，把最小的放到第一个位置上，把第二小的放到第二个位置上等等。空间复杂度是O(n)。</li>
<li>一个是使用链表，空间复杂度是O(1)。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>交换次数比冒泡排序少，交换次数是跟数组长度呈线性关系。</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h3 id="一句话描述-2"><a href="#一句话描述-2" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>扑克牌拿牌后插牌的排序：把数组右侧未排序区域的最左侧元素插入数组左侧已排序区域中。</p>
<h3 id="直接插入排序代码"><a href="#直接插入排序代码" class="headerlink" title="直接插入排序代码"></a>直接插入排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="comment">// 初始时未排序区域共有n个数，每次向左侧已排序区域插入一个数，总共需要插入n次  </span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// nums[0,i-1]为已排序区域  </span></span><br><span class="line">  <span class="comment">// nums[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序区域第一个元素开始，从后往前一个个跟已排序区域数字比较，相邻两个数字顺序不对就交换，直至顺序正确  </span></span><br><span class="line">  <span class="comment">// 由于要比较当前数字和前一个数字的大小，所以索引j最少只能取到第2个元素位置即索引1  </span></span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果相邻两个数不是升序则需要交换  </span></span><br><span class="line">  <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                    <span class="comment">// 交换元素  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[j]  </span><br><span class="line">                    nums[j] = nums[j - <span class="number">1</span>]  </span><br><span class="line">                    nums[j - <span class="number">1</span>] = tmp  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>已排序区域寻找插入位置可以使用二分查找。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适合部分有序的数组，这样比较次数就会大大减少，从而提高效率。</p>
<p>对于大规模乱序的数组，插入排序很慢，因为只会交换相邻的元素，元素只能一步一步的从数组的一端移动到另一端。</p>
<p>例如，如果是升序排序，数组最小的元素在数组末尾，那么移动到开头就要交换N-1次。如果有一个完全降序的数组，用插入排序变为升序的话，要做的事情太多了。</p>
<p>给定一个10万个元素的数组，部分有序，部分无序，选择哪一种排序算法最好？</p>
<p>用插入排序，插入排序在已排序区域寻找插入位置可以用二分法加快寻找</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h3 id="一句话描述-3"><a href="#一句话描述-3" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>先大步再小步的插入排序。</p>
<p>大步插入排序使得用很少的交换次数让数组变得部分有序，从而在小步排序时发挥插入排序的优势，达到总体的比较和交换次数变少。</p>
<h3 id="希尔排序代码"><a href="#希尔排序代码" class="headerlink" title="希尔排序代码"></a>希尔排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (d &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            d = <span class="number">3</span> * d + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> d until n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo d step d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[j - d]) &#123;</span><br><span class="line">                        <span class="keyword">val</span> tmp = nums[j]</span><br><span class="line">                        nums[j] = nums[j - d]</span><br><span class="line">                        nums[j - d] = tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递增序列如何选择？不同的递增序列有什么影响？"><a href="#递增序列如何选择？不同的递增序列有什么影响？" class="headerlink" title="递增序列如何选择？不同的递增序列有什么影响？"></a>递增序列如何选择？不同的递增序列有什么影响？</h3><blockquote>
<p>《算法（第4版）》</p>
<p>如何选择递增序列呢？要回答这个问题并不简单。算法的性能不仅取决于h，还取决于h 之间的数学性质，比如它们的公因子等。</p>
<p>有很多论文研究了各种不同的递增序列，但都无法证明某个序列是 “ 最好的” 。</p>
<p>算法2.3中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。但可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。</p>
</blockquote>
<p>一个简单的序列选择：<br>从1开始，一直 d * 3 + 1，直到小于 n / 3。</p>
<h3 id="希尔排序更高效的原因？"><a href="#希尔排序更高效的原因？" class="headerlink" title="希尔排序更高效的原因？"></a>希尔排序更高效的原因？</h3><p>希尔排序权衡了数组的规模和有序性。</p>
<p>排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p>
<p>子数组部分有序的程度取决于递增序列的选择。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>在大规模乱序的情况下，希尔排序可以减少元素交换的次数，数组越大优势越大。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>选取一个轴心元素，将数组划分成比这个数小的和比这个数字大的两个子数组，分别对两个子数组递归调用划分。</p>
<h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">val</span> pivotIndex = partition(nums, low, high)</span><br><span class="line">        quickSort(nums, low, pivotIndex - <span class="number">1</span>)</span><br><span class="line">        quickSort(nums, pivotIndex + <span class="number">1</span>, high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start = low</span><br><span class="line">    <span class="keyword">var</span> end = high</span><br><span class="line">    <span class="keyword">val</span> pivot = nums[start]</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] &gt;= pivot) &#123;</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] &lt;= pivot) &#123;</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[end] = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么partition()里的while判断条件里low不能等于high？</strong></p>
<p>因为一开始取pivot就已经挖空了一个位置。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>每次划分，轴心元素就在最终排序完成后的位置上。</p>
<h3 id="快排为什么是O-n-log-n-复杂度？"><a href="#快排为什么是O-n-log-n-复杂度？" class="headerlink" title="快排为什么是O(n log n)复杂度？"></a>快排为什么是O(n log n)复杂度？</h3><p>根据主定理推导。</p>
<p>参考： <a href="https://www.zhihu.com/question/22393997/answer/406278523">如何证明快速排序法的平均复杂度为 O(nlogn)？ - 知乎 </a></p>
<h3 id="什么会影响时间复杂度？"><a href="#什么会影响时间复杂度？" class="headerlink" title="什么会影响时间复杂度？"></a>什么会影响时间复杂度？</h3><p>用于划分数组的中枢元素的选择会影响时间复杂度，划分的左右子数组数量越接近效果越好，否则会让整个快速排序退化到O(n^2)级别。</p>
<p>具体怎么划分要根据数组本身的数据分布特性来决定</p>
<p>以下情况会变得低效：</p>
<p>（1）近乎有序的数列</p>
<p>对于一个近乎有序的数列，当直接使用第一个元素作为基准点的时候，将会导致划分的子数组大小差距太大，进而无法发挥快排划分的优势</p>
<p>（2）含有大量重复数据的数列</p>
<p>選取的數字如果是重複較多的數字，划分出的两个子数组有一边的长度会很大，因为移动指针的时候，判断条件是大于等于和小于等于枢纽元素</p>
<h3 id="如何优化时间复杂度？"><a href="#如何优化时间复杂度？" class="headerlink" title="如何优化时间复杂度？"></a>如何优化时间复杂度？</h3><p>针对近乎有序的数组：</p>
<p><strong>三数取中法</strong></p>
<p>选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间大的数交换到数列首位的位置，之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。</p>
<p><a href="https://leetcode-cn.com/problems/sort-colors/">LeetCode.75.颜色分类（中等）</a>正好就是用到这种方法。</p>
<p><strong>随机交换法</strong></p>
<p>选取基准点之前设计随机种子，通过随机函数得到一个在数列长度内的数，将这个随机数作为索引所指的数和第一个元素进行交换，之后将首位元素作为基准点。即随机选一个数放到首位的地方。这样一来，第一次就将最小的数交换到首位的概率是非常小的，第二次将次小的数交换到首位的概率依然非常的小。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h3 id="一句话说明"><a href="#一句话说明" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>堆就是一个完全二叉树，堆排序两步走：<br>建堆：从最后一个非叶子节点到根结点不停的向下调整堆。<br>排序调整：堆顶元素与数组末尾元素交换，再向下调整堆顶元素。</p>
<h3 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        buildHeap(nums)</span><br><span class="line">        <span class="comment">// 堆顶最大的元素与数组末尾的数字进行交换</span></span><br><span class="line">        <span class="comment">// 堆大小减1</span></span><br><span class="line">        <span class="comment">// 新的堆顶元素可能破坏最大堆性质，需要向下调整，把缩小后的堆的最大的元素放到堆顶</span></span><br><span class="line">        <span class="comment">// 重复如此最后堆大小缩减为0，原数组从末尾开始向前填充大的数，最后得到升序数组</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> nums.size downTo <span class="number">1</span>) &#123;</span><br><span class="line">            nums.swap(<span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">            sink(nums, <span class="number">1</span>, length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildHeap</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 给数组元素从1到n编号，最后一个非叶节点的编号为n/2</span></span><br><span class="line">        <span class="comment">// 从最后一个非叶节点开始往前不停的向下调整堆</span></span><br><span class="line">        <span class="comment">// 如果一个结点的左右子树已经是堆，从该结点向下调整后该结点为根结点的二叉树依然保持着堆的性质</span></span><br><span class="line">        <span class="comment">// 所以可以从下往上不停的向下调整</span></span><br><span class="line">        <span class="keyword">for</span> (parent <span class="keyword">in</span> n / <span class="number">2</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            sink(nums, parent, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对[nums]的第[k]个元素为根结点的子堆进行向下调整，把大的元素放到堆顶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要从[k]向下调整是因为[k]与孩子结点可能不满足堆性质</span></span><br><span class="line"><span class="comment">     * 初始时已经建立了堆，交换前我们可以认定k的左右子树都已经满足最大堆的性质，即k的左右子结点一定比它下面的所有结点值都大</span></span><br><span class="line"><span class="comment">     * 如果k当前比左右孩子最大的一个要小，当把k的左右孩子结点与k交换，依然满足k大于所有其孩子结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sink</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> parent = k</span><br><span class="line">        <span class="comment">// 最后一个非叶节点编号是length/2</span></span><br><span class="line">        <span class="comment">// parent初始时是在上层的结点，一直会往下遍历，一直遍历到最后一个非叶节点</span></span><br><span class="line">        <span class="keyword">while</span> (parent &lt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 找出较小的孩子结点child</span></span><br><span class="line">            <span class="keyword">var</span> child = parent * <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果child不是最后一个元素，对比下其相邻的孩子谁更大，取更大的孩子结点，以便接下来跟其父结点parent比较，检查是否满足最大堆的性质</span></span><br><span class="line">            <span class="keyword">if</span> (child &lt; length &amp;&amp; nums[child - <span class="number">1</span>] &lt; nums[child]) child++</span><br><span class="line">            <span class="comment">// 因为初始已经建了最大堆，我们可以认定parent的左右子树都已经满足堆的性质</span></span><br><span class="line">            <span class="comment">// 如果当前parent与child也满足堆性质，则不用继续调整了</span></span><br><span class="line">            <span class="comment">// 这里构建的是大顶堆，要求父结点比孩子结点要大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[parent - <span class="number">1</span>] &gt;= nums[child - <span class="number">1</span>]) <span class="keyword">break</span></span><br><span class="line">            <span class="comment">// 父结点比孩子结点小，不满足最大堆性质，交换父结点和孩子结点的值，以满足最大堆性质</span></span><br><span class="line">            nums.swap(parent - <span class="number">1</span>, child - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 交换后，以孩子结点child为根的子堆可能不满足最大堆性质，继续向下检查调整</span></span><br><span class="line">            parent = child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组IntArray的扩展函数swap，用以交换数组内两个位置[i]和[j]的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？"><a href="#堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？" class="headerlink" title="堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？"></a>堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？</h3><p>因为堆是一种完全二叉树，访问的数据不在内存中连续的区域，空间访问局部性效果不太好，缓存命中率低，进而降低了程序运行速度。</p>
<p>快速排序会访问数组相邻的元素，空间访问局部性比较好，程序运行速度快。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="一句话说明-1"><a href="#一句话说明-1" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>归并两个子数组为一个有序数组。</p>
<p>可以自顶向下递归进行，也可以自底向上迭代进行。</p>
<h3 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h3><p>自顶向下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下，分而治之</span></span><br><span class="line"><span class="comment">     * 类似于二叉树后序遍历的写法，理解二叉树后续遍历这个递归写法就好理解对应上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素的时候，low与high相等，只有一个数字的子数组认定是有序的，不需要再排序了</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            mergeSort(nums, low, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自底向上：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 从最小的子数组开始向上归并，最小的子数组长度是1，每次向上归并后子数组大小变为原来的两倍</span></span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (size &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 按照子数组的大小将长度为n的数组划分为n/size个子数组</span></span><br><span class="line">            <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 依次归并 n/size 个子数组</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; n - size) &#123;</span><br><span class="line">                <span class="comment">// 第一个子数组的右边界索引（包含）</span></span><br><span class="line">                <span class="keyword">val</span> mid = low + size - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 第二个子数组的右边界索引（包含），最后一个子数组可能只包含的元素个数较少，需要防止数组越界</span></span><br><span class="line">                <span class="keyword">val</span> high = min(low + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 归并两个子数组</span></span><br><span class="line">                merge(nums, low, mid, high)</span><br><span class="line">                <span class="comment">// 每次归并2个子数组，所以下一次归并发生在第三个子数组的位置</span></span><br><span class="line">                low += size * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            size *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h3 id="一句话说明-2"><a href="#一句话说明-2" class="headerlink" title="一句话说明"></a>一句话说明</h3><ol>
<li> 记录待排序数组每个取值的个数</li>
<li> 用一个数组累加记录有多少数是小于等于当前索引I</li>
<li> 逆序输出</li>
</ol>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> w = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [nums]取值范围在1到w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> copied = nums.copyOf()</span><br><span class="line">        <span class="keyword">val</span> count = IntArray(w + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 统计每个取值有多少个</span></span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            count[num]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加计数</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.w) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序遍历原数组，保持元素相对顺序不变</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> index = count[copied[i]] - <span class="number">1</span></span><br><span class="line">            nums[index] = copied[i]</span><br><span class="line">            count[copied[i]]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么最后要逆序遍历原数组？"><a href="#为什么最后要逆序遍历原数组？" class="headerlink" title="为什么最后要逆序遍历原数组？"></a>为什么最后要逆序遍历原数组？</h3><ol>
<li> 这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边，从而保证排序的稳定性</li>
<li> 如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法，但如果不关注稳定性，那么结果还是正确的</li>
</ol>
<p>保证相同的数字还是按照原数组中的顺序，保证稳定性</p>
<p>比如[1,2,3,4,5,5,5]</p>
<p>最后从后向前遍历原数组，3个5的输出顺序还是跟原数组的顺序是一致的</p>
<p>如果是从前向后输出，3个5的位置正好倒过来了，因为最终排序的索引是通过计数来得到的，计数是从大到小的，所以最后相同值的索引位置的计算是从大到小的，也就是说相同值的索引位置是从后往前的，如果顺序遍历原数组，遇到几个相同的数字，会先把前面的数字先放到后面了</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>O(n)时间复杂度</p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>数组取值范围是常数范围。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Class常量池、运行时常量池、字符串常量池</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Class%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="Class常量池"><a href="#Class常量池" class="headerlink" title="Class常量池"></a>Class常量池</h1><h2 id="Class常量池在哪，是做什么的？"><a href="#Class常量池在哪，是做什么的？" class="headerlink" title="Class常量池在哪，是做什么的？"></a>Class常量池在哪，是做什么的？</h2><p>每个Class文件中都有常量池，位于魔数和主次版本号之后，是Class文件中第一个出现的表类型的数据项，占用空间最大的数据项之一，也是与其他项目关联最多的数据类型。</p>
<p>Class常量池主要存放：</p>
<ol>
<li> 字面量（Literal）</li>
<li> 符号引用（Symbolic References）</li>
</ol>
<p>可以理解为Class文件中的资源仓库。</p>
<p>参考《深入理解Java虚拟机（第2版）》168页 6.3.2 常量池。</p>
<h3 id="字面量是什么？"><a href="#字面量是什么？" class="headerlink" title="字面量是什么？"></a>字面量是什么？</h3><p>直观的数据值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 100;</span><br><span class="line">float f = 2.3f;</span><br><span class="line">String s = &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
<p>100、2.3f、”abc”是字面量</p>
<p>0x1FB等十六进制、八进制、二进制等直观的数据值也是字面量。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/55994121/answer/147296098">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎 </a></li>
<li><a href="https://www.cnblogs.com/itplay/p/11137526.html">Java 8 中的常量池、字符串池、包装类对象池</a></li>
</ul>
<h3 id="符号引用是什么？"><a href="#符号引用是什么？" class="headerlink" title="符号引用是什么？"></a>符号引用是什么？</h3><ol>
<li> 类和接口的全限定名</li>
<li> 字段的名称和描述符 </li>
<li> 方法的名称和描述符</li>
</ol>
<blockquote>
<p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。</p>
<p>也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</p>
<p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<p>因为java要支持动态性，所以不能在编译期就确定最终的内存布局。</p>
<p>参考《深入理解Java虚拟机（第2版）》168页 6.3.2 常量池。</p>
<h4 id="字段描述符和方法的描述符是什么？"><a href="#字段描述符和方法的描述符是什么？" class="headerlink" title="字段描述符和方法的描述符是什么？"></a>字段描述符和方法的描述符是什么？</h4><p>字段的描述符唯一确定一个字段，方法的描述符唯一确定一个方法。</p>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》177页 6.3.5 字段表集合</li>
<li><a href="https://blog.csdn.net/zhangjg_blog/article/details/21487287">深入理解Java Class文件格式（二）</a></li>
</ul>
<h2 id="Class常量池的实际存储格式是什么样的"><a href="#Class常量池的实际存储格式是什么样的" class="headerlink" title="Class常量池的实际存储格式是什么样的?"></a>Class常量池的实际存储格式是什么样的?</h2><p>常量池整体上分为两部分：</p>
<ul>
<li>常量池计数器</li>
<li>常量池数据区</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235549.png"></p>
<p>常量池计数器（constant_pool_count）：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。</p>
<p>常量池数据区：数据区是由（constant_pool_count-1）个cp_info结构组成，一个cp_info结构对应一个常量。在字节码中共有14种类型的cp_info（如下图6所示），每种类型的结构都是固定的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235546.png"></p>
<p>具体以CONSTANT_utf8_info为例，它的结构如下图7左侧所示。首先一个字节“tag”，它的值取自上图6中对应项的Tag，由于它的类型是utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度Length，然后Length个字节为这个字符串具体的值。从图2中的字节码摘取一个cp_info结构，如下图7右侧所示。将它翻译过来后，其含义为：该常量类型为utf8字符串，长度为一字节，数据为“a”。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235548.png"></p>
<p>参考</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》168页 6.3.2 常量池</li>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
</ul>
<h2 id="Class常量池一个具体内容的例子？"><a href="#Class常量池一个具体内容的例子？" class="headerlink" title="Class常量池一个具体内容的例子？"></a>Class常量池一个具体内容的例子？</h2><p>定义如下的类：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0x101</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">this</span>.value = temp + v; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>生成的class常量池如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constant pool: </span><br><span class="line">   #1 = Methodref          #6.#29         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">   #2 = Fieldref           #5.#30         // JavaBasicKnowledge/JavaBean.value:I </span><br><span class="line">   #3 = String             #31            // abc </span><br><span class="line">   #4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.s:Ljava/lang/String; </span><br><span class="line">   #5 = Class              #33            // JavaBasicKnowledge/JavaBean </span><br><span class="line">   #6 = Class              #34            // java/lang/Object </span><br><span class="line">   #7 = Utf8               value </span><br><span class="line">   #8 = Utf8               I </span><br><span class="line">   #9 = Utf8               s </span><br><span class="line">  #10 = Utf8               Ljava/lang/String; </span><br><span class="line">  #11 = Utf8               f </span><br><span class="line">  #12 = Utf8               ConstantValue </span><br><span class="line">  #13 = Integer            257 </span><br><span class="line">  #14 = Utf8               &lt;init&gt; </span><br><span class="line">  #15 = Utf8               ()V </span><br><span class="line">  #16 = Utf8               Code </span><br><span class="line">  #17 = Utf8               LineNumberTable </span><br><span class="line">  #18 = Utf8               LocalVariableTable </span><br><span class="line">  #19 = Utf8               this </span><br><span class="line">  #20 = Utf8               LJavaBasicKnowledge/JavaBean; </span><br><span class="line">  #21 = Utf8               setValue </span><br><span class="line">  #22 = Utf8               (I)V </span><br><span class="line">  #23 = Utf8               v </span><br><span class="line">  #24 = Utf8               temp </span><br><span class="line">  #25 = Utf8               getValue </span><br><span class="line">  #26 = Utf8               ()I </span><br><span class="line">  #27 = Utf8               SourceFile </span><br><span class="line">  #28 = Utf8               StringConstantPool.java </span><br><span class="line">  #29 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V </span><br><span class="line">  #30 = NameAndType        #7:#8          // value:I </span><br><span class="line">  #31 = Utf8               abc </span><br><span class="line">  #32 = NameAndType        #9:#10         // s:Ljava/lang/String; </span><br><span class="line">  #33 = Utf8               JavaBasicKnowledge/JavaBean </span><br><span class="line">  #34 = Utf8               java/lang/Object </span><br></pre></td></tr></table></figure>

<p>字面量：</p>
<p>这里需要说明的一点，上面说的存在于常量池的字面量，指的是数据的值，也就是abc和0x101(257),通过上面对常量池的观察可知这两个字面量是确实存在于常量池的。</p>
<p>而对于基本类型数据(甚至是方法中的局部变量)，也就是上面的private int value = 1;常量池中只保留了他的的字段描述符I和字段的名称value，他们的字面量不会存在于常量池。</p>
<p>符号引用：</p>
<p>对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1450501">彻底弄懂java中的常量池</a></li>
</ul>
<h2 id="一个方法名最多可以有多长？"><a href="#一个方法名最多可以有多长？" class="headerlink" title="一个方法名最多可以有多长？"></a>一个方法名最多可以有多长？</h2><p>在HotSpot VM中，运行时常量池里，CONSTANT_Utf8_info可以表示Class文件的方法、字段等等，其结构如下：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235522.png"></p>
<p>首先是1个字节的tag,表示这是一个CONSTANT_Utf8_info结构的常量，然后是两个字节的length，表示要储存字节的长度，之后是一个字节的byte数组，表示真正的储存的length个长度的字符串。这里需要注意的是，一个字节只是代表这里有一个byte类型的数组，而这个数组的长度当然可以远远大于一个字节。当然，由于CONSTANT_Utf8_info结构只能用u2即两个字节来表示长度，因此长度的最大值为2byte，也就是65535。</p>
<h2 id="Android虚拟机的Class常量池跟JVM的有什么不同？"><a href="#Android虚拟机的Class常量池跟JVM的有什么不同？" class="headerlink" title="Android虚拟机的Class常量池跟JVM的有什么不同？"></a>Android虚拟机的Class常量池跟JVM的有什么不同？</h2><blockquote>
<p>Java从设计之初就非要支持分离编译（separate compilation）与按需动态类加载（on-demand dynamic class loading），导致Java的Class文件必须独立的（self-contained）——每个Class文件必须自己携带自己的常量池，其主要信息是字符串与若干其它常量的值，以及用于符号链接的符号引用信息（symbolic reference）。</p>
<p>如果大家关注过Class文件的内容的话，会知道其实通常Class文件里表示程序逻辑的代码部分——“字节码”——只占Class文件大小的小头；而大头都被常量池占了。而且多个Class文件的常量池内容之间常常有重叠，所以当程序涉及多个Class文件时，就容易有冗余信息，不利于减少传输/存储代码的大小。</p>
<p>大家或许还记得Google在Google I/O 2008的<a href="https://link.zhihu.com/?target=https://sites.google.com/site/io/dalvik-vm-internals">Dalvik VM Internals</a>演讲里，Dan得意的介绍到Dalvik的Dex格式在未压缩的情况下都比压缩了的JAR文件还小么？</p>
<p>Dan准确的介绍了Dex体积更小的原因：一个Dex相当于一个或多个JAR包，里面可以包含多个Class文件对应的内容。一个Dex文件里的所有Class都共享同一个常量池，因而不会像Class文件那样在多个常量池之间有冗余。这样Dex文件就等同于在元数据层面上对JAR文件做了压缩，所以前者比后者更小。</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/35777031/answer/64575683">栈式虚拟机和寄存器式虚拟机？</a> </li>
</ul>
<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h2 id="字符串常量池在内存区域中的哪一块？"><a href="#字符串常量池在内存区域中的哪一块？" class="headerlink" title="字符串常量池在内存区域中的哪一块？"></a>字符串常量池在内存区域中的哪一块？</h2><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210225235523.png"></p>
<p>方法区实际上是在一块叫“非堆”的区域包含——可以简单粗略的理解为非堆中包含了永生代，而永生代中又包含了方法区和字符串常量池。</p>
<p>其中的Interned String就是全局共享的“字符串常量池（String Pool）”，和运行时常量池不是一个概念。但我们在代码中申明String s1 = “Hello”;这句代码后，在类加载的过程中，类的class文件的信息会被解析到内存的方法区里。</p>
<p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。</p>
<p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p>
<h2 id="String-s1-“Hello”，到底有没有在堆中创建对象？"><a href="#String-s1-“Hello”，到底有没有在堆中创建对象？" class="headerlink" title="String s1 = “Hello”，到底有没有在堆中创建对象？"></a>String s1 = “Hello”，到底有没有在堆中创建对象？</h2><p>class文件里常量池里大部分数据会被加载到“运行时常量池”，包括String的字面量；但同时“Hello”字符串的一个引用会被存到同样在“非堆”区域的“字符串常量池”中，而”Hello”本体还是和所有对象一样，创建在Java堆中。</p>
<p>当主线程开始创建s1时，虚拟机会先去字符串池中找是否有equals(“Hello”)的String，如果相等就把在字符串池中“Hello”的引用复制给s1；如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。</p>
<p>当用字面量赋值的方法创建字符串时，无论创建多少次，只要字符串的值相同，它们所指向的都是堆中的同一个对象。</p>
<h2 id="字符串常量池本质是个什么东西？"><a href="#字符串常量池本质是个什么东西？" class="headerlink" title="字符串常量池本质是个什么东西？"></a>字符串常量池本质是个什么东西？</h2><p>字符串常量池是JVM所维护的一个字符串实例的引用表。</p>
<p>在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。</p>
<h2 id="String”字面量”-是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？"><a href="#String”字面量”-是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？" class="headerlink" title="String”字面量” 是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？"></a>String”字面量” 是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？</h2><p>在执行ldc指令时，该指令表示int、float或String型常量从常量池推送至栈顶。</p>
<blockquote>
<p>ldc全称：load constant</p>
</blockquote>
<p>就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生），在执行ldc指令时，触发lazy resolution这个动作。</p>
<p>ldc字节码在这里的执行语义是：到当前类的运行时常量池（runtime constant pool，HotSpot VM里是ConstantPool + ConstantPoolCache）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。</p>
<p>在遇到String类型常量时，resolve的过程如果发现StringTable已经有了内容匹配的java.lang.String的引用，则直接返回这个引用，反之，如果StringTable里尚未有内容匹配的String实例的引用，则会在Java堆里创建一个对应内容的String对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p>
<p>可见，ldc指令是否需要创建新的String实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的String的引用。</p>
<h2 id="String-intern-用法和规则是什么？"><a href="#String-intern-用法和规则是什么？" class="headerlink" title="String.intern()用法和规则是什么？"></a>String.intern()用法和规则是什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">		System.out.println(str1.intern() == str1);</span><br><span class="line">		String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">		System.out.println(str2.intern() == str2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>以上代码，在 JDK6 下执行结果为 false、false，在 JDK7 以上执行结果为 true、false。</p>
<p>首先我们调用StringBuilder创建了一个”计算机软件”String对象，因为调用了new关键字，因此是在运行时创建，之前JVM中是没有这个字符串的。</p>
<p>在 JDK6 下，intern()会把首次遇到的字符串实例复制到永久代中，返回的也是这个永久代中字符串实例的引用；而在JDK1.7开始，intern()方法不再复制字符串实例，String 的 intern 方法首先将尝试在常量池中查找该对象的引用，如果找到则直接返回该对象在常量池中的引用地址。</p>
<p>因此在1.7中，“计算机软件”这个字符串实例只存在一份，存在于java堆中！通过3中的分析，我们知道当String str1 = new StringBuilder(“计算机”).append(“软件”).toString();这句代码执行完之后，已经在堆中创建了一个字符串对象，并且在全局字符串常量池中保留了这个字符串的引用，那么str1.intern()直接返回这个引用，这当然满足str1.intern() == str1——都是他自己嘛；对于引用str2，因为JVM中已经有“java”这个字符串了，因此new StringBuilder(“ja”).append(“va”).toString()会重新创建一个新的“java”字符串对象，而intern()会返回首次遇到的常量的实例引用，因此他返回的是系统中的那个”java”字符串对象引用(首次)，因此会返回false。</p>
<p>在 JDK6 下 str1、str2 指向的是新创建的对象，该对象将在 Java Heap 中创建，所以 str1、str2 指向的是 Java Heap 中的内存地址；调用 intern 方法后将尝试在常量池中查找该对象，没找到后将其放入常量池并返回，所以此时 str1/str2.intern() 指向的是常量池中的地址，JDK6常量池在永久代，与堆隔离，所以 s1.intern()和s1 的地址当然不同了。</p>
<h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><h2 id="运行时常量池是什么？"><a href="#运行时常量池是什么？" class="headerlink" title="运行时常量池是什么？"></a>运行时常量池是什么？</h2><p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过加载、链接（验证、准备、解析）、初始化，在第一步加载的时候需要完成：</p>
<ol>
<li> 通过一个类的全限定名来获取此类的二进制字节流</li>
<li> 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构    </li>
<li> 在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ol>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下不同的类共用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210225235522.png"></p>
<h2 id="运行时常量池-和-驻留字符串常量池-有什么联系？"><a href="#运行时常量池-和-驻留字符串常量池-有什么联系？" class="headerlink" title="运行时常量池  和  驻留字符串常量池  有什么联系？"></a>运行时常量池  和  驻留字符串常量池  有什么联系？</h2><p>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = &quot;abc&quot;;</span><br><span class="line">String str2 = new String(&quot;def&quot;);</span><br><span class="line">String str3 = &quot;abc&quot;;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = &quot;def&quot;;</span><br><span class="line">System.out.println(str1 == str3); // true</span><br><span class="line">System.out.println(str2 == str4); // false</span><br><span class="line">System.out.println(str4 == str5); // true</span><br></pre></td></tr></table></figure>

<p>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p>
<p>回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。</p>
<p>“abc”的常量会被ldc指令从常量池推送到栈顶，ldc会触发动态解析。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/itplay/p/11137526.html">【JVM】Java 8 中的常量池、字符串池、包装类对象池</a></li>
<li><a href="https://www.zhihu.com/question/55994121/answer/147296098">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎 </a></li>
<li><a href="https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">Java中几种常量池的区分</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1450501">彻底弄懂java中的常量池</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Class常量池</tag>
        <tag>运行时常量池</tag>
        <tag>字符串常量池</tag>
        <tag>驻留字符串</tag>
        <tag>String.intern()</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-HashMap原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>JDK 1.7：</p>
<ul>
<li><a href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java</a></li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li><a href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java</a></li>
</ul>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ol>
<li> 非线程安全，所以存取速度快</li>
<li> 可以接受null的键和值</li>
<li> 不保证key有序</li>
<li> key的顺序会随时间变化（动态调整大小后会变化）</li>
</ol>
<h1 id="散列过程"><a href="#散列过程" class="headerlink" title="散列过程"></a>散列过程</h1><ol>
<li> 通过散列函数，用元素的key计算出元素在数组中的索引位置</li>
<li> 解决散列冲突，即相同散列值（数组索引位置）元素如何存取</li>
</ol>
<h1 id="散列函数的选取标准"><a href="#散列函数的选取标准" class="headerlink" title="散列函数的选取标准"></a>散列函数的选取标准</h1><ol>
<li> 易于计算</li>
<li> 均匀分布所有键</li>
</ol>
<h1 id="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"><a href="#拉链法查找一个元素的最少、最坏、平均次数分别是多少？" class="headerlink" title="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"></a>拉链法查找一个元素的最少、最坏、平均次数分别是多少？</h1><p>设哈希表大小为m，已存储的元素个数为n</p>
<p>如果散列函数把所有元素散列到一个位置，链表的长度就是n，最坏情况下就是查找链表中最后一个元素，查找次数是n</p>
<p>如果散列函数散列到哈希表每个位置的概率相同，此时元素分布最均匀，拉链法相当于把n个元素分为m组，那么每组（链表）长度最多为n/m，最坏情况下查找链表最后一个元素，需要n/m次</p>
<h1 id="桶（bucket）是什么意思？"><a href="#桶（bucket）是什么意思？" class="headerlink" title="桶（bucket）是什么意思？"></a>桶（bucket）是什么意思？</h1><p>HashMap内部的哈希表由数组实现，数组的每一个位置称为桶，存储一个链表的头结点，或红黑树的根节点，一个桶下所有元素key的hashCode都相同，元素存储在哪一个桶是根据元素key计算出数组索引位置而定的</p>
<h1 id="什么情况下会要求哈希表的大小要是质数？"><a href="#什么情况下会要求哈希表的大小要是质数？" class="headerlink" title="什么情况下会要求哈希表的大小要是质数？"></a>什么情况下会要求哈希表的大小要是质数？</h1><p>简述：</p>
<ul>
<li>关注哈希表的大小是因为求得元素在哈希表中存储存储位置是通过  key的hashCode % 哈希表大小  得到，如果散列函数计算结果不均匀，容易产生散列冲突，提高了查找次数。</li>
<li>质数不容易被整除，故而可以让计算出的索引分布的比较均匀。合数有公因子，计算出的索引位置容易聚集在公因数的位置，产生较多的散列冲突。</li>
</ul>
<p>key与哈希表大小互质，这样取模的结果就分散的比较均匀。</p>
<p>如果key可以整除哈希表大小，如果key容易在公因数的位置产生聚集，就会产生较多的散列冲突。</p>
<p>使用质数作为容量，可以使元素更分散，减少冲突；</p>
<p>如果用合数作为容量，会使元素聚集，增加冲突，增加查找次数。</p>
<p>一般是通过除留取余法确定元素在数组中存储索引位置，即：</p>
<p>元素在数组中的存储位置 = key的hashCode % 哈希表长度</p>
<p>假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。</p>
<p>例如2 4 6 8 10 12这6个数，如果对 6 取余  得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多，并且呈现以合数的因子为间隔增长；如果对 7取余  得到 2 4 6 1 3 5 得到6种HASH值，没有冲突。</p>
<p>用质数作为数组容量使得任何数想整除它是不可能的，因此探测序列最终会检查到所有单元，冲突较少。</p>
<p>当散列函数计算结果的均匀性较差时，最好使用质数作为哈希表大小可以在除留取余时使得计算出的索引位置分布的更均匀。</p>
<p>但是库一般都会提供散列比较均匀的散列函数，只要散列函数设计的均匀，什么数做桶的大小都行，有时为了方便支持桶的动态扩容或者避免使用除法，桶的大小使用2的幂。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？
</a></li>
<li><a href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">算法分析：哈希表的大小为何是素数</a></li>
<li><a href="https://blog.moew.xyz/2019/07/29/%E4%B8%BA%E4%BD%95%E5%9C%A8%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%EF%BC%8C%E8%A6%81%E5%B0%BD%E9%87%8F%E5%8F%96%E7%B4%A0%E6%95%B0/">为何在散列表中除留余数法取模运算中，要尽量取素数
</a></li>
</ul>
<h1 id="为什么桶容量要是2的次方？"><a href="#为什么桶容量要是2的次方？" class="headerlink" title="为什么桶容量要是2的次方？"></a>为什么桶容量要是2的次方？</h1><p>散列表用数组实现时，要计算元素应当存储在数组的哪个位置（索引），应当将元素key的hashCode对散列表大小取模，取模结果就是元素要存放在数组的索引位置。</p>
<p>如果key的hashCode函数不能把key散列的均匀，就需要用质数作为哈希表大小，在除留取余的求数组索引时能够让元素分布的比较均匀。</p>
<p>如果key的hashCode能够散列的比较均匀，那么其实用什么数作为哈希表大小都可以。</p>
<p>桶容量为2的幂时取模的好处：<br>1.可以用位运算取模，计算速度更快，位运算也很方便。<br>2.可以让元素分布的均匀，减少散列冲突。<br>3.方便扩容计算，扩容也只需要乘以2，容量左移一位。</p>
<h1 id="为什么2的幂的容量可以让元素分布更均匀？"><a href="#为什么2的幂的容量可以让元素分布更均匀？" class="headerlink" title="为什么2的幂的容量可以让元素分布更均匀？"></a>为什么2的幂的容量可以让元素分布更均匀？</h1><p>位运算对2的幂取模过程：一个二进制数乘以2的n次方相当于将该数左移n位，一个二进制数除以2的n次方相当于将该数右移n位，右移出界的部分就是余数，其实也就是原数低n位，取低n位的数，只需要将原数跟低位是n个1的二进制数做与操作就可以得到，低位是n个1的二进制数可以由2的n次方再减1得到。</p>
<p>如果对不是2的幂的数进行位运算取模，假设这个数是x，x-1的二进制数一定不是全部都是1，而是含有0，此时x-1与原数做与操作后，那些有0的位置都会用不到，造成空间浪费，也增大了散列冲突。如果x-1全部是1的话，只要key的hashCode的二进制中的1在低n位分布均匀，就可以保证计算index的过程是分布均匀的，要求x-1的二进制全部是1，那么x就是2的幂。</p>
<h1 id="通过构造函数传入不是2的幂的容量值会怎样？"><a href="#通过构造函数传入不是2的幂的容量值会怎样？" class="headerlink" title="通过构造函数传入不是2的幂的容量值会怎样？"></a>通过构造函数传入不是2的幂的容量值会怎样？</h1><p>会找一个最接近传入容量的2的幂作为实际桶的容量。</p>
<h1 id="哈希表容量是2的幂会有什么问题？"><a href="#哈希表容量是2的幂会有什么问题？" class="headerlink" title="哈希表容量是2的幂会有什么问题？"></a>哈希表容量是2的幂会有什么问题？</h1><p>key的hash取余求索引时，会截断hash的高位，如果多个key的hash的低位比较固定，高位变化较大，那么最后计算的散列冲突就很多了。</p>
<p>所以需要扰动函数处理一下key的hash，把高位的变化信息传递到低位。</p>
<h1 id="扰动函数是什么，起到什么作用？"><a href="#扰动函数是什么，起到什么作用？" class="headerlink" title="扰动函数是什么，起到什么作用？"></a>扰动函数是什么，起到什么作用？</h1><p>存储一个元素时，需要决定该元素应该存储在table（桶）中哪一个位置，需要用元素的key的hashCode对桶容量做取模运算来获得要存储的数组索引位置。</p>
<p>如果桶容量较小，取模操作会仅对key.hashCode()的低位做运算，如果多个元素的key的hashCode()低位相同，只是高位不同，那么冲突就较多，所以需要将高位和低位结合起来取模，减少冲突，避免散列分布不均。</p>
<p>所以在对hashCode做取模运算之前，还需要让hashCode经过扰动函数扰动一下。</p>
<p>jdk1.8中对key的hashCode的扰动函数做了优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将key.hashCode()的低16位和高16位做异或运算。</p>
<p>仅仅异或一下做扰动，权衡了速度、性能、质量，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<h2 id="为什么是右移16位？"><a href="#为什么是右移16位？" class="headerlink" title="为什么是右移16位？"></a>为什么是右移16位？</h2><p>推测：因为java中int是32位的，高16位和低16位异或已经算是顾全到了数字的二进制的每一位。</p>
<p>实际：权衡了速度、性能、质量</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
</ul>
<h2 id="扰动函数为什么是异或运算？"><a href="#扰动函数为什么是异或运算？" class="headerlink" title="扰动函数为什么是异或运算？"></a>扰动函数为什么是异或运算？</h2><ol>
<li> 实现简单，运算快捷</li>
<li>对参与运算的两方的二进制的每一位都各自有50%的概率影响结果输出</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">Why is XOR the default way to combine hashes?</a></li>
</ul>
<h1 id="桶的最大容量为什么是2的30次方，不是2的31次方？"><a href="#桶的最大容量为什么是2的30次方，不是2的31次方？" class="headerlink" title="桶的最大容量为什么是2的30次方，不是2的31次方？"></a>桶的最大容量为什么是2的30次方，不是2的31次方？</h1><p>java中int是32位，理论上1可以最多左移31位，因为1不移动就占了1位，所以可以移动的位数是32-1=31位；而虚拟机规定int类型最高位是符号位，符号位不参与移动，可移动位数就是31-1=30位</p>
<h1 id="两个key对象的hashCode相同，如何获取value对象"><a href="#两个key对象的hashCode相同，如何获取value对象" class="headerlink" title="两个key对象的hashCode相同，如何获取value对象?"></a>两个key对象的hashCode相同，如何获取value对象?</h1><p>在遍历该桶的链表，链表中每个节点保存了键值对信息，将目标key与每个节点的key调用equals方法比较，相等的则为想要找到的节点，取其value对象。</p>
<h1 id="什么对象适合做为HashMap的key"><a href="#什么对象适合做为HashMap的key" class="headerlink" title="什么对象适合做为HashMap的key?"></a>什么对象适合做为HashMap的key?</h1><p>使用String，Integer等系统类比较好，因为他们的hashCode方法实现是比较均匀的，可以减少散列冲突。</p>
<p>其次这些类一旦创建都是不可变的，一来可以缓存hashCode，二来保证唯一性，三来线程安全。</p>
<h1 id="自定义对象实现hashCode-方法有什么注意事项？"><a href="#自定义对象实现hashCode-方法有什么注意事项？" class="headerlink" title="自定义对象实现hashCode()方法有什么注意事项？"></a>自定义对象实现hashCode()方法有什么注意事项？</h1><p><strong>原则：</strong><br>一个对象的hashCode应该认为有均等的机会得到2的32次方中的任意一个32位整数值。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205744.png" alt="《算法4》节选"></p>
<p>一个优秀的散列方法需要满足三个条件：</p>
<ul>
<li>一致性 - 等价的键必然产生相等的散列值</li>
<li>高效性 - 计算简便</li>
<li>均匀性 - 均匀地散列所有的键</li>
</ul>
<p>保证均匀性的最好办法也许是保证键的每一位都在散列值的计算中起到了相同的作用，实现散列函数最常见的错误是忽略了高位的键。</p>
<p>可以参考String的hashCode设计，kotlin的data class自动生成的hashCode以及集合类的hashCode算法都很相似。</p>
<p>需要使用不可变的属性实现hashCode()方法，因为：</p>
<ol>
<li> 可以在计算一次哈希值后缓存起来，提高哈希表的读取速度。</li>
<li> 如果key在放入哈希表时和取出哈希表时hashCode()发生变化，则会取不到之前存放的对象。</li>
<li> 不可变的属性是线程安全的。</li>
</ol>
<h1 id="装载因子是什么？"><a href="#装载因子是什么？" class="headerlink" title="装载因子是什么？"></a>装载因子是什么？</h1><p>哈希表中已存储元素个数与哈希表总大小比值，即已存储元素个数与桶个数比值。</p>
<p>装载因子越大，说明填充率高，空间利用率高，但是散列冲突可能性增大。</p>
<p>装载因子越小，说明填充率低，浪费很多空间，但是散列冲突可能性减小。</p>
<p>冲突越多，查找元素的时间越长，所以必须在时间和空间上进行权衡。</p>
<h1 id="装载因子有什么作用？"><a href="#装载因子有什么作用？" class="headerlink" title="装载因子有什么作用？"></a>装载因子有什么作用？</h1><p>装载因子 = 已存储的元素个数 / 桶大小</p>
<p>HashMap构造时可以传入一个装载因子，不传入的话会使用默认的装载因子0.75，构造时规定这个装载因子意思是装载因子的最大值。</p>
<p>随着哈希表中存储元素的个数增多，填充率越高，实际的装载因子会逐渐增大，当  实际装载因子  大于  预设装载因子  时，为了避免大量的散列冲突，要增大桶的数量，HashMap会将通大小调整为原来的两倍，因为桶大小要求是2的幂，所以就扩大2倍。</p>
<h1 id="桶容量是如何动态扩展的？"><a href="#桶容量是如何动态扩展的？" class="headerlink" title="桶容量是如何动态扩展的？"></a>桶容量是如何动态扩展的？</h1><p>当  已存储元素个数  超过  哈希表大小 * 装载因子，会扩容至原大小的两倍，并对部分元素重新散列。</p>
<p>当put元素时，发现已存储元素个数超过threshold时，会触发扩容。</p>
<p>threshold的首次赋值由构造HashMap时传入的初始容量和装载因子决定。</p>
<p>threshold = 初始容量 * 装载因子</p>
<p>每次扩容桶（table）大小会变为原来两倍，threshold也会变为原来的两倍。</p>
<h1 id="构造函数传入不是2的幂的初始容量会怎样？"><a href="#构造函数传入不是2的幂的初始容量会怎样？" class="headerlink" title="构造函数传入不是2的幂的初始容量会怎样？"></a>构造函数传入不是2的幂的初始容量会怎样？</h1><p>不管传什么初始容量，都会经由tableSizeFor()计算得到大于等于传入的初始容量的最小的2的幂作为桶的实际容量大小</p>
<p>在put()时触发resize()，threshold也会被重新赋值为桶容量乘以装载因子。</p>
<h1 id="tableSizeFor-算法过程是怎样的？"><a href="#tableSizeFor-算法过程是怎样的？" class="headerlink" title="tableSizeFor()算法过程是怎样的？"></a>tableSizeFor()算法过程是怎样的？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三种情况</p>
<ol>
<li>cap小于0，返回1</li>
<li>cap经过位运算后大于等于MAXIMUM_CAPACITY，返回MAXIMUM_CAPACITY</li>
<li>cap经过位运算后返回n+1</li>
</ol>
<p>先考虑正常的情况，对于一个给定的cap，分为两种情况，cap可能是2的幂或非2的幂。</p>
<ol>
<li>当cap不是2的幂，例如10，二进制为1010，cap - 1 = 1001，几个右移操作实际的结果就是从cap - 1的二进制的1的最高位开始到最低位全部变成1，最后返回n + 1就是2的幂了</li>
<li>当cap是2的幂，例如16，二进制为10000，cap-1 = 1111，右移操作后n还是为1111，n+1就还是16</li>
</ol>
<p>所以正常情况下tableSizeFor()得出的就是大于等于cap的数</p>
<p>如果cap一开始不减1，当cap是2的幂时，最后计算得出的就会是cap的2倍</p>
<p>cap小于0，没有实际的意义，不能表示桶容量，故而返回最小正整数1</p>
<p>cap大于等于MAXIMUM_CAPACITY时，MAXIMUM_CAPACITY是2的30次方，此时cap的二进制最高位1是在第31位，逻辑右移再加1会得到32个1，int中最高位（第32位）是符号位，最高位1表示负数了，没有意义，故而将最大值限定在2的30次方，2的30次方减1的二进制是从第1位到第30位全都是1</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）
</a></li>
</ul>
<h1 id="为什么要调整桶大小？"><a href="#为什么要调整桶大小？" class="headerlink" title="为什么要调整桶大小？"></a>为什么要调整桶大小？</h1><p>为了减少散列冲突，减少元素查找次数</p>
<h1 id="为什么桶初始容量是16？"><a href="#为什么桶初始容量是16？" class="headerlink" title="为什么桶初始容量是16？"></a>为什么桶初始容量是16？</h1><p>这个问题不好解答可以考虑边界情况，桶容量过大、过小会导致什么</p>
<p>桶容量过大会导致大量空间浪费</p>
<p>桶容量过小会导致频繁扩容，扩容一次是耗时的</p>
<p>16应当是一个权衡评估后得出的值</p>
<h1 id="默认装载因子为什么是0-75？"><a href="#默认装载因子为什么是0-75？" class="headerlink" title="默认装载因子为什么是0.75？"></a>默认装载因子为什么是0.75？</h1><p>可以先考虑装载因子过大和过小分别会有什么问题</p>
<p>装载因子过大，表明哈希表填充率高，但是散列冲突的可能性大，查找元素的次数多</p>
<p>装载因子过小，表明哈希表的空闲空间大，空间利用率低，但冲突较少，查找元素次数少</p>
<p>0.75乘以2的幂是整数，不需要再做四舍五入，计算方便</p>
<p>根据HashMap注释</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost(reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>参考资料</p>
<ul>
<li><a href="https://blog.csdn.net/reliveIT/article/details/82960063">HashMap defaultLoadFactor = 0.75和泊松分布没有关系
</a></li>
<li><a href="https://www.jianshu.com/p/64f6de3ffcc1">HashMap的loadFactor为什么是0.75？
</a></li>
<li><a href="https://stackoverflow.com/a/31401836/2011291">StackOverflow: What is the significance of load factor in HashMap?
</a></li>
</ul>
<h1 id="resize-的大致过程"><a href="#resize-的大致过程" class="headerlink" title="resize()的大致过程"></a>resize()的大致过程</h1><p>根据resize()方法的注释所言，resize()会将桶容量扩充两倍，由于容量是2的幂，原来桶中的元素位置要么是原封不动，要么是再移动2的幂个位置。</p>
<p>求元素的在table中的索引依然是  元素key的hashCode &amp; (桶容量-1)</p>
<p>例如原来容量是16，二进制为10000，求元素索引时是 hashCode &amp; 1111</p>
<p>扩容两倍后容量是32，二进制位100000，求元素索引的计算变成了 hashCode &amp; 11111，比之前多了一个1，如果元素key的hashCode在该位也是1，等同于元素的索引位置增加了2的幂。</p>
<p>桶中是链表时，会将链表划分为两个链表，一个留在原桶，一个放入移动了2的幂的桶中。</p>
<p>为什么要这样调整？原封不动不行吗？</p>
<p>因为这样做是为了保证散列均匀，减少冲突。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现
</a></li>
</ul>
<h1 id="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"><a href="#为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"></a>为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？</h1><p>因为节点数过少时，红黑树的插入、删除的成本比链表要高很多。</p>
<p>在散列均匀的情况下，冲突较少，每个桶中链表的平均长度比较短，性能可接受。</p>
<h1 id="为什么链表的长度为8时变成红黑树？"><a href="#为什么链表的长度为8时变成红黑树？" class="headerlink" title="为什么链表的长度为8时变成红黑树？"></a>为什么链表的长度为8时变成红黑树？</h1><p>根据jdk1.8的HashMap中的注释所言，假设散列分布均匀，在负载因子为0.75的条件下，某一个桶中元素出现的频率满足λ为0.5的泊松分布。从概率来看，之所以链表长度超过 8 以后要变成红黑树，因为在散列分布均匀的情况下出现这种情况的概率小到忽略不计，一旦出现，几乎可以认为是散列函数设计有问题导致的，即散列不均匀。</p>
<p>所以红黑树是专门应对元素key糟糕的（分布不均匀）的散列函数而准备的。</p>
<p>二项分布：n次重复独立伯努利试验，一次伯努利实验只有两种对立的结果。</p>
<p>泊松分布：当二项分布的n很大，p很小时，可以近似为泊松分布。</p>
<p>算法第四版465页：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205936.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205952.png"></p>
<p>散列均匀时，每个桶的链表的平均长度为  实际元素总数  / 哈希表大小，这个就是装载因子λ</p>
<p>现在的问题就是，将N个元素随机放入M个桶，每个桶的元素平均个数为λ（N/M），求每个桶元素个数为k的概率。</p>
<p>对于某一个桶而言，一个元素放入桶中是一个二元结果，要么放入，要么不放入，散列均匀的情况下，不管有多少个桶，每个元素出现在同一个桶的概率是相同，每个桶中平均有λ个元素时，那么一个元素出现在同一个桶的概率就是λ/N，就是桶元素数量占元素总数的比值，理解很直观。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://ysmull.cn/JCF/HashMap.html">谈谈 HashMap 实现中的若干数学问题
</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26263743">泊松分布 (Poisson Distributions) 的推导
</a></li>
</ul>
<h1 id="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"><a href="#为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？" class="headerlink" title="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"></a>为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？</h1><p>是为了防止频繁插入和删除元素时不停的在树和链表之间互相转换、降低性能，红黑树和链表之间的转换是有成本的。</p>
<h1 id="MIN-TREEIFY-CAPACITY是做什么的？"><a href="#MIN-TREEIFY-CAPACITY是做什么的？" class="headerlink" title="MIN_TREEIFY_CAPACITY是做什么的？"></a>MIN_TREEIFY_CAPACITY是做什么的？</h1><p>桶中元素超过TREEIFY_THRESHOLD个（8个）后，还要保证哈希表数组table的大小大于等于MIN_TREEIFY_CAPACITY才会把链表转红黑树，容量过小时使用红黑树性价比不高，用扩容来解决桶元素堆积的问题更适合。</p>
<p>这个值为什么要是4 * TREEIFY_THRESHOLD，是为了避免在resize和树化之间产生冲突，比如初始容量是16，装载因子0.75，存储元素有16*0.75=12个时就应该扩容，但是此时如果是4个元素在一个桶，8个元素在另外一个桶，是要先树化的，树化后再等resize扩容了，可能又要将红黑树链表化，这样反复来回影响性能。</p>
<h1 id="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"><a href="#平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？" class="headerlink" title="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"></a>平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？</h1><p>单次的插入和删除操作：</p>
<p>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</p>
<p>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</p>
<p>大量的插入和删除操作：</p>
<p>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</p>
<p>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</p>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考</p>
<ul>
<li><a href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎</a></li>
<li><a href="https://stackoverflow.com/questions/16257761/difference-between-red-black-trees-and-avl-trees">Difference between red-black trees and AVL trees</a></li>
<li><a href="https://blog.csdn.net/21aspnet/article/details/88939297">为什么Java8中HashMap链表使用红黑树而不是AVL树
</a></li>
</ul>
<h1 id="put方法大致过程"><a href="#put方法大致过程" class="headerlink" title="put方法大致过程"></a>put方法大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>table数组为null则通过resize()初始化table，创建HashMap对象不会立刻初始化table数组</li>
<li>利用扰动后的hashCode除留取余求得元素在table中的索引</li>
<li>如果没有碰撞冲突，直接存入桶中</li>
<li>如果有碰撞冲突，桶中维护一个链表存储哈希值相同的元素，java7是头插法，java8是尾插法</li>
<li>链表长度超过TREEIFY_THRESHOLD，链表转为红黑树</li>
<li>如果元素已存在，替换value。元素存在先通过key的hashCode查看桶中是否有元素，没有则不存在，有元素需要依次遍历桶中元素，通过key的equals方法比较是否相等，有相等的则存在。</li>
<li> 哈希表实际存储元素数量超过了阈值threshold（哈希表大小 * 装载因子），调用resize()扩容。</li>
</ol>
<h1 id="get方法的大致过程"><a href="#get方法的大致过程" class="headerlink" title="get方法的大致过程"></a>get方法的大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>根据哈希值求得table索引</li>
<li>若桶中第一个元素命中，直接返回</li>
<li> 有冲突则依次遍历链表或红黑树，通过key的equals比较来寻找目标节点，找到了返回其value，没有找到返回null</li>
</ol>
<h1 id="HashMap为什么线程不安全？高并发下会产生什么问题？"><a href="#HashMap为什么线程不安全？高并发下会产生什么问题？" class="headerlink" title="HashMap为什么线程不安全？高并发下会产生什么问题？"></a>HashMap为什么线程不安全？高并发下会产生什么问题？</h1><p>一句话：jdk7的HashMap在扩容时会改变链表中元素原本的顺序，高并发情况下容易导致链表产生环，进而导致死循环，CPU占用率飙升到100%。</p>
<p>jdk7中扩容采用头插法是考虑到缓存的时间局部性原则，最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数。</p>
<p>jdk8中扩容改为尾插法，高并发情况下不会产生死循环了，但是resize依然不是原子性的，可能会产生数据丢失。</p>
<p>其他方法例如链表和红黑树互转的过程，都不是原子性的，都可能会产生数据丢失的问题。</p>
<p>参考</p>
<ul>
<li><a href="https://www.jianshu.com/p/e2f75c8cce01">为什么HashMap线程不安全
</a></li>
</ul>
<h1 id="Java-8-对HashMap做出了哪些改进？"><a href="#Java-8-对HashMap做出了哪些改进？" class="headerlink" title="Java  8  对HashMap做出了哪些改进？"></a>Java  8  对HashMap做出了哪些改进？</h1><ol>
<li>桶中链表长度超过8将链表转为红黑树，以应对不均匀的散列函数导致的查询次数增多</li>
<li> 链表插入元素由头插法改为尾插法，以解决并发下插入元素时链表产生环进而导致的死循环</li>
</ol>
<h1 id="modCount是做什么的？"><a href="#modCount是做什么的？" class="headerlink" title="modCount是做什么的？"></a>modCount是做什么的？</h1><p>对哈希表做出了修改（添加和删除元素），modCount就会增加，表示修改的次数，使用迭代器迭代哈希表时一旦发现modCount变化了，就会立刻抛出ConcurrentModificationException，以避免迭代时的不确定性，这称为fail-fast机制。注意修改一个已存在的元素的value不改变modCount。</p>
<h1 id="HashMap的缺点是什么？想要用哈希表还有哪些选择？"><a href="#HashMap的缺点是什么？想要用哈希表还有哪些选择？" class="headerlink" title="HashMap的缺点是什么？想要用哈希表还有哪些选择？"></a>HashMap的缺点是什么？想要用哈希表还有哪些选择？</h1><p>缺点就是结构复杂，占用内存可能较多，对哈希表有简单需求的地方不需要这么复杂而完善的类</p>
<p>例如ThreadLocalMap就自己实现了一套简单的哈希表，采用开放定址法</p>
<p>还有Android上SparseArray、ArrayMap实现的内存消耗更低的哈希表</p>
<h1 id="HashMap与Hashtable的区别？"><a href="#HashMap与Hashtable的区别？" class="headerlink" title="HashMap与Hashtable的区别？"></a>HashMap与Hashtable的区别？</h1><ol>
<li> Hashtable的get、put、clear、contains、size等大部分方法上都加上了synchronized关键字，给整个对象上锁，HashMap非线程安全</li>
<li> Hashtable中没有红黑树仅有链表</li>
<li> Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li> Hashtable不允许null的key和value，而HashMap都允许</li>
<li> Hashtable求key的hashCode没有扰动</li>
<li> HashMap和Hashtable使用Iterator遍历元素过程中对哈希表添加或删除元素是会抛出异常的（fast-fail），但Hashtable用Enumeration迭代时不会fast-fail，因为通过Enumeration的nextElement()获取下一个元素时没有对modCount做判断，而Iterator的next方法对modCount做了判断。</li>
<li> Hashtable是jdk1添加的，HashMap是jdk2添加的</li>
</ol>
<p>Dictionary已被废弃，所以Hashtable已经被废弃，而且同步性能较差，大多数操作都会锁住整个对象。用jdk1.5引入的采用分段锁的ConcurrentHashMap同步性能更好。</p>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>HashMap</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图的连通</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A/</url>
    <content><![CDATA[<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>有两个图G=(V,E)和G’=(V’,E’)，V’是V的子集且E’是E的子集，称G’是G的子图。</p>
<p>并非所有V和E的子集都能构成G的子图，因为这样的子集可能不是图。</p>
<h2 id="连通"><a href="#连通" class="headerlink" title="连通"></a>连通</h2><p>无向图中顶点u到顶点v之间有一条路径，称顶点u和顶点v是连通的。</p>
<h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><p>有向图中顶点u到顶点v之间有一条路径，顶点v到顶点u之间也有一条路径，称顶点u和顶点v是强连通的。</p>
<h2 id="弱连通"><a href="#弱连通" class="headerlink" title="弱连通"></a>弱连通</h2><p>有向图中顶点u到顶点v之间有一条路径，顶点v到顶点u之间没有路径，称顶点u和顶点v是弱连通的</p>
<h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>无向图中任意两个顶点连通，称此无向图为连通图。</p>
<h2 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h2><p>有向图中任意两个顶点强连通，称此有向图为强连通图。</p>
<h2 id="弱连通图"><a href="#弱连通图" class="headerlink" title="弱连通图"></a>弱连通图</h2><p>有向图的边去掉方向后是一个连通图，称此有向图为弱连通图。</p>
<h2 id="非连通图"><a href="#非连通图" class="headerlink" title="非连通图"></a>非连通图</h2><p>一个图的顶点数为n，若边数小于n-1，则该图是非连通图，即图的所有边无法连接图中所有的顶点。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAAEMCAIAAACa0sctAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADaaSURBVHhe7Z1/TBRn/sfbq6ZHT8/iQU49xXpaelLLHdhri0nrFy8ehsYYMdUIicRi6B+YSMSrJnA920ijDTR4wUskRaMpELyI8Ro5rSmeRwrmWiBHFavV+uOItZGTGo3U2OS+r+7ncbqwO7Ozu7PLzvK8/hjm+cwzM888z/v5PJ9nZnZ4+H//+99DGk0c8SP1V6OJF7SmNfGG1rQm3tCa1sQbWtOaeENrWhNvaE1r4g2taU28oTWtiTe0pjXxhta0Jt7QmtbEG1rTmnjD4ffyvvnmm76+Ppbffvvt448/PsuD2qbRRAVnNP3VV191dnaePXt2aGgoISHhxz/+MUZkTZKVlJSUF198ce7cuZ68Gk1kCVfTqLmxsfHSpUsLFizIyMiYOnUq7llt88iaDGi9o6OD9by8PLKpbRpNZAhL062trYcPH87JycnNzTV8s2wyEDt0dXU1NTUh+pKSEsOoiUvwcTiy/v7+27dvIwmaG2h6vF4UYtHQNb1r1y6KXlZWRll9peyL6Liurq63t3fbtm3e7lwTN+DmZExGuwhjypQpYmeKhcSvXr3KJsZqwwlGghA1jaApJYKmZHYEbUB+Lhu0rOMMxuG9e/ei4yVLljz99NNmksV/t7W1sSQQXbRokbI6Siiabmlp6e7uRpSsByVogavlCPTmqqoqZdK4HBl+165dO3/+fJIWqhCtM8LjFukAuEWxO0jQ96cpzbFjxzZt2sR6CIIG9qKPJiYmMrlUJo2bqa6uvnHjBh4KQdO41qqQDEQm5EffFRUVaoNzBK3p+vr6ZcuWETZYFJ2ySnc0g31fffXVkydPEsAok8ad4G5pzfLyclrcQhIjICeUlJSkpKQ4LuvgNE0YRFEIg1gqkw9sIlwmp7WsGXcWLlx44MABlda4ECJjxm0EzbqFJMxgl+Li4oSEBGdH7OA0zTUwabUQK5sItTdu3Ig7VyYTuJ7s7GyCMJXWuA3G2ObmZnwt6yEIWmBHjsCITd9QprAJTtOcOCMjQyVMwEnjgMlpx1UTwzBfVmmNq2CMJYAmMg5Z0AIaIJp10FUHoWnpSQjR7BpQsEi5tLQ0KSkJp642mJOWlnbu3DmV0LgHNMAYu3TpUpX2B3kM0IaZg2Mr0exXHpQpPILQ9M2bNxG0WcmE48eP0+3mzp2Lq0bTFFdtMGHKlClOXYkmmnR0dMhTFbMmRicNDQ1FD3jttdfYxUw82NPT00+cOKHS4RHE/Wk0euHCBYJ6C6VS+pdffjk/Px+HvW7dOmYPFhNKroTA4+jRo+QPqH5N7IDbamlpQdO5ubkWjVtRUXHjxg0G7cHBQfL39PS89957fmMVUcKhQ4fkoUeYBKFpAuX+/n4zTUuxXn/99XfeeWf27NlYNm/enJycTCkDappsV69eVVZNzLNgwQIEmpeXx4BsrWlWRKZMKHF2+DizboDuq6urHXkMF5yfJlZmlmqmacpEdzQe8Us2uqbZCMUujEeMOHIzSOMiNm3aVFZWlpiYqNI+jNA04kEetbW1FnNK8svrQyodKkHE05zMIvZlE+VG8XQ1LoPlW2+9RemtgyS6LwOZSmhcAs2KZBMSElTaBDLgBJEyHWDXrl14LuubJBzTYqt9gtM0p/T75I/SdHZ2sjU7O5tyMySxnD9/flZW1pEjRywKStitfyvgRuyLj5zIIykpiTGc5mZdbYgYQWgah0qBLl686Fssyt3d3c10UHQvYJfgyexK2EQ/lpwaFyGtOTQ0ZC1QMuCwcM+M2zt37mQkx1urbf5ACRbBjH2C0DRkZmaeOnVKJYYjAZa3QFknf319vd94muo4c+YMK4TUlZWViFvsGldA8127dk0lAkHrk5+ZJd7NVwmChLWOBKKPbN26Va3agIhi3759zz77LP3pu+++U1YP48aNU2vDwe53E8a//OUvzJ0LCwvv3LnDwPTJJ5/MmDEjnJ5Kx2hvb29tbSWI//DDD4nviYg+//zzW7ducVhrp6IJigsXLty/fx83PEIGBrQv9c8KozfrqBlX/dxzz5H03YWm6enpGRgYeOmll5QpDIK47yEgPqTDgGLW4ezANXDBiM/73g1Hxmfj1PPz81kqqz04lNRgamrqnDlzJk2a9Nhjj5G8e/fulStXqFDcAMckFtLhuyOggYaGBusbtRUVFTiXefPmkezv76fmzW6VkJmpZEZGBopXpjAIWtNAmMG5Le63W8MFoDDGhy1btuD4ldUDBxR1cv24cDvK7vL8vILjWOuVqS0dhoOTp6ioiDKoDZpQQQbUJPVpJgNiy6+//pqt1PbPf/5zi58LDA4OEn/KG9XKFAahaFoUWVxcLO+AK6s9KDS70IOlVyjrcMggPjs9PX3lypUWMVZjY+PJkyelJCStCyOn3r9/f29vLw5jRHfSBAuuB6xdtVrzYJGNuSP+m/FZmcIjuHhamDhxIuP7jh078KMowyyi8oXS4y85I3NH3LCy+kD49cwzzzCloKM3NTWxy5NPPukblFMRBBV/+tOffvnLX1JfAYshGZ5//nk6CfsyJoYTu2toesY92oXW8Vv5GL1R1uEgCUZajrNx40bfJg6NUDQNycnJ6LKuro446de//jUlMyu0QAZKLN162bJlFoI2YBe8LzEWswf88QhlY0HQHI1s1u55BJSTxpg2bRpTlhdffJHd1QZN8OB6cG0oAT1YC8AvVD7NyhFKS0uDnUFZEKKmASdH/PDpp5/Km6+UacKECWjOF6723//+N1HvF198wV4zZsxAnXKQgDAmMFlG2Z2dnQcOHEC+BHBMUJqbm/HQwQpaoDwpKSmPPPLIvn37fv/73yurJnhoHdpdBr1gZS2CJgpdunQpY7KyOkEo8fQI8JeEvwTZ6BXBTZkyRcb0u3fvMkVgK3ABdABAghs2bPCdHdqB49B/hoaGbty4YSeat1Y8W5mXUGA7g4bGAmY+eIfCwkKRph0vQ+XjmGpqanJychyvfwc0LXAl3d3dp0+fJjwiiSNkSeSKdtGNt4KJQIifQn4Di4AHTVvcTBQpyz18ehdl8JuTbHSS7du3E4SwrqyakECgeGtxEBJFmNU5S9wzAmByb3QDZ3FM0wZojhkkLlml/cGIw8WY3fewhn0LCgqoPrNaY9A4ePCgbGVJ+G7xfmx1dTWHCq0kmhEwiuKzqc8XXnhh9uzZI25YIWUcTXt7e29vL3kid0fVeU3TX/HK1iqRu4FMDizu0/kFz8rx8fFmGiWcwAfgAJj/YSE/Swpjlp820C+7OgjCZRxmxKbCqV7GSZasDw4OiiUtLS07O9vBGaEvo6NpMJ5HqrQ92GtgYMCv36W+2Irf/fOf/yy3qw38Clpg0zYP7K5MGiegYnEoSLmnpwevjIghWBcWGsG9w+QgBF5cMG5Spe1BNRHYqMRwqERCDvqSzB29UTn8gZRB3LnGQahVpEyEyZjMkvXoCBpGTdNQUlLCfNlacyMg86RJk1RiOPSQ69evB/xUwwioesZH9lVpjdN4vEoQTRw+o6lpQhR8KrGKSttgaGhIXk4aAdKUimNFLPYx9tXEB6OpaSAyPn/+vNz+CwdEKWpmjiIW+2hBxxmjrGlA1nv37lWJQCQkJJjFCYQQhNrHjh1jPShvjabN4hmNGxl9TRN+EITU1dWptCXJyckEzSoxHHRcWFiIy6+urha3DazIwxczyEAnkY83aOKD0dc0MFlEi3ZuPsybN++sya+8UCfz67feequ1tbWgoKCiokJe8G1paUHcKtNwsMtJozYl10SBmNA02lq1apWdyWJmZiZ+F/zKFFnn5ua+//77K1asIBTB/aNp64889fT0pKamqoQmLogJTcOiRYuQKT5VpU0gz9y5cy2+GYJ8p3p+/VVWVob7R+KIW23zgcwdHR3WHzLUuI5Y0TQQKjDDsw5/IS8vT/7BgF9XDSjVG2X1gd2JUuT5ljJp4oJRezbuF/y08d+PLGhsbET6Iz69EBQImkh6+/btIbxzEg4Um/nAhQsXbt++LRZKQnUx+LAUy6jAfObKlSsUT6qUUjG+PfXUUxb/QcsmuCrmNtGs5NB/E2DGJ598QnXYf+vfG5oW3zlu3DjrBn7mmWdQ/507d1gJ7ecVtNybb775yiuvcEZljTBtbW319fXt7e0U+xe/+AUXCDNmzHj44YevX79+9OjRDz/8kE0YuXy1T+ShY+MgDhw4QDej1RiyaDj5IgWF+fTTT2mOzz77jGRycrLaJ0i4rpdeeinMjhEUseWnwab7JPbYvHnzsmXLOFFQ3loEjedguunUjzqtwTGjZmSRnZ3NSc1al2zoniVXFHLt2YdKoFScjplMVlaWWQCG52YajbJpUybcIbjb6Pvph9C0s9TW1h45ckQlQqKhoaGqqkolzBkcHGQWuHv3bkkO2YBsX375JXtxCtkr0nCi4uLijz/+WJKqHP6QDBRPPsYlyQghlUDVUYdiUYXwh2yVC8FzS377ECIaZ4kOMTRHNMB94q0DPjCn6yN9AlM8QYfnG/SC2uyF2PFMjLMMAhw/Oh6aIauvr48xZ8GCBZwd1AZ/SAbcIYJmoOeirPOHDL5ZKgGNSrVYn0i2kr+0tLSuri7YVymjT2zF0wY0LYJYvHixdXDJVuQyYcIEBkcGbnnZIyEhwfi1L9E2ToKI8O9//3tTUxP2jRs3hlk2m9B/6JnyZra1aLyhwPD8888PDAwcPHjQ+udCIUAsgaBRM6ewXyqgVMQn8+bNo13mzJljP7zW8fQPcJzx48dT+yodCPz6qVOnZOZu1KA0G32MuSD6iFpUhzND0yH/5hK4hOrq6okTJ9qvATusX78+z/OPvoMStAGlws3X1NTYv18U/Xg6djVNpYf2C3O8Nb5Z2oyqRNDRdBIgJWekpiOFJh0D4zgqHR7h3wMFKtM4jjJZEn1Nx2I8LVB3hYWF+CqVtg3VRzdAB8BwGWVBQ0tLS3p6OmcPU9CUfNWqVUzOVDo86OonT54MfyLBReHpCatAmWKM2NU0ECsjSryCSrsEAg+zYQqZGiiTOahHJpeOqIcpx/z586lPi56mSvYAZfWBTUQvAV9kGC1iWtNQ4vnHvYx0Kh3zENajGwYKv9IR9wZyRRa6EciQmZl5/PhxlQ6D7u5u+S29GdJ5vFEbfCBnVlYWGSy6xygS65omkFi2bBkxukrHPGiaqEMlvECdiIApGvElsFJUVCRvjVsrOyMjI/x/tCddyKynAWVoa2tbt26dUTzrqI9+C/KfHmKNWNc0yDjO0CnJGAf9zZw5UyV8QFKMPFWef022YsWKw4cPMwu0fh8L6YTvDulOHMe683AWPAgFo3i1tbUBp4D0kCtXrqhELOECTQM6oPnl9nOMgzImT56sEj6gKrQlU1hmWsz/BgYGrEchESLuH18bMpcvX+a8ckALOBcFo3iCsppAB+DIKhFLxO69vBHIIwyb37gZcTvPTnM6RUVFBT0w0eelbeRy9uxZhnW8oHFLBCPjD6P8+++/b+aPuRD24oBciDIFz40bN+Rri35PAZSEGj5y5Ij3bRazzEB+YpWenp6A7pzC6/vTphDk5efnLzD/amBHR0dnZ6eomUoXozQMmpB/F2LYIwRNSDPb1zRGruudd96RT+1I5hEQD8gnAlU6eOTeEbVndgpKQh4ELdU7NDTECo1okV/euKIDK5MJ0de0O2IPgeoz+8YN9Uvd4fNoeOZeiMAbRMY8XSQV6TuDNDYlZKnSDhGmJijPnTt3VMIhGAzHjx+vErGEmzSNXtPT0+vr61XaAzWLG0DTImVciwSCCEtgnWEdD42yCV3w4vhF9O3Z23kSEhKCijLlltm0adMk6YsMO2GGT0xbCT9Uwhx6DlUEUpNSe2ZwmdOnT1eJWMJNmgaE29vbaygSQWzevDkzM5M2kAFdkK0Gyur5N6k4+7Vr19bU1NAN1GZHoUcxIVMJc3CcQJHoovL6Mutqmxfk4Rp9I5lgmT17Nn3DziRbivF9ZVkKmq0ULJxwKHK4TNO0cXFxsdwowE/goQsLC2XqY90GBmQjct26dWtzc3MkZI1A5Uu1Kj0c7Hfv3mVJ4Yn+6aJcERGR2uwP+S6oSoQKDpgT9fX1sVQmf1AwQPqyoqw+SE9jJeC9kVHBZZoG4xs31dXVOF15eqy22YP8+EWRteNBiDTzmTNnzNTz9ttvM+GThxqMMPRPBGd2CciLcYnASaXDgINY/N5euH79Ot3MgI5ndhXt7e0UXiViDDfd9/Dm5ZdfRhkWE/mA0FpdXV30jd27dyuTQ+CAma0SDo0oG8mLFy+qhCcekJmf2SVQQma0xAwB7y3YhI7EoSRIUyYvONG1a9fu3bun0g89lJaW5qtpLGgdj2Dzf4bo+x62wLnSMGZ3W6noEagNw2FfXD6TTsfvhMjtMGQ94tQkOaMBScrg9xKArYzvJ0+epOsqU9jgAgjfzc5I1E6pKLyBWdXt2bMnJyfHbOuo40pNNzQ0MA6Y1Snel0AZSQkW0QWtS8dAN2bNHDK4w8OHD3PqEYX8XsIPUCZ/sBcZtm/fzmzBQQ+HTAm6kLVZ1UnBDJTVC3bEBQwNDVFvyhR7uE/TDHxUN81jVulNTU2VlZXoHmg/Ij+zJgTaODU11fHJIodlLltTU4OvtTi7X8jPpTFeL1y4kMtUVocoKyujSOgy2FIBu+AjiKwomzLFJO7TdGdnJyq0aBIEwXxIBM1yzZo1ftVvIP8qVyWcg3EcL4uvRQSU1qLA3pANzRGDMgML//19vxDo9/X1yWt39ksF9AQ0ze429xot3KdpBnSzf+kSAsid0JzpkUo7Cl52y5YtSIF5s9xDMFODsamlpYVuwMgeIUEDJxJd0nOM/gZq83BkE3VOZjpbVVVVNGd7oeE+TRPMMbKrhAnSQtIeYrFAnmigOUk6y6xZs2prazkF4RDKJtanF0nBDMiGaJC+6GbHjh2O3LyzRp490YU4Kd6X82JUBXoAXZ2ojJIz4tHNysvLMcrusYz77uURzNEeZo/WqHRRhtwnRkC0HGGAdfiB3wrzJaGAfOPvHweKHemwnpKSsnjxYil2NKGb/eMf/5BhJCEhwbi9SKlYUs7s7OxwwnqaI8r38uJT07QQE6z79+9jweeZ3ZEV2IVjRlrTBpSELieKITlp0qRp06YFHHmiAKW6efPmrVu3WKdOKJIjHSz6mnZf7IEUgEpXaR/YygSruLgY6QMNg0Vt84dstTigs3AiOg+ej84GjCGxIGigoiiMlIriRX/EcAr3aRpNWGsUJAPLgDlBspk5fo3rcJ+m8WoyoXEEeojMDmN/Oq+xifs0zcBtfTsZmYJK2ODs2bPuHWc1vrhP04R6eFbwK1yiCGYkRUVFrChTILq7u4kgVULjflwZT6enp3/wwQcq7YPHTdvy02STG8bRueOhiQ7u0zSsXLkSLZq5avug5qamptWrV6u0Ji5wpaaZz4X/cSb6w/79+xM9L1gqkyYucKWmIdfzjw+rq6tDc9Xs1dra2tvbW2bvg7MaF+FWTQNyHBwcFFkHpWwyt7S0HD58OPZfMdOEgIs1DYiSpbzg4RF2AIGSgRiabtDR0RHl/4yoiRru1jTgrYlDkGldXZ2hbL/g1HHPFRUVEydOdMU7k5rQcOtvbEeA90Wv3d3daDctLe2JJ54wnnXfvXv3ypUrZ8+eRdMULC8vL0berxgj6PfywqWrq+vcuXM47KGhIbEkJCQkJyfPmzcv0/z/bWoih9a0Jt7Q75pqRhmiOMY6ArnGxkamKCxZl6etKkfMo/30qPHNN9/09fVdvnz5K88v4bHgzJgGPPXUU6PyGAjhHj16lFkHZSBaS0pKEvvAwMCNGzfEvmTJkmDLpmOPMQET1tbWVqSMSqirKVOmSKCPsq9fv85kQKaz1CFL2SWicMZ6z9diFy1axKzDr/4orRSbohYVFdkvmNZ0nINvpn6QrPyWxKylEVBnZ2dbW9tcz+e0Izq1JbQ4duzYqlWr5OVEixhDikGpmpub5b8OiN0aHU/HMwzumzdvRqbbPF93RiIIyC/4bxRDtvHjx6MJ/Kg6hNPQwbq7u+WX6nJqtcEfkoGcW7du7ejokH8aFoNoTUcJ3BsiKC0tFfdmrR4gA6IvLi4m//bt2xn31QbnoDwMCPQcnGjA8hiQc+rUqex19epVZpDKGktoTUcDPDTjNe4NJ21fPUBm/KJ8pgz9KasT0Md6e3uJCjhFUEUCyc++eGsQY+ygNR1xiKHFQ+PeglUPsMv8+fOJd+VrYI5AkehjZWVl4UTq7Fti/h92RhGt6YhDzMqMKlgP7Q074q3pEk6N9QcOHKCfMJUPR47sy0VxnP379ytTbKA1HVnkPRNmhGE6M3bPz88/efIkLlaZQoVDEQstXbpUpcOAQ3EcYpgwr85ZtKYjS0tLCy424BBPBkGl/YGfTk9PJw5W6VDhCKmpqX4DISx+jWrNHxwHfx9TUbXWdARBDUzsFlj+xxl0zFYcJ1JjaS0gukf46unp6cnIyFAJLyhJQ0NDVVWVd9dikCFo5qQW/S1CHzsOGa3pCNLd3Y0bs37cQIhcVFT09ttvE3a/8cYbBQUFZv/fCLnL07swb4DIQ0qVGA6Bje+/Ubx+/bpFT5NSOXtPJky0piPI5cuXzdQDCLe6urq+vh4ds4Ta2lr0/dhjj6kcPrBLYmJiOI9gRJ0cxEymvv+alpOCSviDo7G00H2U0ZqOIHjEKVOmqMRwUEmrh3feeScvLw9fjgWnzjrdwEIfycnJYU4TPRI11ahskjwgerVGcsaOpvX7HhEEN5yVleU3nkYE69evR8rbHvzLOSyyCcz0QR55PSMlJUWZgmRoaOjs2bMEzb49h4PLLzVzcnKU6aGH7t+/zxnLy8sJ5S1Uy1Vs2rTJb5Sl3/eIN8x0gK8lBk1LS5Mk2ZggCtahBTkRdHaoIE3jJVK/cPzzXth5Js8u4N0nRxn8tLMQFB45ckQlxjZGVeAdRyA3rRsaGiTnl19+mZ+fT+CBU9+9e7ffXQA7x/zoo488O4UITpfTsaIO+gAsuNuSkhJPLoWUU86o8g0He19fH8f0ZPeDfLJCJaKC9tMRZO7cuf39/SoxHLwaw7HcLsDJEUkTszFNfOKJJySDGexCZpUICTuzTHG9gGqVyRyOZifsjhpa05GC6OLChQtXr15V6eGgaVwyc0SyyaiNxAMGnWRGZxb3Uuzg+O1ksxveo4XWtPMgu8bGRiZGEyZMYB035htrYi8oKEDEjPUSs2LBB6Na+Tc0vnCQ7u5uPKLv0YKCvkSgzLl8j4NX9j07BQOV8IHjAMdU6RhAa9phcL3M9GlmQkxC5MzMzOPHj6ttw0HQVVVVaHT9+vVFHtatW4fRwue1tbUxz1OJUEHK8+fP9/3YMcJdvnx5YWGht4ITEhK4ELMXsDhUS0sLgg6zmzmMiqudY8zOEZlIMR9imiUzMIHpUXFx8bVr11j3zKmGIXmYYx08eJBK+/TTT8UoW73ByFaO79kjXDggpeK8sm5gbPXGrxEwcgSOI+tm6DmiK+nq6iLSwImuXr0ar+Yd7+J3c3Jy9uzZo9LD+X5Q97yxmZeXl5ubKz/J9usRMe7du9epT2XjVvHHNTU1HNbbxX5fGp+z+zWyF2ESR0DTseWkdewRJoTClZWVTU1NKBIPLaIcAXrFkzFGm7W9iEZQpuGw465du+RlZWUKGwKGhQsXyhOfYEVJfvZiX47gYJGcQms6RIiYq6urkRrhL2Gx9SSJCPvYsWOE2iG4NHapq6tDQ8wmlckhCPdTUlIYYbgW+wUjJ/m5osj9l/8w0ZoOGsZcRIZ7njp1Kmq28xYAEciOHTvQdGNjI5qwKSDJRs85efJkhG6WETks8vwOnLKRtC6bbGLAIT9XHZuCBv2+RxDgLGnRjo6O9PT0lStXolS1wR7sjkCZMBUVFRFIiEU2eWOoigC9ubmZ8Z3KlDskzLdkk7Pgd4n4KRijTVZWlt9nOuTp7Ozk2inGq6++av+5T/Tf99CatgtqRmQynwvnSR4HwSmiDNTD0Ubcb0blqKenp0dew/f+L+j0BzZFTh/MDSgYp+C8XCAFEztax0jBaFaculEem2hNxyKGChltve9phAOSxe2JgBISEqTJiWqYTVqoh35FXF5aWhqssIICcVOw+vp63DbipmwsQz6j1nQo0AY4NvElYqEGKQPNEKYEu7q6mpqaRvhLZ7l06dLNmzdv3brF+qRJk6ZNm2Y9CFCkd999l+gF0StTZECIyDF8LWpNBwFe7cCBA+fPn0dzaWlpU6ZMQRPY7927x6b+/n7ZhLMJoTD0k4aGBjqJvCunrLEBvZcZKjE9MzxligAIsaSkJJwoS9CatotEtzKnMXPGKPLMmTNHjx5FBGvXrrV5JxXH2djYSBDJJUTaF4YMl7bN8/+ZkAv9VozO4l5Nu+9eHs1JHeFH5YUKBI3FL2RGx2RD0Hv37g34wRekT4dkKkaYUVVVFbOCBnSMplNSUlAMxVZWjQeXaZqgglYk0kCpuBBDu2ZIBpSNRnHA6FVtGA555JYzE0FyEm+oDbENsQdFpUIIspVJ4zpN45xwn7hnEauyBkJy0g1YQbtiNCCMQRb379/n4Bw5QkN5hKA2GLW4KK5CmcY8btI0XjY1NRXPZF/N3rBXWVlZb29vx4PPvrS2tq5fvx7/jdyJHaMZ8zkIkdKOHTu4KLNRaKzhGk3Lj0/XrFkTmqAFfDDaJbDmaPjmnp4ekgg9/JnQ6EJvJGRihYsiPBPjmMU1mm5qago/MKA/4NXS09MPHTok74VG6K7zqEDnzMzM3Lx5M51fmcYk7tD0Wc+vmxYE+vCcoNImcITFixezjMGXJMOHbl9YWEiE3Rb2pyLdizs0LbeiVcIfaBTdC8pkzqxZsxITE+P1XgEVxWS3ubk54L3LeMUdmmYwtQgS8M19fX2EkkBzDg4OBvTWHC2O73/RaXfu3EmdVFZWKtNYwgWalkmP3I0WywiwE0cy22MdTeODzXIazJw50+wrBfEBvZqqSE5OXr9+/Vh7KOMCTYvftb7RRgbwXrEAxU+ePFkl4pri4uLc3FyGrzH1UMYFmkaCCQkJKuEQAXUfN6DpkB/KOF7t0cEd8fSQjS9cacyQhzLMs3ft2qVMgWACA62trfQElrh5FwUwLtA0UQeuGlQ6bHDSY+3BBHVYW1srb8tY1OTZs2fRPXnq6+uZoty5c2dgYKC/v//o0aPV1dX4+8bGxtivOhdoWn5ERFQtSUfA67h0YA2H8vJylLphwwZ8sDI9AEtlZSVSZi7ObBv5lpWVEY4L7MiMs6CgAJVLJOOgi3EcF2jaM+v7MZXOUpnC5sKFC/H0BNE+xkMZ46UXIMDYvn27fNQhz/OPCjB6hsYfwEKNoW/EzTq+3M6jgFHBHfE03sX6U5xGvRsrFpDh/PnzWVlZKj3GkIcy+/btk4cyBBvd3d3yeQOpPZCcI5BNeBaUvXbt2pqaGu+OETu4Q9OLFi3q7e01i+SoZVqFtqHG8UDWz1wkM0u3v7cUDvJQhqHvtddeo1aRuMXtf1/IOX/+/C1bttAxYvAuoTs0zRSHSjxw4IBfsVLFaWlpjJtMg9C09TMXNjHULl++XKXHKtQkI9XEiROJm6kTixrzC/npGKWlpcTWsXZLxB2ahjVr1uASiOH8yhoj0Z6gTP4gG4JG9HH5AlNQIMQw/40+sqa2ly1bZv8WYXRwjaapesI4YjjGSr/N4PE136PSPrAXveLkyZPyFH2MQzCdk5MTVMjhC/vKj6ljKrB2jaYB50ozEPyZydoC8uPj3333XYZL68fsYwGcNMG0TAqVKQwI5EJ4SBk53KRpyMvLk9fezYIQX8gGra2t+HiibevgZIxw4sSJBbY/7m+djV7x9NNPs+J7z3u0cJmmQe6wIlBGTyrUo1j/lS6b5GlCW1vb1q1btaCFvr6+p556SiWGQ43t37+/urqaFUlSzxs2bLC4m4Q9NTW1s7NTpUcb92ka8DE7duygluWZFlGyIW4DtqJj2gaQclVV1Vi+eecNdQWzZ89mqUzDueqBFapR3hJhImgdec+bN0/76XAhJmaqV15ePmHChEOHDhFko2/8MQpmyToreI6MjIza2lq3fK8jOhBMI1aLSUVCQoL8J30CvD/+8Y/Uc8DIOzExMXbeM3OrpgWcB6EIgoaCgoIlS5ZkZWWxLCoqwjGj+Fj+ltJocfPmzYDvuiB6JuKbNm2iesFa0Gwlv0rEAO7WtAF1SoAxf/58whKW8saCJjSozNu3bzPWUZk4aWtBC1rTmtFk8uTJAeOEgYEBAg/7U2o7uo8aWtNjDnl3wOzlGWAraiZyY07CHDGgDyZDTL27qzXtALRoR0dHS0tLY2NjXV0dS6QQO/cBRsDsUFRoIVYUL98lZI5o51HA5cuXYyfe05oOHfwZOjbusZCk7ZOSktjU09MjPxhB3xYecbRISUlBqSphDsE0c26uwroDQF9fX4T+M1gIaE2HSOuD/yu+fPnybdu2lZWV4dXyPLBCEmNRUZH8MARlq91ig8WLFzOwmAXBRNvGf9LnKvDr69atY9jxK2uMdA8JV5RptNGaDhraD5miCYSLJ5NX/DCOACPNLD8MGRwclA+oeg4w+hAnoEUuwVemlJyoY9myZXIVZKD8ubm59F6Vwwe6d0zdM9WaDg65a5uWlkZLowxpeLXNB9mKLJA+/nv79u12RvzoUFBQ0Nzc7LfwCFTetgMycJmUf4G/jxVyaV2e780a+WMBrekgoFHx0LSfPIbwbWMzyIlQSktL6Qkx4q3ldj5Bv19X7X1pkgSVfgA70sOZE6N4ZYoNtKaDAEXirgI+KPYLuyAjmh9vHcLukYC4iKAIUfrKOiDswlVQITk5ObETSQta03YhamQZ8EGxBewojznr6+uVabRh2Ll69ap4a/vKJifhNTFYZmYmMZWyxgxa07ZAjocPHy4qKlLpUOE4a9as6e3ttZhyRRPUia+lVAhU7kOD2uYPyUD3juV/o681bYu2trbU1FSZFCpTqKAJxuuY+mFIWVkZAsVbV1dXy+/ARbsj4NqpB9Tf0dGxZcuWmJoXevOw/n/jdmCMXr58OWGDtaYJT5HF6tWrrXOSrbKysqqqCqEoU2xAT+vu7qbkU6dOlft9ImXmgkxtKXZiYuKSJUvk9qVN6APUXjR/L6f9dGBoUdrV4iV6AzJ0dnbKPw+3AMXQxmfOnFHpmIHgmFAEt52RkcG1oGMCkv7+fjZlZ2cjzfLy8qAEPSpoTQfm4sWL+Cc7ngavJm9TqLQ5aWlp586dU4kYgy4nL3uUeCguLmad2W00fW04aE0H5sqVK8nJySrhEOiDoVwlNI6iNW2LCRMmqDWHkDhVJTSOojVtCprr6uqKwW9naazRmvYDUt61axdTokOHDk2fPp348s6dO2qbQ4iTpsOA/O5d7Jrw0Zr+AfHKmzZtQsroWN4Xzc3NnTlz5o0bN1QmcyScgEcffVSZzPnmm29mzZq1ePFiopqjR4/SfyorK1taWmLnJSf3ojX9/S/+DSknJSWJlPPy8pC1ZJg9ezbzOVQoSb/IvY6enh5Wpk2bJkYL+vr66CrIOj8/v7y8HE1nZ2cPDAw0NDRQEvnRlI55QmPsPnNByu3t7efPn0eFmZmZWVlZhoh9QXPWz1xwsZcuXUKIq1atKi4uNssmyDOX2tpalR4OUqZvUDxWKFtKSgrnffrpp6XbuI7oP3MZc5oeIeWMjAxKq7aZ09rayo64cAtNd3R0eL95bAbnbWxsRNYlNl7R5KTo23iGN3fuXJsFjh20piOFSFk+mZWWloZXDlYZr732WmlpKaryK2vDiVp7aCDD5s2bt27dajEs+ELkQ7hy+vRpuQT2pSQQ1EFGBa1phxE/J//sIjQpGxBXgLzFpkzBQzGon/HjxxOfKFPwuCs40Zp2BpEyjo31MKXsDUEwxwn5FWo0R68gSnHq7SWKQVgS48FJnGiamh2VH13StJ2dnY5L2QAN0UJcWl5eXrCyRsRdXV3vvvsunj4SmvMOTigbMQnijoXgJB40XV1dTZtF8+cP3lJmIH7xxRdpS9nkOEiHFlqwYIG8Dm9T2eKhm5ubJSJX1ogRO8GJeIHy8vJodi1nNC2qYjk0NHTjxg3iRemXMhpG6JUuQ8pUXGpqakSl7A2no99ypQUFBXJGM2WLhhBWY2Mjy7Kysuh7TQnDqKuoBSdcqYiBM1Izt2/fnjhxIlWRkJAQhbNDuJru6OhobW2l6JmZmU888QRtRsVhp8lxaVwedQpcBo7NkRYdLSmPgKsGruv//u//Zs+e7dtpKR5FbW9v7+3tNfz6KBKFOydcr9ympFo4MkuRMpswIgbOfv78eRQS7A8LgiJ0TVNHzHVYYTqIoI1xzXBahoWcjLzHjh1buHBhyE1LfeFv5FcYoyjlESBrejVFop2Sk5ON1/doP6AGCOupn2hGk3agbI4HJ3V1dfReLtZ7WPYVAxbxg/SlkpKScM5oRoiapjpqampycnIkbjaKbgZFR9lMH/HfxKP2r4RKxysbUqbqI9e/Q4ZLu3jx4pUrV6QeuLopU6bgpRx0gRGCAouzkHEvtOCEy5eJL8EYarYjBvLIUyrisaDOZYdQNC3v+hQXFyOvgBfgDRfD2IRAxcFb4C1lrvmFF16IQSnHGUgTZaNvKl+q/fvQJFBwwl6bN28W7xasGGTevGXLFmdlHbSmueCtW7daPFGzhiuhPxDS0bOVyQst5RiBhrAZnGzatIlgI4Sbm8DRcNX79u3buXOn75FDJmhNcw3ETIsWLQrhGgRKX1lZSZcw7veJlKlBmV5oKccUtAv6JkTxvXNCMMmSsDgcMTB0c/Dy8nJlCpvgNC0v+HL6kK8BuAzD2UswZ0jZvW+fjQUkODHunOCemeoFDCMDQovjKHFwHFCZwiMITaNjzi1BvYWmKWJAxUvvPHjwIP6eTu9920TjCvBK1dXV8h5iOA4OaHpmaE1NTeF3DyGI3wQQ+jBdsBY0mygfflelTSBbdna23M2hd2pBuw656+wbgtKUgkp7YWbnCISabCIEUKbwCELTBAlZWVkqYQJqfv311ymc39J7g6CBma9Ka1wFDZeamurbygSTjMB+BYCRTTh4lR4OY7VTYrCraToTemV+oNImcCW+F2MGR3Oqa2qiDA03b948lXgATY/9rbfeqqmpGeG/gQklmxC9X4UgBjO5B4tdTVMUlkx7fcsaMjNnznTqMjRRZmhoiGFWJYYze/bs/v7+bs8762Jh5cyZM0iITWIZAaLiaCwdUVcQmiaEsu+DA0LpJ0+erBIaVyHiQwwslekBWKZPn47TbRn+4dZDhw5lZGRYvCPA0SDgTMwOQcQenFIlNGMb0Z/ZP/m8c+dOXl6e3NKWnKyQXL58uW8fGEHADHawey+vtbWVYgW8M00/W7duXVlZmZ2HMnI/aO3atSqtcQn37t1jtrdt2zb0qkweSOKeGzxs2LCBSSRKwE4r09bkX7FihYU2yFBSUmIW0tjHrqaJ/SmuFNEC+5rm+jkml5GWlqZMGvfQ19dXVVUlQbAyeWn64MGDbW1tSJl17AUFBXjDzMxMC01jQQwwop+EApq2A3MCinXt2jVWLCBDbm7uxx9/rHbz7OgXNh05cmT37t2STeMuEJ+0smpODyRRM4GHJFmhibHk5+ezSbTx0UcfjdgLsNBJEBgr4WM3nqb3JCYmSoSkTOZcv36dnIAntvDWbJ0zZ45KaFwFs8DTp0+rhA80OjrBK4vPZkVtMAcxhB91CHY1DcxbOzs7VcIcLqa+vn6Th/Xr13f4+2ep8I3n3yk49YhfE2WysrLOnz9v4bAgOzubViYPwYYymc8Cu7u7X3jhBZUIjyA0jf7E+1q4anx5rQeCLXjvvffYy/cyOAKTTvq6xaE0sQw+lbbzdVgkk5KSWKHRyUOwkZOTY9zCmz59um+LY5Hx3KmXMYN+Lw9NE+ab9TYYUWi/OTGG8C0iTUyBEHft2oXnUulQQTAVFRX4cm93Hg5B+Gkg6kfTZuGEgF69UVYv2Je6WLhwoRa0q2GYhf3791uIISDsK09nnBI0BKdpwEmjSOsIxAL2amxsZKo76r+j1oRPUVFRb28vYWTIYujq6jp27BhTL2VygkcIANSqPYiY8a/Ies6cOax89913aoMNRNC4+W3bto0bN05ZNa6FRszIyNi9e/cjjzyCzw5WDPJhqjfeeMPZETu4eNpAfma7bNkyJgEk/cYY3nABTIHr6+vleVJo3VoTm9CmlZWV6enpa9asoWXtiIElIQce2vEf2EKImgauBG/NivE5IvC+HkO4GNva2hihuOxwvuepiVloYolI5SdY0vQjxG3ogYEaQTPgl5SUROLLJ6FrWhCxUtzMzMyZM2dOmzbNeLVlcPindwigHe+Rmpji7NmzDQ0NSBkxeH+UC5hBXbt27dy5c/IOKsN75B5NhKtpgYuRL5ZL16TQssIl4cKzLP+thCbOwFt3PvheHklvMeDUiL+NUT1COKNpb4ibWXIlIBbNmAU1i6AjEWOY4bymNZrRJej70xpNjKM1rYk3tKY18YbWtCbe0JrWxBta05p4Q2taE29oTWviDa1pTbyhNa2JN7SmNfGG1rQm3tCa1sQbWtOaeENrWhNvaE1r4g2taU28oTUdNF999ZX8Po0l62K04NKlS3ayaZxC/3brB+TjUgF/DlxdXT1x4sTi4uLGxsa+vr5tw/9xemtrK8cpKSlRac+3IjZu3Oj7gcPKysqsrKxFixZ1dHScPn16woQJd+7ckU2yzi4gP8YWOyQkJAwNDanEAyL6M2zXEfR3mOKYL7/88s033/zd737n++tghPXZZ5/hbv/zn/988sknP/vZz1DbF198gf3xxx/HyPrNmzenTZs2bty4nTt30jFI7t27t729nU337t1jrxMnTpCEn/zkJ+REteRE0w8//PDdu3fJJh+TYMe//vWvX3/9NYonyY7d3d2vvPLKk08+SV8aGBhYtWpV+gPmzJlz6tQp7M8884wq65hHa/oHENDnn3+Ohl566SVlesDx48f/9a9/ITtAwfPmzUND+ON//vOfRCAYWb9169Zzzz2X6IGDsI67/dvf/sbRfvvb3+JfZ8yYgdYhNTUVFaLRy5cv9/f3L1myZO7cuaxwZPR94cIFXPumTZsoD6fm4Ki8sLCQ3XHYJJOTk1E2XYJTL1y4kFNzcK1pg7Ebe3z77bf4P1Q1ZcoU46OaeOL169fX1taiPLH44h17oKfy8nK1wQeOhjTr6+sHBwf37NnjNyfF4CCIlZ5AeZDp9OnTccCsZGRkEFQQzPT09JSVlRHksCJRDSNJc3Mz3eDgwYMcn331NzUNxu4csaKiYt++fQTEu3btYl2MSDkpKcnOv0PwC+rkaGhdJoWs40fRH8LlRJJHaGtrY2tLSwtb2YsMiLKqqmrWrFn0lry8PEIaFKxyP/TQ/v37KRvKJtpB6+THW7/33ntycJVJ42GMxh7oAPWsXbsWD01sUFdXl5mZiUrYdP78+evXr48IP5Ag7pAloCqJPQgVcKLE2WLnmIQHRA4ffPDBb37zm8mTJxMu/+hHPyIOIUQhWiAnveXDDz/k1GRmiGB3gmOOg4e+ffs2pyb4Ifhm08WLFxExAYwENn/4wx9YR8HsTp/hOC+//DKnGz9+PMfX8bQ3Y1TTzORQMOpkxoYm0A0hLxJh0+nTp//73//6fuIbhREBAyM+GmKOiEZRKj5V7CiVI2DngETMJH/1q1/JCvEuulyxYoXkTElJYZmWltbR0bF06VI2Xb16FY/+05/+lJI8++yzhNeUgUKKphE93YxRBSnT94hnKB5enPAD9//dd98Re2hNG4zR2INoFWXU1NQga1wd/k9t8NxH8x3N0eWCB7AuRrIhdGUdbpcV9C2biBY4LEKUpHxoa8QtOe+TMt0cUYYnnniCwGP16tUSLDFn5ZiMA6+++qp34TUwRjXNnIyQd/fu3czbiF+9BcR8zlclZMabChIrA9nIrKwexA6PPvoosTLTTZDOg0eXdZaEOirfAwg8CFroYHfu3OH4eOURiqcnUMjHHnusqKhoyZIlzCNJUgA6lcqhecAY1bSImCXg9sQoIM0R/1pX8lQ/AOXhdLEjKTIrqwfcv+wCeGU6DOBfCZrJzApgWblypcrkgeMTjdC1SkpKiCLYMSsry/jksQHBtxTj0KFDnJdzURK1TePFGNU0QTBLfB6OkxXjq5sIBbkwrEtSQI7btm2rqqqSf5NHRCsP/MhM4CtGgeMQInOEU6dOsY4TFciGWAlOJCmn27NnD6F5V1cXduPztfn5+fhp5qOsFxQUiFFA8ZyCkmDnIAhaa9ovY/r+9JkzZyZPnoykUCfCBfl3M0hHZfJHZWUlokRhvs/GERmdBE984sQJpClSxk4fYBaI+5fOMGfOHFHk2rVriUOYreKnPQd4KCkpiYKxQs779+/n5uZyHM5oiJ5CyopAZroQs099f9pAv+/xA4ijoqICjRqzPb/ITWXU1tbWRuDrLSb0d+3aNaaGrOOAz507JyIeARmIjMVhI0p6EcfB7puZKIVjciLf+zAG7e3tdBKLDGMNrekfIGDFYWuH53a0pjXxxth9Nq6JV7SmNfGG1rQm3tCa1sQbWtOaeENrWhNvaE1r4g2taU28oTWtiTe0pjXxhta0Jt7QmtbEG1rTmvjioYf+H6fQc9CYASHBAAAAAElFTkSuQmCC" alt="非连通图"></p>
<h2 id="连通子图"><a href="#连通子图" class="headerlink" title="连通子图"></a>连通子图</h2><p>在非连通图中，存在至少两个连通的子图。</p>
<h2 id="极大连通子图（针对无向图）"><a href="#极大连通子图（针对无向图）" class="headerlink" title="极大连通子图（针对无向图）"></a>极大连通子图（针对无向图）</h2><p>非连通图中的连通子图称为极大连通子图。</p>
<h4 id="加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？"><a href="#加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？" class="headerlink" title="加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？"></a>加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？</h4><p>无向连通图只有一个极大连通子图，就是本身。</p>
<h2 id="极小连通子图（针对无向图）"><a href="#极小连通子图（针对无向图）" class="headerlink" title="极小连通子图（针对无向图）"></a>极小连通子图（针对无向图）</h2><p>保持子图连通但边数最少。</p>
<p>若极小连通子图有n个顶点，则其有n - 1条边。</p>
<h2 id="极大强连通子图（针对有向图）"><a href="#极大强连通子图（针对有向图）" class="headerlink" title="极大强连通子图（针对有向图）"></a>极大强连通子图（针对有向图）</h2><p>子图中的每两个顶点都是强连通的。</p>
<p>推论：一个环肯定是极大强连通子图，每两个顶点互相都有路径到达。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASoAAADpCAIAAAAcU+3WAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAEgpSURBVHhe7Z0HXFNXG8bDkA0GQUUcGNwLJG60VWi1/eSztYDVihs3jqooDmxtS7W1ULVKq1bqAhUwaFWso422VZwkonXgiqIiCJrI3vme5NzmiywZIfcm3n/93Z57zrmXe3Le57zvudOgoEDOYWFhoQND6v8sLCxah5UfCwttsPJjYaENVn4sLLTByo+FhTZY+bGw0AYrPxYW2mDlx8JCG6z8WFhog5UfCwttsPJjYaENVn4sLLTByo+FhTZY+bGw0AYrPxYW2mDlx8JCG6z8WFhog5UfCwttsPJjYaENVn4sLLTByo+FhTZY+bGw0AYrPxYW2mDlx8JCG6z8WFhog5UfCwttsPJjYaENVn4sLLTByo+FhTZY+bGw0AYrPxYW2nhzv+8XGbnj4sXziYmXr1+/XlxcXFpaikwjIyO5XO7q6uri4urh8c6YMeNIZRaWhuCNk19GxrMffvh+y5afysrKeDxe//79O3fu7Ozs7ODggNK0tLTk5GSRSHTnzp2UlBTIcubM2fPmLbS3b0o2Z2HRIG+W/IKDg7Zvj7C0tJw5c+bQoUOhQLg7MzOzgoICY2NjVCgpKSksLESmhYWFVCo9fPhwXFxcXl7exImTv/hiNdkJC4umeFPk9+hRyoQJYx49ejR58uSRI0ciB0GmgYEB/BvSSDRq1AgJrEKHhoaG+fn5UCBkCYnu3r17x44dXbp0iY4+0Lp1G8XuWFg0wRtx6uXChXMDBvSCkDZu3Ojt7Y0c6A3yI96PgDRZRT7mgSYmJvCEWJqamk6aNGnv3r3wir169bh8+SLZJwtL/dF/+Z0/nzBypJe7u/u6devatm0LgUFXVNnrgCCxhGNs3bo1Nufz+djVuXNnSSkLSz3R8+AzJeWhu3tvaG/ZsmXwY/BsRHsIL0kFApwhlaoCVCBTROzn/PnziYnX2CiUpf7oufwGDOBDdd9//z3Eg0iyqKgImYgt4dYgRXhCUu218gPklExWVlZQUBDUe/bsZaqAhaWu6HPwuXTpIvirpUuXwuNBYMXFxZAcgHiI98vPz8cSUiTTPJUaK8Xc3BxRqJ2dHXaYmJi4YsUSqoCFpa7orfyeP8/cuXO7r69vkyZNIBv4PbgvMpcDkB/8IZfLRZoILzo6etq0aQ8fPiQVKoJtoWHQvn37BQsWREXtzsh4RpWxsNQJvZXfhg1hEN67775rbW0NsZFQkzg9ApwhBInQFLrasGHDN998IxaLpVIpVfwq2BwhKyCr48ePx1YbN64jqywsdUNv5bd9e8S4ceOgPaSJ9iwtLUmRCmNj48zMzBUrVkRGRhJlwiWSoopgJ5AcgAOEbkeMGLF162aqjIWlTuin/Pbs2YV53Ycffoi5H1wWtAfN5OXlUcVKEHkiIoXTO3PmzKJFi6ArKLBcHXWwByyJG0TNMWPGYJOYmD2klIWlDuin/P7881T37t2RQGyJJVFOOeD3MCeERGNiYsaOHQtRIRxVj07VwR5QpCqF27SxsXF0dExIOENyWFjqgH7K7+bNG126dIFmyJWGiqAIcSbc14ABA5o3b67SFbwlSVRPSUkJtNq+fXuxWERlsbDUHv2U39WrV93d3eHQzM3NqaxXQQwJ16eKJKFGUhOZpEL1YEP4VRcXF5GIlR9L3dFP+cHpOTs7E3VBWiqoYqV+VI4OrqywsBBzRegQ/pBkVoTaxb9gz05OTtXUZ2F5LfopPwJEQqU0DZwkcHBwgAipLBaW2qPP8mNhYTis/OpCsZK0tLTq71NjYakevZXfhQsXqgk+UUTOuJiamubl5ZEzLtASufqXm5uLJXn+vRqePHliYmJCrbCw1B79lF/Pnj3FYnG5u8wqAg+GpbW1NbnXDKtEsWZmZkr3piitFMhVLpcnJSW5uLhQWSwstUc/5efi4nr79m0LCwvyTEOlkEsORUVFX3/99YQJE0jmkiVLwsLCoC64tWqcZ2FhIeo8ePCgWzfFxX0Wlrqhn/IbMsTz4cOH8GlQIJVVAYSd0FhJSUn37t3ff//9KVOmQIRjx45t164dlAmBoYiqWgErK6vMzEwEn2+/PYTKYmGpPXr7uG2TJpazZs3y9fUld7dQufUA0SaiWaJM7HPbtm379u17+vQFVczCUnv09tTLtGkzDhw4gOAT2qsmjKw5iFSxKyiwcePGkGJsbOyUKVOpMhaWOqG38luyZDmCzxMnTmB2pxH5QXLYDxSYnZ29detWrC5YsJgqY2GpE3orPzs7e3//abt27UpLS9OIA0TMibkixPxA8gDyw87ZV1+z1BM9f9XSwIG9ES6uWrXKzs7OwsKiWPm6F6qsxpBNyGVAiBlTSiRu3ryvKGNhqQd66/0I0dEH7ty5s3bt2qysLGgP87faukGiPWxVUFDw4sWLL7/8Estjx4TIlEju45+yFgtLXdBz+bVq1frw4WO3b98ODg7Oy8sj1/pqrkCV9nJzc+H3Vq5cmZycfODAESentsgXiRLnzw/Yvn1bVW+IYWGpHj0PPgkXLpz78MPhzs7On376abdu3cjNZTWJQlGHaO/58+cLFy6EgGNiDvTrN4AqVjrAlSuXQX6bNm3m8ZypXBaWmvFGyA+kpDz08Rnx+PHj0aNHjx8/3tzcHNKCCMn9ZUiQqV1JSUlRUVGjRo0KCwstLS0RcGZmZsbGxsbExHTo0EEgONymjRPZoTpwgPv3x3h7+/r7T6eyWFhqwJsiP8LKlUu3bdsK7zdr1qz//Oc/pqamcG4QW05ODrl5Gtpr3LgxlghTU1NT4+PjDx8+DBFOnuwfEvIt2UmlEDeIxFdfrWHdIEsNebPkFxGxdenSQMSfEokkKyvL0dGxf//+Xbp0adOmjerzmo8ePUq8nHgr+Rbq2NjYfPKJ36JFQU2bNiN7qB7s382tF5/fi1pnYamWN0t+jo52mL95eY2IioqJjo7644+Tt28nX7lyRf0NSwhHXVxcunXrPniwR50/Lo3ZoEwmZd0gS/W8QfILDl4aGqoIIJ8+fWFra0syGwih8Hf8LR+fUd7eoxr6b7HoLnp+4UEF5maIDJEIDAzSgh48Pd8ND98CEULz7LVBlqp4U+QHGSAgRDSIiRyV1cDgbyHEhQ67dm0vEMRSuSwsarwR8hOJEuGIkNCO61MH8eeNG3fj4mL9/D5m3SBLOd6Iud/w4UMhPz6/V3z8SbpmYgh9uVxbqJFaZ2F5E+QH4UF+SCAUZIj1ww2yJ0VZgP7Lr0uXdjB3zMEgPyachMTBIBDFFJSusSBLqniJRo5M8YLgbGVahbWt4tYfK66RjTLB0tDoufwQ8gUEzEAiIeEyc66GQ4HBwUuRCAn5piHcYLZUni6R3xcbZEs5SCAnTaLIz5LlZUqfmtvmG0Bp3Ipfs5DLOYq3cjyVFBtxrOxtW9hwFW/KsbblWHI5zXkGSDTncRx4BhbcUmtb9gWnGkCf5SeVSt3dexPXd/ToSSqXMfwSsfW70G8DA4PqeadolrT4tjj7lignVZKfLjGQSuyNOVZQi4NCKoZK2RhAP1aKZS1kAyeZJzPKkXJyZQo958ogaU6OVJ4mkb+U5Zhwn0OKjjwLR55ZC8U/E9Zh1gF9lh+5zo6AE66PmXMtDBAIRHGEtXWDSUKFGLC8I5LLZNLWbi/a841a8sw7ulk78sy1oIRUSQHUnizKeyYxLpbZ5kqNrWw5zm4KzTvzi6FGqh5Lteit/OD0hg8fiiV8S3j4FiqXeUCBcXH7pdIXcINUVhXA4i8LX4iFBQ9FNq14tu35hrB1F09FNEjVoA84SXjF+2LOHVEpQtwiTmZznryTm3UvzyasV6wGvZUfpnyY+MGlIOzU3dOM2dKyNElZQpz8rkheysm15+W+7WMJF8dwm4ZjvC0qkIhNJCJTa1vDdm4G7fjwjXKkqRosSvRTfiJRopfXUDgWBHWv9SqMorFZl51RP3l49r8tzjkjKEmXGLXhcZvxOK6eBh34uudGlCeBECRz7ovlJZw8O17W297WnfnWVPEbj37Kj1xnh9PDrI8JFxtqToIweVXAb6acZt35bYZ6O/f2bGpjW6MP7jIfEjz/Kcg24dh14lu/79/IgfemO0M9lJ/qOjumfLry+HmWtOTPuOeXhS+zpaVv+ZikSq9fFJ+BD5zk703V0CNSJYUJAqPjEcVNeQXD/A2G+HCpgjcPfZMfAk6EnQg++fxecH1ULoNJk8hPRMjhE7p75kN4vT2bkHxybdDMzCQ4+Csej0cy9YxEYdZZAecfodEgH8Oh/gYteGZUwRuDvsmPXGdHwEmeNqByGUmyKP9khME1oYm7j9x7EafSK3JojkCw/+jRE9S6PpIjlZ+MKL0jzm/Cyxnub+v4JolQr+Snus7u4zMK8qNymcddUdnxiLJUSb67T+lb3lbsqXmQLS05HZcRHyHr6tbiPf9GnfiWVIFeo1fyCw39FgEbXF98/ElmvnAlWZR3IqK0QGbh7m3o4llWq1u3MLJgKqv3L1M7LcjcEVzI4xdMC2mp955Qf+QH19e1azssmXmdHXM8QWhJqiRvmL/czbMuHg9NmzNnJhIhIfr/MrWY0JwLcWaunkZD/Uta8PTk3G9F9Ed+5Do7A28xy5KWCMIK/4gwnRBiOMy/XqfaocC4uFih8A9vb1/MbHXrmkptyVbMCTl3xAXdPQve8mb6nQZ1Q0/kh/lely7tkAgMDAoJ+YZk0g4MKCGu9E9BTg/PIi9/jd1+JRIlhoWtteXaLgpcovdu8LaoIC6szIhj9tEig/Z8+m+v0yx6Ij8/v48Fglh4A+Z8bvaOqCQurNSKa+QdWNYQtyDD1YeFrr1x8y61rtecFch3Bcv7+xRODjGnsvQCfZAfvIG7e28kmPM8+67g0pOCe/PDm/b21Of4UJsght8WnJYhMZsUYq4350V1Un6YAonFiVyuLTm9OXz40FOn/nBz4zPhOnuiMDsymNPGLWdBeAsqq+HBvBc/hd6fFAWJQunxiOK2bqVjA7X38zYcOim/0NBvV65cxuVyPT3fdXPrRT6uEB9/gt7r7JjpHQgrk0lzB/rIe3k2pnK1ArlFBokGenyeUaRKCnYE55tycxeFt6KydBadlB9xd9SKEg+Pd+h9nv2OqDguTO7AM/xoEYeuc3QYlRAUYAx6E9zg9uC8G6LMBeHNHXmmVJYOYhQcvIpK6g5RUbsfPFC+veRfsFpQkA9PaG5Ow9T8jKBs18qSYf7yD+aYmJrTdhe/u/sghKAREVuFwt+7du2m35cl3DwbmZtZ/BZu3JzHadJCV8+I6s8TH2Fhax0d7RCDYWZIZTU8WdKSHwJeXhEWBUWZvOVD/y0aiDyjomIgQvKkP5Wrp7zl02iYv8Eqr7IrwmIqS9fQyeDT3b23WCyiViojP1/xxq6GBtoLn5Njx8sZs6g5057Kwxik395PBQn7B3obD/LRPV+iP97PQA0qqyERCXMWuufx3Iqnh7Ri4BOxKu0hFsU/bUYEWqYDv5H3IoNdwSV/C3TPB+qk/KoxJm9v3ydPMqmVBiM+4kWCwHBJlMmYwKZUFlPBfBhTQcTkehyLQoFfHjU6GcG5J9KxUE4n5Qf/JleiWgVt2/I2bvxp48bNDR10/Rycel5g4hNo3JGvA/fjYx5IZoOI2OEGqVy9w4Fn5B3I2RFclC3VJQXq5NzPxsa0qKjI0NCQKBDag9PTwkfV0bU7g4vknMK54TZUlu4A7xeq/LpoYGCQvl4b/C0i/5zAdEmUoZWOTHt1z/sJBLHQnpGRUVmZ4vwKl8vdvXtfZGR0w2uv7Kc5pda2hhNDFK9e1znw+4SHb4EbDAiYIRIlUrn6xX/8zdvzDeLCdMaj6Jj3w6wPQdTDhw+gPXg/7Tg9AL/305wSnlvJqECdv+UXbpDLRYSun+dFs6Wl3/oVeAfK+Z5WVBaDYZb8oqOj/vrr9Pnz527fvl1SUqKKLZF466232rfvYGpqtnnzj8gk93Zo5wbrNEnpruAyZzcD38A63s6yf/8+tCsh4ezNmzdLSxWfFiLAh/fs2dPFxXXIEM/Ro/2oXG0hFP4OKdbnFpmYmD1///2nqr9I09AoY2NjV1fXHj1cBg/2+PjjsaSy1kgUZh8INQyKMmP+d2AYIb/MzIwffvgeuiouLm7fvn2fPn06dOiARPPmzVGanp5+9+7da9eu3bp16969e3B6ffv227ZtZ9OmzcjmDQr83nd+pQN8Sv7jX+sTLWjX2rWro6J25+fnd+rUqX///h07dnR2dm7ZsiVKnzx5ghaJxWLYbkpKCsx31qyAgID59vZaOpta59kg6a+IiJ8LCwvRTb179yb95eDggNK0tDT0l0gkunPnDtoFTc6cOVub7QK7guUOPM4wf6bfDUO//D77bFlk5C6Iav78+e+99x6sECJEbAmnZ2KieEwOq+bm5uRcC4LPw4cPx8TEoHTs2HFffdWwT9bC733rVzTQu1Ed/N6yZYHbtm1t0qTJ3LlzPTw8SCaZr8I/YIkWwaujURYWFmjXb7/9Fhsbi7Fm2rQZq1d/p6yuDSIitkKEUGAN3eCKFUuio/fiyAMDA4cOHYr+AtAYGtKokeL6J1YLCgrQRvSaTCY7duzY/v37nz17hnZ9/fVaspOGJk0i/3y4/LuEMoY/I0+n/FJSHo4a9eHz588/VoJuQ5+hF4l1QmAkQbqTKNDMzAw9nZWVdeTIkY0bNyLC2bNnf5s2Tsr9aZgcxXnO4nb80vf9azffS3mUMnrMRy8yn48bN87X1xcHDEgRrBbtQmyGNIYV2CvaC98IBaII1aDADRs2dOnSJTr6QAO1qyIQ/5w5iq8gLloUxK/6FVXoLx+fERggxo8fP2rUKDQEmaTLkFBvF5mZq9qFHIFA8MMPP2izXcciii4JM1dGOVLrjIQ2+V24cO6TT3wRrnzxxRcIxtBDRGwqSO8S0IVUisMhnY36qampS5YswbB6+PCxvn37k1IN8p1fSTs3I+/A2gUwFy+e/+ij/yISW7x4sZOTExQFo6yqLeqgXaQa7HvevHkYlX799Wjv3n1JaUMDBcbFxYpEigcmKp1Rnz+fMHq0N/pr1apVrVu3RrvQXzVsF5YoRbuWLVuWmZm5d+/+huivigQPz2X4ORh65Hfp0oWRI70wF0J/YIBEDvFvKi8BqulaFJFSuMFvv/02MTExNvZgv34DSGn9yZFi8lBmYVvks6hRrabv0J6v74d8Ph82StwC8dgk5iRUZaaAtAsgZlu7du2pU6eOHxdqsF2vBfKztbWtOA9Ef40Y8X6/fv1WrFiB/kLT0F+mpqbqbXltu5DIzs5evnw5ZrwHD8b36dOPlDYcImH2iQijpVHMvVBEg/wePUrp27enu7s7/IO9vX1ubi4ZShGJoQtVvUg6jFBp16ICtkKEs2bNGkww/vnntqaimp3BJblSw9nhtbso+iglpf8Afp8+fT7//PPGjRtjaIDq0CiYKXw1VamKtkCoKomSdr148QLtuqjgipNTW1KkNSSS+0Lh72Q2+PDhA/QXxsqlS5c2a9YsJycH/YUDxsxcvS2VtksdtAu/A7bF2CQWi8+dS2zdug1V1mB86ffgLW9rDx87ap1h0CC/gQN7o6u2bt2KJeZ1MFBYG9LqLgK8Vn4A+bADxJ8rV67Ers6fF1MF9WBPaFqmxGJyiGVtT1u7u/dBUzBzs7GxgfYQc6JdAAeGUlUTKm0Lqql7ftTBKnwFLB6bX7hwhSrQFuSkqEym+ELbpElj4eu2bdum6hH85jhCUJM+Ugf10csIdBH1QL2nTiVQBQ1Gsihn/Zy0nxLaU+sMQ9uP237++fLLly8FBwfb2dmhJ2Cj6Ev0CjoPdkaGVYA0uhwJ5BALRmVLS0uYNboN9Qnk9he4mq5du2JmX1RU6OFRr/dNHIl4fnqP4aKIWr9V8stVn108f37lZyubN2+OMR5Hjkw0CsePZWFhIVYRXaNRaDJpKfKRJqXklJJyTwpI69A0Ho+HcSonJ/vdd9+jyrQCQlAvrxFZWS83blyXlvYUamnaVHHZgBwYSeDISUKxwb9FgKziF0Ca1FGB/kImGtuxY0f0V0FBvqen4ltUDYd9CxOJqFF+QV7brky8X0Kr3u/580wXl86TJ08ePXo05ATzIp0EyyPGh0z0DeKuEydOHD9+HPaKWf7MmTOtra2JfyjXqehOWDA53x0ZGQlLvXnznp2dPSmtLYmKqYJ8Yohpbd9fkJmZ0b1Lx7lz53qP8kYTcHg4TixVx4kjRwiKJVoB0AQoECpFAjUxrKAhRKLqYHPUOXTo0JYtW65dS9bmdTOCol3dO+L39/X1xSqOFqgaVQ2ogwYigd4hOUC1IZqM0gMHDvz44483btxt6HbdFuV945fzy01tXCWuLbWb3tSTtWtXY1gdOXKkSnvIJPaKBHIgs0ePHvn5+X333XdJSUnnzp2LiYl59913b9y4AetE31tZWal6EQnSu7BRdOeoUaMg1/XrQ0lpbXkqKYoLlQ/zN6jDu0PWfx/G5XJHjBhB2kIERpUpgcCI9rBEW7766itElRhiMI9CTQw3FbUHUISR5YMPPkA0Gx6+gcrVIqGh32DU+M9//oM0DgaQ/OrBL4Ca2BBQWUrQ3QT8SliFpC0sLNata/ArnB35Fm35OTGh2dQ6k9Cq97OxMf3000/HjBmDDiDdia4inUFWkZ4/f35CQsLQoUM9PT2hwPj4eNhoixYt4ARQGZ1HdoW0agmbxobo7F27dm3fvv3Zs5fKKrUgW1q60it/qH+xl39d7oR0aGo7b978YcOGmlma4QhJQ0iR6ghxeMhct27d7t27UYeEnXw+H54NYwdQdxTqYG+Yd8XGxj5+nEFlaYs2bZpPnToVwwq5/6HmoGl79uxBYuzY/99xRvoORfgdSHy+Y8cOxCyZmQ0uDMwAo4JNF0cZW9vWaATRGtrzflFRO/HTe3t7EwOlctVAaUZGxtWrV728vEJCQjw8PJYsWdKvXz94gNTU1GfPniFCo6r+i0KyyjkS6mC38JMwlMjIHVRxjRGElXb3LKib9mKj92Lp5TXcXHmJGbYFsSGBTLIEcNr5+flisRjaQ7vg/WbPng0TvHTp0sWLF4n2VJXLgeki4gVU2L9/H5WlIYTC30NDv8WSWn+V6Ogo/Gn0BdKqY6vqIAEcOErRfHQHHPvGjRtPnTqFn4IqVgtzALoJ1d577z0ELPhDJLPh6MS3MuAYJQmrPHi60J78/vrrdPfu3WFGgOSQzlCXolQqRa/MmDED3YbIBEXofqgO6by8PJJDVa0Adtu2bVv4yYsXz1NZNeOMoCxDYvzxotd84jg0dC3+UStq/PXXn+3b///EGhqlgsricODAEX/C9bm6umKJRn3yySft2rWDFcIrorHZ2VV6AFRo3Lhx06ZNz579m8rSEBERW1euXOblNYx8Cp/K/ZczZ/7q3LkzuoP0V7kWVQQjICpAY2lpaWvWrMHggml8ObdJdkI6EfXRXw4ODhcunCOlDYqHf7ZYmE+tMAbtyS85+VaHDh3QnS9flg8OVaKCHR8/frxVq1boG/Rfbm7u77//jjSKnJyc0LUq6VYEoy826dKlS60eZkuTlB6PKB0f8vqXcwYHL8O/Fi3ssMQwQeVyODeu/9OmTRtYaaOqo0ccNg5v69atmzdvRg7S169fh6vn8Xhubm4oxaSXVK4INkf9Du07JCVp+PKD5N/XT5w69QdE6O7eOy5uP8kB15XtwrEBKut1oIPAt99+i7ESq+gOHDkpqgh8PipD4dp5+HCIT+OHkrRkUS61zgy0J7/z588PHjwYxkTmAJUCpZHxEo4OS3Q8whg4h3HjxsF7oMOq7074yW7duiUm1rQ7MeVb5XdriP9zB15NfgeM/XIIDwHbW+79vvh8JTHfs+fP/ve//0XIWdWxYbzHEraIoQdtR0R39+7dpUuXZmVlwUuQX6Oa3wRFEGdPt56IVKksDcHlvhJsi8WiceNGQ4TEE2IG/sEHH+DgK8b8lUL6bt++fWfOnOFyFaFE9dJFf+E36dGjh8bbVRVv+1j8FZdDrTAD7Z16MTMzgJaaNWuGH13l7iqCWAtOD72O+RLmSDExMXBomKBTxa9CLJuANHr0ypUr8+bN++CDkVTuvxDrLlP8X7EwKGtixel2V5Sby3nSmd8YE4NSTn4p57mck2eskJlhKcdQjmOUY+qC/yv+Spzg/56BUMYp4/GcHz9+FB8f36RJEwwT6ipSb6P6cf7111+Y02LgRyZCr6CgIIxKsN2q1Iv9oF1nz55dvHjxyJHeVK4mgMxkMhm1okR1nO7uAxMSziISsbOzg/zUY8hy7cKYgobj4FFHIpGMGTPmrbfeQpizbdu2Xr16/fzzz+ptVwf52DPGyrlz52rHCFMlBTuDi+dssmDOc4AMkh9sl5gvrA19KRAIVq9eDW+2fv36qmIz9a7FtrDpR48eeXuXt1FUU8pOhZkRp6ktpw9SuUbXC+SP8DcNFOWKv24oV1Qs4ygMTi4vhlINlX9ErhShOpAfllAO5Gdvb492keMnVCW/jz76qHnz5gizyYUH5Bw9ehQ5VTkZ2DeW9+7d8/X1rfR30yDkONEitAUJyA/tgrvGmKgsV6B+DEgrflvlo0Zoy+zZs2/fvh0XF4dB87XyQ7vQ0VDsqFGjtGaE4QElrp6GzHkjKLO8H/oDHYnujI2NDQ0NhY1u2LABFgBdUTVeNWV11OXn7a24TEwgv7Rie/xNxZ81MSyzyZGaPhSbdXZr0sg2nWP0nFOKuYq8DMakrKEC6yoEglgq9S91kx8xZcyObty4MWXKFHNzc1gtwteqhhh1+Wn26f6K3g/HbGtr6+TU1ta2yR9/nHyt/ABRIMaO3bt3Y2b7/fffv/POO+g1ZsovSSg/FlEcFFW76ygNBw3yw49OZVUAFgxzxNiJSZGzs/OmTZtsbGwwD6yJ/JCPPZPgMzv7NdOVuX472/DsF4cozqrXEAu4zFeB/AIDgzZs+L5W8oNcsYRNw8P3798fRZMnT541axZCOFKhHCSfBJ+5uVX+dHWg3Jdq3Nz4ISHfqL4Shf56rfwQc6KDsrOzH0gejPUb+95773322Weo/NNPPzEw+ASY7a/xy1oaZcWQNyNr1Qv/888/6EtqpTKgveTkZPi9zp07h4eHN23atHHjxuikGTNmLF++HOpSt+9yoJTcsFZcXLkdqzgteGkg7Vwr7QEDGB7cIcZ6A3lj28ZLli57+vQF7BXmePnyZRxkNceGImPl3a0Y8skQA+0h0aNHDxwz7FV9fCkHakKxUqm0mv3XDdWTtW3b8uLjTyQkXC73hTb0V35+vqWlZVUSwsGjCMf/y/ZfkDh27Ji7uztUt337dpRCWkiT823YT7lhF8MKfo2MDK3eS4BZnz0v93Rcg7+IuYZoT37du3cXiUTkBCaVVQGEjhMnTkSF3r177927NzIyEmHMypUrsaGDgwMZL6mqFSBe5dKlS+hyklMpaRKOMMI6IKQHtV5LuFzulCnTYKmrVoWQl4W5uLjg8GBJgNSpCJRD3B2sEE3AGAG95ebmXr9+Ha4DTgNpqmoFoFtUFovFrq6uVJaGWLQoKDIyGsK7efNeOeGBrl27ol0IParpL0gIUTSOED9FXzXgM1EKcSKN7kDH4RdA15OtCPg1kH/x4kU+n09laQU3TzPmfJJFe/Jzdx944cIFaqUKEF/BJ8DaMJEA69evR/Ry+vRp5KCPrawUjy2jz1SQrQgIhKBATP1dXV2orMo4ESF39TToxK/1I5h/J1zYHbUPwgsP36L+QKqra887d+7ATCEtKqsCGP4hv+nTp+/fv588i/T06dPg4GBkIvJs2bIludBSKVAmhI2BqWvXblSWhoBmMJmsKDzCwIGDXttfAG3BCDJnzpwf1cCAgqJu3bohBP3666/RU/CQ5YYYMh7hp8MPSGVpBQ8f+4eixohCqXVa0Z78Bg16+/Hjx+gD4qYq5YMPPpgyZQomQgsWLBg3bhzSU6dOHT9+PJZDhw7FthXPT6imIpiEpKenP3jwwGOIJ8mpSHyENFmUM8y/ykivGhCqefv4VnwS/O23h+CPymSyaiQEB3Lz5s1z585t2bLlww8/DAoK8vX1TUhI8PLyWrhwISqoe060iDSKLNEuaDU1NXVI1e1qCNBfT548Ic6NyqoAvB8GHRx8kyZNFN7/X8hcER0NZZJBE2mITdU0oOovLbcL9PK0virUnuVXg/ZOvYBmzRpPmzYNuoI3K+e76gZ2gqgGS1gJxnJEqkd+PfTgUTpV/CoY8L7xy3P3Kfbyb0JlaQgu1xyz0wkTJiCNppFMlZ0RYMRw47du3UpKSsIBd+rUqZ8SqlgNlY1CtGS+t3nz5vj4+Pv3nyjLtYeDgy0GPkwHSEhCMtXbhUzVqnqHRihB5PnDDz+U62jSXxAtZInpfWxsbFqatr++dDyi7J6IU9u3GTQEWj2CmTNn79u3LzNTMxNfdDzpSywx+iKYOXz4sM+o0VRxBU5EcBx5FhrXHliwYNHBgwdfvnyp0M2rqiNgFoSDHDBgwMyZMxGbbdq0ad68ee7u7kRd5SD2CldPTtIgERcX5+v7MSnVJjNmzEJ/ZWRkVNWuSjNB+/btEXli9qg+b0RlVX+RaXN0dDT+BCnVJi6eJZeFWdQKrWhVfvPmLYT2Dh06hF5R7zlF3yqh1msGOpL0JcZgTKh27tyJWGjZ8pVU8avcERVDfhNDqjw7Uh8CAuZDe0eOHIFgKm0FDg8qQkiGCSrAYeMXIKdhqBpqYA9oCGkXYto9e/YgnAsKWkEVa5G5cxcoX7j2q7qXqwn9+/fftWsXxhr18aVcf8H1IQ2ToIq1SAueialteqqE/juwtSo/e/ums2YFHDhwAJNAKqtOqEyBTN9h0Ajq4FImTJhU6aPT2VL5wTDDcSGlDfThG/xRzFLhKDBDw7FVtFToh8vlQnLA0tKSVMCRVzqtgo2iAurDOiUSCSLPiRMn1/kR/vqAdiFgge999OiRsln/bxcOEirCklp/FThtDC4oJc8TU7lq/ZWcnLx37178aLS0Czi7cRKF9H9yVKtzP4KHhzsGv3Xr1iH6h12iP9BP6h2pnq4ISmGXWGK+B1NGjyIxa9YsdPmlS1epSq9yIkKeJJQvjmrYsWbAAD682fr16+3s7Bo1aoR0pQ1RN0ekK9ZB62CgaBq0t3TpUrTr7NnLVBkdvPPOIIwaX3zxhb29PeREzn4hB0scqrLK/ynXOlIBQsWvAZeOhIWFxcOHDz///HOUVtVfWuBwxNMnkryZIe2odZrQqvcj7Ny5Ny0tbe3atehC0iVUQQ0gPUoUiPke+hLWuWLFCsR+cXFHqEqv8lRSJBLmfbioRrft14fo6AOIFUNCQhBgIwrFEarbYqVUqj1shSEJ9hoaGop27dlT/lZvLbN9exS8H/oLgwLcNekvjJtYvrbvUAFtRIvQTRhtMeXDalhYGMKfqvpLO/TytL3LgE/h0iC/Nm2c4uIOX7169csvv8RoSrwEeghQNaoGNQFsFP0KF4qYMygo6N69ewLBoapeGrk/tNjJLVcLX6JFu3bv3nfjxo3ly5dnZ2eT+VtNGqWC1Ee77t69O2fOnPv37+/bJ9D+Sz7LgXbt2ROLn5q8zRHCQxcgHwnw2gaif4lo0ddoUWBgIJYHDhzRwks+q8GRZ/ZCovmTcLWFBvmBfv0GxMYeFIvFCxYsgL2qFKgU12vGJPX53vz5869du3bwYHxVLy0/K5AXyMwa4mxnpbi7D8LIcufOnU8//fT69eu1UqBKexkZGbDR27dvw+i18CromtC/v3t0dBz6C4MdxINDrXl/4UfAElNBeDx0N36WmJgDAwYMJKU00pJnnS6h0nRBj/wAFHjuXCJiEpjazz//DLMj3YnxFYMl+gxpMr4iQewYKiVn8FNTU3/55ZcpU6ZglvXnn+eqstEsaUlcWNkwf0NtfuYGB3PpkuLK3rJly7Zs2YJ2YeAnZ0QJqIMmAORjiVkiTBMJbJKenh4TE+Pn52djY3P+vEg7H0KoIWgXDgkHOX78+E2bNsGV4cjRWWgFSskSHUf6C/loKRkokYMBZfv27Z988gm6LyHhMkPa5cAzoD3+pOHUSzmWLFkQHb0XJjh79uwPPvgAnUrMFJATg1Ad0uhUrD579iw2Nva3337Lzc2dNGnKmjXVvVZwW3CaMafxpBAa3q8aGvptdHQUhgmkJ0+ejHZZW1vn5eVhiZbCKJGPdhEFWlpawkD37t17/PhxyHXcuAnffbdeuRsmEhS0cN++PZDWzJkzR4wYAUVBYBgfITlVu5CDpqEr0V9xcXHoL7R94sTJ2vxw2msRhJYZcAxq+wkdzUK//EBmZkZ4+IbNm3+EabZo0WLgwIE9evRwcHBo1aoVShG0PHz48NKlSwjqHjx4AGMdP37i4sXLqj9nfVtUEBdWGrCJhk+cSqXSt9/uf+fObRxn8+bNd+/eialgmzZt0Ki+ffva2tqq2pWZmYl2YaaHBsJk0fZp02bNmDGb7IexPH+eOW/erNOnT6G/nJycevXq1a1bN7RU1a6UlBS0C/Ez2gVPjt8hMHApXdcYquKMoPSq0IDee18YIT8V+/fv++OPk7duKW6PJOEZMpGA90Mf9+jh4uHxjq/vGFK5elYMzxnqXzrEpzG1rkXg+j77bDlkduTICTc3xe38+/ZFnj379z//XLt48SIaBU+OTOLS3dzcSLuOHDl86NBBlO7evU/9cWFm0q1bh3v37r733vutW7e+fv0f9BdVoARN4/P5Li6uaJf2Py5dQ+6KyjA3WRKlvYlJRZglP03xW0T+DVHmovDW1LoWgevz8hoqEiX6+IyKioqhcmuARHK/SxfqMlRgYNCiRUHkziwGEhGxNSBA8TnOmzfv1eqr1IwiXcL5MaDsi6N0ej86/3YDkSaRx4UaTAtRfGdc+5CPVEI50A+VVTPU7Rj+08/vY+28ga8OBAcvxdLff7ruag9YcEuzZIoXItKIHspPEFriG2hM19sEoBws3dx6VfOV5pogFP4OL0r2xihwSOQ1p3DRJEdHsbY1KuQ8o1ZoQt/kd1rwMlVS8J4/PQE9NENe/hkS8g3JqQ+wcvgZEuYxBBwSIk8kEFrrtOsjmHMLsqRVPsuvBfRKfvgpz8cZTwyh7S06JCrz9Hy3nq5PHWLuDAEH8+CBBKG1RsYX2pFzynJkrPw0xImIMkeehRbuL6sUgUAx60NCs1GZBpVcT1SuD+OLHrg+YKB8CJtaoQP9kd8TSd4VYan3ItquooaFKeZpUEtVb0+pLTDxqKiYhAQ6H3dQh7g+LperH64P2Nia5sjofO2S/sgvLOCBu09ZAz3R91ow6yOuTyOmqbrkoCkl1x+V6/P21odZ37/QecsL0BP5nRa8MOM4Dvd/5VV22oScoqyn68PmKo8HBUok9+Piyr9amy5wJMT16foJT0ahD/JTnnEx9A3U9s1lKuD34P2QqKfrg+pu3rxHTirCySCHnMthAuRI9Mv1KbDi0vm6a32Q3/GIYnteAd+zyk/kNTQan/UBomSEfEy49IdjIF+D0JtZH6HiZ3O0jM7LL00ifyA2He7/mm/TNhwq1+fvP53kaAQEn2SH0DZESDJpAX+djC9TpkxTTUpZNILOy+9ERJmzm4Ejj56LDYDIA66PhIsaBLMsmLvqnAdd4K/D9enlrC9bWkzvt/50W35PJUXJory6vbVaI0gk98mHx6A9jXsG1QwQAiA302gf/F19POFJUSAzt+LS+cSDbstvU4DirdU0DmDkhIQqUNQ4xAGqNKB98Hf19YRntrS0Cbe5Nt+EUBEdll+SsLRA1iBvra4hCAuJ62u4h4NUDhB/SPszQFUD9dL1PZMY2tjSNmch6LD8jkUUTwihc+hSub4G9QwqB0jOf2gT/EX8XX291pcj48g5NH/nSFfld1ogLeUUuHrSdvywS3JNvIHCThXqM0BtOkDVKR+9dH0gXcJx4NFs/7oqv3NxjXwW/f+Lx9qHiAF2WdvHautASMg3cID4c9p0gOSMLv6unl3rU5HGyq9unBXIjTkWnfg0vMKMoDoX4uOj+ROeFcGfID5Waw5Q5frwd7XQQFrIkcqb86g0Xeik/I5HyIf503mzLJGBShVagJzdwR/Vzm1o+CukgVrw7XSRK+M057G3XNcSkTDH0hazPprlhyW0p7VJkUrqmHDC95LMBkJ9Wquvri9LWiKT5jqw3q+2RAYbDvCm84SVKgLUmusjwBFB7fjTDX0XKHmbi3amtXSRKHzZhEf/FzZ1TH5JQrk11+xtH9rurgYk/NOm6yPAEWGqiUSDOkCV69POtJYu0iTyDnw6bzcj6Jj8zgrkQ/3pvEudeAYktOz6CETzDeoAVa6PlgZqjQdiMxrvE1ahS/J7Kil6Iskd5EPboAW7JLM+eAY+Ha9gUamigRyg+qxPy75dm2RLFWfOO7pZUev0oUvyOyMo6+5ZQK3QAXmPIL3nAyEMHEADOUDi+rB//XZ9V4UcSy6H3rs9CTojvxwpAgaTwbTO+shVb0+NvkewtqjErzoDVE8CAma4u/fG3jCyEN+O/evxrA+kSTjt+TRfciDozDceMOu7IiwNCNf2iAWHANUhEoPqiMNJSLhMo/wILVo0gfbgo8LDt1BZdcXcnBqCuVwucX1Pn74gOfrKZ8OLZ4c3ov2qA9AZ75cQJ6dl1oe5EIxSJEok2oPwaNceIDeCaXYGSF4nAchTDvpKsijb3Jb+K34E3ZBfqiQ/S1razo2GgAHaM1D7OjR0iFCNdgMlt0Hj2DQ+A8Q+/fw+7tKlXUOc2mECl4XStm6F1Ard6Ib8RMIcZ34RLe/wrDgLggJhoPR+ekF1dqThToHqq/yuCIsG0/HVx0rRDfldE5o4u9H2NmJ4v4pQZfRBrg3AWWnwLlCqbQYG2LmbG1Nebq9BkkV5JpxmTLjiR9AB+WVL5c8lVnxP+q/SqPjqqzX1P+dRT1QOUPVZJY3A5XIjI6PROr08+Xk+juaT5+XQAfklCeWY9VnTd5UG3oBKKa1z06bNDHn6W+MO0M2Nf+OG4j2/1LrecTyi1N2bEZccCDogv6tCuQt9zzeoOxYPj3fi408Sn8ME1GaA++vmANW3mjJlGlqnl06PcFog5bkV0vUVkErRget+07sUf5/QSOO/2p49uxISzly5Ir58+bKhoWFZmeJthUhg6erq6uLiCrF17NjF3b23srrC1ZCnzskqcyDXAKdOnQG3jNWYmD1//XU6IeHszZs3sSqXK/oXDtzU1LRnz549ergMHuzh6ztGsSWH4+f3sUAQi1bv3r1Pj50eYcXwLO9Ag170vQ29IkyXX6qk4Fu/gg0JGnuJdUbGsw0bwrZs+amwsLBLF6jL3cnJqXPnzs2bN0dpenr6rVu3RCLRnTt3UlJSiouLUXTv3r0FCxYz9nVDERFbAwJmQF3+/lNjY2Nyc3M7derUr1+/jh07omktWrRAnadPn96/f18sFicnJ6NdRUVFM2bMGjFi5ODB7lAmtOft7Uv2pq8kCcsEoWVfHqX/RjN1mC6/U4KM+Iis0KPtqPX6sWLFkl9+2WZlZTVz5swRI0aUlJRAhBj7jYyMTExMUAF2CbBqYWEBl/KrEplMNnmy/1dfMfeVJ/369Xzw4EFpaekXX3wxePBgKlfp+ho1UnxCBOMIQEvRLjQnNjY2Li6uoKCgXbt2Uqns2rVkUl+PWetX/J6/Mb1PaVeE6fLbEvzAimvsF9iKWq8rKSkPx48f/fjx40mTJn300UfIgbFCcnl5eebm5jBNY2PFuAhBIgEzzc/Ph6XCQKHGI0eOhIWFubi47NsX5+TUVrk/poB2jRr14ZMnT6ZMmTJmzBi4MhwwVcbhYBwBSKCxWKrahUgbTjI6Onrbtm2Ojo7HjgmZ1i7NkizK3xVc8vVRBoWdBKaferktym/Js6BW6srFi+cHDuwDV/DDDz/4+PggB2YKu4RRImaDLSKNUkASRJmQIpaWlpbYBL4Cq5gHYldkn0yAtAtN2PjDRhwkDhtg+FCBZqJ1AAnURwKVUQerCAEwEkGBGH3efrv/hQvnyD71kpMRBsNofUy0KpguvwKZZUd+vT6aCRv18fmgf//+33//PY/HgweAkIg5vhbYK5aI31q1arV27dpu3bqNGPH+pUsXSCm9oF0ffjicz+dv3LjRuZ0zGS+Ir3staBcZa9q0abNp0yZXV1e0S18VmCSU58tMBvvYUOtMgtHBZ7a0dJF7ydabdX+fJ2KzgQN7QXtBQUHGjYyNjRQ2Cu1BhDVUIIFsAh3Omzfv1q1bf/55rnXrNlQZHTx8+GDQoL7Q3po1a4iWED/j8ODckKAqvQrqUCk1yI+A32TlypVJSUl//32hTRsnUqQ3fOdXNsCbM8iHiZ6G0d4vXfEW/np9fHT06A+dnZ0XL1mMkd7I0AjWBi8BIaGoUnOsClIZS5ipk5PT6NGK2SON+PmNgif/8ssviX9GuxBDQns1d+wE0i6EqUuXLrW3t6e9XRpHJMwt5eS7ejLUxzBafrkyxVPJdSY4eEl2dvby5csNDQzNLcwbmSiUrLLXWpkpwIYwbhsbm9mzZ4tEoqVLF1EFWmflSsVLOOfPn09CTdIQzOiKioqIJ1TWKg9pckXIVmjXsmXLxGJxcLD+vN0M0dPuYM4A71J6P+JXDUyf+9X5PcTPn2fu2BExatQoOzs7CK+kWHGNAaYJYHNUpdqADWGm8Jxdu3YNCAjYsycyMzODKtMi+KObN/84bty4Tp06YZW0pW4tAmgUQlZsjnZ17twZkqarXQ3BuThDR545M2d9BEbLL01S95hh/fpQjOjvvf+elbUVws7SslL4QOTX2VKBSoHjx4/HfjZuXEcVaBH80caNGw8bNgxpIpv6tAibE4jbnDBhAjx8ePgGqliXSZUUJgnlHy2q+4+jBZju/axs6/jz/fzzltGjR1tbKS71lJSWQIHQISlSAYOjUq9CDBrhHFlVhygQFf773/9u3aq4yUvLbN8eMXnyZEzzcAzkOEkrSLom4PiplBLVhhBecXGxl5cXvCvJ0Wl+i8h1dpMz5J0uVcFo+RngvzqxZ8+uvLw8b2/fwsLi0hJ5I2MYq1FeboHSYhWgjrW1QpkWFhYISonS4uPjly5devToUXgDIjMsVSj2qwRpVBg7diy2ionZQ+VqhejoKJlMNnz4cEgFhwdUY4T6Ear49ddftyiJiIiIjIyEtKKjo7GtskH/h1Q2Ud73g3aZm5truV0aRyTMzZRYDvOnVhkL070f7Ir6f204fVro4uICkZiZVf5gJWwuKysL056CggJYW1JSkre39+eff46Eo6MjKqhUWinYMyLbli1bJiScobK0wqlTf5B2EakQ8RBIhXIcOXJk165dO3bs+PHHH9etWyeVStFqY+X9PQRq43/nwyhq0qRJ06ZNtdwujRMZbDTUv4SxZ1xUMF9+deHq1aQuXbrATNXvwFIHRZaWlsR7HD58ePr06SkpKQsXLoTra9euHTFHdTMtBxwI9ty+fXuxWERlaYVr16726NEDowaiROX4oIAqq4KuXbtOnTp11qxZWE6ZMsXDw6P6duE34fF4IlEilaWD7AgubO0m43vW624N7cBo+VlyFR9ho1Zqw/Xr19966y1YEmJLMroTqGIlcAVYQm9wenCAK1euHDduHOZUDg4OqAmzrv4OEvgfOCKxWEytawX8uUGDBiGB4yQ51QPf7urq6u/vP2HCBCxnzJiBUanc71AO/GKoo+V2aZAkofyasNGCcAdqndkwWn5Wtpx0SV2mf3AOGMJhZxjOqSwlCgn+C7xfenr6999/j3xMeMhcDvNAAM9GvIrSu1Aod0AB54k9t2nTRjX10ggBATPMzAzc3XsLhb9TWa+CAQURL/4oElSWEuoQlVBZSvA7IEhW3HFgaIghBhvm5uYiTVVVQlVVgpovX77En6jq1hmGkyUtOREhnxBSF5uhBaZ7v1zq3ZN1gdgWpTYlJJ+Ql5e3fv36nJyc1q1bBwQEIAHrhKjgMRCeVe/6UIoIEH5Ss/ITixUhHwK/4cOH4l81IqRSSspJSJ27d+/GxsbC76GBa9euffLkCURIlVUG2gWvjnZR67rGtuCMtm7FTHuqqBoYLT8HnkF2g31K2crK6vjx41Daxx9/PGzYsD59+iBCO3ToEExQJpPBB0KHVFVtof5VE2gPCqzGEypdlwJqvTIw4qSmpiKSBHv27PHx8RGJRDrq2V5LdGhGoczyfX9mPVBbPUx/3u9T9+wlUY1q+2Y4hHAnT55s0qQJrFPdQakb6+nTp1esWAGZHThw4PHjx8+ePVu9ejUqe3l5rVq1CjYKfVZ15gbV4IKuXr06e/bskSO9qdx6A6WRGWk5bG1t3dx6YSkQxB47dgwJ+F51H1iVCDGmYGTp1asXtoLwMGPkcrmY7pYLBFRgn2g4as6ZM4fhhlGOO6KCtX5FP99k7g0ulcJ0+S0eLhkdyO3tWbs3rFhbm6xZs2bQoEGwS0x1qNxXzfSPP/4ICgpCrJWQkAA5wSIvXrw4b948FO3bt69FixbW1tblwjwVkCUEAN1CsVSWtli3bt2QIUMwalR1ArMqKcbFxeFocdgbNmzo27cvlfsqRH7k8eKXL+n8mFSteCop2hVcNtS/VCfOdqrD/KfdHzryTEf41242MnBg706dOi1YsADaq8pLbN++PTw8HBUgP+Tn5+fDW7q5uUGKu3fv5vF4mCZV5SWIXENCQu7fv9+lSzcqt9681vvdu3ene/fu8+fPh/zUT36qt6sq+eXm5g4dOhQDx3fffefh4UHlvgp+DUyJMXKlpaWdOXOJymU8y4e/dPcp/a9/E2pdd2C6/E4JMhOFWYHhtfvU46xZ/teuXd2xY8eLFy/UTzaom2ZiYuKMGTOQc/78eWgJbhBLRGso2rp1q6urK3Rb1QkYmD68hK+vr6fnO5s2KT7KpRHIe8eoFSV8fq+QkG88Pd8lq9OnT0pMvPzTTz+VO4NSE/mVlJSMHTv23r17GzdudHd3p3JfBY3C5lOmTOnTp+/mzb9QuQwmW1q6PTjPzPbl9JD6vo6EFhh96gV04lvdE9d6gBgyxDMlJUUmk2H+RmVVoGXLlljC2s6cOQPtFRQUPHr0iEgOzq2aa9MAPkQikTx58sTdXXEVTlNwuf+PsSG8o0dPJiRcVmkPeHi8A/3ARwEqqzLQiooVcnJysC3a26FDByrrX1SKxc/1/PlztGvw4MrdI9M4EWFYILPQUe0BpsvPkWfWhNv8tiifWq8Zo0f7QU6YmyGUqspS7ezshg0bBo+HEPTZs2ewPMwGMTVCfufOnVGhnOtDTewKS+wZ8jt9+rSNjc3YsROoYk3g46P4bhH+RUXFlBMe4ZNPxjdu3DgqKgqCUWmmHAgyIT+UTp069ZNPPjl48CAaAlEtWbIEo8zgwYMRxKIV6pANEX7D+x06dAhp/CGSyWSORxTfF8snhDD9zrJqYLr8QCe+pUSsuMWxVkyZMvXXX3+FSRFbpHLVgH9btmwZlPb06dORI0civWXLFlRGbAZ7xYYwVqqqEmiP+EYIAKsxMTHjxmlSewB6u3nzHv5V88ZbP7/xJ0+exHihFGAl7cJho2k4VESbd+7c+eqrr0aMGIGBBsF2//79IUJ1x449kDEFS8gSW+3fv9/ffxpVzGDOCuRxoUbjQzgM+VJf3WD63A8kCeUnIuSLo2o3Ujx/ntmzZ1d/f38Yn5mZGQwLmer2CuuEx0tPT4eTFIvFhYWFHTt2nDx5MnwaiiwtLbGkqv4LNoelwvX98ssv2OrKlRtNmzajyrRFZmaGm1u3iRMnYuYJIRHfpd4uzEuRieEDbnDv3r0IOOH6nJycvLy8MNZAYzh+qqoSokD8Psjfvn27QCBISrppb9+UKmYkV4QlJyMMx4cYOPAqDwF0BR2QH/jUPXdJlFFtr/599tmyPXsi169fD+MjylGZKRIAZodpHizV3NwcISXS1tbWSGCVXFiDJkl9gDSUmZ2djVmfn5/fwoWBq1d/R5Vpl+XLF+/evfOnn34iN9aptwtARWS4QeugT6wigQrIAUigPqqpNkG7uFzuy5cvb9++PWnSpCVLln755RpSxEzuieQ/zimbuamsA79e7wFiArohv63BTyy4peMCa/1ysQED+DC+NWvWQFcQFblgQJWpUc4iAUmTfPXSFy9ezJo1C/admPgPVuli4MDeGCA+++wzKAfxMBEYVaYEqzhs9UxVw1X5JAebI4F2zZ07F3K9fPmashZDuSIsjgw2nLmJ056vw1M+FTow9wNve9vcFdflVqmYmIPJycmrV6/GGA/twezULbImEBvFVtgDPMnXX3+NedeBA/GklC6iow/cvXv3m2++ycrKgvaQo1IXodyqOuQXIBWwbbESjFBQoEBwWFmFodwVyU9GGI0LKdMP7QHdkF9nvrUpp7lImEOt15jWrdscO/bH9evXAwMDEXrB5pQCrKkCVdrDPAozqGXLliUlJR05crwN3S/DbNWq9cGD8QgXg4ODyciCzGokVw6V9hBLZ2RkBAUFYfYrEBxi8qvm74pKV3mVDfM36Omp8zGnCt2QH+jlaXleUJe3zffu3Xf//l9v3Lgxbdq0mzdv1laBRHuZmZkLFiyAjA8fPtav3wCqjFbQrujoOExEFy5cCB3WVoFEe+np6bNnz75y5QrE3KdPP6qMeSQJ5QfCDFbFc3ToaYaaoDPyc/c2yJVxkkW51HptgGCuXLkBIUFC27Zty8/PJxOekpISWCEMF0tMpTDzQZ2CggLk5+QoPK2VldXLly937949adKkxo0bnz17iVE2inYlJFxG6AgFbt26FXLCpBTtUoE6aClAgrQLQwnaiHbJZLLIyMipU6fa29tfvHiFIWNKpVwRlv4YIIff05uYU4VunHohxIYWPpa8WBCu+GBd3QgODtq3bw+itenTpw8fPtxE+cZrgEkd5IcKMGVra2sSzqWmpv7666+HDx+GXGfOnM3kD4yRc6EQ2IwZM0aNoq4ZQn5Qmk63C5wVyBPi5B8tkuuf9oAuyS9bWjqja35YgmkLXt2j/8zMjLVrV0OEUqnU0dFxwIABnTt3bt++verzmg8fPky8nHjz1k3EdZaWlpMn+y9YsNjOzp5szlieP88MDf0mKmo33DWPx3N1dXV2du7atSt5djYtLS0lJUW32oXuFoQVZ0hMxocY6vS19WrQJfmB+AipRGQ6J7y+nxwDMTF7fv/9xPXr/1y9ehU+oUx5XZ5EoT169OjevceQIZ5jxowjlXWIffsi//77z4sXL2BCiGiTzAkRfyK01q12bQ4oy5aVzdxkaG2rM1Ok2qJj8gOLh0umhjTtxK/yXmoWXeeppPjHgCJHnhn8Xp3fs6wT6N64MtzfKjrsBbXConfcFhVAe+/6l84KN9Jv7QHdk5+HT1MTTpO/BNnUOosecVogXemVA6fH5O+iaBCdjKonhpicjDDB1JxaZ9F9sqXyncHFCXGG6xKsO/Krex2bPqGT8mvBM+nmmb0juHYPAbIwlmxp2Y9zinOlhnM3WTny6v4xY51DV88pjQm0vy9udEbAOkCdJ0lYtsi91NmtbHa4EfO/yqBZdO/Mp4q7orIDYRy/EMUpMiqLRad4KineH1qULzPzXmTI8C+BNRA6LD9wLKLwovDZZ1GtqXUWHeGuSJ4QpzjJOcAn/y1vGxtbXXo3rgbRbfmB1X6ypryC0Yvs39gu1CGypCV/x2VfE5pKRGbegRx3b/mbFm2WQ+flhx7dGVxoxDGfoLhES2WyMIpsKXxdKTzeVaERj58/1L+sl6fi26YsOi8/giBU8T6YjwJLBnq/cdN3ZoJh8bY4566o5KHYMk9q2oxX6uppiH/W+n4lvVboifxAqqQgOlRaJOO6eZoN8Oaw3ax94OXuiznpEsXU7okk38Q2o72bcWe+TQc3C3ZqUCn6Iz/CU0nxyQhjdH9TXp67j7yDmznb8Q1HlrT4tjjrqaQEknsmMcmTmjvyTJrzDNrzOc5uZWwY8lr0TX4ERD4iYc65OON8qYWVbVlPTyNnN86beWpbg2RLS9MlhlBamgQuruylLOe5NK05j9OSp7hW3pFv6ch7U+5W0RT6KT8VOVLOPbE8Sci5Iyp5Isl24r9EONSJD3PBOM1eLawOBPOpknwsn0oKn0pK86WmJpxmCCXg3Bx4HKiuGa+4Ba/Wrz9mUUfP5acOiZRuibIvC2WIlEpkTTu52TjwDB14xrCnprzCjvw3TpBpEnmuVOHNcmVlmLkpE4pbwODZTLjS5jxFANlSMVRZdHCzZMN4jfMGya8cCFDviw2eSQwxUYTNPZZkP5A8asYrsuIaE9+IpbWtsTXXGEtddJVoYI6sBB4sW6p4XXe2rAR+DGn091NJgRHH4oXEDnGjAccArszKVvEpbweeIo1/7Ikr7fDmyq9SVBEXzDRVUgjzzZYW58jK8qQWppxmtrbWFgobVdS0sjWAvVorrVa5qliCf1cV5mv1alGtQNisWCo/bZ8jpfoIwwTJJyg9FclUVEACoEIZp/iB5Im5bY4l10A1gry6bKSjY4qewcqvpmRLS3NlRjD0dIliNUcmh6FjqUhLFf6TQOShUgK0J5VmFXLSSjg1fUmpMcfKlONgzFE88AZ5AyJpQJSsWoWPgsCUjguHAaUpNI9SS1t2VqYbsPLTKggIqVQVsPOrNwpWfiwsNMHh/A/dV85G38+TVgAAAABJRU5ErkJggg=="></p>
<h2 id="连通分量（针对无向图）"><a href="#连通分量（针对无向图）" class="headerlink" title="连通分量（针对无向图）"></a>连通分量（针对无向图）</h2><p>无向图中的极大连通子图称为无向图的连通分量。</p>
<p>无向连通图只有一个连通分量，为本身。</p>
<h2 id="强连通分量（针对有向图）"><a href="#强连通分量（针对有向图）" class="headerlink" title="强连通分量（针对有向图）"></a>强连通分量（针对有向图）</h2><p>有向图的极大强连通子图。</p>
<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><p>对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。</p>
<p>来自 &lt;<a href="https://oi-wiki.org/graph/cut/">https://oi-wiki.org/graph/cut/</a>&gt;</p>
<h2 id="桥（割边）"><a href="#桥（割边）" class="headerlink" title="桥（割边）"></a>桥（割边）</h2><p>对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。</p>
<p>来自 &lt;<a href="https://oi-wiki.org/graph/cut/">https://oi-wiki.org/graph/cut/</a>&gt;</p>
<h2 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h2><p>dfn[u]是图的dfs节点访问次序，dfn意为depth first number</p>
<p>low[u]是默认为dfn[u]，如果dfs时通过一条边访问到了已访问的节点，选取已访问节点中的最小的dfn值</p>
<p>low数组在另一个意义上可以看作，把有环的部分给标记出来了，环上的节点low值都一样</p>
<p>参考资料：</p>
<ul>
<li> <a href="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）</a></li>
<li><a href="https://oi-wiki.org/graph/scc/">OI WIKI: Tarjan算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101923309">60 分钟搞定图论中的 Tarjan 算法（一）</a>&gt;</li>
<li><a href="https://blog.csdn.net/hurmishine/article/details/75248876">全网最!详!细!Tarjan算法讲解。</a>&gt;</li>
</ul>
<h2 id="tarjan算法有什么应用场景"><a href="#tarjan算法有什么应用场景" class="headerlink" title="tarjan算法有什么应用场景?"></a>tarjan算法有什么应用场景?</h2><ol>
<li> 求图的割点</li>
<li> 求图的割边（桥）</li>
<li> 判断图的连通性</li>
<li> 判断图有没有环</li>
</ol>
<h2 id="tarjan算法为什么可以判断图的割点和割边？"><a href="#tarjan算法为什么可以判断图的割点和割边？" class="headerlink" title="tarjan算法为什么可以判断图的割点和割边？"></a>tarjan算法为什么可以判断图的割点和割边？</h2><p>判断一个顶点是不是割点除了从定义，还可以从DFS（深度优先遍历）的角度出发。我们先通过DFS定义两个概念。</p>
<p>假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的父顶点，V为U的孩子顶点。在顶点U之前被访问过的顶点，我们就称之为U的祖先顶点。</p>
<p>显然如果顶点U的所有孩子顶点可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U至少存在一个孩子顶点，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。</p>
<p>来自：<a href="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）</a></p>
<h2 id="tarjan算法在LeetCode中的可以应用的题目？"><a href="#tarjan算法在LeetCode中的可以应用的题目？" class="headerlink" title="tarjan算法在LeetCode中的可以应用的题目？"></a>tarjan算法在LeetCode中的可以应用的题目？</h2><ul>
<li><a href="https://leetcode-cn.com/problems/critical-connections-in-a-network/">1192.查找集群内的关键连接</a></li>
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ViewDragHelper源码解析</title>
    <url>/Android/Android%20ViewDragHelper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p>在自定义ViewGroup的构造方法里调用<code>ViewDragHelper</code>的静态工厂方法<code>create</code>()创建<code>ViewDragHelper</code>实例</p>
</li>
<li><p>实现<code>ViewDragHelper.Callback</code><br>最重要的几个方法是</p>
<ul>
<li><code>tryCaptureView()</code>里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>clampViewPositionVertical()</code>决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>
<li><code>clampViewPositionHorizontal()</code>与<code>clampViewPositionVertical()</code>同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>
<li><code>getViewVerticalDragRange()</code>要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>
<li><code>getViewHorizontalDragRange()</code>与<code>getViewVerticalDragRange()</code>同理，只不过是发生在水平方向上。</li>
</ul>
</li>
<li><p>在<code>onInterceptTouchEvent()</code>方法里调用并返回<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>方法</p>
</li>
<li><p>在<code>onTouchEvent()</code>方法里调用<code>ViewDragHelper()</code>的<code>processTouchEvent()</code>方法。<code>ACTION_DOWN</code>事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在<code>onTouchEvent()</code>返回<code>true</code>，否则将收不到后续事件，不会产生拖动。</p>
</li>
<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的<code>computeScroll()</code>方法，方法实现如下：</p>
<pre><code> @Override
 public void computeScroll() &#123;
     if (mDragHelper.continueSettling(true)) &#123;
         postInvalidate();
     &#125;
 &#125;
</code></pre>
<p>并在<code>ViewDragHelper.Callback</code>的<code>onViewReleased()</code>方法里调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>，或在任意地方调用<code>smoothSlideViewTo()</code>方法。</p>
</li>
<li><p>如果要实现边缘拖动的效果，需要调用<code>ViewDragHelper</code>的<code>setEdgeTrackingEnabled()</code>方法，注册想要监听的边缘。然后实现<code>ViewDragHelper.Callback</code>里的<code>onEdgeDragStarted()</code>方法，在此手动调用<code>captureChildView()</code>传递要拖动的子View。</p>
</li>
</ol>
<p>具体的使用Demo请见最后面公布的几个案例。</p>
<h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><p>ViewDragHelper的完整源码可在<a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java">GitHub</a>或<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol>
<li>了解View的坐标系统，<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a></li>
<li>了解MotionEvent中关于多点触控的机制，<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a></li>
<li>了解Scroller类原理，<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li>了解Touch事件的分发机制，<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>
</ol>
<h3 id="ViewDragHelper实例的创建"><a href="#ViewDragHelper实例的创建" class="headerlink" title="ViewDragHelper实例的创建"></a>ViewDragHelper实例的创建</h3><p><code>ViewDragHelper</code>重载了两个<code>create()</code>静态方法，先看两个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code>的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。<code>create()</code>直接调用了<code>ViewDragHelper</code>构造方法，我们再来看看这个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apps should use ViewDragHelper.create() to get a new instance.</span></span><br><span class="line"><span class="comment"> * This will allow VDH to use internal compatibility implementations for different</span></span><br><span class="line"><span class="comment"> * platform versions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parent view may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Callback may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mParentView = forParent;</span><br><span class="line">	mCallback = cb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">	mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">	mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">	mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">	mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">	mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过<code>create()</code>工厂方法来创建<code>ViewDragHelper</code>实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li><code>mParentView</code>和<code>mCallback</code>分别保存传递过来的对应参数</li>
<li><code>ViewConfiguration</code>类里定义了<code>View</code>相关的一系列时间、大小、距离等常量</li>
<li><code>mEdgeSize</code>表示边缘触摸的范围。例如<code>mEdgeSize</code>为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于<code>mParentView.getLeft() + mEdgeSize</code>时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见<code>ViewDragHelper</code>的<code>getEdgesTouched()</code>方法。</li>
<li><code>mTouchSlop</code>是一个很小的距离值，只有在前后两次触摸点的距离超过<code>mTouchSlop</code>的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>
<li><code>mMaxVelocity</code>、<code>mMinVelocity</code>是fling时的最大、最小速率，单位是像素每秒。</li>
<li><code>mScroller</code>是<code>View</code>滚动的辅助类，该类的详细解析参见下面几篇文章<ul>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html">Android中Scroller类的分析</a></li>
</ul>
</li>
</ul>
<p>再看三个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span></span><br><span class="line"><span class="comment"> *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">	helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">	<span class="keyword">return</span> helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数<code>sensitivity</code>是用来调节<code>mTouchSlop</code>的值。<code>sensitivity</code>越大，<code>mTouchSlop</code>越小，对滑动的检测就越敏感。例如<code>sensitivity</code>为1时，前后触摸点距离超过20dp才进行滑动处理，现在<code>sensitivity</code>为2的话，前后触摸点距离超过10dp就进行处理了。</p>
<h3 id="对Touch事件的处理"><a href="#对Touch事件的处理" class="headerlink" title="对Touch事件的处理"></a>对Touch事件的处理</h3><p>当<code>mParentView</code>（自定义ViewGroup）被触摸时，首先会调用<code>mParentView</code>的<code>onInterceptTouchEvent(MotionEvent ev)</code>，接着就调用<code>shouldInterceptTouchEvent(MotionEvent ev)</code> ，所以先来看看这个方法的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if this event as provided to the parent view&#x27;s onInterceptTouchEvent should</span></span><br><span class="line"><span class="comment"> * cause the parent to intercept the touch event stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看9~21行，首先是关于多点触控（<code>MotionEvent</code>的<code>actionIndex</code>、<code>ACTION_POINTER_DOWN </code>等概念），不明白的请参阅<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a>。</p>
<p><code>mVelocityTracker</code>记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生<code>ACTION_DOWN</code>事件都会调用<code>cancel()</code>，而在<code>cancel()</code>方法里<code>mVelocityTracker</code>又被清空了，所以<code>mVelocityTracker </code>记录下的是本次<code>ACTION_DOWN</code>事件直至<code>ACTION_UP</code>事件发生后（下次<code>ACTION_DOWN</code>事件发生前）的所有触摸点的信息。</p>
<p>再来看24~42行<code>case MotionEvent.ACTION_DOWN</code>部分，先是调用<code>saveInitialMotion(x, y, pointerId)</code>保存手势的初始信息，即<code>ACTION_DOWN</code>发生时的触摸点坐标（x、y）、触摸手指编号（<code>pointerId</code>），如果触摸到了<code>mParentView</code>的边缘还会记录触摸的是哪个边缘。接着调用<code>findTopChildUnder((int) x, (int) y);</code>来获取当前触摸点下最顶层的子View，看<code>findTopChildUnder </code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the topmost child under the given point within the parent view&#x27;s coordinate system.</span></span><br><span class="line"><span class="comment"> * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x X position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y Y position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">				y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">			<span class="keyword">return</span> child;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现<code>Callback</code>里的<code>getOrderedChildIndex(int index)</code>方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（<code>getOrderedChildIndex()</code>默认直接返回<code>index</code>），会选择到topView，要想让bottomView被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">	<span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">	<span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">		<span class="keyword">return</span> indexBottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32~35行，这里还看到了一个<code>mDragState</code>成员变量，它共有三种取值：</p>
<ol>
<li><code>STATE_IDLE</code>：所有的View处于静止空闲状态</li>
<li><code>STATE_DRAGGING</code>：某个View正在被用户拖动（用户正在与设备交互）</li>
<li><code>STATE_SETTLING</code>：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br><code>mCapturedView</code>默认为<code>null</code>，所以一开始不会执行这里的代码，<code>mDragState</code>处于<code>STATE_SETTLING</code>状态时才会执行<code>tryCaptureViewForDrag()</code>，执行的情况到后面再分析，这里先跳过。</li>
</ol>
<p>37~40行调用了<code>Callback.onEdgeTouched</code>向外部通知<code>mParentView</code>的某些边缘被触摸到了，<code>mInitialEdgesTouched</code>是在刚才调用过的<code>saveInitialMotion</code>方法里进行赋值的。</p>
<p><code>ACTION_DOWN </code>部分处理完了，跳过<code>switch</code>语句块，剩下的代码就只有<code>return mDragState == STATE_DRAGGING;</code>。在<code>ACTION_DOWN</code>部分没有对<code>mDragState</code>进行赋值，其默认值为<code>STATE_IDLE</code>，所以此处返回<code>false</code>。</p>
<p>那么返回<code>false</code>后接下来应该是会调用哪个方法呢，根据<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在<code>mParentView</code>的所有子View中寻找响应这个Touch事件的View（会调用每个子View的<code>dispatchTouchEvent()</code>方法，<code>dispatchTouchEvent</code>里一般又会调用<code>onTouchEvent()</code>）；</p>
<ul>
<li><p>如果没有子View消费这次事件（子View的<code>dispatchTouchEvent()</code>返回都是<code>false</code>），会调用<code>mParentView</code>的<code>super.dispatchTouchEvent(ev)</code>，即<code>View</code>中的<code>dispatchTouchEvent(ev)</code>，然后调用<code>mParentView</code>的<code>onTouchEvent()</code>方法，再调用<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>方法。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动（除了<code>ACTION_DOWN</code>外的其他事件发生时返回<code>true</code>或<code>false</code>都不会影响接下来的事件接受），因为拖动的相关代码是写在<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分的。要注意的是返回<code>true</code>后<code>mParentView</code>的<code>onInterceptTouchEvent()</code>就不会收到后续的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件了。</p>
</li>
<li><p>如果有子View消费了本次<code>ACTION_DOWN</code>事件，<code>mParentView</code>的<code>onTouchEvent()</code>就收不到<code>ACTION_DOWN</code>事件了，也就是<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>收不到<code>ACTION_DOWN</code>事件了。不过只要该View没有调用过<code>requestDisallowInterceptTouchEvent(true)</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分还是会执行的，如果在此时返回了<code>true</code>拦截了<code>ACTION_MOVE</code>事件，<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分也就会正常执行，拖动也就没问题了。<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分具体做了怎样的处理，稍后再来解析。</p>
</li>
</ul>
<p>接下来对这两种情况逐一解析。</p>
<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用<code>processTouchEvent(MotionEvent ev)</code>的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process a touch event received by the parent view. This method will dispatch callback events</span></span><br><span class="line"><span class="comment"> * as needed before returning. The parent view&#x27;s onTouchEvent implementation should call this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev The touch event received by the parent view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">			<span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">			<span class="comment">// Start immediately if possible.</span></span><br><span class="line">			tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跟<code>shouldInterceptTouchEvent()</code>里<code>ACTION_DOWN</code>那部分基本一致，唯一区别就是这里没有约束条件直接调用了<code>tryCaptureViewForDrag()</code>方法，现在来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to capture the view with the given pointer ID. The callback will be involved.</span></span><br><span class="line"><span class="comment"> * This will put us into the &quot;dragging&quot; state. If we&#x27;ve already captured this view with</span></span><br><span class="line"><span class="comment"> * this pointer this method will immediately return true without consulting the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCapture View to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pointerId Pointer to capture with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if capture was successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;</span><br><span class="line">		<span class="comment">// Already done!</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;</span><br><span class="line">		mActivePointerId = pointerId;</span><br><span class="line">		captureChildView(toCapture, pointerId);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>Callback</code>的<code>tryCaptureView(View child, int pointerId)</code>方法，把当前触摸到的View和触摸手指编号传递了过去，在<code>tryCaptureView()</code>中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在<code>tryCaptureView()</code>中返回<code>true</code>，让<code>ViewDragHelper</code>把当前触摸的View捕获下来，接着就调用了<code>captureChildView(toCapture, pointerId)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Capture a specific child view for dragging within the parent. The callback will be notified</span></span><br><span class="line"><span class="comment"> * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span></span><br><span class="line"><span class="comment"> * capture this view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childView Child view to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;captureChildView: parameter must be a descendant &quot;</span> +</span><br><span class="line">				<span class="string">&quot;of the ViewDragHelper&#x27;s tracked parent view (&quot;</span> + mParentView + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCapturedView = childView;</span><br><span class="line">	mActivePointerId = activePointerId;</span><br><span class="line">	mCallback.onViewCaptured(childView, activePointerId);</span><br><span class="line">	setDragState(STATE_DRAGGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，在<code>captureChildView(toCapture, pointerId)</code>中将要拖动的View和触摸的手指编号记录下来，并调用<code>Callback</code>的<code>onViewCaptured(childView, activePointerId)</code>通知外部有子View被捕获到了，再调用<code>setDragState()</code>设置当前的状态为<code>STATE_DRAGGING</code>，看<code>setDragState()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">		mDragState = state;</span><br><span class="line">		mCallback.onViewDragStateChanged(state);</span><br><span class="line">		<span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">			mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态改变后会调用<code>Callback</code>的<code>onViewDragStateChanged()</code>通知状态的变化。</p>
<p>假设<code>ACTION_DOWN</code>发生后在<code>mParentView</code>的<code>onTouchEvent()</code>返回了<code>true</code>，接下来就会执行<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);</span><br><span class="line"></span><br><span class="line">				dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</span><br><span class="line"></span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">					reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">					<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">						<span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">					<span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">							tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断<code>mDragState</code>是否为<code>STATE_DRAGGING</code>，而唯一调用<code>setDragState(STATE_DRAGGING)</code>的地方就是<code>tryCaptureViewForDrag()</code>了，刚才在<code>ACTION_DOWN</code>里调用过<code>tryCaptureViewForDrag()</code>，现在又要分两种情况。<br>如果刚才在<code>ACTION_DOWN</code>里捕获到要拖动的View，那么就执行<code>if</code>部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，<code>mDragState</code>依然是<code>STATE_IDLE</code>，然后会执行<code>else</code>部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让<code>mDragState</code>变为<code>STATE_DRAGGING</code>，之后就会执行<code>if</code>部分的代码了。这里还有两个方法涉及到了<code>Callback</code>里的方法，需要来解析一下，分别是<code>reportNewEdgeDrags()</code>和<code>checkTouchSlop()</code>，先看<code>reportNewEdgeDrags()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_LEFT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_TOP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_RIGHT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">		mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">		mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在<code>mEdgeDragsInProgress</code>中，再调用<code>Callback</code>的<code>onEdgeDragStarted(int edgeFlags, int pointerId)</code>通知某个边缘开始产生拖动了。虽然<code>reportNewEdgeDrags()</code>会被调用很多次（因为<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分会执行很多次），但<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code>只会调用一次，具体的要看<code>checkNewEdgeDrag()</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">			(mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;</span><br><span class="line">		mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>checkNewEdgeDrag()</code>返回<code>true</code>表示在指定的<code>edge</code>（边缘）开始产生拖动了。</li>
<li>方法的两个参数<code>delta</code>和<code>odelta</code>需要解释一下，<code>odelta</code>里的o应该代表opposite，这是什么意思呢，以<code>reportNewEdgeDrags()</code>里调用<code>checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)</code>为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里<code>delta</code>为<code>dx</code>，<code>odelta</code>为<code>dy</code>，也就是说<code>delta</code>是指我们主要监测的方向上的变化，<code>odelta</code>是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>
<li><code>mInitialEdgesTouched</code>是在<code>ACTION_DOWN</code>部分的<code>saveInitialMotion()</code>里生成的，<code>ACTION_DOWN</code>发生时触摸到的边缘会被记录在<code>mInitialEdgesTouched</code>中。如果<code>ACTION_DOWN</code>发生时没有触摸到边缘，或者触摸到的边缘不是指定的<code>edge</code>，就直接返回false了。</li>
<li><code>mTrackingEdges</code>是由<code>setEdgeTrackingEnabled(int edgeFlags)</code>设置的，当我们想要追踪监听边缘触摸时才需要调用<code>setEdgeTrackingEnabled(int edgeFlags)</code>，如果我们没有调用过它，这里就直接返回<code>false</code>了。</li>
<li><code>mEdgeDragsLocked</code>它在这个方法里被引用了多次，它在整个<code>ViewDragHelper</code>里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行<code>mEdgeDragsLocked[pointerId] &amp; edge) == edge</code>执行的结果是<code>false</code>。我们再跳到11到14行看看，<code>absDelta &lt; absODelta * 0.5f</code>的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用<code>Callback</code>的<code>onEdgeLock(edge)</code>检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在<code>mEdgeDragsInProgress</code>里了，也不会收到<code>Callback</code>的<code>onEdgeDragStarted()</code>通知了。并且将锁定的边缘记录在<code>mEdgeDragsLocked</code>变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的<code>edge</code>被锁定，就直接返回<code>false</code>了。</li>
<li>回到第7行的<code>(mEdgeDragsInProgress[pointerId] &amp; edge) == edge</code>，<code>mEdgeDragsInProgress</code>是保存已发生过拖动事件的边缘的，如果给定的<code>edge</code>已经保存过了，那就没必要再检测其他东西了，直接返回<code>false</code>了。</li>
<li>第8行<code>(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)</code>很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>
<li>最后一句返回的时候再次检查给定的<code>edge</code>有没有记录过，确保了每个边缘只会调用一次<code>reportNewEdgeDrags</code>的<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code></li>
</ul>
<p>再来看<code>checkTouchSlop()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if we&#x27;ve crossed a reasonable touch slop for the given child view.</span></span><br><span class="line"><span class="comment"> * If the child cannot be dragged along the horizontal or vertical axis, motion</span></span><br><span class="line"><span class="comment"> * along that axis will not count toward the slop check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx Motion since initial position along X axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the touch slop has been crossed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（<code>mTouchSlop</code>）了，注意<code>dx</code>和<code>dy</code>指的是当前触摸点到<code>ACTION_DOWN</code>触摸到的点的距离。这里先检查<code>Callback</code>的<code>getViewHorizontalDragRange(child)</code>和<code>getViewVerticalDragRange(child)</code>是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分就不会调用<code>tryCaptureViewForDrag()</code>来捕获当前触摸到的View了，拖动也就没办法进行了。</p>
<p>回到<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了<code>Callback</code>中的相关方法，让<code>tryCaptureViewForDrag()</code>正常的捕获到触摸到的View了，下一次<code>ACTION_MOVE</code>时就执行<code>if</code>部分的代码了，也就是开始不停的调用<code>dragTo()</code>对<code>mCaptureView</code>进行真正拖动了，看<code>dragTo()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clampedX = left;</span><br><span class="line">	<span class="keyword">int</span> clampedY = top;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</span><br><span class="line">		mCapturedView.offsetLeftAndRight(clampedX - oldLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</span><br><span class="line">		mCapturedView.offsetTopAndBottom(clampedY - oldTop);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">		mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">				clampedDx, clampedDy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>dx</code>和<code>dy</code>是前后两次<code>ACTION_MOVE</code>移动的距离，<code>left</code>和<code>top</code>分别为<code>mCapturedView.getLeft() + dx</code>, <code>mCapturedView.getTop() + dy</code>，也就是期望的移动后的坐标，对<code>View</code>的<code>getLeft()</code>等方法不理解的请参阅<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>
<p>这里通过调用<code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>来完成对<code>mCapturedView</code>移动，这两个是<code>View</code>中定义的方法，看它们的源码就知道内部是通过改变<code>View</code>的<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>、<code>mBottom</code>，即改变<code>View</code>在父容器中的坐标位置，达到移动<code>View</code>的效果，所以如果调用<code>mCapturedView</code>的<code>layout(int l, int t, int r, int b)</code>方法也可以实现移动<code>View</code>的效果。</p>
<p>具体要移动到哪里，由<code>Callback</code>的<code>clampViewPositionHorizontal()</code>和<code>clampViewPositionVertical()</code>来决定的，如果不想在水平方向上移动，在<code>clampViewPositionHorizontal(View child, int left, int dx)</code>里直接返回<code>child.getLeft()</code>就可以了，这样<code>clampedX - oldLeft</code>的值为0，这里调用<code>mCapturedView.offsetLeftAndRight(clampedX - oldLeft)</code>就不会起作用了。垂直方向上同理。</p>
<p>最后会调用<code>Callback</code>的<code>onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)</code>通知捕获到的View位置改变了，并把最终的坐标（<code>clampedX</code>、<code>clampedY</code>）和最终的移动距离（<code>clampedDx</code>、 <code>clampedDy</code>）传递过去。</p>
<p><code>ACTION_MOVE</code>部分就算告一段落了，接下来应该是用户松手触发<code>ACTION_UP</code>，或者是达到某个条件导致后续的<code>ACTION_MOVE</code>被<code>mParentView</code>的上层View给拦截了而收到<code>ACTION_CANCEL</code>，一起来看这两个部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				releaseViewForPointerUp();</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下<code>releaseViewForPointerUp()</code>和<code>dispatchViewReleased()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releaseViewForPointerUp()</code>里也调用了<code>dispatchViewReleased()</code>，只不过传递了速率给它，这个速率就是由<code>processTouchEvent()</code>的<code>mVelocityTracker</code>追踪算出来的。再看<code>dispatchViewReleased()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like all callback events this must happen on the UI thread, but release</span></span><br><span class="line"><span class="comment"> * involves some extra semantics. During a release (mReleaseInProgress)</span></span><br><span class="line"><span class="comment"> * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">	mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">	mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">	mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">		<span class="comment">// onViewReleased didn&#x27;t call a method that would have changed this. Go idle.</span></span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>Callback</code>的<code>onViewReleased(mCapturedView, xvel, yvel)</code>通知外部捕获到的View被释放了，而在<code>onViewReleased()</code>前后有个<code>mReleaseInProgress</code>值得注意，注释里说唯一可以调用<code>ViewDragHelper</code>的<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方就是在<code>Callback</code>的<code>onViewReleased()</code>里了。</p>
<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（<code>flingCapturedView</code>的四个参数<code>int minLeft, int minTop, int maxLeft, int maxTop</code>可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用<code>settleCapturedViewAt(int finalLeft, int finalTop)</code>。</p>
<p>为什么唯一可以调用<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方是<code>Callback</code>的<code>onViewReleased()</code>呢？看看它们的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * The appropriate velocity from prior motion will be taken into account.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot settleCapturedViewAt outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view based on standard free-moving fling behavior.</span></span><br><span class="line"><span class="comment"> * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span></span><br><span class="line"><span class="comment"> * to continue the motion until it returns false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minLeft Minimum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minTop Minimum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLeft Maximum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxTop Maximum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot flingCapturedView outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法里一开始都会判断<code>mReleaseInProgress</code>为<code>false</code>，如果为<code>false</code>就会抛一个<code>IllegalStateException</code>异常，而<code>mReleaseInProgress</code>唯一为<code>true</code>的时候就是在<code>dispatchViewReleased()</code>里调用<code>onViewReleased()</code>的时候。</p>
<p><code>Scroller</code>的用法请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读<code>Scroller</code>源码，代码量不多。</p>
<p><code>ViewDragHelper</code>还有一个移动View的方法是<code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code>，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span></span><br><span class="line"><span class="comment"> * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child view to capture and animate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Final left position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Final top position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	mCapturedView = child;</span><br><span class="line">	mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If we&#x27;re in an IDLE state to begin with and aren&#x27;t moving anywhere, we</span></span><br><span class="line">		<span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">		mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> continueSliding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它不受<code>mReleaseInProgress</code>的限制，所以可以在任何地方调用，效果和<code>settleCapturedViewAt()</code>类似，因为它们最终都调用了<code>forceSettleCapturedViewAt()</code>来启动自动滚动，区别在于<code>settleCapturedViewAt()</code>会以最后松手前的滑动速率为初速度将View滚动到最终位置，而<code>smoothSlideViewTo()</code>滚动的初速度是0。<code>forceSettleCapturedViewAt()</code>里有地方调用了<code>Callback</code>里的方法，所以再来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Target top position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xvel Horizontal velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> yvel Vertical velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">		mScroller.abortAnimation();</span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">	mScroller.startScroll(startLeft, startTop, dx, dy, duration);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到自动滑动是靠<code>Scroll</code>类完成，在这里生成了调用<code>mScroller.startScroll()</code>需要的参数。再来看看计算滚动时间的方法<code>computeSettleDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">	<span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clampMag()</code>方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过<code>computeAxisDuration()</code>算出来，通过它的参数可以看到最终的滚动时间是由<code>dx</code>、<code>xvel</code>、<code>mCallback.getViewHorizontalDragRange()</code>共同影响的。看<code>computeAxisDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">			distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> duration;</span><br><span class="line">	velocity = Math.abs(velocity);</span><br><span class="line">	<span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">		duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6<del>10行没看明白，直接看14</del>19行，如果给定的速率<code>velocity</code>不为0，就通过距离除以速率来算出时间；如果<code>velocity</code>为0，就通过要滑动的距离（<code>delta</code>）除以总的移动范围（<code>motionRange</code>，就是<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过<code>MAX_SETTLE_DURATION</code>的，源码里的取值是600毫秒，所以不用担心在<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回错误的数而导致自动滚动时间过长了。</p>
<p>在调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>和<code>smoothSlideViewTo()</code>时，还需要实现<code>mParentView</code>的<code>computeScroll()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这属于<code>Scroll</code>类用法的范畴，不明白的请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>
<p>至此，整个触摸流程和<code>ViewDragHelper</code>的重要的方法都过了一遍。之前在讨论<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次<code>ACTION_DOWN</code>事件的情况，现在来看看这种情况。</p>
<p>假设现在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完了，也有子View消费了这次的<code>ACTION_DOWN</code>事件，那么接下来就会调用<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分，不明白为什么的请参阅<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">				<span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">					<span class="comment">// check the callback&#x27;s</span></span><br><span class="line">					<span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">					<span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">					<span class="comment">// would clamp to the same value. If you can&#x27;t move at</span></span><br><span class="line">					<span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">							targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">							(<span class="keyword">int</span>) dy);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">							toCapture);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">					<span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">							&amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">							|| verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">				<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">					<span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			saveLastMotion(ev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用<code>findTopChildUnder(int x, int y)</code>寻找触摸点处的子View，再用<code>checkTouchSlop(View child, float dx, float dy)</code>检查当前触摸点到<code>ACTION_DOWN</code>触摸点的距离是否达到了<code>mTouchSlop</code>，达到了才会去捕获View。<br>接着看19~41行<code>if (pastSlop)&#123;...&#125;</code>部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到<code>getView[Horizontal|Vertical]DragRange</code>和<code>clampViewPosition[Horizontal|Vertical]</code>四个方法。如果<code>getView[Horizontal|Vertical]DragRange</code>返回都是0，就会认作是不会产生拖动。<code>clampViewPosition[Horizontal|Vertical]</code>返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接<code>break</code>，不会执行后续的代码，而后续代码里有调用<code>tryCaptureViewForDrag()</code>，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的<code>tryCaptureViewForDrag()</code>捕获子View，如果捕获成功，<code>mDragState</code>就会变成<code>STATE_DRAGGING</code>，<code>shouldInterceptTouchEvent()</code>返回<code>true</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，后续的移动事件就会在<code>mParentView</code>的<code>onTouchEvent()</code>执行了，最后执行的就是<code>mParentView</code>的<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，拖动正常进行。</p>
<p>回头再看之前在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分留下的坑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他部分...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的<code>tryCaptureViewForDrag()</code>尝试捕获View，如果捕获成功，<code>mDragState</code>就变为<code>STATE_DRAGGING</code>了，<code>shouldInterceptTouchEvent()</code>就返回<code>true</code>了，然后就是<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，接着执行<code>mParentView</code>的<code>onTouchEvent()</code>，再执行<code>processTouchEvent()</code>的<code>ACTION_DOWN</code>部分。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动。</p>
<p>至此整个事件传递流程和<code>ViewDragHelper</code>的重要方法基本都解析完了，<code>shouldInterceptTouchEvent()</code>和<code>processTouchEvent()</code>的<code>ACTION_POINTER_DOWN</code>、<code>ACTION_POINTER_UP</code>部分就留给读者自己解析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>
<ul>
<li><p><a href="http://www.processon.com/view/link/5550a7bae4b09739f465ec64">单点触摸，没有考虑边缘滑动检测的最简流程图</a><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827220255.png"></p>
</li>
<li><p><a href="http://www.processon.com/view/link/5550d3dce4b09739f46789bd">单点触摸，考虑了边缘滑动检测的流程图</a><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210827220313.png"></p>
</li>
</ul>
<p>多点触摸情况我就没研究了，在这里忽略~</p>
<p>三个开启自动滚动的方法：</p>
<ul>
<li><code>settleCapturedViewAt(int finalLeft, int finalTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code><br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>
</ul>
<p><code>Callback</code>的各个方法总结：</p>
<ul>
<li><p><code>void onViewDragStateChanged(int state)</code><br>拖动状态改变时会调用此方法，状态<code>state</code>有<code>STATE_IDLE</code>、<code>STATE_DRAGGING</code>、<code>STATE_SETTLING</code>三种取值。<br>它在<code>setDragState()</code>里被调用，而<code>setDragState()</code>被调用的地方有</p>
<ul>
<li><code>tryCaptureViewForDrag()</code>成功捕获到子View时<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分捕获到</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
</ul>
</li>
<li>调用<code>settleCapturedViewAt()</code>、<code>smoothSlideViewTo()</code>、<code>flingCapturedView()</code>时</li>
<li>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>、<code>ACTION_CANCEL</code>）</li>
<li>自动滚动停止时（<code>continueSettling()</code>里检测到滚动结束时）</li>
<li>外部调用<code>abort()</code>时</li>
</ul>
</li>
<li><p><code>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</code><br>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>
<ul>
<li>在<code>dragTo()</code>里被调用（正在被拖动时）</li>
<li>在<code>continueSettling()</code>里被调用（自动滚动时）</li>
<li>外部调用<code>abort()</code>时被调用</li>
</ul>
</li>
<li><p><code>void onViewCaptured(View capturedChild, int activePointerId)</code><br><code>tryCaptureViewForDrag()</code>成功捕获到子View时会调用此方法。</p>
<ul>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里成功捕获</li>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>手动调用<code>captureChildView()</code></li>
</ul>
</li>
<li><p><code>void onViewReleased(View releasedChild, float xvel, float yvel)</code><br>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>）或被父View拦截事件时（<code>processTouchEvent()</code>的<code>ACTION_CANCEL</code>）会调用此方法。</p>
</li>
<li><p><code>void onEdgeTouched(int edgeFlags, int pointerId)</code><br><code>ACTION_DOWN</code>或<code>ACTION_POINTER_DOWN</code>事件发生时如果触摸到监听的边缘会调用此方法。<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。</p>
</li>
<li><p><code>boolean onEdgeLock(int edgeFlags)</code><br>返回<code>true</code>表示锁定<code>edgeFlags</code>对应的边缘，锁定后的那些边缘就不会在<code>onEdgeDragStarted()</code>被通知了，默认返回<code>false</code>不锁定给定的边缘，<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>其中之一。</p>
</li>
<li><p><code>void onEdgeDragStarted(int edgeFlags, int pointerId)</code><br><code>ACTION_MOVE</code>事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。<code>edgeFlags</code>取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。可在此手动调用<code>captureChildView()</code>触发从边缘拖动子View的效果。</p>
</li>
<li><p><code>int getOrderedChildIndex(int index)</code><br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给<code>tryCaptureViewForDrag()</code>来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>
</li>
<li><p><code>int getViewHorizontalDragRange(View child)</code>、<code>int getViewVerticalDragRange(View child)</code><br>返回给定的<code>child</code>在相应的方向上可以被拖动的最远距离，默认返回0。<code>ACTION_DOWN</code>发生时，若触摸点处的<code>child</code>消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。<br>被调用的地方有三处：</p>
<ul>
<li>在<code>checkTouchSlop()</code>中被调用，返回值大于0才会去检查<code>mTouchSlop</code>。在<code>ACTION_MOVE</code>里调用<code>tryCaptureViewForDrag()</code>之前会调用<code>checkTouchSlop()</code>。如果<code>checkTouchSlop()</code>失败，就不会去捕获View了。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>
<li>在调用<code>smoothSlideViewTo()</code>时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在<code>getView[Horizontal|Vertical]DragRange</code>里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>
</ul>
</li>
<li><p><code>boolean tryCaptureView(View child, int pointerId)</code><br>在<code>tryCaptureViewForDrag()</code>中被调用，返回<code>true</code>表示捕获给定的<code>child</code>。<code>tryCaptureViewForDrag()</code>被调用的地方有</p>
<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
</ul>
</li>
<li><p><code>int clampViewPositionHorizontal(View child, int left, int dx)</code>、<code>int clampViewPositionVertical(View child, int top, int dy)</code><br><code>child</code>在某方向上被拖动时会调用对应方法，返回值是<code>child</code>移动过后的坐标位置，<code>clampViewPositionHorizontal()</code>返回<code>child</code>移动过后的left值，<code>clampViewPositionVertical()</code>返回<code>child</code>移动过后的top值。<br>两个方法被调用的地方有两处：</p>
<ul>
<li>在<code>dragTo()</code>中被调用，<code>dragTo()</code>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里被调用。用来获取被拖动的View要移动到的位置。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>
</ul>
</li>
</ul>
<h2 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h2><p>在这里列举一部分对<code>ViewDragHelper</code>的应用案例，大家自己剖析它们的源码来实践巩固。</p>
<ol>
<li><a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a>，这是最简单的Demo</li>
<li><a href="https://github.com/BlueMor/DragLayout">QQ5.x侧滑菜单</a>、<a href="https://github.com/kyze8439690/ResideLayout">ResideLayout</a></li>
<li><a href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a>、<a href="https://github.com/liuguangqiang/SwipeBack">SwipeBack</a></li>
<li><a href="https://github.com/umano/AndroidSlidingUpPanel">SlidingUpPanel</a></li>
<li><a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java">DrawerLayout</a></li>
</ol>
<h2 id="其他关于ViewDragHelper的分析文章"><a href="#其他关于ViewDragHelper的分析文章" class="headerlink" title="其他关于ViewDragHelper的分析文章"></a>其他关于ViewDragHelper的分析文章</h2><ul>
<li><a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a></li>
<li><a href="http://blog.csdn.net/pi9nc/article/details/39583377">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewDragHelper</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
</search>
