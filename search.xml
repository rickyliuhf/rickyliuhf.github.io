<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Task 相关</title>
    <url>/2015-07-20-android-task-about/</url>
    <content><![CDATA[<p>在日常开发过程中，只要涉及到activity，那么对task相关的东西总会或多或少的接触到，不过对task相关的一些配置的作用理解的还不是很透彻，官方文档在细节上说的也不够清楚，要透彻理解还是得自己写demo实践检验，所以便有了这篇总结。</p>
<span id="more"></span>

<h2 id="task的概念"><a href="#task的概念" class="headerlink" title="task的概念"></a>task的概念</h2><p>参考<a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></p>
<h2 id="查看设备当前task的方法"><a href="#查看设备当前task的方法" class="headerlink" title="查看设备当前task的方法"></a>查看设备当前task的方法</h2><ul>
<li><a href="http://stackoverflow.com/questions/2442713/view-the-tasks-activity-stack">View the Task’s activity stack</a></li>
<li><a href="http://stackoverflow.com/a/22392616/2011291">Show Back Stack of Android</a></li>
</ul>
<h2 id="AndroidManifest中activity标签下和task有关的属性"><a href="#AndroidManifest中activity标签下和task有关的属性" class="headerlink" title="AndroidManifest中activity标签下和task有关的属性"></a>AndroidManifest中activity标签下和task有关的属性</h2><h3 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#aff">taskAffinity</a></h3><ul>
<li>此属性用来标记activity应该属于哪个task。</li>
<li>拥有相同affinity的activity从理论上属于同一个task（在用户的角度看来好像这些activity属于同一个应用），一个task的affinity是由其根activity的taskAffinity取值决定的。</li>
<li>affinity决定了两件事。<ul>
<li>一个是在使用allowTaskReparenting修饰activity时，activity要重新宿主到哪个task。</li>
<li>另一个是使用FLAG_ACTIVITY_NEW_TASK启动activity时，activity要放入哪个task。</li>
</ul>
</li>
<li>如果没有给activity设置taskAffinity，默认都会读取application标签下的taskAffinity属性值，如果application标签下也没有设置taskAffinity，那taskAffinity默认值就是manifest标签下设置的包名。</li>
<li>不仅可以给同一个应用的不同activity设置不同的affinity，也可以给不同应用的activity设置相同的affinity，使它们在用户角度看来好像属于同一个应用。</li>
</ul>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#lmode">launchMode</a></h3><p>launchMode有四种取值，与Intent里以<code>FLAG_ACTIVITY_</code>开头的flag结合，可以对activity的启动达到各种不同的效果。</p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>activity默认的启动模式，每次启动一个standard模式的activity时，都新建一个实例。</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>当前task栈顶存在本activity的实例，直接使用该实例，调用该activity的onNewIntent()，否则新建一个activity的实例入栈。</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>当启动一个singleTask模式的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。 </p>
<ul>
<li>如果存在，那么检查该task栈里是否存在该activity实例。<ul>
<li>如果存在，则将该task调入前台，销毁在该activity以上的activity，并调用该activity的onNewIntent()。</li>
<li>如果不存在，则新建一个该activity实例，并入栈。 </li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他activity，允许其他activity跟自己处于同一个task栈中，也允许其他activity重新宿主到本activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard。</p>
<ul>
<li>从B启动C，C是singleTask，C的affinity和A、B相同，C会进入taskA栈顶。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C相同，D会进入taskA栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B、C不同，D会进入新建的taskB中。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskB中，taskB的affinity为D的affinity。<ul>
<li>从D启动C，taskA调入前台，放在taskB的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
<li>从B启动C，C是singleTask，C的affinity和A、B不同，C会进入新建的taskB中。<ul>
<li>从C启动D，D是standard或singleTop，不论D的affinity是什么，D会进入taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B相同，D会进入taskA栈顶。<ul>
<li>从D启动C，taskB调入前台，放在taskA的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同但与C相同，D会进入新建的taskB栈顶。<ul>
<li>从D启动C，D出栈被销毁，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleTask，D的affinity和A、B不同且与C也不同，D会进入新建的taskC中。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
<li>从C启动D，D是singleInstance，D的affinity不论是什么，D会进入新建的taskC中，taskC的affinity为D的affinity。<ul>
<li>从D启动C，taskB调入前台，放在taskC的上面，C接收到onNewIntent()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>当启动一个singleInstance的activity时，首先会检查是否存在与该activity的taskAffinity相同的task。</p>
<ul>
<li>如果存在，检查这个task中是否存在该activity的实例。<ul>
<li>如果存在，则将该task调入前台，并调用该activity实例的onNewIntent()。</li>
<li>如果不存在，则新建一个task，再新建该activity实例放入新建的task中，系统允许多个相同affinity的task同时存在。</li>
</ul>
</li>
<li>如果不存在，则新建一个task，再新建该activity实例并放入新建的task中。</li>
<li>从该activity再启动其他任何activity，都会放到其他task中（新建task或者寻找已存在的task，即使要启动的activity与该activity具有相同的affinity），也不允许其他activity宿主到本task，该activity是task中唯一的activity。</li>
</ul>
<p>例如有四个activity叫A、B、C、D，其中A、B具有相同的affinity，现在taskA里有A、B，其中A和B是standard</p>
<ul>
<li>从B中启动C，C是singleInstance，C的affinity和A、B相同，C会放入新建的taskB中，taskA和taskB的affinity相同，因为两个task的根activity的affinity相同。<ul>
<li>从C中启动D，D的affinity和A、B、C相同。<ul>
<li>D是standard、singleTop、singleTask时，D会放入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA、taskB的affinity相同，因为三个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B、C不同，不论D是何种launchMode，D都会进入新建的taskC中，taskC的affinity是D的affinity。</li>
</ul>
</li>
<li>从B中启动C，C是singleInstance，C的affinity和A、B不同，C会放入新建的taskB中，taskA和taskB的affinity不同，因为两个task的根activity的affinity不同。<ul>
<li>从C中启动D，D的affinity和A、B相同。<ul>
<li>D是standard、singleTop、singleTask时，D都会进入taskA中，taskA调入前台，放在taskB上面。</li>
<li>D是singleInstance，D会进入新建的taskC中，taskC和taskA的affinity相同，因为两个task的根activity的affinity相同。</li>
</ul>
</li>
<li>从C中启动D，D的affinity和A、B不同，不论和C是否相同，D都会进入新建的taskC中，因为C所在的task不允许其他activity的存在，taskC的affinity为D的affinity。</li>
</ul>
</li>
</ul>
<p>使用场景：<br>使用singleInstance时，尽量给此activity设置单独的taskAffinity，以保证此activity处于不同名的task中，这样在“最近应用”的列表中可以看到这个task。否则如果有相同task名称的task存在，在“最近应用”的列表中就看不到这个含有singleInstance的activity的task了，只能通过代码启动这个activity来切换回这个task中。<br>而两个不同的task在用户角度来看是两个不同的应用，也就是两种不同的功能，所以使用singleInstance的activity功能上要与其他activity的功能区别较大。并且singleInstance是单例，也就是这个activity是公用的，可以在其他地方启动它来重复使用（可以是被同一个应用的其他地方重复使用，也可以是被其他的应用重复使用）。<br>例如，UC浏览器中有一个可以浏览office文档的activity（launchMode为singleInstance，taskAffinity也是独立的），这显然不是浏览器的主要功能。在文件管理器中点击一个excel文件（或者word、ppt文档）的时候，可以选择使用UC浏览器的这个activity来打开它，并且从用户角度看起来这个activity和UC浏览器是两个不同的应用（在“最近应用”的列表中可以看出来）。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#reparent">allowTaskReparenting</a></h3><p>此属性为true的activity被启动后，若有和此activity相同affinity的task转入前台，则此activity会从启动它的task移动到具有相同affinity的这个task。</p>
<p>例如，现在有两个应用分别为appA和appB，appA中有三个activity分别为activityA1、activityA2、activityA3，其中activityA1、activityA2的taskAffinity为taskA，activityA3的taskAffinity为taskB，appB中有一个activity为activityB1，其taskAffinity为taskB。所有activity都是standard模式。<br>启动appA，默认启动activityA1，再依次启动activityA2、activityA3，此时这三个activity都属于taskA。<br>按home键回到launcher，此时这三个activity扔都属于taskA。</p>
<ul>
<li>此时若点击appA的图标启动appA，看到的是activityA2，activityA3会进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskA、Launcher所在的task、taskB。<ul>
<li>按home键回到launcher，点击appB的图标启动appB，taskB调入前台显示，看到的是activityA3，而不是activityB1。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。</li>
</ul>
</li>
<li>此时若点击appB的图标启动appB，看到的是activityA3，activityA3进入新建的affinity为taskB的task中。此时所有task的顺序由前到后依次为taskB、Launcher所在的task、taskA。taskB中还有activityB1在栈底部，在activityA3中按返回键可以回到activityB1。taskA中仅剩activityA1、activityA2。</li>
</ul>
<h3 id="alwaysRetainTaskState"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#always">alwaysRetainTaskState</a></h3><p>如果用户离开一个task已经很久了，系统会在某个时刻清理掉这个task中除了根activity外所有的activity。当用户再次回到这个task，只有根activity被恢复。这样做是因为长期离开一个task，用户很有可能已经放弃了他之前所做的事情，转而要开始做新的事情，所以只保留根activity。<br>若根activity上的alwaysRetainTaskState为true，强制保留本task中的所有activity，即使过了很长时间，也不让系统清理task。<br>例如浏览器打开了很多个tab页，长时间不操作后也要保证再次回来时还是上次浏览的页面。</p>
<h3 id="clearTaskOnLaunch"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#clear">clearTaskOnLaunch</a></h3><p>与alwaysRetainTaskState相反，若根activity上的clearTaskOnLaunch为true，不论何时用户再次从Launcher回到这个task时，除了根activity以外的其他activity都销毁。</p>
<h3 id="finishOnTaskLaunch"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#finish">finishOnTaskLaunch</a></h3><p>此属性为true的activity，不论何时用户再次回到这个activity所属的task时，此activity会被销毁。此属性优先级优于allowTaskReparenting。</p>
<h2 id="Intent中和task有关的部分flag"><a href="#Intent中和task有关的部分flag" class="headerlink" title="Intent中和task有关的部分flag"></a>Intent中和task有关的部分flag</h2><h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_NEW_TASK">FLAG_ACTIVITY_NEW_TASK</a></h3><p>和launchMode的属性值singleTask等效。如果一个Intent中包含此flag，尝试将要启动的activity放在一个新的task中，如果已经有一个task栈里存在目标activity的实例，将此task从后台调到前台来，调用已存在的activity实例的onNewIntent()方法。此flag不能用于startActivityForResult()。</p>
<h3 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_SINGLE_TOP">FLAG_ACTIVITY_SINGLE_TOP</a></h3><p>和launchMode的属性值singleTop等效。如果一个Intent中包含此属性，并且要启动的Activity就是当前的Activity（当前task栈顶activity），直接调用该activity的onNewIntent()，否则新建一个activity实例。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a><a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP">FLAG_ACTIVITY_CLEAR_TOP</a></h3><p>如果一个Intent中包含此属性，并且当前task栈存存在目标activity的实例，清除该实例上面的所有的activity。<br>如果目标activity的launcherMode为standard，且Intent没有添加FLAG_ACTIVITY_SINGLE_TOP标记，则会销毁目标activity再重新创建，否则会重用该实例，调用onNewIntent()。</p>
<h3 id="FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET"><a href="#FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET" class="headerlink" title="FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET"></a><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET">FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</a></h3><p>如果一个Intent中包含此属性，则它转向的那个Activity以及在那个Activity其上的所有Activity都会在task重置时被清除出task，这只发生在task重置的时候，而从Launcher中点击应用图标启动应用的时候会发生task重置（从Launcher启动应用会在Intent中附带一个FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://developer.android.com/intl/zh-cn/guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a></li>
<li><a href="http://blog.csdn.net/ff20081528/article/details/17219951">Tasks and Back Stack中文翻译</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html">AndroidManifest中activity标签API Doc</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Intent.html">Intent API Doc</a></li>
<li><a href="http://blog.csdn.net/liuhe688/article/details/6761337">Activity的task相关</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Task</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Task</tag>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle之Transform</title>
    <url>/Gradle/Gradle%E4%B9%8BTransform/</url>
    <content><![CDATA[<h1 id="AOP两种方式实现"><a href="#AOP两种方式实现" class="headerlink" title="AOP两种方式实现"></a>AOP两种方式实现</h1><ol>
<li> 通过gradle提供的transform api</li>
<li> 通过Java Instrument机制hook dx.jar，拦截gradle编译把class转为dex的过程</li>
</ol>
<p>参考</p>
<ul>
<li><a href="https://www.jianshu.com/p/c202853059b4">Android AOP之字节码插桩</a></li>
</ul>
<h1 id="Transform-API-有什么用？"><a href="#Transform-API-有什么用？" class="headerlink" title="Transform API 有什么用？"></a>Transform API 有什么用？</h1><p>transform拦截jar转为dex的过程。</p>
<p>jar转为dex时先经过transform处理。</p>
<p>jar -&gt; transform -&gt; dex</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825195255.png"></p>
<h1 id="Transform-API如何使用？"><a href="#Transform-API如何使用？" class="headerlink" title="Transform API如何使用？"></a>Transform API如何使用？</h1><p>参考</p>
<ul>
<li><a href="https://juejin.im/post/6844903831646502920">Android Transform + ASM 初探</a></li>
</ul>
<p>不管你修不修改输入，都必须要把类复制到指定的transform输出位置。</p>
<p>步骤：</p>
<ul>
<li>com.android.build.api.transform.Transform是android gradle plugin里的类，引用Transform需要先引入agp的依赖。<br>implementation(“com.android.tools.build:gradle:xxx”)</li>
<li>实现一个自定义的类继承Transform，然后将其注册到agp中即可。</li>
<li>注册到agp，先要获得android的扩展，通过project.extensions.findByType(BaseExtension::class.java)<br>来获取。</li>
<li>再调用BaseExtension中的registerTransform()添加自定义的Transform。</li>
</ul>
<p>一个通过自定义插件添加自定义Transform的示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        project.extensions.findByType(BaseExtension::<span class="keyword">class</span>.java)</span><br><span class="line">            ?.registerTransform(MyTransform())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> : <span class="type">Transform</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyTransform&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInputTypes</span><span class="params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getScopes</span><span class="params">()</span></span>: MutableSet&lt;<span class="keyword">in</span> QualifiedContent.Scope&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isIncremental</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(transformInvocation: <span class="type">TransformInvocation</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.transform(transformInvocation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Transform类中各方法的作用"><a href="#Transform类中各方法的作用" class="headerlink" title="Transform类中各方法的作用"></a>Transform类中各方法的作用</h1><h2 id="getName-String"><a href="#getName-String" class="headerlink" title="getName(): String"></a><code>getName(): String</code></h2><p>本Transform的名称</p>
<h2 id="getInputTypes-Set-lt-ContentType-gt"><a href="#getInputTypes-Set-lt-ContentType-gt" class="headerlink" title="getInputTypes(): Set&lt;ContentType&gt;"></a><code>getInputTypes(): Set&lt;ContentType&gt;</code></h2><ul>
<li>处理的输入类型</li>
<li>分为class文件或者java资源</li>
<li>class文件来自于jar或者文件夹</li>
<li>资源就是标准的java资源，默认约定位于src/main/resources目录下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DefaultContentType</span> <span class="keyword">implements</span> <span class="title">ContentType</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The content is compiled Java code. This can be in a Jar file or in a folder. If</span></span><br><span class="line"><span class="comment">       * in a folder, it is expected to in sub-folders matching package names.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      CLASSES(<span class="number">0x01</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The content is standard Java resources.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      RESOURCES(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getScopes-Set-lt-super-Scope-gt"><a href="#getScopes-Set-lt-super-Scope-gt" class="headerlink" title="getScopes(): Set&lt;? super Scope&gt;"></a><code>getScopes(): Set&lt;? super Scope&gt;</code></h2><p>输入文件所属的范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Scope</span> <span class="keyword">implements</span> <span class="title">ScopeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Only the project content */</span></span><br><span class="line">    PROJECT(<span class="number">0x01</span>), <span class="comment">//只是当前工程的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the project&#x27;s local dependencies (local jars) */</span></span><br><span class="line">    PROJECT_LOCAL_DEPS(<span class="number">0x02</span>), <span class="comment">// 工程的本地jar</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the sub-projects. */</span></span><br><span class="line">    SUB_PROJECTS(<span class="number">0x04</span>),  <span class="comment">// 只包含子工工程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the sub-projects&#x27;s local dependencies (local jars). */</span></span><br><span class="line">    SUB_PROJECTS_LOCAL_DEPS(<span class="number">0x08</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Only the external libraries */</span></span><br><span class="line">    EXTERNAL_LIBRARIES(<span class="number">0x10</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Code that is being tested by the current variant, including dependencies */</span></span><br><span class="line">    TESTED_CODE(<span class="number">0x20</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local or remote dependencies that are provided-only */</span></span><br><span class="line">    PROVIDED_ONLY(<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransformManager预定了一些SCOPE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_PROJECT =</span><br><span class="line">            ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);</span><br></pre></td></tr></table></figure>

<h2 id="isIncremental-Boolean"><a href="#isIncremental-Boolean" class="headerlink" title="isIncremental(): Boolean"></a><code>isIncremental(): Boolean</code></h2><p>是否是增量编译。</p>
<h2 id="transform-TransformInvocation"><a href="#transform-TransformInvocation" class="headerlink" title="transform(TransformInvocation)"></a>transform(TransformInvocation)</h2><p>input的内容将会打包成一个TransformInvocation对象，交给方法体处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransformInvocation</span> </span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getReferencedInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;SecondaryInput&gt; <span class="title">getSecondaryInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TransformOutputProvider <span class="title">getOutputProvider</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transform方法中如何处理TransformInput的JarInput和DirectoryInput？"><a href="#transform方法中如何处理TransformInput的JarInput和DirectoryInput？" class="headerlink" title="transform方法中如何处理TransformInput的JarInput和DirectoryInput？"></a>transform方法中如何处理TransformInput的JarInput和DirectoryInput？</h2><p>DirectoryInput 进行ASM插桩（参考<a href="https://github.com/lijiankun24/Koala/blob/master/buildSrc/src/main/groovy/com/lijiankun24/koala/plugin/PreClass.groovy">koala - PreClass.groovy</a>）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDirectoryInput</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    directoryInput: <span class="type">DirectoryInput</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    outputProvider: <span class="type">TransformOutputProvider</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directoryInput.file.isDirectory) &#123;</span><br><span class="line">        directoryInput.file.walkTopDown().forEach &#123; file -&gt;</span><br><span class="line">            <span class="keyword">val</span> name = file.name</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; name != <span class="string">&quot;R.class&quot;</span></span><br><span class="line">                &amp;&amp; !name.startsWith(<span class="string">&quot;R\$&quot;</span>) &amp;&amp; name != <span class="string">&quot;BuildConfig.class&quot;</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">val</span> reader = ClassReader(file.readBytes())</span><br><span class="line">                <span class="keyword">val</span> writer = ClassWriter(reader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                <span class="keyword">val</span> visitor = MyClassVisitor(writer)</span><br><span class="line">                reader.accept(visitor, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                <span class="keyword">val</span> code = writer.toByteArray()</span><br><span class="line">                <span class="keyword">val</span> classPath = file.parentFile.absolutePath + File.separator + name</span><br><span class="line">                <span class="keyword">val</span> fos = FileOutputStream(classPath)</span><br><span class="line">                fos.write(code)</span><br><span class="line">                fos.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完输入文件之后，要把输出给下一个任务</span></span><br><span class="line">    <span class="keyword">val</span> dest = outputProvider.getContentLocation(</span><br><span class="line">        directoryInput.name,</span><br><span class="line">        directoryInput.contentTypes, directoryInput.scopes,</span><br><span class="line">        Format.DIRECTORY</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JarInput 不处理（参考<a href="https://github.com/lijiankun24/Koala/blob/master/buildSrc/src/main/groovy/com/lijiankun24/koala/plugin/PreClass.groovy">koala - PreClass.groovy</a>）：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">    <span class="keyword">def</span> jarName = jarInput.name</span><br><span class="line">    <span class="keyword">def</span> md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">    <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">        jarName = jarName.substring(<span class="number">0</span>, jarName.length() - <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> dest = transformInvocation.outputProvider.getContentLocation(jarName + md5Name,</span><br><span class="line">            jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line"></span><br><span class="line">    FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>JarInput 处理ASM：<br>参考:</p>
<ul>
<li><a href="https://github.com/chenenyu/Router/blob/master/gradle-plugin/src/main/groovy/com/chenenyu/router/RouterTransform.groovy">Router - RouterTransform.groovy</a></li>
<li><a href="https://github.com/chenenyu/Router/blob/master/gradle-plugin/src/main/groovy/com/chenenyu/router/Scanner.groovy">Router - Scanner.groovy</a><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleJarInput</span><span class="params">(jarInput: <span class="type">JarInput</span>, outputProvider: <span class="type">TransformOutputProvider</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//重名名输出文件,因为可能同名,会覆盖</span></span><br><span class="line">    <span class="keyword">var</span> jarName = jarInput.name</span><br><span class="line">    <span class="keyword">val</span> md5Name = DigestUtils.md5Hex(jarInput.file.absolutePath)</span><br><span class="line">    <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">        jarName = jarName.substring(<span class="number">0</span>, jarName.length - <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt; 处理输入的jar文件中的class，输出到一个临时的jar文件</span></span><br><span class="line">    <span class="keyword">val</span> jarFile = JarFile(jarInput.file)</span><br><span class="line">    <span class="keyword">val</span> enumeration = jarFile.entries()</span><br><span class="line">    <span class="keyword">val</span> tmpFile = File(jarInput.file.parent + File.separator + <span class="string">&quot;classes_temp.jar&quot;</span>)</span><br><span class="line">    <span class="comment">// 避免上次的缓存被重复插入</span></span><br><span class="line">    <span class="keyword">if</span> (tmpFile.exists()) &#123;</span><br><span class="line">        tmpFile.delete()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jarOutputStream = JarOutputStream(FileOutputStream(tmpFile))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存</span></span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">        <span class="keyword">val</span> jarEntry = enumeration?.nextElement() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> entryName = jarEntry.name</span><br><span class="line">        <span class="keyword">val</span> zipEntry = ZipEntry(entryName)</span><br><span class="line">        <span class="keyword">val</span> inputStream = jarFile.getInputStream(jarEntry)</span><br><span class="line">        <span class="comment">// 插桩class</span></span><br><span class="line">        <span class="keyword">if</span> (entryName.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; !entryName.startsWith(<span class="string">&quot;R\$&quot;</span>)</span><br><span class="line">            &amp;&amp; <span class="string">&quot;R.class&quot;</span> != entryName &amp;&amp; <span class="string">&quot;BuildConfig.class&quot;</span> != entryName</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">//class文件处理</span></span><br><span class="line">            println(<span class="string">&quot;----------- deal with jar class file &lt;&#x27; + <span class="variable">$entryName</span> + &#x27;&gt; -----------&quot;</span>)</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            <span class="keyword">val</span> classReader = ClassReader(inputStream)</span><br><span class="line">            <span class="keyword">val</span> classWriter = ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">            <span class="keyword">val</span> cv = MyClassVisitor(classWriter)</span><br><span class="line">            classReader.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">            <span class="keyword">val</span> code = classWriter.toByteArray()</span><br><span class="line">            jarOutputStream.write(code)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            jarOutputStream.write(inputStream.readBytes())</span><br><span class="line">        &#125;</span><br><span class="line">        jarOutputStream.closeEntry()</span><br><span class="line">    &#125;</span><br><span class="line">    jarOutputStream.close()</span><br><span class="line">    jarFile.close()</span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt; 处理输入的jar文件中的class，输出到一个临时的jar文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt; 处理过class的临时jar文件输出到目标位置</span></span><br><span class="line">    <span class="keyword">val</span> dest = outputProvider.getContentLocation(</span><br><span class="line">        jarName + md5Name,</span><br><span class="line">        jarInput.contentTypes, jarInput.scopes, Format.JAR</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyFile(tmpFile, dest)</span><br><span class="line">    tmpFile.delete()</span><br><span class="line">    <span class="comment">// &lt;&lt;&lt;&lt; 处理过class的临时jar文件输出到目标位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Java-Agent和Instrument机制是什么？有什么用？大概如何使用？"><a href="#Java-Agent和Instrument机制是什么？有什么用？大概如何使用？" class="headerlink" title="Java Agent和Instrument机制是什么？有什么用？大概如何使用？"></a>Java Agent和Instrument机制是什么？有什么用？大概如何使用？</h1><p>JavaAgent使用指南</p>
<p><a href="https://www.cnblogs.com/rickiyang/p/11368932.html">https://www.cnblogs.com/rickiyang/p/11368932.html</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.im/post/6844903780916396039">【Android】函数插桩（Gradle + ASM）</a></li>
</ul>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Transform</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.10.正则表达式匹配（困难）</title>
    <url>/LeetCode/LeetCode.10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode.10.正则表达式匹配（困难）</a></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>题目已经给出了匹配规则。</p>
<h3 id="怎么做匹配？"><a href="#怎么做匹配？" class="headerlink" title="怎么做匹配？"></a>怎么做匹配？</h3><p>用两个指针<code>i</code>和<code>j</code>分别指向<code>s</code>和<code>p</code>的开头，一直匹配，如果两个指针都能到达<code>s</code>和<code>p</code>的末尾，说明匹配成功。</p>
<h3 id="的注意事项"><a href="#的注意事项" class="headerlink" title="*的注意事项"></a><code>*</code>的注意事项</h3><p><code>p</code>中遇到<code>*</code>时要考虑它前面一个字符是什么。</p>
<p>但我们是从左向右匹配的，所以在当前位置匹配字符时，要考虑<code>p</code>的下一个位置是不是<code>*</code>。</p>
<h3 id="如何用-匹配多个字符？"><a href="#如何用-匹配多个字符？" class="headerlink" title="如何用*匹配多个字符？"></a>如何用<code>*</code>匹配多个字符？</h3><p>可以匹配0个字符、1个字符，多个字符递归去解决。</p>
<ul>
<li>匹配0个字符时，指针<code>i</code>不动，<code>j</code>跳到<code>j + 2</code></li>
<li>匹配1个字符时，先要看<code>s[i]</code>是不是跟<code>p[j]</code>匹配，匹配的话<code>j</code>是不动的，因为可以匹配多个。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>按道理<code>j == p.length &amp;&amp; i == s.length</code>时，说明匹配完成，否则没有完成匹配。<br>但是因为有<code>*</code>的存在，可能<code>j</code>还指向<code>*</code>前面一个字符，<code>i</code>会先到末尾，即此时<code>j != p.length &amp;&amp; i == s.length</code>，也可能是匹配成功的，<code>i</code>发现<code>s</code>后面没有字符可匹配时，可以走<code>*</code>匹配0个字符的逻辑，这样<code>j</code>就到达末尾了。</p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">val</span> isStarPattern = j &lt;= n - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (isStarPattern) &#123;</span><br><span class="line">                <span class="keyword">val</span> isZeroMatched = match(i, j + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">val</span> isOneMatched = isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j)</span><br><span class="line">                isZeroMatched || isOneMatched</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：平均O(n * 2 ^ 星号数)，最差O(2^n)，</p>
</blockquote>
<h2 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h2><p>普通递归存在很多重叠子问题。</p>
<p>比如执行两次<code>match(i +  1, j)</code>再执行两次<code>match(i, j +  2)</code>的结果跟执行两次<code>match(i +  1, j +  1)</code>的结果是一样的。</p>
<p>所以需要记录中间结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;String, <span class="built_in">Boolean</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">val</span> key = <span class="string">&quot;<span class="variable">$i</span>,<span class="variable">$j</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (memo.contains(key)) <span class="keyword">return</span> memo[key]!!</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">val</span> isStarPattern = j &lt;= n - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">val</span> matched = <span class="keyword">if</span> (isStarPattern) &#123;</span><br><span class="line">                <span class="keyword">val</span> isZeroMatched = match(i, j + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">val</span> isOneMatched = isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j)</span><br><span class="line">                isZeroMatched || isOneMatched</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isCharMatch &amp;&amp; match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            memo[key] = matched</span><br><span class="line">            <span class="keyword">return</span> matched</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：平均O(n*(星号数+1))，最差O(n²)</p>
</blockquote>
<h2 id="解法3：自底向上动态规划"><a href="#解法3：自底向上动态规划" class="headerlink" title="解法3：自底向上动态规划"></a>解法3：自底向上动态规划</h2><p>由递归解法分析可知，大问题可以划分为子问题+有限步骤解决，并且符合最优子结构、无后效性、重叠子问题。<br>这里的关键是梳理出子问题是经过怎样的步骤得到大问题，即可得到状态转移方程。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[i][j]</code>为 <code>s</code> 的前<code>i</code>个字符是否能被 <code>p</code> 的前<code>j</code>个字符匹配。</p>
<ul>
<li><code>s[i - 1] == p[j - 1]</code>时，<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>s[i - 1] != p[j - 1]</code>时：<ul>
<li><code>p[j - 1] != &#39;.&#39; &amp;&amp; p[j - 1] != &#39;*&#39;</code>时，<code>dp[i][j] = false</code>。</li>
<li><code>p[j - 1] == &#39;.&#39;</code>时：<br><code>.</code>可以匹配任意字符，跟<code>s[i - 1] == p[j - 1]</code>的处理情况一样，即：<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>p[j - 1] == &#39;*&#39;</code>时：<br><code>*</code>可以匹配前面字符的0个或多个；<ul>
<li>匹配0次：<code>dp[i][j] = dp[i][j - 2]</code></li>
<li>匹配1次：<code>dp[i][j] = dp[i - 1][j] &amp;&amp; (p[j - 2] == s[i - 1] || p[j - 2] == &#39;.&#39;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> ls = s.length</span><br><span class="line">        <span class="keyword">val</span> lp = p.length</span><br><span class="line">        <span class="comment">// dp[i][j]表示s的前i个字符否能与p的前j个字符匹配，i和j分别从0开始取值</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(ls + <span class="number">1</span>) &#123; BooleanArray(lp + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">		<span class="comment">// 0个字符跟0个字符是匹配的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// p中有*是可以匹配0个字符的，所以做一下初始化</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">2</span> until dp[<span class="number">0</span>].size) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until dp.size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until dp[i].size) &#123;</span><br><span class="line">                <span class="keyword">val</span> si = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> pi = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (p[pi] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 匹配0次，字符可以不相等</span></span><br><span class="line">                    <span class="comment">// 匹配1次，字符要相同</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                            || dp[i - <span class="number">1</span>][j] &amp;&amp; (s[si] == p[pi - <span class="number">1</span>] || p[pi - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[si] == p[pi] || p[pi] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ls][lp]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 O(mn)：m、n分别为s、p长度，填充二维dp数组所需的时间。<br>空间复杂度 O(mn)：二维dp数组占用的空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1014.最佳观光组合（中等）</title>
    <url>/LeetCode/LeetCode.1014.%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">LeetCode.1014.最佳观光组合（中等）</a></p>
<p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。<br>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。<br>返回一对观光景点能取得的最高分。、</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ol>
<li>对一个确定的<code>j</code>，需要在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得观光组合得分最高。</li>
<li>不知道选哪个<code>j</code>能让得分最高，就需要穷举所有<code>j</code>的取值可能性。</li>
</ol>
<h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p>目标是求最大的观察观光组合得分，那么就得思考得分与什么相关，能否分解为独立的几个部分，再穷举每个部分所有的可能性，看这些可能性是怎么操作得到的，就可以知道得分是怎么来的了。</p>
<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>得分公式<code>values[i] + values[j] + i - j</code>里会变的东西就是<code>i</code>和<code>j</code>，这两个是独立变化的，那么就可以把公式拆成两部分：</p>
<ol>
<li>仅跟<code>i</code>相关的，即 <code>values[i] + i</code>，可以称为<code>scoreI</code></li>
<li>仅跟<code>j</code>相关的，即 <code>values[j] - j</code>，可以称为<code>scoreJ</code></li>
</ol>
<p>总分<code>score = scoreI + scoreJ</code></p>
<h3 id="对于一个确定的j，怎么使得得分最高呢？"><a href="#对于一个确定的j，怎么使得得分最高呢？" class="headerlink" title="对于一个确定的j，怎么使得得分最高呢？"></a>对于一个确定的j，怎么使得得分最高呢？</h3><ol>
<li><code>j</code>确定了， <code>scoreJ</code> 是确定的，不会变动。</li>
<li>然后在<code>[0, j - 1]</code>中选取一个<code>i</code>，使得<code>scoreI</code> 最大，得分就是最高了。</li>
</ol>
<p>不确定选哪个<code>j</code>可以得分最高，那就遍历数组，穷举<code>j</code>所有的取值可能。</p>
<p>但是按照这个思路，先穷举<code>j</code>，再在每个<code>j</code>处往回穷举<code>i</code>，时间复杂度是O($n^2$)，是否存在不必要的操作？</p>
<h3 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h3><p>仔细分析两个步骤可以发现，没有必要往回穷举<code>i</code>，因为<code>i &lt; j</code>，在数组中遍历到<code>j</code>，<code>j</code>前面的位置肯定都遍历过了，<code>i</code>已经可以确定了；简单点说，<code>j</code>确定了，<code>i</code>就确定了。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(values: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = values.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxScoreI = values[<span class="number">0</span>] + <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxScore = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 穷举所有的j</span></span><br><span class="line">        <span class="comment">// 只有1个景点无法形成观光组合，所以从1开始遍历，这样至少2个有两个景点能形成观光组合</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> scoreJ = values[j] - j</span><br><span class="line">            <span class="keyword">val</span> score = maxScoreI + scoreJ</span><br><span class="line">            maxScore = maxOf(maxScore, score)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 上面已经处理过j，对于下一个j而言，需要知道下一个j前面最大的scoreI是多少</span></span><br><span class="line">            <span class="keyword">val</span> scoreI = values[j] + j</span><br><span class="line">            maxScoreI = maxOf(maxScoreI, scoreI)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxScore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1137.第N个泰波那契数（简单）</title>
    <url>/LeetCode/LeetCode.1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">LeetCode.1137.第 N 个泰波那契数（简单）</a></p>
<p>泰波那契序列 Tn 定义如下：<br>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据公式直接递推，比斐波那契数列多一项。<br>记忆化递归就不写了。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tribonacci</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre3 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2 + pre3</span><br><span class="line">            pre3 = pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1143.最长公共子序列（中等）</title>
    <url>/LeetCode/LeetCode.1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode.1143.最长公共子序列（中等）</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h3><p>尝试划分子问题。</p>
<p><strong>如果text1和text2存在公共子序列，那是怎么得来的？</strong><br>肯定是之前没有公共子序列或者存在公共子序列，然后又发现了两者相同的字符，得到了更长的公共子序列。</p>
<p><strong>如果末尾字符不相同怎么办？</strong></p>
<ol>
<li>删除text1的末尾字符，剩余字符串去跟text2比较。</li>
<li>删除text2的末尾字符，剩余字符串去跟text1比较。</li>
</ol>
<p>取两种情况中可以得到的最长公共子序列的情况。</p>
<p>同时删除text1和text2的末尾字符要不要考虑？</p>
<p>这里划分出了子问题和所有的递推步骤。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span> || i2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (text1[i1] == text2[i2]) <span class="number">1</span> + solve(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> maxOf(solve(i1 - <span class="number">1</span>, i2), solve(i1, i2 - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(text1.length - <span class="number">1</span>, text2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在重叠子问题，有大量重复计算，用数组记录中间计算结果。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun longestCommonSubsequence(text1: String, text2: String): Int &#123;</span><br><span class="line">        val memo = Array(text1.length) &#123; IntArray(text2.length) &#123; 0 &#125; &#125;</span><br><span class="line">        fun solve(i1: Int, i2: Int): Int &#123;</span><br><span class="line">            if (i1 == -1 || i2 == -1) return 0 </span><br><span class="line">            if (memo[i1][i2] &gt; 0) return memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = if (text1[i1] == text2[i2]) 1 + solve(i1 - 1, i2 - 1)</span><br><span class="line">            else maxOf(solve(i1 - 1, i2), solve(i1, i2 - 1))</span><br><span class="line">            return memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(text1.length - 1, text2.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：自底向上动态规划"><a href="#解法2：自底向上动态规划" class="headerlink" title="解法2：自底向上动态规划"></a>解法2：自底向上动态规划</h3><p>设<code>dp[i][j]</code>为<code>text1</code>的前<code>i + 1</code>个字符与<code>text2</code>的前<code>j + 1</code>个字符最长公共子序列的长度。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>text1[i] == text2[j]</code>时，<code>dp[i][j] = 1 + dp[i - 1][j - 1]</code></li>
<li><code>text1[i] != text2[j]</code>时，<code>dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
<p><strong>边界处理</strong><br>设<code>s1</code>是<code>text1</code>子字符串，<code>s2</code>是<code>text2</code>子字符串。</p>
<ul>
<li><code>s1</code>和<code>s2</code>为一个字符时，只需要判断字符是否相同，可以计算<code>dp[0][0]</code>。</li>
<li><code>s1</code>只有一个字符时，如果跟<code>s2</code>的字符不相同，<code>s1</code>没办法再删减，直接取<code>s2</code>删减后的结果。</li>
<li><code>s2</code>只有一个字符时，如果跟<code>s1</code>的字符不相同，<code>s2</code>没办法再删减，直接取<code>s1</code>删减后的结果。</li>
</ul>
<p><strong>复杂度</strong><br>设<code>text1</code>长度为<code>m</code>，<code>text2</code>长度为<code>n</code>。<br>时间复杂度O(mn)：双循环无法省略。<br>空间复杂度O(mn)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = text1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = text2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n1) &#123; IntArray(n2) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) dp[i][<span class="number">0</span>] = <span class="keyword">if</span> (text1[i] == text2[<span class="number">0</span>]) <span class="number">1</span> <span class="keyword">else</span> dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) dp[<span class="number">0</span>][j] = <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[j]) <span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n2) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (text1[i] == text2[j]) <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1 - <span class="number">1</span>][n2 - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.118.杨辉三角（简单）</title>
    <url>/LeetCode/LeetCode.118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></p>
<p>给定一个非负整数 _<code>numRows</code>，_生成「杨辉三角」的前 <em><code>numRows</code></em> 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递推公式题目已经给出，讨论一下边界情况，把问题具体定义就好了。</p>
<h3 id="问题公式化"><a href="#问题公式化" class="headerlink" title="问题公式化"></a>问题公式化</h3><p>三角形每行用List存储，所有行也用List存储。<br>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>把三角形左侧对齐可以观察到：<br>左上方的数就是<code>dp[r - 1][c - 1]</code>；<br>右上方的数就是<code>dp[r - 1][c]</code>；</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>r = 0时，没有上方，但其实知道第一行是1，只有1个元素，直接添加到结果集就行了。<br>r &gt; 0后：<br>c = 0 处于第一列时，没有左上方，左上方当作0，只累加右上方，<code>dp[r][0] = dp[r - 1][c]</code>。<br>c = r 处于最后一列时，没有右上方，右上方当作0，只累加左上方，<code>dp[r][r] = dp[r - 1][r - 1]</code>。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(numRows: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> triangle = mutableListOf&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">        triangle.add(listOf(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until numRows) &#123;</span><br><span class="line">            <span class="keyword">val</span> rows = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0.</span>.r) &#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 第一列，只能加右上方</span></span><br><span class="line">                    c == <span class="number">0</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                    <span class="comment">// 最后一列，只能加左上方</span></span><br><span class="line">                    c == r -&gt; rows.add(triangle[r - <span class="number">1</span>][r - <span class="number">1</span>])</span><br><span class="line">                    <span class="comment">// 中间列，左上方+右上方</span></span><br><span class="line">                    <span class="keyword">else</span> -&gt; rows.add(triangle[r - <span class="number">1</span>][c - <span class="number">1</span>] + triangle[r - <span class="number">1</span>][c])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            triangle.add(rows)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.119.杨辉三角 II（简单）</title>
    <url>/LeetCode/LeetCode.119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></p>
<p>给定一个非负索引  <code>rowIndex</code>，返回「杨辉三角」的第  <code>rowIndex</code>  行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最直观就是求出杨辉三角所有行，取第<code>rowIndex</code>行。<br>实际每一行由上一行推导而来，不需要存储所有行，只需要保存上一行，递推来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是杨辉三角第r行第c列的数。<br>左上方的数：<code>dp[r - 1][c - 1]</code>；<br>右上方的数：<code>dp[r - 1][c]</code>；<br><code>dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>用一个数组就可以完成每行迭代。<br><code>dp[c] = dp[c - 1] + dp[c]</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>更新第c列时，会读取c - 1列的旧值；<br>但是c - 1列在更新数组的时候已经被新值覆盖了。<br>解决方案：</p>
<ol>
<li>从左向右遍历数组时，临时存储一下旧值。</li>
<li>从右向左遍历数组。</li>
</ol>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRow</span><span class="params">(rowIndex: <span class="type">Int</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = IntArray(rowIndex + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        rows[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1.</span>.rowIndex) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> r - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">                rows[c] = rows[c - <span class="number">1</span>] + rows[c]</span><br><span class="line">            &#125;</span><br><span class="line">            rows[r] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows.toList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.120.三角形最小路径和（中等）</title>
    <url>/LeetCode/LeetCode.120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/triangle/">LeetCode.120.三角形最小路径和（中等）</a></p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目已经给出了递推公式，是从上往下取值的，所以要从最后一行往上递推，最后得到结果。<br>如果用递归写，这个顺序就会比较明白，递归划分为子问题后，实际是自底向上传递计算结果的。</p>
<p>设<code>dp[i][j]</code>为第i行第j列向下的最小路径和。<br>总共<code>n</code>行。</p>
<p>最后一行没有下一行了，所以<br><code>dp[n - 1][j] = triangle[n - 1][j]</code></p>
<p>上面的行，状态转移方程为：<br><code>dp[i][j] = triangle[i][j] + minOf(dp[i + 1][j], dp[i + 1][j + 1]</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minimumTotal</span><span class="params">(triangle: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Int</span>&gt;&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = triangle.size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[n - <span class="number">1</span>][j] = triangle[n - <span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.i) &#123;</span><br><span class="line">                dp[i][j] = triangle[i][j] + minOf(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.121.买卖股票的最佳时机（简单）</title>
    <url>/LeetCode/LeetCode.121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode.121.买卖股票的最佳时机（简单）</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>设dp[i]为第0天到第i天获取最大利润。</p>
<p>在第i天，可以选择不卖股票或卖出股票。</p>
<ol>
<li>不卖股票，dp[i] = dp[i - 1]</li>
<li>卖出股票，由于只能买入一次和卖出一次，那要获得最大利润，肯定要在第0天到第i -1中股票最低的时候买入，dp[i] = prices[i] - minPrice</li>
</ol>
<p>dp[i]只与上一个状态有关，所以可以用变量存储状态，不需要数组记录。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxProfit = maxOf(maxProfit, prices[i] - minPrice)</span><br><span class="line">            minPrice = minOf(minPrice, prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="comment">// dp[i][k]表示前i天持有和未持有第i天的股票的最大收益</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 第i天未持有，可能是前i-1天就未持有然后今天不操作，或者以前持有了今天卖出了</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            <span class="comment">// 第i天持有，可能是前i-1天就持有了然后今天不操作，或者以前就未持有今天买入了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.122.买卖股票的最佳时机 II（简单）</title>
    <url>/LeetCode/LeetCode.122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划。</p>
<h3 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h3><p>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。<br>归纳合并一下，这些操作会产生的结果状态是：</p>
<ol>
<li>第<code>i</code>天持有股票</li>
<li>第<code>i</code>天不持有股票</li>
</ol>
<h3 id="为什么要关注操作得到的结果状态？"><a href="#为什么要关注操作得到的结果状态？" class="headerlink" title="为什么要关注操作得到的结果状态？"></a>为什么要关注操作得到的结果状态？</h3><p>因为选择某个操作，就是上一个状态转变为下一个状态，所以需要知道操作前后的状态是什么。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>第<code>i</code>天有两个股票持有状态，不同股票持有状态的收益是不一样的。<br>一个状态经过选择操作后可能会转化为另一个状态，所以要记录所有状态的信息。<br>也就是要把天数和股票持有状态组合的所有状态都要记录下来。</p>
<p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p>根据第<code>i</code>天的选择操作来梳理状态转移方程：</p>
<ol>
<li>第<code>i</code>天买入，变成持有股票的状态，利润要减去<code>prices[i]</code>，题目要求买入前不能持有股票，所以<code>dp[i][1] = dp[i - 1][0] - prices[i]</code>。</li>
<li>第<code>i</code>天卖出，变成不持有股票的状态，利润要加上<code>prices[i]</code>，卖出前肯定要持有股票才能卖，所以<code>dp[i][0] = dp[i - 1][1] + prices[i]</code>。</li>
<li>第<code>i</code>天什么也不做，不管是持有还是不持有股票，前<code>i</code>天的利润跟前<code>i - 1</code>天的利润一样，所以<code>dp[i][0] = dp[i - 1][0]，dp[i][1] = dp[i - 1][1]</code>。</li>
</ol>
<p>综合一下：<br><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code><br><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></p>
<h3 id="到了最后一天，应该取dp-n-1-0-还是dp-n-1-1-？"><a href="#到了最后一天，应该取dp-n-1-0-还是dp-n-1-1-？" class="headerlink" title="到了最后一天，应该取dp[n - 1][0]还是dp[n - 1][1]？**"></a>到了最后一天，应该取dp[n - 1][0]还是dp[n - 1][1]？**</h3><p>最后一天如果还持有股票，利润肯定要变小，肯定是不持有股票的时候收益最大，取<code>dp[n - 1][0]</code>。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p><code>dp[0][0] = 0</code>，第0天不持有股票利润就是0。<br><code>dp[0][1] = -prices[i]</code>，第0天持有股票只能买入，利润为负。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i][k]</code>只跟上一个状态有关，用变量记录上一个状态，不需要用数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.124.二叉树中的最大路径和（困难）</title>
    <url>/LeetCode/LeetCode.124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">LeetCode.124.二叉树中的最大路径和（困难）</a></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设找到了最大路径和的路径，观察这个路径的特点，可以发现路径必然会经过一个根节点，也就是从一个根节点向左和向右延伸可以到达整个路径。</p>
<h3 id="路径和怎么计算？"><a href="#路径和怎么计算？" class="headerlink" title="路径和怎么计算？"></a>路径和怎么计算？</h3><p>可以遍历每一个节点，计算当前节点左、右子树上的最大路径和，再与当前节点的值相加即可。</p>
<h3 id="计算路径和的注意事项"><a href="#计算路径和的注意事项" class="headerlink" title="计算路径和的注意事项"></a>计算路径和的注意事项</h3><p>这里要注意节点值可能是负数，所以左右子树的路径和可能是负的，越加越小，如果是负的肯定就不加了。</p>
<h3 id="左右子树最大路径和怎么求？"><a href="#左右子树最大路径和怎么求？" class="headerlink" title="左右子树最大路径和怎么求？"></a>左右子树最大路径和怎么求？</h3><p>对于某个节点x来说，若其左子树路径和为leftSum，右子树路径和为rightSum，对于x的父节点来说，只能选用leftSum和rightSum种较大的那个，再加上x的值，作为x的父节点的子树路径和。否则就路径就有分叉了，不满足题意。</p>
<h3 id="怎么求最大路径和？"><a href="#怎么求最大路径和？" class="headerlink" title="怎么求最大路径和？"></a>怎么求最大路径和？</h3><p>计算每个节点路径和时，记录最大的那个路径和的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var ti = TreeNode(5)</span></span><br><span class="line"><span class="comment"> * var v = ti.`val`</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var left: TreeNode? = null</span></span><br><span class="line"><span class="comment"> *     var right: TreeNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxSum = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">maxGain</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> leftSum = maxOf(<span class="number">0</span>, maxGain(root.left))</span><br><span class="line">            <span class="keyword">val</span> rightSum = maxOf(<span class="number">0</span>, maxGain(root.right))</span><br><span class="line">            <span class="keyword">val</span> currentPathSum = root.`<span class="keyword">val</span>` + leftSum + rightSum</span><br><span class="line">            maxSum = maxOf(maxSum, currentPathSum)</span><br><span class="line">            <span class="keyword">return</span> root.`<span class="keyword">val</span>` + maxOf(leftSum, rightSum)</span><br><span class="line">        &#125;</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.126.单词接龙 II（困难）</title>
    <url>/LeetCode/LeetCode.126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-ladder-ii/">LeetCode.126.单词接龙 II（困难）</a></p>
<p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</li>
<li>sk == endWord</li>
</ul>
<p>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>通过广度优先搜索建立图的邻接表。<ul>
<li>在发现最短转换路径时停止构建图。</li>
<li>有可能有多条最短路径，所以发现了一条最短路径时不要立刻终止，等这一层都遍历完。</li>
</ul>
</li>
<li>通过深度优先搜索，求得最短路径。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findLadders</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 单词列表转为哈希集合，便于快速查找</span></span><br><span class="line">        <span class="keyword">val</span> wordSet = wordList.toSet()</span><br><span class="line">        <span class="comment">// 单词列表中没有endWord直接返回，不用搜索了</span></span><br><span class="line">        <span class="keyword">if</span> (!wordSet.contains(endWord)) <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs建立图的邻接表</span></span><br><span class="line">        <span class="keyword">val</span> graph = mutableMapOf&lt;String, MutableSet&lt;String&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> found = bfs(beginWord, endWord, wordSet, graph)</span><br><span class="line">        <span class="keyword">if</span> (!found) <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs搜索</span></span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;List&lt;String&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> path = mutableListOf(beginWord)</span><br><span class="line">        dfs(beginWord, endWord, graph, path, result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;, graph: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, MutableSet&lt;String&gt;&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = java.util.ArrayDeque&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        queue.add(beginWord)</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> levelVisited = mutableSetOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> levelCount = queue.size</span><br><span class="line">            repeat(levelCount) &#123;</span><br><span class="line">                <span class="keyword">val</span> currentWord = queue.poll()</span><br><span class="line">                <span class="keyword">val</span> nextNodes = getNextLevelNodes(currentWord, wordSet)</span><br><span class="line">                <span class="keyword">for</span> (nextWord <span class="keyword">in</span> nextNodes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited.contains(nextWord)) <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> (nextWord == endWord) &#123;</span><br><span class="line">                        found = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(nextWord)</span><br><span class="line">                    levelVisited.add(nextWord)</span><br><span class="line"></span><br><span class="line">                    graph.getOrPut(currentWord, &#123; mutableSetOf() &#125;)</span><br><span class="line">                            .add(nextWord)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在某一层发现了路径终点，就直接不继续了，这样保证路径是最短的</span></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            visited.addAll(levelVisited)</span><br><span class="line">            levelVisited.clear()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, graph: <span class="type">Map</span>&lt;<span class="type">String</span>, Set&lt;String&gt;&gt;, path: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;, result: <span class="type">MutableList</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginWord == endWord) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(beginWord)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        graph[beginWord]?.forEach &#123; nextWord -&gt;</span><br><span class="line">            path.add(nextWord)</span><br><span class="line">            dfs(nextWord, endWord, graph, path, result)</span><br><span class="line">            path.removeAt(path.lastIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变化[word]每一个位置的字符，看是否存在于单词列表中，存在的话，记录为下一层的顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextLevelNodes</span><span class="params">(word: <span class="type">String</span>, wordSet: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>: Set&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> nodes = mutableSetOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> chars = word.toCharArray()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> chars.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> oldChar = chars[i]</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = <span class="string">&#x27;a&#x27;</span> + j</span><br><span class="line">                <span class="keyword">if</span> (c == oldChar) <span class="keyword">continue</span></span><br><span class="line">                chars[i] = c</span><br><span class="line">                <span class="keyword">val</span> next = String(chars)</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(next)) &#123;</span><br><span class="line">                    nodes.add(next)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[i] = oldChar</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>广度优先搜索</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.127.单词接龙（困难）</title>
    <url>/LeetCode/LeetCode.127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-ladder/">LeetCode.127.单词接龙（困难）</a></p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code>  和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p>
<ul>
<li>序列中第一个单词是 beginWord 。</li>
<li>序列中最后一个单词是 endWord 。</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典 wordList 中的单词。</li>
</ul>
<p>你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p>
<span id="more"></span>
<p>提示：</p>
<ul>
<li>1 &lt;= beginWord.length &lt;= 10</li>
<li>endWord.length == beginWord.length</li>
<li>1 &lt;= wordList.length &lt;= 5000</li>
<li>wordList[i].length == beginWord.length</li>
<li>beginWord、endWord 和 wordList[i] 由小写英文字母组成</li>
<li>beginWord != endWord</li>
<li>wordList 中的所有字符串 互不相同</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>有一个起点、一个终点，加上一系列路径的选择，就是搜索问题。</li>
<li>可以用深度优先搜索或广度优先搜索，每个单词就是图中一个结点。</li>
</ul>
<h3 id="用DFS还是BFS？为什么？"><a href="#用DFS还是BFS？为什么？" class="headerlink" title="用DFS还是BFS？为什么？"></a>用DFS还是BFS？为什么？</h3><ul>
<li>题目要求最短转换序列，也就是求最短路径，用广度优先搜索用时最短，发现到达终点就直接返回。</li>
<li>如果用深度有限搜索，遍历完所有路径还得回溯，会比较耗时。</li>
</ul>
<p>但是搜索需要有路径选择，这就引出了下一个问题。</p>
<h3 id="对于每一个单词，它的邻接单词有哪些？"><a href="#对于每一个单词，它的邻接单词有哪些？" class="headerlink" title="对于每一个单词，它的邻接单词有哪些？"></a>对于每一个单词，它的邻接单词有哪些？</h3><ul>
<li>每次转换单词只能改变一个字母，但是单词有n个字母，不知道转换哪个，那就所有的都尝试转换一遍，看能得到哪些单词。</li>
<li>可以提前存储好每个单词能转换到的单词，直接O(1)时间查询，可以用哈希表存储。</li>
<li>对于转换到的单词而言，他跟转换前的单词的区别也就是那一个字符不同，其他字符都相同，并且可能有多个能转换到的单词。<ul>
<li>我们可以用对要变化的位置上加上*再加上剩余字母作为哈希表的键，单词列表作为哈希表的值。</li>
<li>提前读取所有单词，做预处理。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ladderLength</span><span class="params">(beginWord: <span class="type">String</span>, endWord: <span class="type">String</span>, wordList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 所有单词长度一致</span></span><br><span class="line">        <span class="keyword">val</span> wordLength = beginWord.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key是通配词，value是这个通配词对应的所有词</span></span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()</span><br><span class="line">        wordList.forEach &#123; word -&gt;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until wordLength) &#123;</span><br><span class="line">                <span class="keyword">val</span> key = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, wordLength)</span><br><span class="line">                <span class="keyword">val</span> list = map.getOrDefault(key, mutableListOf())</span><br><span class="line">                list.add(word)</span><br><span class="line">                map[key] = list</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问数组，防止绕环</span></span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">val</span> queue = ArrayDeque&lt;String&gt;()</span><br><span class="line">        queue.add(beginWord)</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> emptyList = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> count = queue.size</span><br><span class="line">            repeat(count) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = queue.poll()</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until wordLength) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, wordLength)</span><br><span class="line">                    <span class="keyword">val</span> adjacentWords = map.getOrDefault(key, emptyList)</span><br><span class="line">                    adjacentWords.forEach &#123; adjacentWord -&gt;</span><br><span class="line">                        <span class="comment">// 加1是因为endWord也算一个步骤，要加上</span></span><br><span class="line">                        <span class="keyword">if</span> (adjacentWord == endWord) <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(adjacentWord)) &#123;</span><br><span class="line">                            visited.add(adjacentWord)</span><br><span class="line">                            queue.add(adjacentWord)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1277.统计全为 1 的正方形子矩阵（中等）</title>
    <url>/LeetCode/LeetCode.1277.%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">LeetCode.1277.统计全为 1 的正方形子矩阵（中等）</a></p>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是  <code>0</code>  就是  <code>1</code>，请你统计并返回其中完全由  <code>1</code>  组成的  <strong>正方形</strong>  子矩阵的个数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p><code>side</code>数组每一项累加，就是所有能用1组成的正方形的个数。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countSquares</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        count += side[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    count += side[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化后代码（kotlin）"><a href="#优化后代码（kotlin）" class="headerlink" title="优化后代码（kotlin）"></a>优化后代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countSquares</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            count += side[j]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储上一行状态，以便接下来读取左上方状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                side[j] = <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// side[j]: 上方状态</span></span><br><span class="line">                    <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">                    <span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> </span><br><span class="line">                    <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j], side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>])</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                count += side[j]</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1314.矩阵区域和（中等）</title>
    <url>/LeetCode/LeetCode.1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a></p>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p>
<ul>
<li>i - k &lt;= r &lt;= i + k,</li>
<li>j - k &lt;= c &lt;= j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
<span id="more"></span>

<p>提示：</p>
<blockquote>
<p>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, k &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力解法需要O($n^4$)时间复杂度，考虑时间更优化的算法。</p>
<h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>题目要求解区域和是二维的，可以简化问题，先看看一维数组某一区间的元素和怎么求，因为二维的区域相当于一维的叠加。</p>
<h3 id="一维数组某区间内元素和怎么快速求解？"><a href="#一维数组某区间内元素和怎么快速求解？" class="headerlink" title="一维数组某区间内元素和怎么快速求解？"></a>一维数组某区间内元素和怎么快速求解？</h3><p>可以预先计算和存储每个位置的前缀和（第0个到第i个元素之间所有元素的和），要计算某个区间的和，用区间端点的前缀和相减就可以在O(1)时间复杂度内求解，但需要占用O(n)空间。</p>
<p>考虑用二维前缀和快速求解面积问题。</p>
<h3 id="二维前缀和定义"><a href="#二维前缀和定义" class="headerlink" title="二维前缀和定义"></a>二维前缀和定义</h3><p>第0行第0列到第r行第c列形成的矩形区域内所有元素的和。<br>记为<code>preSum[r][c]</code>。</p>
<h3 id="怎么利用二维前缀和求解区域面积？"><a href="#怎么利用二维前缀和求解区域面积？" class="headerlink" title="怎么利用二维前缀和求解区域面积？"></a>怎么利用二维前缀和求解区域面积？</h3><p>比如要求区域d的元素和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列：                  </span><br><span class="line">0   a a a b b b b b   </span><br><span class="line">1   a a a b b b b b</span><br><span class="line">2   c c c d d d d d</span><br><span class="line">3   c c c d d d d d</span><br><span class="line">4   c c c d d d d d</span><br><span class="line">行： 0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>公式表达：<br><code>区域d所有元素和 = preSum[7,4] - preSum[2, 4] - preSum[7, 1] + preSum[2, 1]</code><br><code>preSum[7,4]</code>：整个区域所有元素和<br><code>preSum[2, 4]</code>：区域a + 区域c<br><code>preSum[7, 1]</code>：区域a + 区域b<br><code>preSum[2, 1]</code>：区域a</p>
<h3 id="二维前缀和怎么推导？"><a href="#二维前缀和怎么推导？" class="headerlink" title="二维前缀和怎么推导？"></a>二维前缀和怎么推导？</h3><ul>
<li>第一行和第一列前缀和不用推导，左边和上边都没有元素，直接等于元素本身。</li>
<li>第一行上方没有元素，当作一维前缀和求解。</li>
<li>第一列和第一行情况相同，方向变了一下，还是当作一维前缀和求解。</li>
<li>非第一行和非第一列位置的前缀和，跟求解区域和类似，前缀和 = 上方二维前缀和 + 左方二维前缀和 - 左上方二维前缀和 + 本元素值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">matrixBlockSum</span><span class="params">(mat: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, k: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> m = mat.size</span><br><span class="line">        <span class="keyword">val</span> n = mat[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> answer = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) preSum[r][<span class="number">0</span>] = mat[r][<span class="number">0</span>] + preSum[r - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) preSum[<span class="number">0</span>][c] = mat[<span class="number">0</span>][c] + preSum[<span class="number">0</span>][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                preSum[r][c] = mat[r][c] + preSum[r - <span class="number">1</span>][c] + preSum[r][c - <span class="number">1</span>] - preSum[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解区域和</span></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> leftTopX = maxOf(r - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> leftTopY = maxOf(c - k, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomX = minOf(r + k, m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> rightBottomY = minOf(c + k, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> wholeArea = preSum[rightBottomX][rightBottomY]</span><br><span class="line">                <span class="keyword">val</span> leftArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][rightBottomY] </span><br><span class="line">                <span class="keyword">val</span> topArea = <span class="keyword">if</span> (leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[rightBottomX][leftTopY - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> leftTopArea = <span class="keyword">if</span> (leftTopX == <span class="number">0</span> || leftTopY == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[leftTopX - <span class="number">1</span>][leftTopY - <span class="number">1</span>]</span><br><span class="line">                answer[r][c] = wholeArea - leftArea - topArea + leftTopArea</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.132.分割回文串 II（困难）</title>
    <url>/LeetCode/LeetCode.132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">LeetCode.132.分割回文串 II（困难）</a></p>
<p>给你一个字符串  <code>s</code>，请你将  <code>s</code>  分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的  <strong>最少分割次数</strong>  。</p>
<span id="more"></span>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 2000</code></li>
<li>  <code>s</code>  仅由小写英文字母组成</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="拆解问题"><a href="#拆解问题" class="headerlink" title="拆解问题"></a>拆解问题</h3><p>如果已经求得一个子串的最少分割次数，是可以推导出整个串的最少分割次数。</p>
<ul>
<li>要保证分割次数最少，先检查整个串s是不是回文。<ul>
<li>如果是，就不用分割了，分割次数是0。</li>
<li>如果s不是回文，需要在0到<code>n - 1</code>（n为s长度）中找一个分割位置<code>i</code>。<ul>
<li>如果<code>s[0: i]</code>的最少分割次数已经知道<code>（0 &lt;= i &lt; n）</code>，同时<code>s[i + 1:]</code>是回文，说明在<code>s[0: i]</code>的最少分割次数基础上还要再多分割一次才能完成整个串的分割，那么整个字符串s的最少分割次数就是<code>s[0: i]</code>的最少分割次数 + 1。</li>
<li>而<code>s[0: i]</code>的最少分割次数其实是需要把<code>i</code>从0到<code>n - 2</code>全部遍历一遍才知道哪一种分割的次数是最小的，那么<code>s[0: i]</code>的最少分割次数的求法，跟上述过程一样，可以递推。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：s[0: i]是python中截取子串的表示方法，表示截取第0位到第i位的字符)</p>
</blockquote>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>令<code>dp[i]</code>表示<code>s[0: i]</code>的最少分割次数。</p>
<p>如果<code>s[0: i]</code>就是回文，那么<code>dp[i]</code>就是0。<br>如果<code>s[0: i]</code>不是回文，但是它的一个子串<code>s[0: j]</code>的最少分割次数已知(<code>0 &lt;= j &lt; i</code>)，并且<code>s[j + 1: i]</code>是回文，则 <code>dp[i] = dp[j] + 1</code> </p>
<p>最终结果就是求<code>dp[n - 1]</code>，从0开始递推就好了。</p>
<p>递推方程： <code>dp[i] = min(dp[j]) + 1</code>，其中<code>0 &lt;= j &lt; i</code>。</p>
<h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><ul>
<li>初始状态<code>dp[0]</code>就是<code>s[0: 0]</code>的最少分割次数，<code>s[0: 0]</code>就是首字符，单个字符是回文串，所以不用分割，<code>dp[0] = 0</code>。</li>
<li>最坏的情况就是每个字符都分割，因为每个单字符都是回文，最大的分割次数就是<code>n - 1</code>，可以给<code>dp</code>数组初始化。</li>
</ul>
<h3 id="怎么快速判断s-i-j-是回文？"><a href="#怎么快速判断s-i-j-是回文？" class="headerlink" title="怎么快速判断s[i, j]是回文？"></a>怎么快速判断s[i, j]是回文？</h3><p>最好预处理整个s，把s的所有子串都判断一下是不是回文串，这样就可以做到O(1)的查表操作来快速判断了。</p>
<p>这里跟 <a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a> 处理方式一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCut</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n)</span><br><span class="line">        <span class="comment">// s[0: i]的子串最大分割次数，就是每个字符都分割一下，分割i次（1 &lt;= i &lt; n）</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            dp[i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 判断s[0:i]是不是回文</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, i)) &#123;</span><br><span class="line">                <span class="comment">// s[0:i]是回文，不用分割，最少分割次数是0</span></span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s[0:i]不是回文，需要在[0,i)之间找到一个分割位置j，使得s[j+1:i]是回文，同时dp[j]最小</span></span><br><span class="line">            <span class="comment">// 需要从0开始遍历到i-1去寻找出最小的分割位置j</span></span><br><span class="line">            <span class="comment">// 这样也才能利用递推，利用之前存储过的状态，因为是从索引0开始递推的</span></span><br><span class="line">            <span class="keyword">var</span> minCut = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(s, j + <span class="number">1</span>, i)) &#123;</span><br><span class="line">                    <span class="comment">// s[j+1:i]是回文，dp[j]+1是dp[i]可能的一个取值，需要找一个最小的</span></span><br><span class="line">                    minCut = minOf(minCut, dp[j] + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// s[j+1:i]不是回文，当前的分割是无效的，就看下一个分割了，忽略当前的分割</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s[0:i]最大的分割次数，就是i次了，在前面已经初始化过了</span></span><br><span class="line">            <span class="comment">// 如果s[0:i]存在更少的分割，更新dp[i]的值</span></span><br><span class="line">            <span class="keyword">if</span> (minCut != <span class="built_in">Int</span>.MAX_VALUE) &#123;</span><br><span class="line">                dp[i] = minCut</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dpStates: Array&lt;Array&lt;<span class="built_in">Boolean</span>&gt;&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串[s]索引从[start]到[end]的子串是否是回文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isPalindrome</span><span class="params">(s: <span class="type">String</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> states = dpStates ?: getPalindromeStates(s)</span><br><span class="line">        dpStates = states</span><br><span class="line">        <span class="keyword">return</span> states[start][end]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPalindromeStates</span><span class="params">(s: <span class="type">String</span>)</span></span>: Array&lt;Array&lt;<span class="built_in">Boolean</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(n) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="comment">// 遍历所有长度的子串，length代表子串的长度，可以从1一直取值到n</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 把所有是长度为length的子串都检查一遍，看是不是回文，start就要从0开始取值，一直取到n-length</span></span><br><span class="line">            <span class="comment">// start 是应该小于 n-length 还是小于等于?</span></span><br><span class="line">            <span class="comment">// 可以举例n为5，length为2，直观上看最后一个length为2的子串应该是s[3:4]，start为3，是n-length的结果</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.(n - length)) &#123;</span><br><span class="line">                <span class="comment">// end和start之间保持相距length</span></span><br><span class="line">                <span class="keyword">val</span> end = start + length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (start + <span class="number">1</span> &lt;= end - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>] &amp;&amp; s[start] == s[end]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = s[start] == s[end]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n^2)</p>
<p>n 是字符串 s 的长度。<br>预处理计算s所有子串是否是回文和动态规划计算s最小分割次数的时间复杂度均为 O(n^2)。</p>
<p>空间复杂度：O(n^2)</p>
<p>预处理计算s所有子串是否是回文需要O(n^2)的空间占用。<br>动态规划计算s最小分割次数需要O(n)的空间占用。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.135.分发糖果（困难）</title>
    <url>/LeetCode/LeetCode.135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/candy/">LeetCode.135.分发糖果（困难）</a></p>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>难点在于<code>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</code></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>化繁为简，这里可以拆解为两个规则：</p>
<ul>
<li>左规则：当 <code>ratings[i − 1] &lt; ratings[i]</code> 时，第<code>i</code> 个学生的糖果数量比第<code>i − 1</code>个孩子的糖果数量多。</li>
<li>右规则：当 <code>ratings[i] &gt; ratings[i + 1]</code> 时，第<code>i</code> 个学生的糖果数量比第<code>i + 1</code>个孩子的糖果数量多。</li>
</ul>
<h3 id="如何求解？"><a href="#如何求解？" class="headerlink" title="如何求解？"></a>如何求解？</h3><ul>
<li>先从左到右遍历评分数组，按左规则分配糖果。</li>
<li>再从右到左遍历评分数组，按右规则分配糖果。</li>
<li>最后同时满足左右规则的糖果数量就是最终结果，也就是取两者较大值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> left = IntArray(ratings.size) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> right = IntArray(ratings.size) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                right[i - <span class="number">1</span>] = right[i] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.indices) &#123;</span><br><span class="line">            sum += maxOf(left[i], right[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n)，n 是孩子的数量，要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。</li>
<li>空间复杂度：O(n)，要保存所有的左、右规则对应的糖果数量。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>之前的解法已经把思路打开了，可以从左到右遍历分析看看能不能不占用额外空间就可以求解。</p>
<p>孩子的分数的排列无非是递增、递减、相等三种情况。</p>
<p>从左向右看：</p>
<ul>
<li><strong>如果孩子分数相等</strong>，就分配1个糖果。</li>
<li><strong>如果孩子处于分数递增的序列中</strong>，可以发现糖果数量从左到右看是会从1开始递增，这样糖果分配数量才最少。</li>
<li><strong>如果孩子处于分数递减的序列中</strong>，可以发现糖果数量从左到右看是会递减到1，这样糖果分配数量才最少。<ul>
<li>如果从分配到1个糖果的孩子从右到左看，糖果数量是会递增到递减序列的开始位置。</li>
<li>所以统计递减序列应该分配多少糖果，只要统计递减序列有多长，看做跟递增情况分配形式一样就行了。</li>
</ul>
</li>
</ul>
<p><strong>递减序列的起点在哪？</strong><br><code>rating[i] &lt; rating[i - 1] &amp;&amp; rating[i - 1] &gt; rating[i - 2]</code>时，<code>i</code>就是递减序列的起点。</p>
<p><strong>边界情况</strong></p>
<p>由于递增序列最后一个元素也可以算是递减序列的一个元素，所以它是受右规则约束的。</p>
<p>比如递增序列有3个元素，递减序列有8个元素，那么递增序列的第3个元素在递增遍历时分配了3个糖果，但最后实际应当分配9个糖果。这多的6个糖果应该怎么算进去？</p>
<p>可以发现如果递增序列和递减序列一样长：</p>
<ul>
<li>递增序列最后一个孩子和递减序列第一个孩子分配的糖果数量是一样的。</li>
<li>这两个孩子的分数可能不一样。</li>
</ul>
<p>这样的话要给递增序列最后一个孩子或递减序列第一个孩子多分配1个糖果的，才能满足左规则和右规则。</p>
<ul>
<li>如果递减序列比递增序列长1，就只能给递增序列最后一个孩子多分配2个糖果。</li>
<li>如果递减序列比递增序列长2，就只能给递增序列最后一个孩子多分配3个糖果。</li>
<li>如果递减序列比递增序列长3，就只能给递增序列最后一个孩子多分配4个糖果。</li>
</ul>
<p>所以：如果递减序列比递增序列长x，就只能给递增序列最后一个孩子多分配x + 1个糖果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = ratings.size</span><br><span class="line">        <span class="comment">// 上一个孩子的糖果数，第一个孩子默认分配1个糖果</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 糖果数量，第一个孩子默认分配1个糖果</span></span><br><span class="line">        <span class="keyword">var</span> candies = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 递增序列长度，已经有一个孩子分配了糖果</span></span><br><span class="line">        <span class="keyword">var</span> inc = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 递减序列长度</span></span><br><span class="line">        <span class="keyword">var</span> dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                ratings[i] == ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 分数持平，分配最少的糖果</span></span><br><span class="line">                    candies += <span class="number">1</span></span><br><span class="line">                    pre = <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 递增序列的开始，算递增序列第1个元素</span></span><br><span class="line">                    inc = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 糖果数为1时，递减序列还没开始或者刚结束</span></span><br><span class="line">                    dec = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                ratings[i] &gt; ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 分数递增，比前一个孩子多分配一个糖果</span></span><br><span class="line">                    <span class="keyword">val</span> cur = pre + <span class="number">1</span></span><br><span class="line">                    candies += cur</span><br><span class="line">                    pre = cur</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 递增序列长度在增加</span></span><br><span class="line">                    inc = cur</span><br><span class="line">                    <span class="comment">// 递减序列还没开始</span></span><br><span class="line">                    dec = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                ratings[i] &lt; ratings[i - <span class="number">1</span>] -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 递减序列长度累加</span></span><br><span class="line">                    dec++</span><br><span class="line">                    <span class="comment">// 给递增序列最后一个孩子多分配 `递减序列长度 - 递增序列长度` 个糖果</span></span><br><span class="line">                    <span class="keyword">if</span> (inc == dec) dec++</span><br><span class="line">                    <span class="comment">// 把递减序列当做递增序列看，最终分配形式是一样的</span></span><br><span class="line">                    candies += dec</span><br><span class="line">                    <span class="comment">// 糖果数量递减到1时，要记录下来</span></span><br><span class="line">                    pre = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n)，遍历一次数组。</li>
<li>空间复杂度：O(1)，仅适用常数个变量。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.139.单词拆分（中等）</title>
    <url>/LeetCode/LeetCode.139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h3><p>提到拆分，我们可以考虑能不能把大问题拆分为子问题+有限步骤，给问题建模，简化讨论。</p>
<ol>
<li>如果s可以被拆分，那么至少s的末尾字符组成的单词肯定是在wordDict中的。<ul>
<li>s的末尾字符组成的单词，可以从s的末尾位置开始，依次穷举取长度为1、2、3……n的子字符串，看子字符串是否在wordDict中。</li>
<li>接下来再去看剩下的前半部分的子字符串能不能继续拆分成功。</li>
</ul>
</li>
<li>如果s不能被拆分，有两种情况:<ol>
<li>穷举s所有末尾子字符串，是没有一个子字符串是在wordDict中的。</li>
<li>末尾有一部分子字符串组成的单词在wordDict中，最后s剩下前半段的子字符串不能被wordDict拆分。</li>
</ol>
</li>
</ol>
<p>这里已经划分出了子问题+有限步骤，可以用递归来解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 如果字符串能拆完，最后索引肯定为-1</span></span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 在字符串s[0,end]中，从末尾依次取长度为1、2、3……end+1的子字符串，检查子字符串是否在wordDict里</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 截取末尾字符串</span></span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 末尾字符串在wordDict里</span></span><br><span class="line">                <span class="comment">// 剩下的前半段子字符串s[0,start - 1]有可能可以被继续拆分，也有可能不可以被拆分，不知道能不能就只能每个情况都试一下</span></span><br><span class="line">                <span class="comment">// 所以这里不是直接return，而是要试一下每一种的单词拆分，看哪一种行的通</span></span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    <span class="comment">// end指向剩下的前半部分子字符串末尾</span></span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试拆分s[0, n - 1]</span></span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：记忆化递归"><a href="#解法2：记忆化递归" class="headerlink" title="解法2：记忆化递归"></a>解法2：记忆化递归</h3><p>递归的问题在于有重叠子问题，有很多重复计算耗时，保存一下中间计算结果就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(s.length) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">canBreak</span><span class="params">(end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (memo[end] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">if</span> (memo[end] == <span class="number">1</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> end downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> tailString = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(tailString)) &#123;</span><br><span class="line">                    result = canBreak(start - <span class="number">1</span>) || result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[end] = <span class="keyword">if</span> (result) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canBreak(s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法3：自下而上递推式动态规划"><a href="#解法3：自下而上递推式动态规划" class="headerlink" title="解法3：自下而上递推式动态规划"></a>解法3：自下而上递推式动态规划</h3><p>能用记忆化递归的，也可以用自下而上递推的方式做。</p>
<p>设<code>dp[end]</code>为第0个到第end个字符组成的字符串是否可以被wordDict中的单词拆分。<br>穷举所有<code>s[0, end]</code>的末尾字符串，判断能否拆分。<br>设<code>s[0, end]</code>的末尾字符串的开始索引为<code>start</code>，<code>0 &lt;= start &lt;= end</code>。</p>
<p><strong>状态转移方程</strong><br><code>dp[end] = dp[start - 1] &amp;&amp; s[start, end] in wordDict</code></p>
<p><code>start==0</code> 时，截取的是整个字符串，直接判断整个字符串是否在wordDict里就行了，<code>dp[0] = s[start, end] in wordDict</code>。</p>
<p>由于计算新的状态需要读取之前的每个最优化的状态，所以空间无法优化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> dp = BooleanArray(n) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (end <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (start <span class="keyword">in</span> <span class="number">0.</span>.end) &#123;</span><br><span class="line">                <span class="keyword">val</span> word = s.substring(start, end + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[start - <span class="number">1</span>] &amp;&amp; word <span class="keyword">in</span> wordDict) &#123;</span><br><span class="line">                        dp[end] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.140.单词拆分 II（困难）</title>
    <url>/LeetCode/LeetCode.140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-break-ii/">LeetCode.140.单词拆分 II（困难）</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<span id="more"></span>

<p>说明：</p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果知道<code>s</code>的末尾的字符组成的单词处在wordDict中，并且前面的子串也是可以被wordDict拆分，就可以把末尾的单词添加到句子中。</p>
<ul>
<li><code>s</code>的末尾字符能不能组成wordDict中的单词，可以从末尾索引开始往前遍历一个个的试。</li>
<li>前面的子串是否可以被wordDict拆分，需要提前计算好，这里就借用 <a href="https://leetcode-cn.com/problems/word-break/">LeetCode.139.单词拆分（中等）</a>中的状态表，即<code>dp[i]</code>：<code>s</code>的前<code>i</code>个字符组成的子串能否拆分成<code>wordDict</code>中的若干个单词。</li>
</ul>
<p>用深度优先搜索递归试一遍就行，直到把<code>s</code>拆分完，结束搜索。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wordBreak</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = wordDict.toHashSet()</span><br><span class="line">        <span class="keyword">val</span> dp = getDpState(s, <span class="keyword">set</span>)</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        dfs(s, <span class="keyword">set</span>, s.length, result, dp, Stack())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个一维数组，第i位表示，[s]的前i个字符组成的子串拆分成[wordDict]中的若干个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDpState</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>: Array&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> state = Array(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125;</span><br><span class="line">        state[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">val</span> s2 = s.substring(j, i)</span><br><span class="line">                <span class="keyword">if</span> (state[j] &amp;&amp; wordDict.contains(s2)) &#123;</span><br><span class="line">                    state[i] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>, wordDict: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;, end: <span class="type">Int</span>, result: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;, dp: <span class="type">Array</span>&lt;<span class="type">Boolean</span>&gt;, path: <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// s[0:end-1]是否是单词，是的话，应当添加到路径中，同时是也是路径的终点，即递归树的叶子节点</span></span><br><span class="line">        <span class="keyword">val</span> prefix = s.substring(<span class="number">0</span>, end)</span><br><span class="line">        <span class="keyword">if</span> (wordDict.contains(prefix)) &#123;</span><br><span class="line">            path.push(prefix)</span><br><span class="line">            result.add(path.reversed().joinToString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            path.pop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检索所有子串的拆分的可能组合</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.end) &#123;</span><br><span class="line">            <span class="comment">// 前i个字符组成的左子串是可以被拆分为若干个单词的</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i]) &#123;</span><br><span class="line">                <span class="comment">// 就看右子串是否是单词</span></span><br><span class="line">                <span class="keyword">val</span> substring = s.substring(i, end)</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(substring)) &#123;</span><br><span class="line">                    <span class="comment">// 右子串是一个单词，应当添加到路径中</span></span><br><span class="line">                    path.push(substring)</span><br><span class="line">                    <span class="comment">// 继续探寻左子串s[0:i-1]</span></span><br><span class="line">                    dfs(s, wordDict, i, result, dp, path)</span><br><span class="line">                    <span class="comment">// 左子串探寻完了，从路径中移除当前单词，以不影响寻找下一个组合的单词路径</span></span><br><span class="line">                    path.pop()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.149.直线上最多的点数（困难）</title>
    <url>/LeetCode/LeetCode.149.%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">LeetCode.149.直线上最多的点数（困难）</a></p>
<p>给你一个数组  <code>points</code>  ，其中  <code>points[i] = [xi, yi]</code>  表示  <strong>X-Y</strong>  平面上的一个点。求最多有多少个点在同一条直线上。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力法梳理出整体框架，剩下细节问题和边界问题再填充。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>穷举所有可能形成的直线。</li>
<li>统计有多少点在这一条直线上。</li>
<li>记录最大的点数。</li>
</ul>
<h3 id="如何确定一个点是否在一条直线上？"><a href="#如何确定一个点是否在一条直线上？" class="headerlink" title="如何确定一个点是否在一条直线上？"></a>如何确定一个点是否在一条直线上？</h3><p>已知点<code>(x1, y1)</code>和<code>(x2, y2)</code>确定的一条直线L。</p>
<p>判断点<code>(x, y)</code>是否在直线L上，可以判断点<code>(x1, y1)</code>和点<code>(x, y)</code>组成的直线的斜率是否与直线L的斜率相等。</p>
<p>换成数学表达式即判断 <code>(y2 - y1) / (x2 - x1) == (y - y1) / (x - x1)</code>。<br>其中两点不能是同一个点，<code>x1</code>不等于<code>x</code>。</p>
<h3 id="斜率计算是浮点数，比较判断不准确怎么办？"><a href="#斜率计算是浮点数，比较判断不准确怎么办？" class="headerlink" title="斜率计算是浮点数，比较判断不准确怎么办？"></a>斜率计算是浮点数，比较判断不准确怎么办？</h3><ul>
<li>由于计算机除法存在数学精度问题，需要把上述表达式的比较，转换为对分子和分母分别比较。</li>
<li>比较之前需要将分子分母约分到最简，进而就要求分子和父母的最大公约数。</li>
<li>可使用辗转相除法来求最大公约数，约分分子、分母到最简。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxPoints</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">// 一个点和两个点都是在同一个直线上</span></span><br><span class="line">        <span class="keyword">if</span> (points.size &lt; <span class="number">3</span>) <span class="keyword">return</span> points.size</span><br><span class="line">        <span class="comment">// 所有的点都是同一个点，表示所有的点都在同一条直线上</span></span><br><span class="line">        <span class="keyword">if</span> (points.distinctBy &#123; <span class="string">&quot;<span class="subst">$&#123;it[<span class="number">0</span>]&#125;</span>,<span class="subst">$&#123;it[<span class="number">1</span>]&#125;</span>&quot;</span> &#125;.size == <span class="number">1</span>) <span class="keyword">return</span> points.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = points.size</span><br><span class="line">        <span class="keyword">var</span> maxPoints = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> x1 = points[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> y1 = points[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> x2 = points[j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">val</span> y2 = points[j][<span class="number">1</span>]</span><br><span class="line">                <span class="comment">// 同一个点确立不了直线，直接跳过，之后再确立了直线的情况，会考察到跳过的这个点</span></span><br><span class="line">                <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">// (x1,y1)和(x2,y2)确立一条直线</span></span><br><span class="line">                <span class="keyword">val</span> line = Line(x1, y1, x2, y2)</span><br><span class="line">                <span class="comment">// 统计所有其他的点，是否在这条线上</span></span><br><span class="line">                <span class="keyword">var</span> tmpMax = <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == i || k == j) <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">val</span> x3 = points[k][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">val</span> y3 = points[k][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> (line.isOnTheLine(x3, y3)) &#123;</span><br><span class="line">                        <span class="comment">// 发现有一个点在线上，计数</span></span><br><span class="line">                        tmpMax++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpMax &gt; maxPoints) &#123;</span><br><span class="line">                    maxPoints = tmpMax</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPoints</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点([x1],[y1])和点([x2],[y2])确定一条直线</span></span><br><span class="line"><span class="comment">     * 直线的斜率为(y2-y1)/(x2-x1)</span></span><br><span class="line"><span class="comment">     * 限制条件：两点不能是同一个点，同时x1不等于x2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>(</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> x1: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> y1: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> x2: <span class="built_in">Int</span>,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> y2: <span class="built_in">Int</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 点([x],[y])是否在同一直线上</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 可判断点([x1],[y1])和点([x],[y])组成的直线斜率是否之前的直线相等</span></span><br><span class="line"><span class="comment">         * 换成数学表达式即 (y2-y1)/(x2-x1) == (y-y1)/(x-x1)</span></span><br><span class="line"><span class="comment">         * 其中两点不能是同一个点，x1不等于x</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 由于存在数学精度问题，需要把上述表达式的比较，转换为对分子和分母分别比较，比较之前需要将分子分母约分到最简</span></span><br><span class="line"><span class="comment">         * 进而就要求分子和父母的最大公约数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">isOnTheLine</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == x1 &amp;&amp; y == y1 || x == x2 &amp;&amp; y == y2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> d1 = greatestCommonDivisor(y2 - y1, x2 - x1)</span><br><span class="line">            <span class="keyword">val</span> d2 = greatestCommonDivisor(y - y1, x - x1)</span><br><span class="line">            <span class="keyword">val</span> isSameNumerator = (y2 - y1) / d1 == (y - y1) / d2</span><br><span class="line">            <span class="keyword">val</span> isSameDenominator = (x2 - x1) / d1 == (x - x1) / d2</span><br><span class="line">            <span class="keyword">return</span> isSameNumerator &amp;&amp; isSameDenominator</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 求[a]和[b]的最大公约数</span></span><br><span class="line"><span class="comment">         * 使用辗转相除法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">greatestCommonDivisor</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a</span><br><span class="line">            <span class="keyword">var</span> big = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">var</span> small = <span class="keyword">if</span> (a &lt; b) a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">while</span> (small != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> remainder = big % small</span><br><span class="line">                big = small</span><br><span class="line">                small = remainder</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> big</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n^3)</code></li>
<li>空间复杂度<code>O(1)</code></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.152.乘积最大子数组（中等）</title>
    <url>/LeetCode/LeetCode.152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode.152.乘积最大子数组（中等）</a></p>
<p>给你一个整数数组  <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。</p>
<p>为了方便描述，设<code>maxProduct[i]</code>为以<code>nums[i]</code>结尾的子数组的最大乘积。</p>
<p>求<code>maxProduct[i]</code>，<code>nums[i]</code>肯定少不了，因为子数组最少需要一个元素。</p>
<h3 id="求maxProduct-i-有哪些可能的组合情况？"><a href="#求maxProduct-i-有哪些可能的组合情况？" class="headerlink" title="求maxProduct[i]有哪些可能的组合情况？"></a>求maxProduct[i]有哪些可能的组合情况？</h3><ol>
<li><code>nums[i]</code>自己单独成为一个子数组。<br>比如前面子数组乘积是0，<code>nums[i]</code>为正数，就没必要跟前面相乘了。但是<code>nums[i]</code>可能会比前面子数组乘积要小，所以要看看其他情况。</li>
<li><code>nums[i]</code>跟前面的子数组的乘积相乘。<br>接下来就是看怎么跟<code>nums[i]</code>相乘可以得到尽可能大的乘积。</li>
</ol>
<h3 id="有哪些乘法情况可以使乘积变大？"><a href="#有哪些乘法情况可以使乘积变大？" class="headerlink" title="有哪些乘法情况可以使乘积变大？"></a>有哪些乘法情况可以使乘积变大？</h3><ol>
<li>正数 * 正数</li>
<li>负数 * 负数</li>
</ol>
<p>也就是说求<code>maxProduct[i]</code>要记录<code>nums[i]</code>前面的子数组的最大乘积和最小乘积。</p>
<h3 id="穷举求maxProduct-i-要考虑的情况"><a href="#穷举求maxProduct-i-要考虑的情况" class="headerlink" title="穷举求maxProduct[i]要考虑的情况"></a>穷举求maxProduct[i]要考虑的情况</h3><ol>
<li><code>nums[i]</code>单独成为一个子数组</li>
<li><code>nums[i]</code>乘以i前面的子数组最大的乘积</li>
<li><code>nums[i]</code>乘以i前面的子数组最小的乘积</li>
</ol>
<p>求<code>maxProduct[i]</code>就是取三者最大值</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>maxProduct[i] = max(nums[i],  nums[i] * maxProduct[i - 1], nums[i] * minProduct[i - 1])</code></p>
<h3 id="怎么求以nums-i-结尾的连续子数组的最小乘积？"><a href="#怎么求以nums-i-结尾的连续子数组的最小乘积？" class="headerlink" title="怎么求以nums[i]结尾的连续子数组的最小乘积？"></a>怎么求以nums[i]结尾的连续子数组的最小乘积？</h3><p>跟考虑求最大乘积思路一样。<br>使乘积变得更小的方式就是正数和负数相乘。<br><code>nums[i]</code>可能为正也可能为负，所以<code>minProduct[i]</code>的求解也是有<code>maxProduct[i]</code>的那三种情况，只不过是求最小值。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p><code>maxProduct[0]</code>就是<code>nums[i]</code>本身，因为以<code>nums[0]</code>为结尾的子数组就是<code>nums[0]</code>本身构成的一个元素的子数组。<br>同理，<code>minProduct[0]</code>也是<code>nums[i]</code>。</p>
<p>递推要从<code>i = 1</code>开始。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>当前状态只跟上一步状态有关，所以不需要用数组存储所有状态，用几个变量记录上一步状态即可。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProduct</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> minProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> maxProduct = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> result = maxProduct</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> num = nums[i]</span><br><span class="line">            <span class="keyword">val</span> newMaxProduct = maxOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            minProduct = minOf(num, num * maxProduct, num * minProduct)</span><br><span class="line">            maxProduct = newMaxProduct</span><br><span class="line">            result = maxOf(result, maxProduct)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.154.寻找旋转排序数组中的最小值 II（困难）</title>
    <url>/LeetCode/LeetCode.154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode.154.寻找旋转排序数组中的最小值 II（困难）</a></p>
<span id="more"></span>

<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</li>
<li>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]</li>
</ul>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>提示：</p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p>进阶：</p>
<ul>
<li>这道题是 寻找旋转排序数组中的最小值 的延伸题目。</li>
<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过模拟可知，多次旋转后得到还是跟一次旋转一样的效果。</p>
<p>旋转一次后，数组可以分为左右两个子数组<code>nums1</code>和<code>nums2</code>，其中：</p>
<ul>
<li><code>nums1</code>和<code>nums2</code>本身都有序。</li>
<li><code>nums1中所有元素 &gt;= nums2中所有元素</code>。<ul>
<li><code>nums1</code>的首元素可能与<code>nums2</code>尾元素相等。</li>
</ul>
</li>
</ul>
<p><strong>最小的数字</strong>是<code>nums2</code>的第一个元素。</p>
<p>二分查找的时候，只要知道<code>nums[mid]</code>是位于<code>nums1</code>还是<code>nums2</code>中，就知道下一步应该往哪去缩减寻找范围。</p>
<h3 id="怎么知道nums-mid-是不是位于nums1？"><a href="#怎么知道nums-mid-是不是位于nums1？" class="headerlink" title="怎么知道nums[mid]是不是位于nums1？"></a>怎么知道nums[mid]是不是位于<code>nums1</code>？</h3><p><code>nums[mid] &gt; nums[0]</code>时，<code>nums[mid]</code>一定位于<code>nums1</code>。</p>
<h3 id="nums-mid-位于nums1，接下来往哪找最小的数？"><a href="#nums-mid-位于nums1，接下来往哪找最小的数？" class="headerlink" title="nums[mid]位于nums1，接下来往哪找最小的数？"></a>nums[mid]位于nums1，接下来往哪找最小的数？</h3><p>最小的数字是<code>nums2</code>的第一个元素，接下来要往右找。</p>
<h3 id="怎么知道nums-mid-是不是位于nums2？"><a href="#怎么知道nums-mid-是不是位于nums2？" class="headerlink" title="怎么知道nums[mid]是不是位于nums2？"></a>怎么知道nums[mid]是不是位于nums2？</h3><p><code>nums[mid] &lt; nums[0]</code>时，<code>nums[mid]</code>一定位于<code>nums2</code>。</p>
<h3 id="nums-mid-位于nums2，接下来往哪找最小的数？"><a href="#nums-mid-位于nums2，接下来往哪找最小的数？" class="headerlink" title="nums[mid]位于nums2，接下来往哪找最小的数？"></a>nums[mid]位于nums2，接下来往哪找最小的数？</h3><p>最小的数字是<code>nums2</code>的第一个元素，接下来要往左找。</p>
<h3 id="nums-mid-位于nums2，怎么知道nums-mid-是不是最小的数？"><a href="#nums-mid-位于nums2，怎么知道nums-mid-是不是最小的数？" class="headerlink" title="nums[mid]位于nums2，怎么知道nums[mid]是不是最小的数？"></a>nums[mid]位于nums2，怎么知道nums[mid]是不是最小的数？</h3><p>如果<code>nums[mid]</code>就是最小的数字，<code>mid</code>处于两个升序序列的分割位置，那么<code>nums[mid]</code>一定是比前一个数字要小的，判断<code>nums[mid] &lt; nums[mid - 1]</code>即可。</p>
<h3 id="nums-mid-nums-0-时，接下来应该往哪找？"><a href="#nums-mid-nums-0-时，接下来应该往哪找？" class="headerlink" title="nums[mid] == nums[0]时，接下来应该往哪找？"></a>nums[mid] == nums[0]时，接下来应该往哪找？</h3><p>由于数组允许有重复数字，<code>nums1</code>的首元素可能与<code>nums2</code>尾元素相等，这里就有两种情况：</p>
<ul>
<li>如果<code>nums1</code>的首元素与<code>nums2</code>尾元素相等，不确定<code>nums[mid]</code>是在<code>nums1</code>还是<code>nums2</code>中，只能线性缩减边界。</li>
<li>如果<code>nums1</code>的首元素与<code>nums2</code>尾元素不相等，说明<code>nums[mid]</code>在<code>nums1</code>中，最小元素在<code>nums2</code>中，要向右找。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>只有一个元素，最小的数就是元素本身</li>
<li>如果最后一个数字比第一个数字大，说明没有旋转，第一数字就是最小的了</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMin</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素，最小的数就是元素本身</span></span><br><span class="line">        <span class="comment">// 如果最后一个数字比第一个数字大，说明没有旋转，第一数字就是最小的了</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.size - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> high = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果mid大于第一个数，从第一个数字到mid都是升序的，旋转的部分在右边，最小的数也就在右边，接下来要往右找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) &#123; <span class="comment">// mid比第一个数小，说明mid已处于旋转的部分，最小的数在左边</span></span><br><span class="line">                <span class="comment">// 如果mid就是最小的数字，mid处于两个升序序列的分割位置，那么mid一定是比前一个数字要小的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[mid]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 还没找到最小的，所以要往左边找</span></span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[<span class="number">0</span>]) &#123; <span class="comment">// mid与第一个数相等</span></span><br><span class="line">                <span class="comment">// 如果mid在前面的升序序列接下来就要往右找，在后面的序列就要往左找</span></span><br><span class="line">                <span class="comment">// 但是无法判断这一点，只能从一侧依次递减</span></span><br><span class="line">                <span class="comment">// 如 [1, 0, 1, 1, 1] 和 [1, 1, 1, 0, 1]</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] != nums[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没找到，说明数组元素全部相等</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>平均时间复杂度O(log n)，最坏情况下数组元素全部相同，需要线性扫描整个数组，时间复杂度O(n)。</p>
<p>空间复杂度O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.1567.乘积为正数的最长子数组长度（中等）</title>
    <url>/LeetCode/LeetCode.1567.%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">LeetCode.1567.乘积为正数的最长子数组长度（中等）</a></p>
<p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。<br>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。<br>请你返回乘积为正数的最长子数组长度。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划，先从某个状态倒推拆解问题。</p>
<h3 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h3><p>设<code>positive[i]</code>是以<code>nums[i]</code>结尾的子数组中，乘积为正数的最长连续子数组的长度。</p>
<h3 id="如何保证乘积为正数？"><a href="#如何保证乘积为正数？" class="headerlink" title="如何保证乘积为正数？"></a>如何保证乘积为正数？</h3><p>正数 * 正数<br>负数 * 负数</p>
<h3 id="以nums-i-结尾的子数组有哪些组合情况？"><a href="#以nums-i-结尾的子数组有哪些组合情况？" class="headerlink" title="以nums[i]结尾的子数组有哪些组合情况？"></a>以nums[i]结尾的子数组有哪些组合情况？</h3><p>按照<code>nums[i]</code>要不要拿去做乘法，分为：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>跟前面的子数组连接</li>
</ol>
<p>实际去求<code>positive[i]</code>，肯定是尽量与前面的子数组的乘积去相乘，这样会得到尽可能大的结果长度。<br>如果<code>nums[i]</code>没法跟前面的子数组乘积相乘，再单独把<code>nums[i]</code>作为子数组。</p>
<h3 id="如何保证以nums-i-结尾的子数组乘积为正数？"><a href="#如何保证以nums-i-结尾的子数组乘积为正数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为正数？"></a>如何保证以nums[i]结尾的子数组乘积为正数？</h3><ol>
<li><code>nums[i]</code>单独为一个子数组时，<code>nums[i]</code>要为正数</li>
<li><code>nums[i]</code>跟前面的子数组连接时<ol>
<li><code>nums[i]</code>为正，前面子数组乘积为正</li>
<li><code>nums[i]</code>为负，前面子数组乘积为负</li>
</ol>
</li>
</ol>
<p>这里还要记录前面子数组乘积为负数的最长长度，可以定义<code>negative[i]</code>是以<code>nums[i]</code>结尾的子数组中乘积为负数的最长连续子数组的长度。</p>
<h3 id="考虑边界情况"><a href="#考虑边界情况" class="headerlink" title="考虑边界情况"></a>考虑边界情况</h3><ol>
<li>在<code>nums[i]</code>要跟前面的子数组连接时，如果：<ol>
<li><code>nums[i]</code>为正数，前面没有乘积是正数的子数组（比如乘积是0或者负数或者没有任何数），这个时候<code>nums[i]</code>可以单独做一个子数组，<code>positive[i] = 1</code>。</li>
<li><code>nums[i]</code>为负数，前面没有乘积是负数的子数组，这个时候<code>nums[i]</code>单独作为子数组也不是正的，<code>positive[i]</code>是0。</li>
</ol>
</li>
<li><code>nums[i]</code>为0时，<code>positive[0]</code>只能为0，因为单独让<code>nums[i]</code>成为子数组乘积是0，<code>nums[i]</code>跟前面子数组乘积相乘也是0。</li>
</ol>
<h3 id="positive-i-的状态转移方程"><a href="#positive-i-的状态转移方程" class="headerlink" title="positive[i]的状态转移方程"></a>positive[i]的状态转移方程</h3><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1. `positive[i] = positive[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0`，前面有乘积为正数的子数组，正数*正数乘积是正数
 2. `positive[i] = 1`，当`i &gt; 0 &amp;&amp; positive[i - 1] == 0`，前面没有乘积为正数的子数组，`nums[i]`单独作为一个子数组
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `positive[i] = negative[i - 1] + 1`，当 `i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0`，前面有乘积为负数的子数组，负数*负数乘积是正数
 2. `positive[i] = 0`，当 `i &gt; 0 &amp;&amp; negative[i - 1] == 0`，前面没有乘积为负数的子数组，`nums[i]`没的乘，以`nums[i]`结尾的子数组的乘积没办法变为正数
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>positive[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>positive[0] = if (nums[0] &gt; 0) 1 else 0</code></li>
</ol>
<h3 id="如何保证以nums-i-结尾的子数组乘积为负数？"><a href="#如何保证以nums-i-结尾的子数组乘积为负数？" class="headerlink" title="如何保证以nums[i]结尾的子数组乘积为负数？"></a>如何保证以nums[i]结尾的子数组乘积为负数？</h3><p>跟<code>positive[i]</code>正好相反。<br><code>nums[i]</code>跟前面的子数组连接时：<br>    1. <code>nums[i]</code>为正，前面子数组乘积为负<br>    2. <code>nums[i]</code>为负，前面子数组乘积为正</p>
<h3 id="negative-i-的状态转移方程"><a href="#negative-i-的状态转移方程" class="headerlink" title="negative[i]的状态转移方程"></a>negative[i]的状态转移方程</h3><ol>
<li><code>nums[i] &gt; 0</code> 时：<pre><code> 1.` i &gt; 0 &amp;&amp; negative[i - 1] &gt; 0` 时，`negative[i] = negative[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; negative[i - 1] == 0` 时，`negative[i] = 0`
</code></pre>
</li>
<li><code>nums[i] &lt; 0</code> 时：<pre><code> 1. `i &gt; 0 &amp;&amp; positive[i - 1] &gt; 0` 时，`negative[i] = positive[i - 1] + 1`
 2. `i &gt; 0 &amp;&amp; positive[i - 1] == 0` 时，`negative[i] = 1`
</code></pre>
</li>
<li><code>num[i] == 0</code> 时：<br> <code>negative[i] = 0</code></li>
<li><code>i == 0</code> 时，<code>negative[0] = if (nums[0] &lt; 0) 1 else 0</code></li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>positive[i]</code>和<code>negative[i]</code>只与上一个状态有关，不需要数据存储所有状态，用变量记录上一个状态即可。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMaxLen</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> positive = <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> negative = <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxLength = positive</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                nums[i] &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (positive == 0)*/</span> <span class="number">1</span> </span><br><span class="line">                    negative = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/*if (negative[i - 1] == 0)*/</span> <span class="number">0</span> </span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] &lt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newPositive = <span class="keyword">if</span> (negative &gt; <span class="number">0</span>) negative + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (negative == 0) */</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">val</span> newNegative = <span class="keyword">if</span> (positive &gt; <span class="number">0</span>) positive + <span class="number">1</span> <span class="keyword">else</span> <span class="comment">/* if (positive == 0) */</span> <span class="number">1</span></span><br><span class="line">                    positive = newPositive</span><br><span class="line">                    negative = newNegative</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] == <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    positive = <span class="number">0</span></span><br><span class="line">                    negative = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, positive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.174.地下城游戏（困难）</title>
    <url>/LeetCode/LeetCode.174.%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/dungeon-game/">LeetCode.174.地下城游戏（困难）</a></p>
<span id="more"></span>

<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<p><strong>说明:</strong></p>
<ul>
<li>  骑士的健康点数没有上限。</li>
<li>  任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设<code>dungeon[i][j]</code>为地牢的第<code>i</code>行第<code>j</code>列的点数，可正、可负、可零。</p>
<p>这题跟最小路径和不一样的点在于：<code>在任意格子，都要求骑士的 生命值x &gt;= 1</code>。</p>
<p>如果骑士位于某行某列，则要求<code>x &gt;= 1 &amp;&amp; x + dungeon[i][j] &gt;= 1</code>，不等式两侧的项换个位置也就是：<code>x &gt;= 1 &amp;&amp; x &gt;= 1 - dungeon[i][j]</code>，我们要求最低的生命值，可得<code>x = maxOf(1, 1 - dungeon[i][j])</code>。</p>
<p>但是骑士是要在走动的，光看当前位置的点数，是不知道当前生命值够不够用，需要知道后面的路径需要的最少生命值是多少，假设是<code>y</code>，那么当前位置就要满足<code>x &gt;= 1 &amp;&amp; x + dungeon[i][j] &gt;= y</code>，我们要求最低的生命值，可得<code>x = maxOf(1, y - dungeon[i][j])</code>。</p>
<p>状态转移的过程就出来了，是要从末尾往开头递推，才能得出结果。</p>
<p>从左上到右下的路径，有两种选择，往右走、往下走。不知道往哪走所需的最低初始健康点数最少，就两个都试一遍，取最小的。</p>
<p><strong>边界条件</strong></p>
<ul>
<li>在最后一行，只能向右走，无法向下走。</li>
<li>在最后一列，只能向下走，无法向右走。</li>
</ul>
<p><strong>回溯递归解法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">findMinHp</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                r == m - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r, c + <span class="number">1</span>) - dungeon[r][c])</span><br><span class="line">                c == n - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r + <span class="number">1</span>, c) - dungeon[r][c])</span><br><span class="line">                <span class="keyword">else</span> -&gt; maxOf(<span class="number">1</span>, minOf(findMinHp(r, c + <span class="number">1</span>), findMinHp(r + <span class="number">1</span>, c)) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findMinHp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归存在重叠子问题，例如<code>findMinHp(r + 1, c)</code>会执行多次，需要记录中间状态。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> memo = Array(m) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">findMinHp</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[r][c] != -<span class="number">1</span>) <span class="keyword">return</span> memo[r][c]</span><br><span class="line">            <span class="keyword">val</span> result =  <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[r][c])</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                r == m - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r, c + <span class="number">1</span>) - dungeon[r][c])</span><br><span class="line">                c == n - <span class="number">1</span> -&gt; maxOf(<span class="number">1</span>, findMinHp(r + <span class="number">1</span>, c) - dungeon[r][c])</span><br><span class="line">                <span class="keyword">else</span> -&gt; maxOf(<span class="number">1</span>, minOf(findMinHp(r, c + <span class="number">1</span>), findMinHp(r + <span class="number">1</span>, c)) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">            memo[r][c] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findMinHp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上的动态规划</strong></p>
<p>记忆化递归已经给出了状态转移方程，需要注意的是要从最右下角开始往左上角递推，才能得到结果。</p>
<p>设<code>dp[i][j]</code>表示骑士位于第<code>i</code>行第<code>j</code>列格子时要达到公主处所需要的最小生命值。</p>
<p><strong>状态转移方程</strong></p>
<ul>
<li>最右下角：<code>dp[i][j] = maxOf(1, 1 - dungeon[m - 1][n - 1])</code>。</li>
<li>最后一列：<code>dp[i][j] = maxOf(1, dp[r + 1][c] - dungeon[r][c])</code>。</li>
<li>最后一行：<code>dp[i][j] = maxOf(1, dp[r][c + 1] - dungeon[r][c])</code>。</li>
<li>其他行和列：<code>dp[i][j] = maxOf(1, minOf(dp[r][c + 1], dp[r + 1][c]) - dungeon[r][c])</code>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = dungeon.size</span><br><span class="line">        <span class="keyword">val</span> n = dungeon[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = maxOf(<span class="number">1</span>, <span class="number">1</span> - dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> m - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = maxOf(<span class="number">1</span>, dp[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i][n - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            dp[m - <span class="number">1</span>][i] = maxOf(<span class="number">1</span>, dp[m - <span class="number">1</span>][i + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][i])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> m - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> n - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">                dp[r][c] = maxOf(<span class="number">1</span>, minOf(dp[r][c + <span class="number">1</span>], dp[r + <span class="number">1</span>][c]) - dungeon[r][c])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.188.买卖股票的最佳时机 IV（困难）</title>
    <url>/LeetCode/LeetCode.188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode.188.买卖股票的最佳时机 IV（困难）</a></p>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最优化问题考虑用动态规划。</p>
<p>看最终结果受哪些因素影响，穷举不同因素的所有状态值，就可以推导出最终结果。</p>
<h3 id="最终收益受哪些维度的状态变化影响？"><a href="#最终收益受哪些维度的状态变化影响？" class="headerlink" title="最终收益受哪些维度的状态变化影响？"></a>最终收益受哪些维度的状态变化影响？</h3><ul>
<li>在第几天买入或卖出肯定是会影响最终收益，可能某一天突然暴涨。</li>
<li>交易次数越多，可能赚取的收益越大。</li>
<li>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。归纳合并一下，这些操作会产生的结果状态是：第<code>i</code>天持有或不持有股票。股票持有状态也会影响最终收益。</li>
</ul>
<p>所以从结果上看，一共有三种纬度的状态变化：</p>
<ul>
<li>第几天做出选择</li>
<li>已经交易了多少次</li>
<li>当前是否持有股票</li>
</ul>
<h3 id="买入的时候算一次交易，还是卖出的时候算一次交易？"><a href="#买入的时候算一次交易，还是卖出的时候算一次交易？" class="headerlink" title="买入的时候算一次交易，还是卖出的时候算一次交易？"></a>买入的时候算一次交易，还是卖出的时候算一次交易？</h3><p>其实都可以，不影响最终结果，只是状态转移过程会有所变化。<br>这里定义买入的时候算一次交易。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i][j][k]</code>表示，前<code>i</code>天，交易了<code>j</code>次，在第<code>i</code>天持有或不持有股票，所获得最大的收益。其中<code>k == 0</code>表示不持有，<code>k == 1</code>表示持有。</p>
<ul>
<li><code>dp[i][j][0]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][0]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天卖出。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][1] + prices[i]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>dp[i][j][1]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j][1]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天买入。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j - 1][0] - prices[i]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>第0天<ul>
<li>持有股票的话，不论多少次交易，只能直接买入一次。</li>
<li>不持有股票的话，收益就是0。</li>
</ul>
</li>
<li>第<code>i</code>天之前都没有交易（即<code>j == 0</code>），第<code>i</code>天要交易操作就是买入。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>如果给定的最多交易次数<code>k</code>非常大，状态数组开辟空间也会非常大，考虑是否有优化的可能。</p>
<p><strong>交易次数上限是多少？</strong></p>
<p>一次交易要买入和卖出，总共n天，交易次数不应该超过n / 2。</p>
<p><strong>交易次数超过n / 2要怎么办？</strong></p>
<p>这就等于不限交易次数，与<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a>解法相同，可以复用这种情况下最优化空间的解答。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(k: <span class="type">Int</span>, prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty() || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfitNonLimitCount(prices)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三种状态：第几天买入或卖出、已经交易了多少次、当前是否持有股票</span></span><br><span class="line">        <span class="comment">// dp[i][j][0或1]表示，前i天，交易了j次，在第i天持有或不持有股票，所获得最大的收益</span></span><br><span class="line">        <span class="comment">// 这里定义买入的时候算一次交易</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(k) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 第0天持有股票的话，最多k次交易，只能直接买入</span></span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第i天，交易了j次，持有股票</span></span><br><span class="line">                    <span class="comment">// 可能是前i-1天就交易了j次并持有股票，也可能前i-1天交易了j-1次在今天买入了</span></span><br><span class="line">                    <span class="comment">// 如果之前没有交易，今天就直接买入就好了</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], -prices[i])</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">maxProfitNonLimitCount</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n * k)</code>。</li>
<li><code>k &gt;= n / 2</code>时，空间复杂度<code>O(1)</code>；<code>k &lt; n / 2</code>时，空间复杂度<code>O(n * k)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.198.打家劫舍（中等）</title>
    <url>/LeetCode/LeetCode.198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">LeetCode.198.打家劫舍（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>从最终状态做倒推，穷举列出到达最终状态所需要的最小步骤，看是否能从上一个状态加上有限步骤得到最终状态，检查上一个状态的最优解是否也能通过不停的倒推拆解得到，拆分步骤的过程可得出状态转移方程。拆分到最开始，做边界条件处理。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>设<code>nums[i]</code>为第i间房屋金额。<br>设<code>dp[i]</code>为达到第i个房屋时能偷到的最高金额。</p>
<ol>
<li>偷第i间房，就不能偷第i - 1房，<code>dp[i] = dp[i - 2] + nums[i]</code></li>
<li>不偷第i间房，<code>dp[i] = dp[i - 1]</code></li>
</ol>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ol>
<li>只有1间房，直接偷</li>
<li>只有2间房，由于不能偷相邻的房间，就偷钱多的。 </li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只从前两项递推得来，所以不需要数组记录所有状态，只需要两个变量记录递推的状态。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1 </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.212.单词搜索 II（困难）</title>
    <url>/LeetCode/LeetCode.212.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-search-ii/">LeetCode.212.单词搜索 II（困难）</a></p>
<p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>网格中找字典单词，而且还是往相邻单元格找，用深度优先搜索。</li>
<li>单词必须按照字母顺序，所以必须尝试从每个单元格开始搜索。</li>
<li>只要在网格中找到了一个单词，接下来就不用再找这个单词了。</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>遍历所有单词。</li>
<li>遍历网格所有的单元格，在每个单元格用回溯找指定单词，找到一个就停止。</li>
</ul>
<h3 id="回溯怎么写？"><a href="#回溯怎么写？" class="headerlink" title="回溯怎么写？"></a>回溯怎么写？</h3><p>标准的回溯模板写法。</p>
<ul>
<li>用一个访问数组记录已访问过的元素，避免循环搜索。</li>
<li>用方向数组简化代码，做好边界检查。</li>
<li>回溯结束条件就是单词所有字符遍历完了。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各索引从小到大依次代表 上、右、下、左</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaRow = intArrayOf(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaColumn = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findWords</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">for</span> (word <span class="keyword">in</span> words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word)) &#123;</span><br><span class="line">                result.add(word)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findWord</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, word: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = board.size</span><br><span class="line">        <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> visited = Array(rows) &#123; BooleanArray(columns) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                <span class="keyword">val</span> found = backtrack(board, row, column, visited, word, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (found) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, row: <span class="type">Int</span>, column: <span class="type">Int</span>, visited: <span class="type">Array</span>&lt;<span class="type">BooleanArray</span>&gt;, word: <span class="type">String</span>, wordIndex: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[row][column] == word[wordIndex]) &#123;</span><br><span class="line">            <span class="comment">// 期待的正确情况的边界条件</span></span><br><span class="line">            <span class="keyword">if</span> (wordIndex == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 单词还没搜完，就继续尝试下一个位置</span></span><br><span class="line">            visited[row][column] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> (direction <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newRow = row + deltaRow[direction]</span><br><span class="line">                <span class="keyword">val</span> newColumn = column + deltaColumn[direction]</span><br><span class="line">                <span class="keyword">val</span> rows = board.size</span><br><span class="line">                <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">val</span> isInBound = newRow <span class="keyword">in</span> <span class="number">0</span> until rows &amp;&amp; newColumn <span class="keyword">in</span> <span class="number">0</span> until columns</span><br><span class="line">                <span class="keyword">if</span> (isInBound &amp;&amp; !visited[newRow][newColumn]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(board, newRow, newColumn, visited, word, wordIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[row][column] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：字典树-回溯"><a href="#解法2：字典树-回溯" class="headerlink" title="解法2：字典树 + 回溯"></a>解法2：字典树 + 回溯</h2><p>解法1 的步骤是</p>
<ul>
<li>遍历单词列表选一个单词。</li>
<li>从网格中的每个位置开始回溯，看能否找到这个单词。</li>
</ul>
<p>如果能在网格中的每个位置开始回溯时：</p>
<ul>
<li>发现找到了单词，就能直接记录下来。</li>
<li>所走的字符不能构成单词就不要继续做没有意义的搜索了。</li>
</ul>
<p>这样就是最省时间的。</p>
<p>符合这个访问特点的就是字典树，所以得吧words所有单词先构建出一个字典树。</p>
<p>在网格中的每个位置开始回溯时，用字典树匹配回溯发现的字符，如果能组成单词，就记录下来。</p>
<p><strong>字典树匹配的问题</strong></p>
<p>如果在每个递归层都从字典数的根节点开始匹配，那么会有很多重复判断，可以在回溯递归时，传递字典树的节点给每个递归层，就不会重复判断了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>(</span><br><span class="line">        <span class="keyword">var</span> isEnd: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">val</span> next: Array&lt;Node?&gt; = Array(<span class="number">26</span>) &#123; <span class="literal">null</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">val</span> i = c - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (p.next[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next[i] = Node()</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next[i]!!</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEnd = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各索引从小到大依次代表 上、右、下、左</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaRow = intArrayOf(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaColumn = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findWords</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 所有单词构建字典树</span></span><br><span class="line">        <span class="keyword">val</span> trie = Trie()</span><br><span class="line">        <span class="keyword">for</span> (word <span class="keyword">in</span> words) &#123;</span><br><span class="line">            trie.insert(word)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">val</span> result = HashSet&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> rows = board.size</span><br><span class="line">        <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> visited = Array(rows) &#123; BooleanArray(columns) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> path = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                backtrack(board, row, column, visited, trie.root, path, result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            row: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            column: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            visited: <span class="type">Array</span>&lt;<span class="type">BooleanArray</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            node: <span class="type">Node</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">Stack</span>&lt;<span class="type">Char</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            result: <span class="type">HashSet</span>&lt;<span class="type">String</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> c = board[row][column]</span><br><span class="line">        <span class="keyword">val</span> currentNode = node.next[c - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.push(c)</span><br><span class="line">            visited[row][column] = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 找到一个单词</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.isEnd) &#123;</span><br><span class="line">                <span class="comment">// 添加结果</span></span><br><span class="line">                <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> path.indices) &#123;</span><br><span class="line">                    sb.append(path[i])</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(sb.toString())</span><br><span class="line">                <span class="comment">// 不能中断搜索，因为字典树当前结点可能还有子树，所以这里找到了一个单词不做return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单词还没搜完，就继续尝试下一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (direction <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newRow = row + deltaRow[direction]</span><br><span class="line">                <span class="keyword">val</span> newColumn = column + deltaColumn[direction]</span><br><span class="line">                <span class="keyword">val</span> rows = board.size</span><br><span class="line">                <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">val</span> isInBound = newRow <span class="keyword">in</span> <span class="number">0</span> until rows &amp;&amp; newColumn <span class="keyword">in</span> <span class="number">0</span> until columns</span><br><span class="line">                <span class="keyword">if</span> (isInBound &amp;&amp; !visited[newRow][newColumn]) &#123;</span><br><span class="line">                    backtrack(board, newRow, newColumn, visited, currentNode, path, result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            path.pop()</span><br><span class="line">            visited[row][column] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>深度优先搜索</tag>
        <tag>回溯</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.213.打家劫舍 II（中等）</title>
    <url>/LeetCode/LeetCode.213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">LeetCode.213.打家劫舍 II（中等）</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="环形排列影响了什么？"><a href="#环形排列影响了什么？" class="headerlink" title="环形排列影响了什么？"></a>环形排列影响了什么？</h3><p>第1间房子和最后一间房子只能偷一个，不知道偷哪个金额最高。</p>
<h3 id="不知道偷第一间还是最后一间，怎么办？"><a href="#不知道偷第一间还是最后一间，怎么办？" class="headerlink" title="不知道偷第一间还是最后一间，怎么办？"></a>不知道偷第一间还是最后一间，怎么办？</h3><p>两种情况都偷一下，取金额大的那个方案。即：</p>
<ol>
<li>偷第1间房子，不偷最后一间房子</li>
<li>不偷第1间房子，偷最后一间房子</li>
</ol>
<p>转换为两个非环问题取较大值的问题。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">0</span>, n - <span class="number">1</span>)),</span><br><span class="line">            linearRob(nums.copyOfRange(<span class="number">1</span>, n))</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">linearRob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> n = nums.size</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">var</span> cur = pre1</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">                cur = maxOf(pre1, pre2 + nums[i])</span><br><span class="line">                pre2 = pre1</span><br><span class="line">                pre1 = cur</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.214.最短回文串（困难）</title>
    <url>/LeetCode/LeetCode.214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/shortest-palindrome/">LeetCode.214.最短回文串（困难）</a></p>
<p>给定一个字符串  _<strong>s</strong>_，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串的特点是左右两端字符相同，要在<code>s</code>前面添加字符串使得新字符串是回文串，那就把<code>s</code>的倒置字符串放在前面就可以形成回文了。</p>
<h3 id="s的倒置字符串添加在s前面会有什么问题？"><a href="#s的倒置字符串添加在s前面会有什么问题？" class="headerlink" title="s的倒置字符串添加在s前面会有什么问题？"></a>s的倒置字符串添加在s前面会有什么问题？</h3><p>这样添加还不是最短的回文。</p>
<p>比如s是abbacd，添加dcabba到开头，形成dcabbaabbacd，可以发现abba是多余的，不用添加，dcabbacd是更短的回文串，只要添加dc就行了。</p>
<h3 id="应该添加什么样的字符串才能获得最短回文？"><a href="#应该添加什么样的字符串才能获得最短回文？" class="headerlink" title="应该添加什么样的字符串才能获得最短回文？"></a>应该添加什么样的字符串才能获得最短回文？</h3><p>得找到abbacd的前缀和dcabba的后缀最长的重合的部分的长度，然后找到不重复的部分，添加到字符串前面。</p>
<p>标准化描述：</p>
<ul>
<li>设<code>s&#39;</code>是<code>s</code>的倒置字符串。</li>
<li>求<code>s</code>的前缀和<code>s&#39;</code>的后缀中相同部分最长的长度<code>x</code>。</li>
<li>取<code>s</code>的子串<code>s[x, n - 1]</code>，倒置后添加到<code>s</code>前面，形成最短回文。</li>
</ul>
<h3 id="怎么寻找s和s的倒置字符串最长前后缀？"><a href="#怎么寻找s和s的倒置字符串最长前后缀？" class="headerlink" title="怎么寻找s和s的倒置字符串最长前后缀？"></a>怎么寻找s和s的倒置字符串最长前后缀？</h3><p>联想到kmp做字符串匹配时，要先求一个前缀函数，前缀函数<code>prefix[i]</code>表示<code>s[0, i]</code>中最长的公共前后缀的长度，只要求出前缀函数就可以求解题目。</p>
<h3 id="前缀函数怎么求？"><a href="#前缀函数怎么求？" class="headerlink" title="前缀函数怎么求？"></a>前缀函数怎么求？</h3><p>一句话：让<code>s[0, n - 1]</code>匹配<code>s[1, n - 1]</code>。</p>
<p>算法步骤：</p>
<ul>
<li>双指针<code>i</code>和<code>j</code>遍历<code>s</code>。</li>
<li><code>i</code>从1开始，<code>j</code>从0开始。</li>
<li>s匹配自己，字符能匹配上，双指针都前进。</li>
<li>当前<code>s[i]</code>和<code>s[j]</code>不匹配，要把<code>j</code>往回退。<ul>
<li><code>j</code>退到前一个位置（<code>j - 1</code>）的最长公共前后缀的前缀的下一个字符的位置。继续拿<code>s[j]</code>跟<code>s[i]</code>尝试匹配，如果能匹配的上，<code>prefix[i]</code>就求出来了。</li>
<li>如果<code>j</code>一直回退，最坏也就是回退到0，因为<code>prefix[0] = 0</code>（一个字符不存在前后缀），没的退了，只能比较<code>s[i]</code>和<code>s[0]</code>，没匹配的话公共前后缀长度就是0。</li>
</ul>
</li>
</ul>
<h3 id="前缀函数应该针对哪个字符串求？"><a href="#前缀函数应该针对哪个字符串求？" class="headerlink" title="前缀函数应该针对哪个字符串求？"></a>前缀函数应该针对哪个字符串求？</h3><p>我们要求<code>s</code>的前缀和<code>s</code>的倒置字符串的后缀最长的公共部分。<br>所以弄一个新字符串 <code>s&#39; + s</code>。</p>
<p><strong>这样存在一个问题</strong>，如果所有字符都相同，此时最长公共前后缀就是整个字符串<code>s&#39; + s</code>本身，这不是期望的结果，所以连接<code>s&#39;</code>和<code>s</code>时，中间隔一个用不到的字符，比如<code>#</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shortestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 加#是为了防止出现全部重复的字符，这样最长公共前后缀的长度就不是期望的了</span></span><br><span class="line">        <span class="keyword">val</span> maxLength = (s + <span class="string">&quot;#&quot;</span> + s.reversed()).prefixArray().last()</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLength).reversed() + s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">prefixArray</span><span class="params">()</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> s = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> n = length</span><br><span class="line">        <span class="keyword">val</span> prefix = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = prefix[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = prefix[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) j++</span><br><span class="line">            prefix[i] = j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>设字符串<code>s</code>长度为n。</p>
<ul>
<li>时间复杂度O(n)：求前缀函数最坏情况需要O(n + n) = O(n)时间；还要遍历整个<code>s&#39; + s</code>，有2n的长度，需要O(n)时间。</li>
<li>空间复杂度O(n)：前缀函数占用O(n)空间。</li>
</ul>
<p>kmp时间复杂度推导可参考：</p>
<ul>
<li><a href="https://blog.csdn.net/niukai1768/article/details/79579709">KMP时间复杂度分析</a></li>
<li><a href="https://segmentfault.com/q/1010000014560162">KMP算法的时间复杂度是如何计算的？</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.218.天际线问题（困难）</title>
    <url>/LeetCode/LeetCode.218.%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/the-skyline-problem/">LeetCode.218.天际线问题（困难）</a></p>
<span id="more"></span>

<p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p>
<p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p>
<p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>模拟一遍天际线形成的过程。</li>
<li>从简单的情况出发，逐步添加条件讨论复杂的情况。</li>
<li>穷举所有可能性，发现和总结重复的规律。</li>
</ul>
<h2 id="天际线受哪几个因素影响？"><a href="#天际线受哪几个因素影响？" class="headerlink" title="天际线受哪几个因素影响？"></a>天际线受哪几个因素影响？</h2><ul>
<li>建筑物左边界和右边界</li>
<li>建筑物高度</li>
<li>建筑物个数</li>
</ul>
<h2 id="只有一个建筑时，天际线的关键点是哪些？"><a href="#只有一个建筑时，天际线的关键点是哪些？" class="headerlink" title="只有一个建筑时，天际线的关键点是哪些？"></a>只有一个建筑时，天际线的关键点是哪些？</h2><p>天际线的形成就是从左到右扫描建筑边界。</p>
<ul>
<li>发现第一个建筑后，边际线的第一个关键点是第一个建筑左上角点。</li>
<li>后面没有其他建筑，边际线的第二个关键点是第一个建筑右下角点。</li>
</ul>
<p>此时看不出来什么规律。</p>
<h2 id="有两个建筑时，天际线的关键点受到怎样的影响？"><a href="#有两个建筑时，天际线的关键点受到怎样的影响？" class="headerlink" title="有两个建筑时，天际线的关键点受到怎样的影响？"></a>有两个建筑时，天际线的关键点受到怎样的影响？</h2><p>为方便描述，先假设：<br>第一个建筑为A，下一个建筑为B，leftB &gt; leftA。</p>
<p>leftB、rightB、heightB的变化都会影响天际线的变化，所以就分类讨论。</p>
<p>先看建筑B在横轴变化，再看高度变化：</p>
<h3 id="B和A没有重叠（leftB-gt-rightA）"><a href="#B和A没有重叠（leftB-gt-rightA）" class="headerlink" title="B和A没有重叠（leftB &gt; rightA）"></a>B和A没有重叠（leftB &gt; rightA）</h3><p>此时B跟A的情况是一样的。</p>
<h3 id="B和A有一部分重叠（leftB-lt-rightA）"><a href="#B和A有一部分重叠（leftB-lt-rightA）" class="headerlink" title="B和A有一部分重叠（leftB &lt; rightA）"></a>B和A有一部分重叠（leftB &lt; rightA）</h3><h4 id="B的高度-gt-A的高度"><a href="#B的高度-gt-A的高度" class="headerlink" title="B的高度 &gt; A的高度"></a>B的高度 &gt; A的高度</h4><p>B的左边界会影响天际线，天际线第2个关键点是B的左上角点（leftB, heightB）。</p>
<p><strong>扩展：建筑横轴坐标不变，高度和个数变化</strong></p>
<p>如果有很多不同高的建筑，边界横轴坐标都是leftB，应该选哪个建筑的边界为天际线？选最高的。</p>
<h4 id="B的高度-lt-A的高度"><a href="#B的高度-lt-A的高度" class="headerlink" title="B的高度 &lt; A的高度"></a>B的高度 &lt; A的高度</h4><p>B的左边界不会影响天际线。</p>
<ul>
<li>如果rightB &lt; rightA，B的右边界对天际线也没有影响。</li>
<li>如果rightB &gt; rightA，天际线第2个关键点坐标是（rightA, heightB）。</li>
</ul>
<p><strong>扩展：建筑横轴坐标不变，高度和个数变化</strong></p>
<p>如果有很多不同高的建筑，左右边界都在rightB两侧，应该选哪个建筑的边界为天际线？<br>选第二高的，因为最高的建筑到头了，只能选次高的做边际线。</p>
<h2 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h2><p>从左到右扫描</p>
<ul>
<li>边际线增高的时候，关键点都是建筑左上角点，并且是相同左边界中最高的。</li>
<li>边际线降低的时候，关键点需要知道建筑右上角点横坐标，以及此横坐标下次高的建筑高度。</li>
</ul>
<p>怎么获得建筑右上角点下面次高的建筑高度？<br>次高的建筑的左边在之前肯定扫描过了，所以可记录下建筑的高度。</p>
<p>也就是要保存所有建筑的左上角点的横坐标和高度、右上角点点横坐标和高度，并且要排序，才能知道哪个是最高哪个是次高。<br>排序还要在线排序才行，不能用离线排序算法，所以用优先队列来存储建筑的点，按高度排序，构建最大堆。</p>
<p>遍历到建筑左上角的点，要么在边际线增高的时候用到，要么在边际线递减的时候用来获得次高的高度，所以左上角点存储后需要保留。</p>
<p>遍历到建筑右上角点，边际线就向右延展结束了，就没有用了，我们需要获得次高的建筑高度，就需要把处在边际线高度的建筑的右上角点从优先队列中去除，这样就可以获得右边界下次高建筑的高度了。</p>
<p>所以优先队列记录的高度还需要区分是建筑的左上角点和右上角点，这里可以用负数表示左上角点的高度，正数表示右上角点的高度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.Comparator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSkyline</span><span class="params">(buildings: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = mutableListOf&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">        <span class="comment">// 建筑物的左上角、右上角顶点坐标提取出来并按横坐标从小到大的排序</span></span><br><span class="line">        <span class="keyword">val</span> points = buildings.toSortedPoints()</span><br><span class="line">        <span class="comment">// 创建大顶堆，用以保存从左向右扫描的高度</span></span><br><span class="line">        <span class="keyword">val</span> queue = PriorityQueue&lt;<span class="built_in">Int</span>&gt;(compareByDescending &#123; it &#125;)</span><br><span class="line">        <span class="comment">// 初始插入0</span></span><br><span class="line">        queue.offer(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 记录先前的天际线高度，如果高度发生变化了说明天际线发生了转折，需要记录</span></span><br><span class="line">        <span class="comment">// 因为有可能有几个高度一样的建筑物重叠在一起</span></span><br><span class="line">        <span class="keyword">var</span> preMax = <span class="number">0</span></span><br><span class="line">        points.forEach &#123; p -&gt;</span><br><span class="line">            <span class="comment">// 遇到左上角顶点，就将该顶点的高度插入最大堆，插入只需要对数时间</span></span><br><span class="line">            <span class="keyword">if</span> (p.y &lt; <span class="number">0</span>) queue.offer(-p.y)</span><br><span class="line">            <span class="comment">// 遇到右上角顶点，就将该顶点高度从最大堆种删除，因为这个建筑不再影响天际线</span></span><br><span class="line">            <span class="comment">// 设堆中有n个元素，从堆中移除，首先需要找到这个元素，最坏需要耗费O(n)时间，与最后一个元素替换当作删除后再调整堆最坏需要耗费O(logn)时间</span></span><br><span class="line">            <span class="keyword">else</span> queue.remove(p.y)</span><br><span class="line">            <span class="comment">// 当前堆顶最大的高度，也就是天际线经过的高度</span></span><br><span class="line">            <span class="keyword">val</span> max = queue.peek()</span><br><span class="line">            <span class="comment">// 天际线高度发生了转折变化</span></span><br><span class="line">            <span class="keyword">if</span> (preMax != max) &#123;</span><br><span class="line">                <span class="comment">// 添加天际线转折点坐标</span></span><br><span class="line">                answer.add(listOf(p.x, max))</span><br><span class="line">                <span class="comment">// 记录这次的最大高度</span></span><br><span class="line">                preMax = max</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    求出每个建筑左上角和右上角坐标（横坐标,高度）, 并按横坐标从小到大的顺序排序</span></span><br><span class="line"><span class="comment">    当横坐标x相等时，该怎么排序，分以下三种情况:</span></span><br><span class="line"><span class="comment">    1. 两个坐标都是左上角的坐标，需要把较高的排在前面</span></span><br><span class="line"><span class="comment">    2. 两个坐标都是右上角的坐标，需要把较低的排在前面</span></span><br><span class="line"><span class="comment">    3. 一个坐标是左上角，另一个坐标是右上角，左上角需要排在前面</span></span><br><span class="line"><span class="comment">    上述判断起来比较麻烦，如果把左上角的高度存储为负数，上述三种情况只需要简单的按高度升序排序就可以达成效果</span></span><br><span class="line"><span class="comment">    同时也可以通过高度的正负来判定哪个是左上角的坐标哪个是右上角的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Array<span class="type">&lt;IntArray&gt;</span>.<span class="title">toSortedPoints</span><span class="params">()</span></span>: List&lt;Point&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> flatMap &#123; building -&gt;</span><br><span class="line">            <span class="keyword">val</span> leftX = building[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> rightX = building[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">val</span> height = building[<span class="number">2</span>]</span><br><span class="line">            listOf(</span><br><span class="line">                    Point(leftX, -height),</span><br><span class="line">                    Point(rightX, height)</span><br><span class="line">            )</span><br><span class="line">        &#125;.sortedWith(Comparator &#123; a, b -&gt; <span class="keyword">if</span> (a.x != b.x) a.x - b.x <span class="keyword">else</span> a.y - b.y &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.221.最大正方形（中等）</title>
    <url>/LeetCode/LeetCode.221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode.221.最大正方形（中等）</a></p>
<p>在一个由  <code>&#39;0&#39;</code>  和  <code>&#39;1&#39;</code>  组成的二维矩阵内，找到只包含  <code>&#39;1&#39;</code>  的最大正方形，并返回其面积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑用动态规划。<br>想办法把大问题划分子问题+有限步骤。</p>
<h3 id="从基本情况出发"><a href="#从基本情况出发" class="headerlink" title="从基本情况出发"></a>从基本情况出发</h3><p>对于某一个点<code>[i, j]</code>，如果它的值是1，那么构成边长为1的正方形。</p>
<h3 id="构成边长为2的正方形需要什么条件？"><a href="#构成边长为2的正方形需要什么条件？" class="headerlink" title="构成边长为2的正方形需要什么条件？"></a>构成边长为2的正方形需要什么条件？</h3><p>对于某一个点<code>[i, j]</code>，如果想要构成边长为2的正方形，要知道周围其余3个点是否都是1。</p>
<p>而这3个点的构成有四个方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b b    b b    a b    b a</span><br><span class="line">b a    a b    b b    b b</span><br><span class="line">左上    右上   右下    左下</span><br></pre></td></tr></table></figure>
<p>判断的方向太多了，能不能归类简化一下。<br>可以发现右上、右下、左下的情况，都可以归类为左上的问题，因为它们右下角的点都会遇到左上的情况。</p>
<p>这里还看不出一般规律，继续看边长更大的情况。</p>
<h3 id="怎么快速判断能否构成边长为3的正方形？"><a href="#怎么快速判断能否构成边长为3的正方形？" class="headerlink" title="怎么快速判断能否构成边长为3的正方形？"></a>怎么快速判断能否构成边长为3的正方形？</h3><p>对于某一个点<code>[i, j]</code>，如果去一个个检查左上方的点是不是都是1，太麻烦了；因为如果要检查边长更大的正方形，那么往回遍历的点就越多，而且之前遍历过的点都要重复遍历。</p>
<p>能不能利用之前的计算结果呢？<br>假设<code>side[i][j]</code>表示以<code>[i, j]</code>为右下角的正方形的个数。<br>个数的统计是通过看是否依次能够成边长为1、2、3、…、n的正方形，所以<code>a[i][j]</code>也表示能形成的最大的正方形的边长。</p>
<p>分析如下的3x3网格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         col </span><br><span class="line">a0 a1 a2  0</span><br><span class="line">b0 b1 b2  1</span><br><span class="line">c0 c1 c2  2</span><br><span class="line"> 0  1  2 row </span><br></pre></td></tr></table></figure>
<p>从正方形的边界来推理，怎么利用<code>side</code>数组快速判断格子是否为1。</p>
<p>如果想要a2、b2为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子上方至少有2x2的正方形。<br>如果想要c0、c1为1，那么<code>side[1][2] &gt;= 2</code>才行，也就是右下角的格子左方至少有2x2的正方形。<br>a0、a1、b0要为1，那么<code>side[1][1] &gt;= 2</code>才行，也就是右下角的格子的左上方至少有2x2的正方形。</p>
<p>如果有两个方向的正方形边长大于2，但有一个方向的正方形边长为1，会怎么影响<code>side[2][2]</code>？<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>只能取边长最小的这个方向的正方形边长。</p>
<p>规律已经浮现。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>side[i][j] = 1 + minOf(side[i - 1][j], side[i][j - 1], side[i - 1][j - 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>第一行的每个格子没有上面，只能形成边长为1的正方形。<br>第一列的每个格子没有左面，只能形成边长为1的正方形。</p>
<h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p>记录最大的<code>side[i][j]</code>，再求平方就是最终结果</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>必须遍历完二维数组所有元素才能完成求解，并且只需要遍历一次，时间复杂度O(mn)。<br>需要记录<code>side</code>二维数组，空间复杂度O(mn)。</p>
<h3 id="代码（kotlin"><a href="#代码（kotlin" class="headerlink" title="代码（kotlin)"></a>代码（kotlin)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        side[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxLength = maxOf(maxLength, side[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            side[i][<span class="number">0</span>] = <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[i][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            side[<span class="number">0</span>][j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[<span class="number">0</span>][j])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    side[i][j] = <span class="number">1</span> + minOf(side[i - <span class="number">1</span>][j], side[i][j - <span class="number">1</span>], side[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                    maxLength = maxOf(maxLength, side[i][j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>状态转移只与左、上、左上三个状态有关，不需要记录所有状态。</p>
<p>由于状态递推是从左到右遍历二维数组的，所以至少要存储一行的记录，否则要是只用三个变量记录上一个状态，换行从第1列开始递推的时候，你不知道左、上、左上的状态了。</p>
<p>但是一行缓存记录还不够，因为要读取左边和左上方的状态，在从左到右递推的时候，左上方的值被覆盖了，只能读取到左边的状态，所以要多记录上一行的状态，以便读取左上方的状态。</p>
<p>空间复杂度O(m)</p>
<p>如果<code>m &gt; n</code>，按列遍历列表，跟按行遍历是一样的，可以做到O(n)空间复杂度，这里不再编写，形式相似。在n远小于m时这样做才有意义。</p>
<h3 id="优化的代码（kotlin）"><a href="#优化的代码（kotlin）" class="headerlink" title="优化的代码（kotlin）"></a>优化的代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalSquare</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> side = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一行状态</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            side[j] = <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            maxLength = maxOf(maxLength, side[j])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储上一行状态，以方便接下来读取左上方的状态</span></span><br><span class="line">        <span class="keyword">val</span> pre = side.copyOf()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">	                <span class="comment">// side[j - 1]: 左方状态</span></span><br><span class="line">					<span class="comment">// pre[j - 1]: 左上方状态</span></span><br><span class="line">					<span class="comment">// pre[j]: 上方状态</span></span><br><span class="line">                    side[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + minOf(side[j - <span class="number">1</span>], pre[j - <span class="number">1</span>], pre[j])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    side[j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = maxOf(maxLength, side[j])</span><br><span class="line">            &#125;</span><br><span class="line">            side.copyInto(pre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength * maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.23.合并K个升序链表（困难）</title>
    <url>/LeetCode/LeetCode.23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode.23.合并K个升序链表（困难）</a></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h2><p>普通二路归并排序直接比较两个链表首元素即可。</p>
<p><strong>多个链表首元素怎么比较？</strong></p>
<p>用优先队列，构建小顶堆，每次加入一个节点，优先队列会调整堆把最小的元素放在堆顶。</p>
<p>调整一次堆需要<code>O(log k)</code>时间，<code>k</code>为列表个数。</p>
<p>由于要把所有节点都加入堆中，设链表节点总数为<code>n</code>，总时间复杂度为<code>O(n * log k)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;ListNode&gt; &#123; n1, n2 -&gt; n1.`<span class="keyword">val</span>` - n2.`<span class="keyword">val</span>` &#125;</span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> p: ListNode? = dummy</span><br><span class="line">        lists.forEach &#123; node -&gt; <span class="keyword">if</span> (node != <span class="literal">null</span>) pq.add(node) &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> smallest = pq.poll()</span><br><span class="line">            <span class="keyword">if</span> (smallest.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(smallest.next)</span><br><span class="line">            &#125;</span><br><span class="line">            p?.next = smallest</span><br><span class="line">            p = p?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> newHead = dummy.next</span><br><span class="line">        dummy.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：分治"><a href="#解法2：分治" class="headerlink" title="解法2：分治"></a>解法2：分治</h2><p>对所有链表两两归并，这样每次链表数量减半，假设总共有k个链表，需要归并<code>log k</code>次。</p>
<p>假设所有链表结点总数为<code>n</code>，每一次的两两归并都要遍历所有结点，所以总时间复杂度为<code>O(n * log k)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) <span class="keyword">return</span> lists[low]</span><br><span class="line">        <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">val</span> l1 = merge(lists, low, mid);</span><br><span class="line">        <span class="keyword">val</span> l2 = merge(lists, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeTwoList</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> tail: ListNode? = dummy</span><br><span class="line">        <span class="keyword">var</span> p1 = l1</span><br><span class="line">        <span class="keyword">var</span> p2 = l2</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.`<span class="keyword">val</span>` &lt; p2.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                tail?.next = p1</span><br><span class="line">                p1 = p1?.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail?.next = p2</span><br><span class="line">                p2 = p2?.next</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail?.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail?.next = <span class="keyword">if</span> (p1 != <span class="literal">null</span>) p1 <span class="keyword">else</span> p2</span><br><span class="line">        <span class="keyword">val</span> newHead = dummy.next</span><br><span class="line">        dummy.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>优先队列</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.25.K 个一组翻转链表（困难）</title>
    <url>/LeetCode/LeetCode.25.K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">LeetCode.25.K 个一组翻转链表（困难）</a></p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>进阶：</p>
<p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>每组翻转后最关键的在于每一组的头尾节点变化了，要把每组重新正确的连接上，梳理整个翻转过程就比较清楚了。</p>
<p>从左到右找到第k个节点，相当于知道了一组节点的头节点和尾节点，对这一组节点进行翻转，记录翻转后的尾节点，在下一组翻转过后，把上一组记录的新尾节点指向下一组的新头节点即可。</p>
<p><strong>边界处理</strong></p>
<p>如果发现最后一组不足k个，不做翻转。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseKGroup</span><span class="params">(head: <span class="type">ListNode</span>?, k: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> tail: ListNode? = head</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line">            tail = tail.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> newHead = reverse(head, tail)</span><br><span class="line">        head.next = reverseKGroup(tail, k)</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表，返回新链表头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverse</span><span class="params">(head: <span class="type">ListNode</span>?, tail: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> pre: ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> cur: ListNode? = head</span><br><span class="line">        <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = cur?.next</span><br><span class="line">            cur?.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n)：n为链表节点总数。<br>空间复杂度O(n/k)：递归一次占用一个方法栈，空间占用多少就看递归深度多少，n个节点每次划分k个一组，一共要递归n/k次。</p>
</blockquote>
<p><strong>迭代</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果一边遍历一边翻转，最后一段长度不足k时也反转了就不对了，所以得先有一个指针往后探路，探到有路了再进行反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseKGroup</span><span class="params">(head: <span class="type">ListNode</span>, k: <span class="type">Int</span>)</span></span>: ListNode &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个虚节点，这样可以统一操作链表的代码，不用做边界情况处理</span></span><br><span class="line">        <span class="keyword">val</span> dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummyHead.next = head</span><br><span class="line">        <span class="comment">// 2. 开拓者指针，往后走k次，如果走了k次后，开拓者不为null，说明是有k个节点，可以翻转；初始时还没走，所以应该在头节点的前一个位置</span></span><br><span class="line">        <span class="keyword">var</span> pioneer: ListNode? = dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 记录当前待翻转区域前面的一个节点，用于把之前已反转的部分跟当前区域反转后重新连接起来，初始时是头节点的前一个节点</span></span><br><span class="line">        <span class="keyword">var</span> predecessor: ListNode? = dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. while循环一开始可能不知道是什么条件，可以先写while(true)，先写遍历代码</span></span><br><span class="line">        <span class="comment">// 13. pioneer探路前，指向的是要翻转的区域的前驱结点，如果不存在要翻转的区域，就不用遍历了，如果还有要翻转的区域则需要继续探路；如果后面不足k个节点，会在循环内break</span></span><br><span class="line">        <span class="keyword">while</span> (pioneer?.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 4. 开拓者要探k次路，如果后面不足k个结点，pioneer应当为null</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                pioneer = pioneer?.next</span><br><span class="line">                <span class="keyword">if</span> (pioneer == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 一开始还没开始翻转，就发现链表不足k个节点的话，按照题意不用翻转，所以就什么都不用做了，先break</span></span><br><span class="line">            <span class="keyword">if</span> (pioneer == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. pioneer不为null，说明是有k个节点的，可以翻转</span></span><br><span class="line">            <span class="comment">// 翻转主要是要解决翻转区域前后节点的连接问题，翻转后翻转区域的头尾都变了</span></span><br><span class="line">            <span class="comment">// 需要把翻转区域前后节点先保存下来，翻转后再重新连接翻转区域到主链表上</span></span><br><span class="line">            <span class="comment">// 当前待翻转区域尾节点就是pioneer，翻转区域后面的节点就是pioneer.next</span></span><br><span class="line">            <span class="keyword">val</span> successor = pioneer?.next</span><br><span class="line">            <span class="comment">// 翻转区域前面的节点还没有记录过，需要有个变量记录一下，到上面定义一下</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 翻转链表链表需要知道头结点，需要记录待翻转区域头节点，翻转后这个节点就变成了尾节点</span></span><br><span class="line">            <span class="keyword">val</span> newTail = predecessor?.next</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 把当前正要翻转区域跟主链表断开连接再做翻转，这样会比较方便，因为本来就是要重新连接的，最后再重新连接上</span></span><br><span class="line">            predecessor?.next = <span class="literal">null</span></span><br><span class="line">            pioneer?.next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10. 翻转链表</span></span><br><span class="line">            <span class="keyword">val</span> newHead = reverse(newTail)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 11. 重新把翻转后的链表连接到原链表</span></span><br><span class="line">            predecessor?.next = newHead</span><br><span class="line">            newTail?.next = successor</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12. 重置前驱指针和开拓者指针，都指向当前翻转区域的尾节点</span></span><br><span class="line">            predecessor = newTail</span><br><span class="line">            pioneer = newTail</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的头节点</span></span><br><span class="line">        <span class="keyword">val</span> newHead = dummyHead.next</span><br><span class="line">        dummyHead.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转链表，返回翻转后的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverse</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> pre: ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> cur: ListNode? = head</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n)：n为链表节点总数，需要遍历所有节点。<br>空间复杂度O(1)：只用了常数个变量。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.264.丑数 II（中等）</title>
    <url>/LeetCode/LeetCode.264.%E4%B8%91%E6%95%B0%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II（中等）</a></p>
<p>给你一个整数  <code>n</code>  ，请你找出并返回第  <code>n</code>  个  <strong>丑数</strong>  。<br><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code>  和/或 <code>5</code> 的正整数。<br>提示：<code>1 &lt;= n &lt;= 1690</code></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：优先队列"><a href="#解法1：优先队列" class="headerlink" title="解法1：优先队列"></a>解法1：优先队列</h3><p>根据丑数定义，除了1这个丑数，其他丑数都是从小的丑数乘以2或3或5得到，那么递推就好了。</p>
<p>主要问题是，几个小的丑数乘以2、3、5后的丑数，你不知道哪个大哪个小，不好确定下一个丑数是哪个。比如：</p>
<ol>
<li>丑数3乘以质因数后得到丑数：6、9、15。</li>
<li>丑数4乘以质因数后得到丑数：8、12、20。</li>
</ol>
<p>所以需要排个序，由于参与排序的元素位置和个数并不确定，所以需要在线算法实现，优先队列（堆）恰好适合元素不确定的排序，入队和出队时调整堆只需要O(log n)的时间复杂度。</p>
<p>还有个问题是要去重，比如 <code>丑数4 * 3 = 12</code>， <code>丑数6 * 2 = 12</code>，丑数肯定不重复，从优先队列取出元素后，检查有重复去去除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            pq.add(u * <span class="number">2</span>)</span><br><span class="line">            pq.add(u * <span class="number">3</span>)</span><br><span class="line">            pq.add(u * <span class="number">5</span>)</span><br><span class="line">            u = pq.remove()</span><br><span class="line">            <span class="keyword">while</span> (pq.isNotEmpty() &amp;&amp; pq.peek() == u) pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用哈希表来去重，用空间换时间，出队入队还是要占用一点不必要的时间的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是小顶堆</span></span><br><span class="line">        <span class="keyword">val</span> pq = PriorityQueue&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> factors = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">var</span> u = <span class="number">1L</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (factor <span class="keyword">in</span> factors) &#123;</span><br><span class="line">                <span class="keyword">val</span> nextU = u * factor</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nextU)) &#123;</span><br><span class="line">                    pq.add(nextU)</span><br><span class="line">                    visited.add(nextU)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            u = pq.remove()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：三指针"><a href="#解法2：三指针" class="headerlink" title="解法2：三指针"></a>解法2：三指针</h3><p>3个质因数都要跟每个丑数乘一次，相当于形成3个丑数序列，每次取3个序列中最小值，作为新数组的元素，这很像归并排序，可以用3个指针3路归并。</p>
<p>已经递推出来的丑数要用数组记录下来，因为3个指针位置不确定，可能某个指针会访问到以前较小的丑数。</p>
<p>由于不能有重复值，再取完3个序列左边最小值后，要把相同值给跳过。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nthUglyNumber</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p3 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p5 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> u = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        u[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">val</span> v2 = u[p2] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> v3 = u[p3] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">val</span> v5 = u[p5] * <span class="number">5</span></span><br><span class="line">            <span class="keyword">val</span> nextU = minOf(v2, v3, v5)</span><br><span class="line">            <span class="comment">// 多个序列有重复元素要跳过，丑数不能有重复</span></span><br><span class="line">            <span class="keyword">if</span> (nextU == v2) p2++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v3) p3++</span><br><span class="line">            <span class="keyword">if</span> (nextU == v5) p5++</span><br><span class="line">            u[i] = nextU</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.279.完全平方数（中等）</title>
    <url>/LeetCode/LeetCode.279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-squares/">LeetCode.279.完全平方数（中等）</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h3><p>给定一个目标，有一组选择，做出选择，得出最优的结果，就是背包问题。<br>完全平方数没有限定选择个数，所以是完全背包问题。</p>
<p>设<code>dp[i]</code>表示和为i的完全平方数的最少数量。<br>对于每个<code>dp[i]</code>求解，从小到大穷举所有可选的完全平方数做出一次选择，挑选一个使用平方数数量最少的。</p>
<p>状态转移方程<br><code>dp[i] = minOf(dp[i], 1 + dp[i - j * j] + 1</code>，其中<code>1 &lt;= j &lt;= i</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numSquares</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i]表示和为i的完全平方数的最少数量</span></span><br><span class="line">        <span class="comment">// dp[0]没意义</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// dp[i]最多数量就是全部1相加，当做默认值，看有没有小的</span></span><br><span class="line">            dp[i] = i</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (j * j &lt;= i) &#123;</span><br><span class="line">                dp[i] = minOf(dp[i], <span class="number">1</span> + dp[i - j * j])</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：$O(n *\sqrt{n})$<br>空间复杂度：$O(n)$</p>
</blockquote>
<h3 id="解法2：bfs"><a href="#解法2：bfs" class="headerlink" title="解法2：bfs"></a>解法2：bfs</h3><p>如果先用递归求解，画出递归树就很好想象了。<br>可以进行层序遍历一层一层的算。<br>第一层依次减去一个平方数得到第二层；<br>第二层依次减去一个平方数得到第三层；<br>每递进一层，使用过的平方数个数加1；<br>当某一层出现了0，当前层数就是答案。</p>
<p><strong>注意点</strong><br>因为会有重叠子问题，所以要避免重复纳入已经计算过的节点，用visited数组记录访问过的节点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numSquares</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        queue.add(n)</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            level++</span><br><span class="line">            <span class="keyword">val</span> size = queue.size</span><br><span class="line">            repeat(size) &#123;</span><br><span class="line">                <span class="keyword">val</span> num = queue.poll()</span><br><span class="line">                visited.add(num)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (j * j &lt;= num) &#123;</span><br><span class="line">                    <span class="keyword">val</span> small = num - j * j</span><br><span class="line">                    <span class="keyword">if</span> (small == <span class="number">0</span>) <span class="keyword">return</span> level</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(small)) &#123;</span><br><span class="line">                        queue.add(small)</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.30.串联所有单词的子串（困难）</title>
    <url>/LeetCode/LeetCode.30.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">LeetCode.30.串联所有单词的子串（困难）</a></p>
<p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力推导"><a href="#暴力推导" class="headerlink" title="暴力推导"></a>暴力推导</h3><ol>
<li>穷举出所有s可能的子串。</li>
<li>对每个子串检查能不能拿words中所有单词串联得出。</li>
</ol>
<h3 id="穷举出所有s可能的子串，有什么优化？"><a href="#穷举出所有s可能的子串，有什么优化？" class="headerlink" title="穷举出所有s可能的子串，有什么优化？"></a>穷举出所有s可能的子串，有什么优化？</h3><p>题目要求恰好可以用words中所有单词串联形成的子串，所以子串的长度是确定的，只要穷举这个特定长度所有子串就行了，不需要穷举所有长度的子串。</p>
<p>其实这就相当于弄一个滑动窗口依次检测。</p>
<h3 id="怎么检查子串能不能拿words中所有单词串联得出？"><a href="#怎么检查子串能不能拿words中所有单词串联得出？" class="headerlink" title="怎么检查子串能不能拿words中所有单词串联得出？"></a>怎么检查子串能不能拿words中所有单词串联得出？</h3><p>按道理得组合所有words中单词的情况。</p>
<p>但是题目说所有单词长度相同，假设长度为n，可以把大子串再分割成m分长度为n的小子串，看小子串是不是在words里。</p>
<p>检查一个东西是不是在某个集合里，可以想到用哈希表，用O(1)时间查询得出结果。</p>
<p>但是哈希表不能存储相同的单词，所以要给重复出现的单词计数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findSubstring</span><span class="params">(s: <span class="type">String</span>, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (words.isEmpty()) <span class="keyword">return</span> emptyList()</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> wordCount = words.size</span><br><span class="line">        <span class="comment">// 每个单词的长度</span></span><br><span class="line">        <span class="keyword">val</span> wordLength = words.first().length</span><br><span class="line">        <span class="comment">// 生成哈希表：记录每个单词有多少个</span></span><br><span class="line">        <span class="keyword">val</span> allWords = words.groupingBy &#123; it &#125;.eachCount()</span><br><span class="line">        <span class="comment">// 穷举所有可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.(s.length - wordCount * wordLength)) &#123;</span><br><span class="line">            <span class="keyword">val</span> countMap = mutableMapOf&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; wordCount) &#123;</span><br><span class="line">	            <span class="comment">// 子串按单词长度切片，检查每一片是否在单词列表里</span></span><br><span class="line">                <span class="keyword">val</span> word = s.substring(i + j * wordLength, i + (j + <span class="number">1</span>) * wordLength)</span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(word)) &#123;</span><br><span class="line">                    <span class="comment">// 注意对重复单词计数，单词在子串中出现过的次数与在words出现的次数应该一致</span></span><br><span class="line">                    <span class="keyword">val</span> count = countMap.getOrDefault(word, <span class="number">0</span>)</span><br><span class="line">                    countMap[word] = count + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> (countMap[word]!! &gt; allWords[word]!!) &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span></span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == wordCount) &#123;</span><br><span class="line">                result.add(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度O(mn)：<br>假设字符串s长度为m，滑动窗口穿过整个s，最坏情况下滑动窗口大小为1，需要移动m次。<br>判断每个滑动窗口的子串是不是能由words所有单词组成，最坏情况需要遍历words所有单词，假设words长度为n，就就要遍历n次。</p>
<p>空间复杂度O(n)：<br>用哈希表记录words中所有单词出现的次数。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.300.最长递增子序列（中等）</title>
    <url>/LeetCode/LeetCode.300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">LeetCode.300.最长递增子序列（中等）</a></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，看能不能把大问题先拆分为子问题+有限步骤。</p>
<p><strong>如果已知最长严格递增子序列，它是怎么得来的呢？上一步的最小操作是什么？</strong></p>
<ul>
<li>如果前面没有递增子序列，当前字符作为新的递增子序列起点。</li>
<li>如果前面有了递增子序列，当前字符比前面子序列最后一个数字大，可以形成新的递增子序列，长度加1。</li>
</ul>
<p><strong>前面的递增子序列可能有很多个，应该追加到哪个递增子序列的后面？</strong><br>找长度最大的递增子序列。</p>
<p><strong>数组前面的部分又是怎么找到最长递增子序列的？</strong><br>还是一样的拆解，递归进行，这里划分出了子问题+有限步骤。</p>
<ul>
<li>子问题是最优的，经过有限步骤得出下一个问题的最优解，符合最优子结构。</li>
<li>子问题的结果不受更大问题的影响，无后效性。</li>
<li>计算长的子数组的最长递增子序列的长度，都要访问前面的递增子序列的长度，有重叠子问题。</li>
</ul>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i]</code>为以<code>nums[i]</code>结尾的最长递增子序列的长度。<br>遍历<code>nums[0, i - 1]</code>，寻找<code>j</code>（<code>0 &lt;= j &lt;= i - 1</code>）：</p>
<ul>
<li>对于所有满足<code>nums[i] &gt; nums[j]</code>的<code>j</code>，找出最大<code>dp[j]</code>，<code>dp[i] = 1 + 最大的dp[j]</code>。</li>
<li>如果<code>nums[i]</code>比<code>nums[0, i - 1]</code>都小，<code>dp[i] = 1</code>。</li>
</ul>
<p><strong>复杂度</strong><br>时间复杂度$O(n^2)$：<br>计算所有<code>dp[i]</code>得遍历整个数组，需要$O(n)$；<br>计算每个<code>dp[i]</code>需要遍历<code>[0, i - 1]</code>，即$O(n)$。<br>双循环共执行<code>1 + 2 + 3 + ... + n - 1 = (1 + n - 1) * (n - 1) / 2 = n(n - 1) / 2次</code>。</p>
<p>空间复杂度$O(n)$：<br><code>dp</code>数组占用线性空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLIS</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> preMaxLen = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    preMaxLen = maxOf(preMaxLen, dp[j])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = <span class="number">1</span> + preMaxLen</span><br><span class="line">            maxLen = maxOf(maxLen, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间优化</strong></p>
<p><strong>计算所有<code>dp[i]</code>的时间能不能优化？</strong><br>计算所有<code>dp[i]</code>必须要遍历整个数组，无法优化。</p>
<p><strong>计算每个<code>dp[i]</code>的时间能不能优化？</strong><br>先看计算单个<code>dp[i]</code>的过程：<br>是要在已经发现的递增子序列中看<code>nums[i]</code>能接到哪些子序列后面，再在能接上去的这些子序列中找一个长度最大的。</p>
<p><strong>直接找之前最长子序列的去接行不行？</strong><br>行，如果能接上肯定最好。</p>
<p><strong>如果接不上最长的，还有必要去接短的递增子序列吗？</strong><br>有必要的，比如数组<code>[1, 6, 7, 2, 3, 4]</code>，有递增子序列是<code>[1]</code>、<code>[1, 6]</code>和<code>[1, 6, 7]</code>，2是接不到<code>[1, 6, 7]</code>后面的，但是可以接在<code>[1]</code>后面形成<code>[1, 2]</code>，最后遇到3和4，可以接在<code>[1, 2]</code>后面形成长度为4的递增子序列，比<code>[1, 6, 7]</code>还要长。</p>
<p>这里就引发一个问题，如果<strong>之前最长的子序列可能会有多个，应该去接哪个？</strong><br>跟末尾元素最小的比较，是最快的；否则要是接不上，得比较多次。<br>比如上面长度为2的子序列有<code>[1, 6]</code>和<code>[1, 2]</code>，后面遇到3和4肯定直接跟2比较，比较次数是最少的。</p>
<p>所以如果当前数字接不到最长的，但是能接到短的子序列后面，如果当前数字比之前子序列末尾元素小，接上去对后面接更长的子序列是有意义的。</p>
<p><strong>能否在查找方法上做优化？</strong><br>一说到查找和比较，就能想到最优化的查找元素方法是二分查找，可以把时间复杂度降低到$O(log n)$。</p>
<p>二分查找是要求在有序数组里做查找比较的，那就把递增子序列的末尾数字从小到大排序。</p>
<p>我们想通过比较末尾元素，是想更新某个长度的递增子序列的末尾元素为更小的。</p>
<p>递增子序列末尾元素的大小顺序和子序列的长度有没有什么关联？</p>
<p>可以发现，如果相同长度的子序列只保留最小的末尾数字，那么长度大的子序列的末尾元素一定比长度小的子序列的末尾元素大。<br>因为只有新的数字比原来短的递增子序列的末尾元素大，才能形成长度更长的递增子序列；如果新的数字比原来短的递增子序列的末尾元素小，是无法形成长度更长的递增子序列的。</p>
<hr>
<p><strong>能否在查找方法上做优化？</strong><br>一说到查找和比较，就能想到最优化的查找元素方法是二分查找，可以把时间复杂度降低到$O(log n)$。</p>
<p>二分查找是要求在有序数组里做查找比较的，那就把递增子序列的末尾数字从小到大排序。<br>新的数字去二分比较后，能否确定新数字可以拼接的子序列最长长度？只有能确定，才可以不跟所有末尾数字比较，二分查找才能节约出时间，否则还得顺序扫描所有元素。</p>
<p>换句话说，递增子序列末尾元素的大小顺序和子序列的长度有没有什么关联？</p>
<p>可以发现，如果相同长度的子序列只保留最小的末尾数字，那么长度大的子序列的末尾元素一定比长度小的子序列的末尾元素大。<br>因为只有新的数字比原来短的递增子序列的末尾元素大，才能形成长度更长的递增子序列；如果新的数字比原来短的递增子序列的末尾元素小，是无法形成长度更长的递增子序列的；如果新数字比某长度的递增子序列的最小的末尾数字都要小，那肯定是无法接在它后面形成长度更长的递增子子序列了。</p>
<p>所以二分查找是可行的，可以保存每个长度的递增子序列的最小末尾数字形成数组，递增子序列长度作为数组索引，数组元素默认就是严格递增。<br>遇到新的数字用二分查找，就可以知道应该更新哪个长度的子序列的末尾元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLIS</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// dp[i]表示以长度为i + 1的所有上升子序列中结尾最小的数，0 &lt;= i &lt;= n - 1，n为数组长度</span></span><br><span class="line">        <span class="comment">// 由于上升子序列的长度可能是小于n的，所以这里创建动态列表来作为状态存储</span></span><br><span class="line">        <span class="keyword">val</span> dp = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp.add(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 可以形成更长的子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; dp.last()) &#123;</span><br><span class="line">                dp.add(nums[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不能形成更长的子序列，但是要更新之前子序列末尾的元素为更小的，方便后续快速比较</span></span><br><span class="line">                <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">                <span class="keyword">var</span> right = dp.size - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">when</span> &#123;</span><br><span class="line">                        <span class="comment">// 要找比子序列末尾元素大的位置，所以不会是mid本身，要mid + 1</span></span><br><span class="line">                        dp[mid] &lt; nums[i] -&gt; left = mid + <span class="number">1</span></span><br><span class="line">                        <span class="comment">// dp[mid] &gt; nums[i]，dp严格递增，不存在dp[mid] == nums[i]</span></span><br><span class="line">                        <span class="keyword">else</span> -&gt; right = mid - <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 熟悉二分法可知，循环结束后，一定会有 nums[left - 1] &lt; nums[i] &lt; nums[left]</span></span><br><span class="line">                <span class="comment">// 更新子序列末尾元素为更小的</span></span><br><span class="line">                dp[left] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</title>
    <url>/LeetCode/LeetCode.304.%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LeetCode.304.二维区域和检索 - 矩阵不可变（中等）</a></p>
<p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<ul>
<li>计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。<br>实现 NumMatrix 类：</li>
<li>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化</li>
<li>int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。<span id="more"></span></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>与<a href="https://leetcode-cn.com/problems/matrix-block-sum/">LeetCode.1314.矩阵区域和</a>思路相同。</p>
<p>NumMatrix.sumRegion()要想做到O(1)时间复杂度查询，就要提前计算好二位前缀和。</p>
<p>设<code>preSum[i][j]</code>为<code>[0, 0]</code>到<code>[i, j]</code>矩形区域所有元素和。</p>
<p>求矩形区域d的元素和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a a a b b b b b   </span><br><span class="line">a a a b b b b b</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br><span class="line">c c c d d d d d</span><br></pre></td></tr></table></figure>
<p><code>区域d所有元素和 = 整个区域所有元素和 - 区域a所有元素和- 区域b所有元素和 - 区域c所有元素和</code></p>
<p>设矩形d左上角坐标<code>(x1, y1)</code>，右下角坐标<code>(x2, y2)</code>。<br><code>整个区域所有元素和 = preSum[x2][y2]</code><br><code>区域a所有元素和 + 区域b所有元素和 = preSum[x1 - 1][y2]</code><br><code>区域a所有元素和 + 区域c所有元素和 = preSum[x2][y1 - 1]</code></p>
<p>所以:<br><code>区域d所有元素和 = preSum[x2][y2] - preSum[x1 - 1][y2] - preSum[x2][y1 - 1] + preSum[x1 - 1][y1 - 1]</code></p>
<p>遇到边界特殊处理一下就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span></span>(matrix: Array&lt;IntArray&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> m = matrix.size</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> preSum = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 求二维前缀和</span></span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            preSum[<span class="number">0</span>][j] = preSum[<span class="number">0</span>][j - <span class="number">1</span>] + matrix[<span class="number">0</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            preSum[i][<span class="number">0</span>] = preSum[i - <span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> left = preSum[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">val</span> top = preSum[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">val</span> leftTop = preSum[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                preSum[i][j] = left + top - leftTop + matrix[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sumRegion</span><span class="params">(row1: <span class="type">Int</span>, col1: <span class="type">Int</span>, row2: <span class="type">Int</span>, col2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> all = preSum[row2][col2]</span><br><span class="line">        <span class="keyword">val</span> left = <span class="keyword">if</span> (col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row2][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> top = <span class="keyword">if</span> (row1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col2]</span><br><span class="line">        <span class="keyword">val</span> leftTop = <span class="keyword">if</span> (row1 == <span class="number">0</span> || col1 == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> preSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> all - left - top + leftTop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.309.最佳买卖股票时机含冷冻期（中等）</title>
    <url>/LeetCode/LeetCode.309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode.309.最佳买卖股票时机含冷冻期（中等）</a></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最优化问题考虑用动态规划。</p>
<h3 id="步骤拆分"><a href="#步骤拆分" class="headerlink" title="步骤拆分"></a>步骤拆分</h3><p>第<code>i</code>天的基本操作有：买入、卖出、什么都不做。<br>买入有冷冻期限制，第i天可能无法买入，也就是只能什么都不做了，所有的操作还是这三种，不影响确定最终状态。<br>经过选择操作后可得第i天的最终状态只有：持有股票或不持有股票。<br>买入冷冻期的限制在状态转移方程中做状态转移时体现出来就行。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[i][k]</code>为前<code>i</code>天最大利润，<code>k = 0</code>表示第<code>i</code>天不持有股票，<code>k = 1</code>表示第<code>i</code>天持有股票。</p>
<p><code>dp[i][0]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1</code>天一样</li>
<li>之前持有股票，第<code>i</code>天卖出</li>
</ol>
<p>可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code></p>
<p><code>dp[i][1]</code>有两种可能的操作得到：</p>
<ol>
<li>第<code>i</code>天什么都不做，利润和前<code>i - 1天</code>一样</li>
<li>之前不持有股票，第<code>i</code>天买入；买入有冷冻期限制，如果是第<code>i - 1</code>天卖出的，第<code>i</code>天就不能买入了。</li>
</ol>
<p>可得<code>dp[i][1] = max(dp[i - 1], dp[i - 2][0] - prices[i])</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i][k]</code>只与前面两个状态有关，用变量记录前面的状态，不需要数组记录所有状态。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 0</span></span><br><span class="line">        <span class="keyword">var</span> preNoholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> preHoldProfit = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i == 1</span></span><br><span class="line">        <span class="keyword">var</span> curNoholdProfit = maxOf(preNoholdProfit, preHoldProfit + prices[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> curHoldProfit = maxOf(preHoldProfit, preNoholdProfit - prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(curNoholdProfit, curHoldProfit + prices[i])</span><br><span class="line">            <span class="comment">// 买入有冷冻期，只能从前天没有持有股票的状态转移而来</span></span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(curHoldProfit, preNoholdProfit - prices[i])</span><br><span class="line"></span><br><span class="line">            preNoholdProfit = curNoholdProfit</span><br><span class="line">            preHoldProfit = curHoldProfit</span><br><span class="line"></span><br><span class="line">            curNoholdProfit = newNoholdProfit</span><br><span class="line">            curHoldProfit = newHoldProfit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curNoholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.31.下一个排列（中等）</title>
    <url>/LeetCode/LeetCode.31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/">LeetCode.31.下一个排列（中等）</a></p>
<p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="字典序是什么意思？"><a href="#字典序是什么意思？" class="headerlink" title="字典序是什么意思？"></a>字典序是什么意思？</h3><p>顾名思义，就跟字典里的单词排布顺序一样。</p>
<h3 id="字典序中下一个排列是什么意思？"><a href="#字典序中下一个排列是什么意思？" class="headerlink" title="字典序中下一个排列是什么意思？"></a>字典序中下一个排列是什么意思？</h3><p>只能查定义，然后举几个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 2 3 5 4</span><br><span class="line">1 2 4 3 5</span><br><span class="line">1 2 4 5 3</span><br><span class="line">1 2 5 3 4</span><br><span class="line">1 2 5 4 3</span><br></pre></td></tr></table></figure>
<p>每一个排列都是从小到大递增的。</p>
<p>总结下一个排列的大致规律：</p>
<ul>
<li>数字要变大</li>
<li>变大的幅度要最小</li>
</ul>
<p>具体怎么获取下一个排列，可以一步步推理分析。</p>
<h3 id="怎么增大一个普通的数？"><a href="#怎么增大一个普通的数？" class="headerlink" title="怎么增大一个普通的数？"></a>怎么增大一个普通的数？</h3><p>把某一位的数字变大。</p>
<h3 id="如何保证一个普通的数增大的幅度最小？"><a href="#如何保证一个普通的数增大的幅度最小？" class="headerlink" title="如何保证一个普通的数增大的幅度最小？"></a>如何保证一个普通的数增大的幅度最小？</h3><ul>
<li>在最低位做加法。</li>
<li>加最小的数字1。</li>
</ul>
<h3 id="增大给定的数字序列可以跟增大一个普通数字一样吗？"><a href="#增大给定的数字序列可以跟增大一个普通数字一样吗？" class="headerlink" title="增大给定的数字序列可以跟增大一个普通数字一样吗？"></a>增大给定的数字序列可以跟增大一个普通数字一样吗？</h3><p>不一样。</p>
<p>因为要找下一个排列，数字还是序列中的那些数，数字不能随便用，只能用给定的数字序列里的数字。</p>
<h3 id="那怎么增大给定的数字序列？"><a href="#那怎么增大给定的数字序列？" class="headerlink" title="那怎么增大给定的数字序列？"></a>那怎么增大给定的数字序列？</h3><ol>
<li>确定一个要变大的位，假设这一位数字为x。</li>
<li>再找一个比x的大的位，两个位的数字做交换，保证不使用额外数字。</li>
</ol>
<p>同时要变大的位尽可能是低位，才能保证增幅最小。</p>
<h3 id="具体需要怎样的条件，交换数字位后才能获得更大的数字序列？"><a href="#具体需要怎样的条件，交换数字位后才能获得更大的数字序列？" class="headerlink" title="具体需要怎样的条件，交换数字位后才能获得更大的数字序列？"></a>具体需要怎样的条件，交换数字位后才能获得更大的数字序列？</h3><p>某两位交换，一个是高位，一个是低位。</p>
<ul>
<li>如果 <code>高位数字 &gt;= 低位数字</code>，交换过后，整个数变得更小了。</li>
<li>只有在 <code>高位数字 &lt; 低位数字</code>时做交换，整个数才会变得更大。</li>
</ul>
<h3 id="应该选取哪个低位数字和哪个高位数字做交换？"><a href="#应该选取哪个低位数字和哪个高位数字做交换？" class="headerlink" title="应该选取哪个低位数字和哪个高位数字做交换？"></a>应该选取哪个低位数字和哪个高位数字做交换？</h3><p>刚才的分析明确了两个条件：</p>
<ul>
<li>要从低位往高位找数字位。</li>
<li>高位数字 &lt; 低位数字。</li>
</ul>
<p>也就是说，如果低位有一个非递增序列（递减或相等序列），可以确定要找的高位数字肯定不在这个非递增序列里的，否则交换后无法变得更大。</p>
<p><strong>那要找的高位数字在哪？</strong></p>
<p>一定是处在一个递增序列中，且位数尽可能低。</p>
<p>也就是从右到左发现的第一个递增序列中第二大的数。</p>
<p>比如[1, 2, 3, 8, 6, 1]，我们要找到的高位数字是3。</p>
<p>为什么不能是8？</p>
<ul>
<li>因为8要是高位，低位只能在8的右边找一个数，这两个是递减的，交换后不会让整体更大。</li>
<li>如果3是要找的高位，至少可以跟比3大的8互换，整体可以形成更大的数，并且3是最低的符合条件的位了。</li>
</ul>
<p>换成代码表达：<br>从右到左遍历<code>num</code>数组，一旦第一次发现<code>num[i - 1] &lt; num[i]</code>，<code>num[i - 1]</code>就是要找到的高位数字。</p>
<p><strong>要找的低位数字在哪？</strong></p>
<p>现在有3个已知条件：</p>
<ul>
<li>要从低位往高位找。</li>
<li>高位数字 &lt; 低位数字。</li>
<li>高位数字位置已确定。</li>
</ul>
<p>高位数字位置已确定，低位数字位置的范围也就确定了，肯定在末尾的非递增序列里。</p>
<p>那么就从右到左遍历，寻找第一个大于高位数字的数就是要找的低位数字了。</p>
<p><strong>为什么要寻找第一个大于高位数字的数？</strong></p>
<p>假设：</p>
<ul>
<li>第一个大于高位数字的数去做交换后，得到的整个数变为a。</li>
<li>第二个大于高位数字的数去做交换后，得到的整个数变为b。</li>
</ul>
<p>可以发现<code>b &gt; a</code>，a是更大的数中增幅较小的那个，b不满足题目要求。</p>
<h3 id="交换后得到的新数字是下一个排列吗？"><a href="#交换后得到的新数字是下一个排列吗？" class="headerlink" title="交换后得到的新数字是下一个排列吗？"></a>交换后得到的新数字是下一个排列吗？</h3><p>回到最开始的例子，带入观察。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 2 3 5 4</span><br><span class="line">1 2 4 3 5</span><br><span class="line">1 2 4 5 3</span><br><span class="line">1 2 5 3 4</span><br><span class="line">1 2 5 4 3</span><br></pre></td></tr></table></figure>

<p>以<code>1 2 3 5 4</code>为例，要找的高位是3、低位是4，交换后得到<code>1 2 4 5 3</code>，但不是下一个排列，下一个排列是是<code>1 2 4 3 5</code>。<br>两者区别在于，交换后低位的<code>5 3</code>变成了<code>3 5</code>才算是更小的排列。</p>
<h3 id="交换后怎么得到下一个排列？"><a href="#交换后怎么得到下一个排列？" class="headerlink" title="交换后怎么得到下一个排列？"></a>交换后怎么得到下一个排列？</h3><p>把末尾递减序列变成递增序列，就是更大的排列中最小的那个排列，也就是下一个排列。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>四步走：</p>
<ul>
<li>从右到左寻找第一个递增序列，确定高位<code>x</code>。</li>
<li>从右到左寻找第一个大于<code>x</code>的低位<code>y</code>。</li>
<li>交换<code>x</code>和<code>y</code>。</li>
<li>把高位右边的递减序列从小到大排序。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>如果序列完全递减，找不到递增序列，要做边界判断。</p>
<h3 id="如何高效的排序递减序列？"><a href="#如何高效的排序递减序列？" class="headerlink" title="如何高效的排序递减序列？"></a>如何高效的排序递减序列？</h3><p>这里可以不需要排序算法，递减序列变递增序列只需要用双指针不停的首尾交换就行了，这样只需要O(n)时间，避免了排序的O(n * log n)。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度O(n)：n为序列长度，寻找递增序列、寻找低位、递增变递减最多遍历完整个序列，都是O(n)时间，线性叠加还是O(n)。</li>
<li>空间复杂度O(1)。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextPermutation</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找要变大的位</span></span><br><span class="line">        <span class="keyword">var</span> i = n - <span class="number">2</span></span><br><span class="line">        <span class="comment">// 末尾是递减序列（或相等）就跳过，直到发现递增序列</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时若i == -1，说明序列全部递减</span></span><br><span class="line">        <span class="comment">// 若i &gt;= 1，说明发现了递增序列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过交换把数字序列变大，且增幅最小</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从末尾递减序列中从右向左找到第一个大于nums[i]的数</span></span><br><span class="line">            <span class="keyword">var</span> k = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= nums[k]) k--</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换后，变成更大的数，增幅最小</span></span><br><span class="line">            nums.swap(i, k)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 末尾递减序列变成递增序列，使得整体序列最小</span></span><br><span class="line">        <span class="keyword">var</span> start = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> end = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            nums.swap(start, end)</span><br><span class="line">            start++</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> nums = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> tmp = nums[i]</span><br><span class="line">        nums[i] = nums[j]</span><br><span class="line">        nums[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.32.最长有效括号（困难）</title>
    <url>/LeetCode/LeetCode.32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode.32.最长有效括号（困难）</a></p>
<p>给你一个只包含  <code>&#39;(&#39;</code> 和  <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h2><p>括号匹配时，左右括号数量相等，子串长度就是左右括号之和。</p>
<p>可以从左到右遍历字符串，记录左右括号的数量，通过数量来判断子串是否是是有效括号。</p>
<ul>
<li>当右括号数量大于左括号时，当前子串肯定不是有效的括号，计数对于累加有效括号子串已经无意义，可以清零，以便后续子串。</li>
<li>当左括号数量大于右括号，有可能还有匹配的右括号在后面，只要右括号数量跟左括号相等，就可以认定当前子串是有效的括记录子串长度，并比较最长的长度。<ul>
<li>这种情况下有可能最终左括号的数量一直大于右括号数量，导致无法触发记录，例如((((((((((())。</li>
<li>此时可以从右向左再遍历一次字符串，就可以触发到左右括号相等的时候，当左括号数量大于右括号，括号数量计数清零。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                left == right -&gt; maxLength = maxOf(maxLength, <span class="number">2</span> * right)</span><br><span class="line">                right &gt; left -&gt; &#123;</span><br><span class="line">                    left = <span class="number">0</span></span><br><span class="line">                    right = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.length - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left++</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                left == right -&gt; maxLength = maxOf(maxLength, <span class="number">2</span> * left)</span><br><span class="line">                right &lt; left -&gt; &#123;</span><br><span class="line">                    left = <span class="number">0</span></span><br><span class="line">                    right = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：栈"><a href="#解法2：栈" class="headerlink" title="解法2：栈"></a>解法2：栈</h2><h3 id="怎么计算有效括号长度？"><a href="#怎么计算有效括号长度？" class="headerlink" title="怎么计算有效括号长度？"></a>怎么计算有效括号长度？</h3><p>从左到右遍历字符串时，发现如果有一个子串是有效括号，要计算它的长度，就是用结束索引减去起始索引得到长度。所以的想办法记录左括号的起始索引。</p>
<h3 id="怎么存储索引比较合适？"><a href="#怎么存储索引比较合适？" class="headerlink" title="怎么存储索引比较合适？"></a>怎么存储索引比较合适？</h3><p>从左到右遍历发现右括号后，得知道左边有没有左括号，如果有，计算括号匹配长度是要知道这个左括号前面一个位置的索引。</p>
<p>如果发现了多个右括号，是要从右到左依次访问匹配的左括号前面一个位置的索引，遍历顺序和访问顺序相反，可以用栈来存储左括号索引。</p>
<p>遍历到右括号时，发现栈不为空说明有左括号，匹配到左括号出栈后，栈顶就是匹配的左括号的前一个位置的索引。</p>
<p>如果匹配的左括号出栈后栈为空，就要手动记录一下第一个左括号左边的索引。</p>
<h3 id="何时入栈？"><a href="#何时入栈？" class="headerlink" title="何时入栈？"></a>何时入栈？</h3><p>有效括号子串的第一个字符一定是一个左括号，因为如果开头是右括号则不是有效括号子串。<br>所以遇到左括号就要记录其索引，因为它有可能是一个长的有效括号子串的起始索引。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> left = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="comment">// 记录可能的有效括号子串的前一个位置，可以利用此索引计算子串的长度</span></span><br><span class="line">        <span class="keyword">var</span> prev = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">when</span> (s[i]) &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> -&gt; left.push(i)</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 遇到右括号，如果前面有左括号，说明匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (left.isNotEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 匹配的左括号从栈中移出</span></span><br><span class="line">                        left.pop()</span><br><span class="line">                        <span class="comment">// 如果前面还有左括号，这个左括号的索引是刚才有效括号子串的前一个位置</span></span><br><span class="line">                        <span class="comment">// 如果前面没有左括号了，读取遇到左括号前记录的位置，也是刚才有效括号子串的前一个位置</span></span><br><span class="line">                        <span class="keyword">val</span> prevOfStart = <span class="keyword">if</span> (left.isNotEmpty()) left.peek() <span class="keyword">else</span> prev</span><br><span class="line">                        <span class="comment">// 当前位置减去有效括号子串的前一个位置就是有效括号子串的长度</span></span><br><span class="line">                        <span class="keyword">val</span> length = i - prevOfStart</span><br><span class="line">                        <span class="comment">// 记录最大长度</span></span><br><span class="line">                        maxLength = max(maxLength, length)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 遇到右括号，但前面没有左括号，说明当前字符结尾的子串没办法构成有效括号</span></span><br><span class="line">                        <span class="comment">// 但后面的子串还有可能是有效的子串，记录当前位置，如果后面紧接着的子串是有效括号子串，可以利用此索引计算子串的长度</span></span><br><span class="line">                        prev = i</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：动态规划"><a href="#解法3：动态规划" class="headerlink" title="解法3：动态规划"></a>解法3：动态规划</h2><p>最值问题考虑用动态规划。尝试划分为子问题+有限步骤。</p>
<p>如果字符串s是一个有效的括号串，最后一个字符一定是右括号。</p>
<ul>
<li>如果最后一个字符不是右括号，去除最后一个字符查看前面的子串是不是有效括号，前面子串查看方法是一样的。</li>
<li>如果最后一个字符是右括号：<ul>
<li>倒数第二个字符是左括号，发生了一次匹配，有效括号长度可以加2了，再继续看前面的子串的有效括号的长度。</li>
<li>倒数第二个字符是右括号，得看前面的有没有左括号能跟最后一个右括号匹配上才行。</li>
</ul>
</li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; length = <span class="number">2</span> + longest(i - <span class="number">2</span>)</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = longest(i - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="comment">// 看前面有没有跟s[i]这个右括号匹配的左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// 匹配到左括号前面的有效括号子串长度还要加上</span></span><br><span class="line">                            length = <span class="number">2</span> + midLen + longest(left - <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (length &gt; maxLength) maxLength = length</span><br><span class="line">            longest(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        &#125;</span><br><span class="line">        longest(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记忆化递归</strong></p>
<p>暴力递归有很多重叠子问题。</p>
<p>例如两次longest(i - 1)和一次longest(i - 2)计算结果是一样的，但是都重复计算了。</p>
<p>需要记录中间计算状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i]</span><br><span class="line">            <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; length = <span class="number">2</span> + longest(i - <span class="number">2</span>)</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = longest(i - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="comment">// 看前面有没有跟s[i]这个右括号匹配的左括号</span></span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// 匹配到左括号前面的有效括号子串长度还要加上</span></span><br><span class="line">                            length = <span class="number">2</span> + midLen + longest(left - <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = length</span><br><span class="line">            <span class="keyword">if</span> (length &gt; maxLength) maxLength = length</span><br><span class="line">            longest(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        &#125;</span><br><span class="line">        longest(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>设<code>dp[i]</code>表示以字符<code>s[i]</code>结尾的最长有效的括号子串的长度。</p>
<p>状态转移方程按照递归的方式写就行了。</p>
<p>边界条件单独判断一下就OK。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestValidParentheses</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 从第2个字符开始遍历，一个字符无法形成有效括号</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">when</span> (s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="string">&#x27;(&#x27;</span> -&gt; dp[i] = <span class="number">2</span> + <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="number">0</span> <span class="keyword">else</span> dp[i - <span class="number">2</span>]</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                        <span class="keyword">val</span> midLen = dp[i - <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">val</span> left = i - <span class="number">1</span> - midLen</span><br><span class="line">                        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            dp[i] = <span class="number">2</span> + midLen + <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> dp[left - <span class="number">1</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = maxOf(maxLength, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.322.零钱兑换（中等）</title>
    <url>/LeetCode/LeetCode.322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">LeetCode.322.零钱兑换（中等）</a></p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一组东西中进行多种选择最终达到一个目标值，联想到背包问题，尝试划分子问题。</p>
<p>得到amount的上一步一定是从coins选择一个硬币得来的，但是不知道哪种选择所需的硬币数最少，那么就每个都试一下，取硬币数最少的。</p>
<p>选取一个硬币coin后，剩下amout - coin的金额是怎么得来的，也是同样的选择过程，并且这个子问题加上新的选择过程得到最优的最终结果，符合最优子结构。</p>
<p>如果一直选择先去有可能发现不能用选择过的硬币累加成amount，那就是无法组合。</p>
<p>如果一直选下去，发现可以凑成amount，记录选择过的硬币数量，同时每次对比最终取一个最少的硬币数量。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重叠子问题</strong><br>画出递归树，会发现会有重叠子问题，有大量的重复计算。<br>例如<code>coins = [1,2,4]</code>。<br>四次<code>select(amount - 1)</code>跟一次<code>select(amount - 4)</code>是重复计算的。<br>两次<code>select(amount - 2)</code>跟一次<code>select(amount - 4)</code>是重复计算的。</p>
<p><strong>记忆化递归</strong><br>消除重叠子问题就是记录中间计算结果。<br>计算的结果是硬币数，中间状态是跟<code>amount</code>有关，但是并不是0到<code>amount</code>都会有计算结果，所以可以用哈希表来存储中间状态，节省一点空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[amount] != <span class="literal">null</span>) memo[amount]!!</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = select(amount - coin)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, <span class="number">1</span> + count)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">            memo[amount] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上动态规划</strong></p>
<p>记忆化递归从大的amount往小的amount去算，也可以从小的amount去递推大的amount。<br>初始值<code>dp[0] = 0</code>要存储一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (a <span class="keyword">in</span> <span class="number">1.</span>.amount) &#123;</span><br><span class="line">            <span class="keyword">var</span> minCount = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">            <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">                <span class="keyword">val</span> count = dp.getOrDefault(a - coin, -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (count == -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">                minCount = minOf(minCount, count + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            dp[a] = <span class="keyword">if</span> (minCount == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> minCount</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[amount]!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.343.整数拆分（中等）</title>
    <url>/LeetCode/LeetCode.343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/integer-break/">LeetCode.343.整数拆分（中等）</a></p>
<p>给定一个正整数 _n_，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目已经说出了步骤，直接干。</p>
<p>穷举所有n可能被拆解的可能性，看哪种拆分的乘积最大。</p>
<p>n可以被拆解为<code>j</code>和<code>n - j</code>两个正整数，穷举所有的<code>j</code>，看哪个<code>j * (n - j)</code>最大就选哪个<code>j</code>，<code>1 &lt;= j &lt;= n - 1</code>。</p>
<p>题目说至少是拆分两个，还可以继续拆分，所以可以对<code>n - j</code>继续拆分，也可以不继续拆分。<br><code>n - j</code>继续拆解，就划分为子问题了。</p>
<p><strong>暴力递归拆解</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxProduct = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> i = n - j</span><br><span class="line">            maxProduct = maxOf(</span><br><span class="line">                maxProduct,</span><br><span class="line">                j * i,</span><br><span class="line">                j * integerBreak(i)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProduct</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记忆化递归</strong><br>存在很多重叠子问题，计算量过大，时间复杂度指数级别，需要记录中间计算结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            <span class="keyword">var</span> maxProduct = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> i = n - j</span><br><span class="line">                maxProduct = maxOf(</span><br><span class="line">                    maxProduct,</span><br><span class="line">                    j * i,</span><br><span class="line">                    j * integerBreak(i)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            memo[n] = maxProduct</span><br><span class="line">            <span class="keyword">return</span> maxProduct</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>设<code>dp[i]</code>为<code>i</code>拆解为多个正整数后的最大乘积。<br>先求出小的<code>dp[i]</code>再求大的；每个<code>dp[i]</code>穷举所有拆解情况。</p>
<pre><code class="kotlin">class Solution &#123;
    fun integerBreak(n: Int): Int &#123;
        val dp = IntArray(n + 1) &#123; 0 &#125;
        dp[2] = 1
        for (i in 2..n) &#123;
            for (j in 1 until i) &#123;
                dp[i] = maxOf(
                    dp[i],
                    j * (i - j),
                    j * dp[i - j]
                )
            &#125;
        &#125;
        return dp[n]
    &#125;
&#125;
```xxxxxxxxxx class Solution &#123;    fun coinChange(coins: IntArray, amount: Int): Int &#123;        val dp = mutableMapOf&lt;Int, Int&gt;()        dp[0] = 0        for (a in 1..amount) &#123;            var minCount = Int.MAX_VALUE            for (coin in coins) &#123;                val count = dp.getOrDefault(a - coin, -1)                if (count == -1) continue                minCount = minOf(minCount, count + 1)            &#125;            dp[a] = if (minCount == Int.MAX_VALUE) -1 else minCount        &#125;         return dp[amount]!!    &#125;&#125;kotlin
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.37.解数独（困难）</title>
    <url>/LeetCode/LeetCode.37.%E8%A7%A3%E6%95%B0%E7%8B%AC%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">LeetCode.37.解数独（困难）</a></p>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ul>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右从上到下遍历所有没有填空的位置，尝试去填数字；填过的位置就跳过。</p>
<p>填过的数字就不能再用了，但是不知道填哪个数字，所以要尝试所有的可能性，采用暴力回溯解法。</p>
<p>填数字时要有三个限制条件，都是保证数字不重复，那么就要存储已访问过的数字，按行、按列、按3x3宫格分开记录和判断，这样最方便快速。</p>
<p>如果能按照限制条件填满一种可能性，就不用再尝试其他可能性了，直接结束程序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solveSudoku</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.isEmpty()) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> n = board.size</span><br><span class="line">        <span class="keyword">val</span> rowUsed = Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> columnUsed = Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> boxUsed = Array(<span class="number">3</span>) &#123; Array(<span class="number">3</span>) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] <span class="keyword">in</span> <span class="string">&#x27;1&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    rowUsed[i][num] = <span class="literal">true</span></span><br><span class="line">                    columnUsed[j][num] = <span class="literal">true</span></span><br><span class="line">                    boxUsed[i / <span class="number">3</span>][j / <span class="number">3</span>][num] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(row: <span class="type">Int</span>, column: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> r = row</span><br><span class="line">            <span class="keyword">var</span> c = column</span><br><span class="line">            <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">                c = <span class="number">0</span></span><br><span class="line">                r++</span><br><span class="line">                <span class="keyword">if</span> (r == n) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rowUsed[r][i] || columnUsed[c][i] || boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i]) <span class="keyword">continue</span></span><br><span class="line">                    board[r][c] = i.toString()[<span class="number">0</span>]</span><br><span class="line">                    rowUsed[r][i] = <span class="literal">true</span></span><br><span class="line">                    columnUsed[c][i] = <span class="literal">true</span></span><br><span class="line">                    boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(r, c + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    board[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    rowUsed[r][i] = <span class="literal">false</span></span><br><span class="line">                    columnUsed[c][i] = <span class="literal">false</span></span><br><span class="line">                    boxUsed[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(r, c + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.376.摆动序列（中等）</title>
    <url>/LeetCode/LeetCode.376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LeetCode.376.摆动序列（中等）</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，先划分子问题。</p>
<p>从某个摆动序列最后一个元素开始倒推，得到这个摆动序列有两个情况：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递增的。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递减的。</li>
</ol>
<p>子摆动序列怎么得来的，也是同样的递归划分。</p>
<p>这里有两个状态变化，一个是元素位置，一个是末尾差值。</p>
<p>设<code>dp[i][k]</code>表示数组中第0个到第<code>i</code>元素之间最长摆动序列长度；<br>k表示<code>nums[i]</code>和前面元素是递增或递减的情况；<br><code>k == 0</code> 时，表示递减；<br><code>k == 1</code> 时，表示递增。</p>
<p>考虑之前相反的情况，如果：</p>
<ol>
<li>前面的子摆动序列末尾两个元素是递减的，子摆动序列末尾元素和新的数字是递减的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递增，也就更有可能得到更长的摆动序列。</li>
<li>前面的子摆动序列末尾两个元素是递增的，子摆动序列末尾元素和新的数字是递增的，摆动序列长度不会增加；同时新数字作为序列末尾元素，因为之后更有可能形成递减，也就更有可能得到更长的摆动序列。</li>
</ol>
<p><strong>状态转移方程</strong></p>
<ul>
<li><code>nums[i] &lt; nums[i - 1]</code>，递减：<br>  <code>dp[i][0] = maxOf(dp[i][0], dp[i - 1][1] + 1)</code></li>
<li><code>nums[i] &gt; nums[i - 1]</code>，递增：<br>  <code>dp[i][1] = maxOf(dp[i][1], dp[i - 1][0] + 1)</code></li>
<li><code>nums[i] == nums[i - 1]</code>，持平：<br>  <code>dp[i][0] = dp[i - 1][0]</code><br>  <code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p><strong>边界处理</strong><br>最一开始只有一个元素，没有形成递增或递减，所以摆动序列长度为0。<br><code>dp[0][0] = 0</code><br><code>dp[0][1] = 0</code></p>
<p><strong>最后取值</strong><br>取<code>dp[n - 1][0]</code>和<code>dp[n - 1][1]</code>中较大的。<br>最后结果还要加1，因为我们是在发生新的摆动的时候才给序列增加长度的，遍历到最后时没有新的摆动了，但是目前的摆动没有算进长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br><code>dp[i]</code>只与<code>dp[i - 1]</code>有关，可以用变量记录状态，不用数组。</p>
<p>用<code>up</code>记录末尾递增的摆动序列的最长长度。<br>用<code>down</code>记录末尾递减的摆动序列的最长长度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> up = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> down = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = maxOf(down, up + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = maxOf(up, down + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxOf(up, down) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.377.组合总和 Ⅳ（中等）</title>
    <url>/LeetCode/LeetCode.377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">LeetCode.377.组合总和 Ⅳ（中等）</a></p>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<span id="more"></span>

<p>示例 1：</p>
<blockquote>
<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只要看到目标值、数组、选择，这三要素，就直接可以反应想到是背包问题。</p>
<p>这里数组中的元素是可以重复选取的，所以是完全背包问题。</p>
<p>大的target可以拆解为小target加一系列选择求解，所以要遍历所有的target取值可能，还要遍历所有数字取值可能，有两层循环。</p>
<p>这里要注意顺序不同的序列被视作不同的组合，这涉及到双层循环的哪一个循环应该放在外层。<br>由于不锁定数字选择顺序，<code>nums</code>数组遍历应该放在内层，这样target才可以由不同顺序的选择得到。<br>如果<code>nums</code>数组遍历放在外层，会锁定<code>nums</code>数组的选取顺序，一个target只会有一种顺序的选择得到。<br>这与<a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a>情况正好相反。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum4</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(target + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (t <span class="keyword">in</span> <span class="number">0.</span>.target) &#123;</span><br><span class="line">            <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= num) &#123;</span><br><span class="line">                    dp[t] += dp[t - num]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.392.判断子序列（简单）</title>
    <url>/LeetCode/LeetCode.392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/is-subsequence">LeetCode.392.判断子序列（简单）</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：<br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h3><p>可以直接拿s和t做比较，遇到不相同的字符就跳过，只要保证s所有字符在t中，并且顺序没有改变即可。</p>
<p>时间复杂度O(m + n)：m为字符串s长度，n为字符串t长度，最坏情况下两个指针都要移动到字符串末尾。<br>空间复杂度O(1)：没有额外空间占用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：后续挑战-动态规划"><a href="#解法2：后续挑战-动态规划" class="headerlink" title="解法2：后续挑战 - 动态规划"></a>解法2：后续挑战 - 动态规划</h3><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。</p>
<p>双指针的问题在于：<br>S中的一个字符跟T中的字符匹配后，再去匹配下一个字符，需要在T中顺序查找，如果能直接查表得到位置，时间就降下来了。<br>假设S的长度为m，那么复杂度就可以降低为O(m)。</p>
<p>可以对T做预处理，记录位于<code>T</code>中第<code>i</code>个位置时字符<code>j</code>第一次出现的索引位置，用<code>dp[i][j]</code>来表示。<br>字符集是常数个，所以<code>j</code>的取值范围是一个常量。</p>
<p><strong>状态转移方程</strong><br>因为<code>dp[i][j]</code>记录的是<code>j</code>在<code>i</code>或<code>i</code>之后第一次出现的位置；<br>如果<code>T[i] == j</code>，<code>dp[i][j] = i</code>。<br>如果<code>T[i] != j</code>，<code>dp[i][j] = dp[i + 1][j]</code>。<br>如果<code>i</code>之后不存在字符<code>j</code>，令<code>dp[i][j] = -1</code><br>要从后往前递推。</p>
<p><strong>复杂度</strong><br>设m为S长度，n为T长度。<br>预处理时间复杂度O(n)。<br>判断子序列时间复杂度O(m)。</p>
<p>空间复杂度O(n * 字符集个数)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSubsequence</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (t.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = t.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; IntArray(<span class="number">26</span>) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = (<span class="string">&#x27;a&#x27;</span>.toInt() + j).toChar()</span><br><span class="line">                <span class="keyword">if</span> (t[i] == c) dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> indexT = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="comment">// t已经没有后续字符了，s还没匹配完，那肯定不是子序列</span></span><br><span class="line">            <span class="keyword">if</span> (indexT == n) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">val</span> cIndex = c.toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">            <span class="keyword">if</span> (dp[indexT][cIndex] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="comment">// s中的字符c匹配到了T中的字符，从T中下一个字符开始继续匹配</span></span><br><span class="line">            indexT = dp[indexT][cIndex] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.4.寻找两个正序数组的中位数（困难）</title>
    <url>/LeetCode/LeetCode.4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode.4.寻找两个正序数组的中位数（困难）</a></p>
<p>给定两个大小分别为  <code>m</code>  和  <code>n</code>  的正序（从小到大）数组 <code>nums1</code>  和 <code>nums2</code>。请你找出并返回这两个正序数组的  <strong>中位数</strong>  。</p>
<p>进阶：你能设计一个时间复杂度为  <code>O(log (m+n))</code>  的算法解决此问题吗？</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1-归并"><a href="#解法1-归并" class="headerlink" title="解法1: 归并"></a>解法1: 归并</h2><h3 id="一个数组怎么找中位数？"><a href="#一个数组怎么找中位数？" class="headerlink" title="一个数组怎么找中位数？"></a>一个数组怎么找中位数？</h3><ul>
<li>数组元素有奇数个，中位数是最中间的一个数。</li>
<li>数组元素有偶数个，中位数是最中间的两个数的平均值。</li>
</ul>
<p>设数组长度为n。</p>
<ul>
<li>n为奇数时，中位数应该是第<code>n / 2 + 1</code>个数，由于数组索引从0开始，所以中位数是<code>nums[n / 2]</code>。</li>
<li>n为偶数时，左中位数是第<code>n / 2</code>个数，右中位数是第<code>n / 2 + 1</code>个数；由于数组索引从0开始，左中位数为<code>nums[n / 2 - 1]</code>，右中位数为<code>nums[n / 2]</code>，实际中位数为<code>(nums[n / 2 - 1] + nums[n / 2]) / 2</code>。</li>
</ul>
<h3 id="两个数组怎么找中位数？"><a href="#两个数组怎么找中位数？" class="headerlink" title="两个数组怎么找中位数？"></a>两个数组怎么找中位数？</h3><p>把两个数组归并为一个有序数组。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(m + n)</code>：需要遍历两个数组所有元素做归并。</li>
<li>空间复杂度<code>O(m + n)</code>：额外需要一个<code>m + n</code>长度的数组存储归并后的元素。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = nums1.size</span><br><span class="line">        <span class="keyword">val</span> n = nums2.size</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二路归并</span></span><br><span class="line">        <span class="keyword">val</span> nums = IntArray(m + n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> i1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> i2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; m &amp;&amp; i2 &lt; n) &#123;</span><br><span class="line">            nums[j++] = <span class="keyword">if</span> (nums1[i1] &lt; nums2[i2]) nums1[i1++] <span class="keyword">else</span> nums2[i2++]            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; m) nums[j++] = nums1[i1++]</span><br><span class="line">        <span class="keyword">while</span> (i2 &lt; n) nums[j++] = nums2[i2++]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取中位数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = (m + n) / <span class="number">2</span></span><br><span class="line">            nums[mid].toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMid = (m + n) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rightMid = leftMid + <span class="number">1</span></span><br><span class="line">            (nums[leftMid] + nums[rightMid]).toDouble() / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：二分"><a href="#解法2：二分" class="headerlink" title="解法2：二分"></a>解法2：二分</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>归并排序产生了新数组，增加了空间复杂度。</p>
<p>既然在一个数组中找中位数不需要额外空间，两个数组应该也能。</p>
<p>我们的思路还是把两个数组往一个数组的情况上考虑，也就是把不熟悉的情况往熟悉的情况上靠拢。</p>
<h3 id="合二为一"><a href="#合二为一" class="headerlink" title="合二为一"></a>合二为一</h3><p>找中位数是跟数组总个数有关的，如果把小的元素和大的元素正好能各分一半，那么看中间的数就行。</p>
<p>可以把两个数组分割为左右两部分，两个数组的左半部分元素个数跟右半部分元素个数相等的时候，直接看中间的元素就行了。</p>
<p>设<code>nums1</code>数组长度为<code>m</code>，<code>nums2</code>数组长度为<code>n</code>。<br>把<code>nums1</code>分为前<code>i</code>个元素和后<code>m - i</code>个元素。<br>把<code>nums2</code>分为前<code>j</code>个元素和后<code>n - j</code>个元素。</p>
<p>如果<code>m + n</code>是偶数，<code>i + j = (m + n) / 2</code>。<br>如果<code>m + n</code>是奇数，<code>i + j = (m + n) / 2 + 1</code>。<br>知道了<code>i</code>就可以确定<code>j</code>。</p>
<h3 id="怎么确定i-？"><a href="#怎么确定i-？" class="headerlink" title="怎么确定i ？"></a>怎么确定<code>i</code> ？</h3><p>左半部分所有元素都小于右半部分的元素。</p>
<p>数组本身是有序的，所以要求两个数组的不同部分也保持顺序，即：<br><code>nums1[i - 1] &lt; nums2[j] &amp;&amp; nums2[j - 1] &lt; nums1[i]</code></p>
<p>这个条件等价于在<code>nums1</code>数组中查找最大的<code>i</code>来满足<code>nums1[i - 1] &lt; nums2[j]</code>，查找过程可以用二分查找。</p>
<h3 id="二分查找的细节"><a href="#二分查找的细节" class="headerlink" title="二分查找的细节"></a>二分查找的细节</h3><p>当发现<code>nums[i - 1] &gt; nums2[j]</code>，说明左半部分的元素多了，要减少，应当继续寻找更小的<code>i</code>。<br>当发现<code>nums[i - 1] &lt;= nums2[j]</code>，说明左半部分可能正好，也可能少了，可以尝试寻找更大的<code>i</code>。</p>
<h3 id="查找完毕后怎么确定中位数？"><a href="#查找完毕后怎么确定中位数？" class="headerlink" title="查找完毕后怎么确定中位数？"></a>查找完毕后怎么确定中位数？</h3><p>查找到最大的<code>i</code>过后，就可以选取中位数了。</p>
<ul>
<li>如果<code>m + n</code>是奇数，分割数组的时候可以让左半部分多一个元素，两数组左半部分最大值即为中位数。</li>
<li>如果<code>m + n</code>是偶数，两数组左半部分最大值和右半部分最小值的平均数即为中位数。</li>
</ul>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(log(min(m, n)))</code>，在短的数组里做了二分查找。</li>
<li>空间复杂度<code>O(1)</code>，只使用了常数个的辅助变量。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = nums1.size</span><br><span class="line">        <span class="keyword">val</span> n = nums2.size</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> leftCount = <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">0</span>) (m + n) / <span class="number">2</span> <span class="keyword">else</span> (m + n) / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = m</span><br><span class="line">        <span class="comment">// 循环结束时left == right，不用思考选取left还是right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算mid向上取整，否则最后只剩两个元素的时候，下面一直走到else，左边界不会更新</span></span><br><span class="line">            <span class="keyword">val</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> j = leftCount - i</span><br><span class="line">            <span class="comment">// i不满足条件，要找更小的</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) right = i - <span class="number">1</span></span><br><span class="line">            <span class="comment">// i满足条件，i可能是要求解的结果，不要跳过i</span></span><br><span class="line">            <span class="keyword">else</span> left = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> i = left</span><br><span class="line">        <span class="keyword">val</span> j = leftCount - left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> nums1LeftMax = <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> nums2LeftMax = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> nums1RightMin = <span class="keyword">if</span> (i == m) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[i]</span><br><span class="line">        <span class="keyword">val</span> nums2RightMin = <span class="keyword">if</span> (j == n) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMax = maxOf(nums1LeftMax, nums2LeftMax)</span><br><span class="line">            <span class="keyword">val</span> rightMin = minOf(nums1RightMin, nums2RightMin)</span><br><span class="line">            (leftMax + rightMin).toDouble() / <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> leftMax = maxOf(nums1LeftMax, nums2LeftMax).toDouble()</span><br><span class="line">            leftMax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：分治"><a href="#解法3：分治" class="headerlink" title="解法3：分治"></a>解法3：分治</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们可以从简单理想的情况开始着手，逐步改变条件，看需要考虑的因素会发生什么变化。</p>
<h3 id="理想情况"><a href="#理想情况" class="headerlink" title="理想情况"></a>理想情况</h3><p>假设m + n是奇数，中位数是第(m + n) / 2个数，令k = (m + n) / 2。</p>
<p>如果两数组长度相同，那么直接比较nums1[k / 2]和nums2[k / 2]的大小，就知道应该取哪个数是中位数了，这是很自然推导。</p>
<h3 id="如果m-n，再比较nums1-k-2-和nums2-k-2-的大小，还能直接得出中位数是哪个吗？"><a href="#如果m-n，再比较nums1-k-2-和nums2-k-2-的大小，还能直接得出中位数是哪个吗？" class="headerlink" title="如果m != n，再比较nums1[k / 2]和nums2[k / 2]的大小，还能直接得出中位数是哪个吗？"></a>如果m != n，再比较nums1[k / 2]和nums2[k / 2]的大小，还能直接得出中位数是哪个吗？</h3><p>不能，但是可以排除掉k / 2个元素不用再参与比较，这样其实就优化了时间复杂度。</p>
<p>比如nums1[k / 2] &lt; nums2[k / 2]时，可得：</p>
<ul>
<li>nums2[k / 2]有可能是第k大的数字，也有可能不是。</li>
<li>但是nums1[k / 2]绝对不是第k大的数。</li>
<li>nums1数组的前k / 2个元素也都不可能是第k大的数，因为nums1是从小到大排序的。</li>
</ul>
<p>第k大的数是有可能出现在nums2的0到k / 2之中的，考虑极端情况：</p>
<ul>
<li>如果nums1[k / 2]后续如果正好有个k / 2 - 1个元素比nums2[0]小，那么nums2[0]就是第k大的数。</li>
<li>如果nums1[k / 2]之后没有元素了，只能在在nums2[k / 2]后面再继续找第k大的数。</li>
</ul>
<h3 id="接下来怎么找第k大的数？"><a href="#接下来怎么找第k大的数？" class="headerlink" title="接下来怎么找第k大的数？"></a>接下来怎么找第k大的数？</h3><p>已经排除了k / 2个元素不用比较后，接着其实是要寻找第 k - k / 2 个数，寻找过程是一样的，这里就划分出了子问题，可以递归进行。<br>并且每次折半查找，时间复杂度是对数级别的。</p>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul>
<li>k一直缩减到1，就是最终想要得到的中位数。</li>
<li>如果数组没有第k / 2个数可选择，就取数组末尾的数比较。</li>
</ul>
<h3 id="m-n是偶数怎么办？"><a href="#m-n是偶数怎么办？" class="headerlink" title="m + n是偶数怎么办？"></a>m + n是偶数怎么办？</h3><p>可以分别查找到左中位数和右中位数，再求平均值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = nums1.size</span><br><span class="line">        <span class="keyword">val</span> len2 = nums2.size</span><br><span class="line">        <span class="keyword">val</span> len = len1 + len2</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> left = len / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> (getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, left) + getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, right)) / <span class="number">2.</span>toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = len / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, mid).toDouble()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getKth</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>, i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = nums1.size - i1</span><br><span class="line">        <span class="keyword">val</span> len2 = nums2.size - i2</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, nums1, i2, i1, k)</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[i2 + k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> minOf(nums1[i1], nums2[i2])</span><br><span class="line">        <span class="keyword">val</span> j1 = i1 + minOf(k / <span class="number">2</span>, len1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> j2 = i2 + minOf(k / <span class="number">2</span>, len2) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (nums1[j1] &lt; nums2[j2]) &#123;</span><br><span class="line">            getKth(nums1, nums2, j1 + <span class="number">1</span>, i2, k - (j1 - i1 + <span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getKth(nums1, nums2, i1, j2 + <span class="number">1</span>, k - (j2 - i2 + <span class="number">1</span>))</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.41.缺失的第一个正数（困难）</title>
    <url>/LeetCode/LeetCode.41.%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">LeetCode.41.缺失的第一个正数（困难）</a></p>
<p>给你一个未排序的整数数组  <code>nums</code>  ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><ul>
<li>如果用哈希表记录，空间复杂度超过<code>O(1)</code>。</li>
<li>如果用排序，时间复杂度超过<code>O(n)</code> 。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>虽然不能用排序，但是可以先看正常判断过程是怎样的，看能不能换一种方式达到同样的目的。</li>
<li>如果排序完了，从左到右遍历数组，如果发现<code>nums[i] != i + 1</code>，<code>i + 1</code>就是没有出现的最小正整数。</li>
<li>换句话说有没有办法不用排序也能把数组中<code>i + 1</code>这个数放到第<code>i</code>个位置存储，这样就能判断了。</li>
<li>可以在遍历的时候直接把数字放到对应位置上，只耗费常数级别时间复杂度。</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>设<code>nums</code>数组长度为<code>n</code>，如果<code>nums[i]</code>是<code>1</code>到<code>n</code>之间的数，就把<code>nums[i]</code>放到<code>nums[i] - 1</code>的索引位置上。</p>
<p>这样从左到右遍历数组就可以知道没有出现的最小正整数是哪个了。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><ul>
<li><code>1</code>到<code>n</code>之间的数交换到数组对应索引上只需要一次交换。</li>
<li>需要遍历整个数组检查每个元素是否在对应索引位置上。</li>
</ul>
<h4 id="空间复杂度O-1"><a href="#空间复杂度O-1" class="headerlink" title="空间复杂度O(1)"></a>空间复杂度O(1)</h4><p>没有额外的空间开辟，只用了常数个变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">firstMissingPositive</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把1放到索引0</span></span><br><span class="line"><span class="comment">        把2放到索引1</span></span><br><span class="line"><span class="comment">        把3放到索引2</span></span><br><span class="line"><span class="comment">        把4放到索引3</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        如[3,4,-1,1]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] <span class="keyword">in</span> <span class="number">1.</span>.nums.size &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums.swap(i, nums[i] - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所求一定是在[1,n+1]之间</span></span><br><span class="line">        <span class="comment">// 如果是[1,2,3,4]，最小的就是n+1</span></span><br><span class="line">        <span class="comment">// 如果是[7,8,9,10]，最小的是1</span></span><br><span class="line">        <span class="keyword">return</span> nums.size + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.413.等差数列划分（中等）</title>
    <url>/LeetCode/LeetCode.413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">LeetCode.413.等差数列划分（中等）</a></p>
<p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<blockquote>
<p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。</p>
</blockquote>
<p>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。<br>子数组 是数组中的一个连续序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>子数组起始索引和结束索引各不相同，可以先按结束索引给子数组分类，分析统计相同结束索引下的等差数列子数组个数，最后累加所有不同结束索引的等差数列子数组个数。</p>
<p>先看以<code>nums[i]</code>结尾的数组中等差子数组个数，可以设其值为<code>a[i]</code>。</p>
<h3 id="等差数列如何判断？"><a href="#等差数列如何判断？" class="headerlink" title="等差数列如何判断？"></a>等差数列如何判断？</h3><p><code>nums[i] - nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]</code></p>
<h3 id="如果已知a-i-1-，如何得到a-i-？即如何递推？"><a href="#如果已知a-i-1-，如何得到a-i-？即如何递推？" class="headerlink" title="如果已知a[i - 1]，如何得到a[i]？即如何递推？"></a>如果已知a[i - 1]，如何得到a[i]？即如何递推？</h3><p>分两种情况：</p>
<ol>
<li><code>nums[i]</code>不能跟前面的元素形成等差数列，那么<code>a[i] = 0</code></li>
<li><code>nums[i]</code>能跟前面的元素形成等差数列，这时候会新增几个等差数列子数组？<ol>
<li>新增长度最短的等差数列：<code>nums[i - 2]、nums[i - 1]、nums[i]</code></li>
<li>所有以<code>nums[i - 1]</code>结尾的子数组，末尾加上<code>nums[i]</code>，所形成的新数组。所有以<code>nums[i - 1]</code>结尾的子数组的个数为<code>a[i - 1]</code>。</li>
</ol>
 即<code>a[i] = a[i - 1] + 1</code></li>
</ol>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>a[i]</code>只跟上一个状态有关，所以可以不用数组记录每一个状态，用一个变量记录上一个状态即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> isCommonDiff = nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">val</span> cur = <span class="keyword">if</span> (isCommonDiff) pre + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum += cur</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.42.接雨水（困难）</title>
    <url>/LeetCode/LeetCode.42.%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode.42.接雨水（困难）</a></p>
<p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度数组height，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划，O-n-空间复杂度"><a href="#解法1：动态规划，O-n-空间复杂度" class="headerlink" title="解法1：动态规划，O(n)空间复杂度"></a>解法1：动态规划，O(n)空间复杂度</h3><h4 id="拆分问题"><a href="#拆分问题" class="headerlink" title="拆分问题"></a>拆分问题</h4><p>所有的积水由每一列的积水量累加得来。</p>
<h4 id="某一列的积水量由什么决定？"><a href="#某一列的积水量由什么决定？" class="headerlink" title="某一列的积水量由什么决定？"></a>某一列的积水量由什么决定？</h4><ol>
<li>先要看左右两边最高的柱子有多高，这决定了当前列能积多高的水，并且最多只能积到较矮的那个柱子的高度，否则水会溢出。</li>
<li>这个高度减去当前柱子高度，就是当前列可以积的水量。</li>
</ol>
<h4 id="第i列的积水量求解公式"><a href="#第i列的积水量求解公式" class="headerlink" title="第i列的积水量求解公式"></a>第i列的积水量求解公式</h4><p><code>第i列的积水量 = min(0到i - 1列中最高的柱子的高度, i + 1列到n - 1列中最高柱子的高度) - 当前列柱子高度</code></p>
<p>所以要把每一列左边和右边最高的柱子先求出来。</p>
<h4 id="第i列左边的最高的柱子怎么找？"><a href="#第i列左边的最高的柱子怎么找？" class="headerlink" title="第i列左边的最高的柱子怎么找？"></a>第i列左边的最高的柱子怎么找？</h4><p>从0到i - 1遍历一遍height数组，找最大的。<br>实际可以从左到右遍历一遍height数组，把前面记录的最大的柱子高度跟第i - 1个柱子高度比较，取较大值就行了。</p>
<h4 id="第i列右边的最高的柱子的高度怎么找？"><a href="#第i列右边的最高的柱子的高度怎么找？" class="headerlink" title="第i列右边的最高的柱子的高度怎么找？"></a>第i列右边的最高的柱子的高度怎么找？</h4><p>从右向左遍历一遍height数组，把前面记录的最大的柱子高度跟第i + 1个柱子高度做对比，取较大的。</p>
<h4 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h4><p>第1个柱子左边没有柱子，其左边最高柱子高度是0，也无法积水。<br>最后1个柱子右边没有柱子，其右边最高柱子高度是0，也无法积水。</p>
<h4 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">val</span> maxLeft = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> maxRight = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            maxLeft[i] = maxOf(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> (n - <span class="number">2</span>) downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxRight[i] = maxOf(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">val</span> h = maxOf(maxLeft[i], maxRight[i])</span><br><span class="line">            <span class="keyword">if</span> (h &gt; height[i]) &#123;</span><br><span class="line">                water += h - height[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：  O(n)<br>空间复杂度：  O(n)</p>
</blockquote>
<h3 id="解法2：动态规划，O-1-空间复杂度"><a href="#解法2：动态规划，O-1-空间复杂度" class="headerlink" title="解法2：动态规划，O(1)空间复杂度"></a>解法2：动态规划，O(1)空间复杂度</h3><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>求每一列的积水的时候，<code>maxLeft[i]</code>和<code>maxRight[i]</code>只用到了一次，后续不会再查询之前的值，所以可以用两个变量<code>leftMax</code>、<code>rightMax</code>代替数组。</p>
<h4 id="怎么用leftMax代替maxLeft数组？"><a href="#怎么用leftMax代替maxLeft数组？" class="headerlink" title="怎么用leftMax代替maxLeft数组？"></a>怎么用leftMax代替maxLeft数组？</h4><p><code>maxLeft</code>数组是从左到右遍历数组height求得的，在从左到右遍历height数组求第i列积水量的时候，就可以顺便计算出第i个柱子左边最高的柱子的高度，即<code>leftMax</code>。</p>
<h4 id="怎么用rightMax代替maxRight数组？"><a href="#怎么用rightMax代替maxRight数组？" class="headerlink" title="怎么用rightMax代替maxRight数组？"></a>怎么用rightMax代替maxRight数组？</h4><p><code>maxRight</code>数组是从右到左遍历数组height求得的，想办法能想办法能从右到左遍历数组就行了。</p>
<h4 id="什么时候应该从右到左遍历？什么时候从左到右？"><a href="#什么时候应该从右到左遍历？什么时候从左到右？" class="headerlink" title="什么时候应该从右到左遍历？什么时候从左到右？"></a>什么时候应该从右到左遍历？什么时候从左到右？</h4><p>当左侧的柱子高度比右侧柱子高，需要看较矮的右侧的柱子高度，才能决定某一列能积多少水，左边不管多高都不会决定能积多少水，此时应该从右到左遍历。<br>直到右侧柱子比左侧柱子高，才需要从左边到右边检查。</p>
<h4 id="初始情况是怎样的？怎么开始？"><a href="#初始情况是怎样的？怎么开始？" class="headerlink" title="初始情况是怎样的？怎么开始？"></a>初始情况是怎样的？怎么开始？</h4><p>第一列左边没有柱子，无法积水。<br>最后一列右边没有柱子，无法积水。<br>计算积水只考虑区间<code>[1, n - 2]</code>。<br>可以直接令：<br><code>leftMax = height[0]</code><br><code>rightMax = height[n - 1]</code></p>
<h4 id="具体怎么判断决定height数组的遍历方向？"><a href="#具体怎么判断决定height数组的遍历方向？" class="headerlink" title="具体怎么判断决定height数组的遍历方向？"></a>具体怎么判断决定height数组的遍历方向？</h4><ol>
<li>如果发现左边柱子比右边矮，即<code>leftMax &lt; rightMax</code>，可以先计算左边的积水，随后如果发现当前柱子高度比leftMax高，再更新leftMax。</li>
<li>如果发现右边柱子比左边矮，即<code>leftMax &gt; rightMax</code>，先计算右边的积水，随后如果发现当前柱子高度比rightMax高，再更新rightMax。</li>
</ol>
<h4 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> leftMax = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> rightMax = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> right = n - <span class="number">2</span></span><br><span class="line">        <span class="comment">// 要计算区间[1, n - 2]中所有列的积水情况，所以边界条件要包含left == right的情况，才能包含所有的情况</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftMax &gt; height[left]) &#123;</span><br><span class="line">                    water += leftMax - height[left]</span><br><span class="line">                &#125;</span><br><span class="line">                leftMax = maxOf(leftMax, height[left])</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightMax &gt; height[right]) &#123;</span><br><span class="line">                    water += rightMax - height[right]</span><br><span class="line">                &#125;</span><br><span class="line">                rightMax = maxOf(rightMax, height[right])</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度： O(n)<br>空间复杂度： O(1)</p>
</blockquote>
<h3 id="解法3：直观模拟-gt-单调栈"><a href="#解法3：直观模拟-gt-单调栈" class="headerlink" title="解法3：直观模拟 -&gt; 单调栈"></a>解法3：直观模拟 -&gt; 单调栈</h3><h4 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h4><p>要能积水，需要多根柱子形成凹槽。</p>
<h4 id="如何判断形成了凹槽？"><a href="#如何判断形成了凹槽？" class="headerlink" title="如何判断形成了凹槽？"></a>如何判断形成了凹槽？</h4><p>朝一个方向依次看柱子高低，是否能形成高、低、高的排列。<br>在已经形成下坡的情况下，一旦发现出现了上坡，就形成了凹槽，就可以计算积水量了。<br>如果发现上坡，但是前面没有下坡，无法积水。</p>
<h4 id="如何计算凹槽的积水量"><a href="#如何计算凹槽的积水量" class="headerlink" title="如何计算凹槽的积水量"></a>如何计算凹槽的积水量</h4><p>穷举出凹槽的所有可能情况，逐个分析，再归纳。<br>从最基本的情况看起，再添加有限的步骤，推导出更复杂的情况。</p>
<h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>一个凹槽最少也要3个柱子，假设3个柱子从左到右依次叫L、M、R，高度排列依次是高、低、高。<br><code>凹槽积水量 = minOf(L高度, R高度) - M高度</code></p>
<h4 id="如果有多个相同高度的M，计算方式会怎么变化？"><a href="#如果有多个相同高度的M，计算方式会怎么变化？" class="headerlink" title="如果有多个相同高度的M，计算方式会怎么变化？"></a>如果有多个相同高度的M，计算方式会怎么变化？</h4><p>就变成求矩形面积了：<br><code>凹槽积水量 = (minOf(L高度, R高度) - M高度) * L到R的距离</code><br><code>L到R的距离 = R索引 - L索引 - 1</code></p>
<h4 id="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"><a href="#如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？" class="headerlink" title="如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？"></a>如果有4个不同高度的柱子（多一个柱子）形成的凹槽，计算方式会怎么变化？</h4><p>因为是从左到右看柱子高度的，一旦发现上坡就触发计算，所以可以先看下坡中柱子多的情况，比如：[3,2,1,4]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             #   </span><br><span class="line">       # a b #</span><br><span class="line">       # # c #</span><br><span class="line">       # # # #</span><br><span class="line">index: 0 1 2 3</span><br><span class="line"></span><br><span class="line">#表示柱子，小写字母表示积水区域</span><br></pre></td></tr></table></figure>
<p>此时积水面积不是矩形，左下方是一个阶梯型。<br>如果按之前的办法求解，从3依次回看2、1，会检测到凹槽形成，可以求得c的面积。<br>积水面积剩下a、b，可以发现刚好是一个矩形，面积为<code>(minOf(3高度, 2高度) - 1高度) * 1到3的距离</code>。<br>如果左边还有更高的柱子，会形成新的矩形，还是一样的计算过程。</p>
<h4 id="计算规律"><a href="#计算规律" class="headerlink" title="计算规律"></a>计算规律</h4><p>这种阶梯形状的积水面积，可以按行拆分为不同的矩形，先求下面的矩形面积，再求上面的矩形面积，最后累加。</p>
<p>然后再看右边柱子多的情况，得看右边形成新的凹槽才有讨论意义，那就是看一下有两个凹槽的情况会怎样。</p>
<h4 id="有两个凹槽时，计算方式会怎样变化？"><a href="#有两个凹槽时，计算方式会怎样变化？" class="headerlink" title="有两个凹槽时，计算方式会怎样变化？"></a>有两个凹槽时，计算方式会怎样变化？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   #</span><br><span class="line">       # b b b b b #</span><br><span class="line">       # a a # b b #</span><br><span class="line">       # # a # b b #</span><br><span class="line">       # # # # # # #</span><br><span class="line">index: 0 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>可以发现0到3的第一个凹槽中第0个最高的柱子会影响到4到6的第二个凹槽的积水面积的计算。<br>第一个凹槽积水量计算过后，1和2两个柱子对于第二个凹槽积水面积计算没有影响了。<br>在计算新凹槽积水量的时候，需要读取以前比较高的柱子高度，太低的柱子就可以忽略了。</p>
<h4 id="怎么获取和存储计算积水量需要的信息？"><a href="#怎么获取和存储计算积水量需要的信息？" class="headerlink" title="怎么获取和存储计算积水量需要的信息？"></a>怎么获取和存储计算积水量需要的信息？</h4><p>每个矩形面积的计算，是在发现有上坡后开始的，检测上坡就是需要知道当前柱子高度和前一个柱子高度，这个在遍历height数组时可以直接获取。</p>
<p>发现上坡后，需要知道：</p>
<ol>
<li>前面有没有形成下坡的柱子</li>
<li>柱子之间的距离</li>
<li>柱子的高度</li>
</ol>
<p>柱子距离必须要记录柱子索引位置；<br>形成下坡意思就是柱子高度要单调递减；<br>柱子高度可以根据柱子索引查询height数组；<br>访问下坡中柱子还要从右到左依次访问。</p>
<p>我们遍历检查的顺序是从左到右，访问顺序反过来，符合这个特点的数据结构就是栈。<br>入栈时保存的是柱子索引。<br>栈内柱子保持高度单调递减，不存储递增的柱子，因为对于后续计算积水没有意义。<br>当前柱子前面一个柱子也算下坡中，也存储在栈中，方便统一处理。<br>判断前面有没有形成下坡，就判断栈是否不为空。</p>
<h4 id="代码（kotlin）-2"><a href="#代码（kotlin）-2" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 栈存储形成下坡的柱子</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> height.indices) &#123;</span><br><span class="line">            <span class="comment">// 之前有下坡，现在发现上坡，形成凹槽了，可以计算积水面积了</span></span><br><span class="line">            <span class="comment">// 凹槽积水面积可能是阶梯形，所以要不停的读取前面下坡中的柱子计算矩形积水面积，这里需要一个循环</span></span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;</span><br><span class="line">                <span class="comment">// 前面凹槽中高度低的柱子要出栈，因为其对于后面凹槽的计算没有意义</span></span><br><span class="line">                <span class="keyword">val</span> cur = stack.pop()</span><br><span class="line">                <span class="comment">// 相同高度的柱子会形成矩形面积的积水，一起计算积水量</span></span><br><span class="line">                <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; height[stack.peek()] == height[cur]) &#123;</span><br><span class="line">                    stack.pop()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前面有下坡，才能形成凹槽，计算积水才有意义，所以要对栈判空，有可能之前栈里只存储了一个柱子</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 现在栈顶的柱子高度是大于curHeight的，形成凹槽了</span></span><br><span class="line">                    <span class="keyword">val</span> h = minOf(height[stack.peek()], height[i]) - height[cur]</span><br><span class="line">                    <span class="keyword">val</span> w = i - stack.peek() - <span class="number">1</span></span><br><span class="line">                    water += w * h</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法4：数学拆解-gt-O-1-空间复杂度"><a href="#解法4：数学拆解-gt-O-1-空间复杂度" class="headerlink" title="解法4：数学拆解 -&gt; O(1)空间复杂度"></a>解法4：数学拆解 -&gt; O(1)空间复杂度</h3><p>从图形上看积水区域特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        b  b  b  b  b  #  a  a  #  c  c  c  c  c</span><br><span class="line">        b  b  #  a  a  #  a  a  #  a  #  c  c  c</span><br><span class="line">        #  a  #  a  a  #  a  a  #  a  #  a  #  c</span><br><span class="line">index:  0  1  2  3  4  5  6  7  8  9 10 11 12 13</span><br></pre></td></tr></table></figure>
<p>观察得知：<br><code>区间矩形面积 = a的面积 + #的面积 + b的面积 + c的面积</code></p>
<p>区间矩形面积已知。<br><code>区间矩形面积 = 区间宽度 * 最高柱子高度</code></p>
<p>#的面积已知。<br><code>#的面积 = 所有柱子高度的和</code></p>
<p><strong>有没有办法知道b和c的面积？</strong><br>b和c是阶梯状的，不好单独计算。<br>可以看其处于哪个好计算的部分，再看能不能把b和c的面积拆解出来。</p>
<ol>
<li>如果从左到右遍历height数组，是可以知道 <code>#的面积 + a的面积 + c的面积</code>，遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为left。</li>
<li>如果从右到左遍历height数组，是可以知道 <code>#的面积 + a的面积 + b的面积</code>，也是遇到比之前高的柱子就一直累加高柱子的高度就行了，假设这个面积为right。</li>
</ol>
<p><code>left + right = #的面积 + a的面积 + (#的面积 + a的面积 + b的面积 + c的面积)</code><br>化简得：<br><code>left + right = #的面积 + a的面积 + 区间矩形面积</code><br>可得：<br><code>a的面积 = left + right - #的面积 - 区间矩形面积</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">trap</span><span class="params">(height: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = height.size</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            left += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeight = maxOf(maxHeight, height[i])</span><br><span class="line">            right += maxHeight</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rectArea = n * maxHeight</span><br><span class="line">        <span class="keyword">val</span> pillarArea = height.sum()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left + right - rectArea - pillarArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.44.通配符匹配（困难）</title>
    <url>/LeetCode/LeetCode.44.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/wildcard-matching/">LeetCode.44.通配符匹配（困难）</a></p>
<p>给定一个字符串 s 和一个字符模式 p，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<blockquote>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。</p>
</blockquote>
<p>两个字符串完全匹配才算匹配成功。</p>
<span id="more"></span>

<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右遍历<code>s</code>和<code>p</code>做匹配，用双指针<code>i</code>、<code>j</code>分别做匹配。</p>
<p><code>p[j] == ?</code>时，当作普通字符跟<code>s[i]</code>匹配就好了。</p>
<p><code>p[j] == *</code>时：</p>
<ul>
<li>匹配0个字符时，让<code>s[i]</code>跟<code>p[j + 1]</code>继续匹配。</li>
<li>匹配1个或多个字符时，让<code>s[i + 1]</code>跟<code>p[j]</code>继续匹配，因为<code>*</code>可以匹配多个字符。</li>
</ul>
<p><strong>边界处理</strong></p>
<p>由于<code>*</code>是会匹配多个字符或0个字符的，如果<code>p</code>后面有很多个<code>*</code>，在<code>i</code>走到头后，<code>j</code>还没走到头的时候，对<code>p</code>尾部的<code>*</code>要做处理。</p>
<p><strong>递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i == m</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                <span class="keyword">var</span> k = j</span><br><span class="line">                <span class="keyword">while</span> (k &lt; n &amp;&amp; p[k] == <span class="string">&#x27;*&#x27;</span>) k++</span><br><span class="line">                <span class="keyword">return</span> k == n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> isCharMatch = s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (isCharMatch) match(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) match(i, j + <span class="number">1</span>) || match(i + <span class="number">1</span>, j) <span class="comment">// 匹配s中的0个或1个字符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>自底向上动态规划</strong></p>
<p>递归已经给出了状态转移方程。</p>
<p>设<code>dp[i][j]</code>  表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前 <code>j</code> 个字符是否匹配。</p>
<ul>
<li><code>s[i - 1] == p[j - 1] || p[j - 1] == &#39;?&#39;</code>时，直接匹配上了，<code>dp[i][j] = dp[i - 1][j - 1]</code>。</li>
<li><code>p[j - 1] == &#39;*&#39;</code>时，匹配0个或1个字符，<code>dp[i][j] = dp[i - 1][j] || dp[i][j - 1]</code>。</li>
</ul>
<p>边界处理：</p>
<p>p开头都是<code>*</code>时可以匹配空字符串，要单独处理一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = s.length</span><br><span class="line">        <span class="keyword">val</span> n = p.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m + <span class="number">1</span>) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="comment">// 空字符串跟空字符串可以匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// *可以匹配空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">when</span> &#123;</span><br><span class="line">                    <span class="comment">// 匹配1个字符</span></span><br><span class="line">                    s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> -&gt; dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment">// *匹配0个字符或1个字符</span></span><br><span class="line">                    p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> -&gt; dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.45.跳跃游戏 II（中等）</title>
    <url>/LeetCode/LeetCode.45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/jump-game-ii/">LeetCode.45.跳跃游戏 II（中等）</a></p>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>不知道怎么办，先模拟一遍跳跃过程。<br>假设<code>nums[0]</code>是3，那么可以选择跳到1、2、3的位置。<br>假设<code>nums[1]</code>是1、<code>nums[2]</code>是10、<code>nums[3]</code>是3，那么肯定选择先跳到2的位置，再跳10个长度，这样跳跃次数最少。<br>后面再跳跃还是重复这个同样的选择过程。</p>
<h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><p>可以得知下一步的跳跃选择，应该在当前可以跳跃到的范围内找一个最远的长度来跳。就是贪心选择，从局部最优得出全局最优。</p>
<h3 id="怎么找最远可以跳跃的长度？"><a href="#怎么找最远可以跳跃的长度？" class="headerlink" title="怎么找最远可以跳跃的长度？"></a>怎么找最远可以跳跃的长度？</h3><p>只有一个个遍历数组，漏一个都不行</p>
<h3 id="什么时候计数跳跃次数？"><a href="#什么时候计数跳跃次数？" class="headerlink" title="什么时候计数跳跃次数？"></a>什么时候计数跳跃次数？</h3><p>因为会在可以跳跃到的范围内找到一个最远的长度来跳，也就是说这个范围内只会跳一次。那就顺便在遍历数组的时候等到达了跳跃范围的边界就可以计数跳跃次数了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxNext = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            maxNext = maxOf(maxNext, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxNext</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.5.最长回文子串（中等）</title>
    <url>/LeetCode/LeetCode.5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode.5.最长回文子串（中等）</a></p>
<p>给你一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h3><p>最值问题考虑动态规划，先拆分大问题为子问题+有限步骤。</p>
<p>判断一个字符串是不是回文串，先看字符串两端字符是否相同，然后去除首尾两端字符后的剩余字符串如果是回文串，整个字符串就是回文串。<br>剩余字符串是不是回文串判断方法是一样的。<br>整个判断可以递归进行，符合最优子结构，无后效性。<br>重叠子问题也有，长度大的回文串是由长度小的回文串推导而来，而长度相同的字符串有很多，会有重复判断。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文串。<br><code>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>
<p><strong>边界处理</strong><br>字符串<code>s</code>长度只有1时，是对称的，是回文串，<code>dp[i][j] = 1</code>。<br>字符串<code>s</code>为2时，去除首尾字符后没有子串了，只需要判断首尾字符是否相同即可，<code>dp[i][j] = s[i] == s[j]</code>。</p>
<p><strong>结果如何求解</strong><br>要遍历所有长度的子字符串，寻找有没有回文串，并记录最大长度的回文串。<br>长度相同的子字符串有很多，都要列举出来。</p>
<p><strong>复杂度</strong><br>设字符串长度为n。<br>穷举所有长度子串需要O(n)时间。<br>穷举每个长度的可能的子串也需要O(n)时间。<br>总的时间复杂度$O(n^2)$。</p>
<p>用二维数组记录了所有子串的是否是回文串状态，空间复杂度$O(n^2)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; BooleanArray(n) &#123; j -&gt; i == j &#125; &#125;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> maxLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="comment">// 穷举子串左端起点</span></span><br><span class="line">            <span class="keyword">for</span> (l <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="comment">// 子串右端终点</span></span><br><span class="line">                <span class="keyword">val</span> r = l + len - <span class="number">1</span></span><br><span class="line">                dp[l][r] = <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">else</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> (dp[l][r] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len</span><br><span class="line">                    maxLeft = l</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLeft, maxLeft + maxLen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：中心扩散"><a href="#解法2：中心扩散" class="headerlink" title="解法2：中心扩散"></a>解法2：中心扩散</h3><p>解法1动态规划是从外向里判断的，也可以从里向外扩散判断。</p>
<p>穷举所有所有可能的中心点，向左右两端扩散，如果左右两端字符相同，说明能构成回文串，再继续扩散查看。</p>
<p>但是回文的中心点有两种可能。<br>回文串字符数是奇数，中心只有一个字符。<br>回文串字符数是偶数，中心有两个字符。</p>
<p>不知道哪种中心扩散生成的回文串长度最大，那就两个都试一下，取最大值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">centerSpread</span><span class="params">(l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">var</span> left = l</span><br><span class="line">            <span class="keyword">var</span> right = r</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] != s[right]) <span class="keyword">break</span></span><br><span class="line">                left--</span><br><span class="line">                right++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里扩散完发现的回文串索引范围是[left + 1, right - 1]</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(left + <span class="number">1</span>, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> odd = centerSpread(i, i)</span><br><span class="line">            <span class="keyword">val</span> even = centerSpread(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> longer = <span class="keyword">if</span> (odd.length &gt; even.length) odd <span class="keyword">else</span> even</span><br><span class="line">            <span class="keyword">if</span> (longer.length &gt; longest.length) longest = longer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong><br>穷举中心点，需要遍历所有元素，消耗时间$O(n)$。<br>从中心点向两边扩散，最多扩展到整个字符串，所以最大消耗时间$O(n)$。<br>总体时间复杂度$O(n^2)$。</p>
<p>没有占用额外存储空间，空间复杂度$O(1)$。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.509. 斐波那契数（简单）</title>
    <url>/LeetCode/LeetCode.509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number">LeetCode.509. 斐波那契数（简单）</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<blockquote>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
</blockquote>
<p>给你 n ，请计算 F(n) 。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法1：记忆化递归"><a href="#解法1：记忆化递归" class="headerlink" title="解法1：记忆化递归"></a>解法1：记忆化递归</h4><p>根据定义，可以直接写出递归式，最简单。<br>但是递归会有很多重叠子问题，重复计算很耗时。</p>
<p>可以想象出函数调用的递归树，F(n)总共调用次数就是树的节点数。<br>从F(n)到F(n - 1)一直分解到F(1)，这样逐一递减，一共n层递归树。<br>第i层(从上到下数)节点数为2的i次方，递归树总节点数为 2的0次方 + 2的1次方 + 2的2次方 + …… + 2的n - 1次方，等比数列求和为2的n次方。递归求解的时间复杂度为O(2^n)。</p>
<p>把会重复使用到的计算结果记下来，每一项只计算一次，时间复杂度降低为线性。<br>自上而下做动态规划。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> memo = IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[n]</span><br><span class="line">            memo[n] = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：自下而上的动态规划"><a href="#解法2：自下而上的动态规划" class="headerlink" title="解法2：自下而上的动态规划"></a>解法2：自下而上的动态规划</h4><p>直接根据公式递推</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            cur = prepre + pre</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.51.N皇后（困难）</title>
    <url>/LeetCode/LeetCode.51.N%E7%9A%87%E5%90%8E%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">LeetCode.51.N皇后（困难）</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>提示：</p>
<ul>
<li>  <code>1 &lt;= n &lt;= 9</code></li>
<li>  皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul>
<li>尝试所有摆放的可能，用回溯。</li>
<li>每一行都放一个皇后，需要遍历所有行。</li>
<li>但是每一行放哪一列不确定，就遍历所有的列，都尝试一遍。</li>
<li>所有行放完了，完成了一种放置结果，添加到结果集。</li>
</ul>
<p><strong>限制条件如何检查？</strong></p>
<p>因为是从上到下放皇后的，当前行肯定没有其他皇后，只需检查当前列、左上方斜线、右上方斜线有没有放置过皇后，若有有放置过，当前行的当前列不能选择，得选择下一列。</p>
<p>标准的dfs，时间复杂度O(n!)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> result: MutableList&lt;List&lt;String&gt;&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> grid: Array&lt;CharArray&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理解题意是关键</span></span><br><span class="line"><span class="comment">     * 期盼上每一行每一列都只能有1个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solveNQueens</span><span class="params">(n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        grid = Array(n) &#123; CharArray(n) &#123; <span class="string">&#x27;.&#x27;</span> &#125; &#125;</span><br><span class="line">        result = mutableListOf()</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(r: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = grid.size</span><br><span class="line">        <span class="comment">// 所有的行选择完了，n个皇后也摆放完了，可以添加结果了</span></span><br><span class="line">        <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">            <span class="keyword">val</span> solution = grid.map &#123; row -&gt; row.joinToString(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">            result.add(solution)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前后的每一列都可以做出选择</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(r, c)) <span class="keyword">continue</span></span><br><span class="line">            grid[r][c] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            backtrack(r + <span class="number">1</span>)</span><br><span class="line">            grid[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(r: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = grid.size</span><br><span class="line">        <span class="comment">// 检查第c列有没有皇后，有皇后了就不能选这列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][c] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 斜着的也能走，要考虑斜着的四个方向，但其实我们选择的时候是从上往下选择的，所以只要考虑左上和右上的方向有没有皇后</span></span><br><span class="line">        <span class="comment">// 检查左上方有没有皇后</span></span><br><span class="line">        <span class="keyword">var</span> i = r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> j = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            i--</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方有没有皇后</span></span><br><span class="line">        i = r - <span class="number">1</span></span><br><span class="line">        j = c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            i--</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.516.最长回文子序列（中等）</title>
    <url>/LeetCode/LeetCode.516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">LeetCode.516.最长回文子序列（中等）</a></p>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回文子序列的定义一定要搞清，不然不知道怎么求解。</p>
<p>根据示例，一个回文子序列是要求首尾字符是相同的，中间可以不是回文子串，但是求解序列长度其实是要删除不能构成回文子串的字符，然后再看剩下能构成回文子串的字符数是多少。</p>
<p><strong>那么什么情况下不能构成回文串？</strong><br>一个字符串首尾字符不相同，一定不是回文串。</p>
<p><strong>那应该删除首尾哪一个字符？</strong><br>因为要求最长的回文子序列，删除哪个字符后能够得到最长的回文子序列就删除哪个，但是不知道是哪个是最长的，所以都分别删除试一下，然后取最大值。</p>
<p><strong>删除字符后怎么办？</strong><br>删除字符后剩余字符串判断是不是回文子序列，还是一样的方法，所以可以递归进行。</p>
<p><strong>递归处理</strong><br>先看字符串两端字符是否相同：</p>
<ul>
<li>如果相同，可以算作回文子序列了，长度加2，但是总长度多少还得看去除首尾字符后剩余的字符串的回文子序列长度。</li>
<li>如果不相同，删除最左边字符，或者删除最右边字符，再看剩下的字符串的回文子序列长度。</li>
</ul>
<p><strong>边界</strong><br>递归一直在缩减字符串。<br>如果字符串是偶数个字符，每次两个字符的删减，最后肯定只剩两个字符，再缩减，会出现左指针索引大于指针右索引，直接返回0就行。<br>如果字符串一直一个个的缩减，最后左指针和右指针都会指向一个字符，一个字符是回文子串，长度返回1。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">	                <span class="comment">// 删除最左边字符</span></span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    <span class="comment">// 删除最右边字符</span></span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, s.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现递归是存在很多重叠子问题的，因为长的序列要依赖短的序列求解，比较短的序列结果就要反复被递归，这增加了耗时，所以给中间计算过的状态记录一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; IntArray(n) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">longest</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">`            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            memo[i][j] = <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="number">2</span> + longest(i + <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(</span><br><span class="line">                    longest(i + <span class="number">1</span>, j),</span><br><span class="line">                    longest(i, j - <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong></p>
<p>状态转移方程：<br>设<code>dp[i][j]</code>为字符串<code>s[i, j]</code>最长回文子序列长度。<br><code>s[i] == s[j]</code>时，<code>dp[i][j] = 2 + dp[i + 1][j - 1]</code><br><code>s[i] != s[j]</code>时，<code>dp[i][j] = maxOf(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>注意递推顺序，<code>i</code>是从<code>i + 1</code>递推来的，所以要从大到小遍历。<br><code>j</code>依赖<code>j - 1</code>，所以<code>j</code>是从小到大遍历。</p>
<p>由于<code>s[i, j]</code>要构成字符串，所以<code>i &lt;= j &lt; n</code>。<br><code>i == j</code>时，<code>dp[i][j] = 1</code>，可以单独处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; i -&gt; IntArray(n) &#123; j -&gt; <span class="keyword">if</span> (i == j) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">if</span> (s[i] == s[j]) <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span> maxOf(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度O(n^2)<br>空间复杂度O(n^2)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.518.零钱兑换 II（中等）</title>
    <url>/LeetCode/LeetCode.518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change-2/">LeetCode.518.零钱兑换 II（中等）</a></p>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>划分子问题</strong><br>设<code>dp[i]</code>为凑成总金额<code>i</code>的硬币组合数。<br>假设<code>coins = [1, 2, 5]</code>，那么<code>dp[i]</code>其实就是硬币总额<code>i - 1</code>、<code>i - 2</code>、<code>i - 5</code>子问题之和。</p>
<p><strong>状态转移方程</strong><br><code>for (coin: coins) dp[i] += dp[i - coin]</code></p>
<p><strong>注意点</strong><br>所求的是硬币的组合数，不是排列数。<br>比如<code>coins = [1, 2]</code>，<code>amount = 3</code>，<code>1 + 2</code>和<code>2 + 1</code>是同一种组合，但是两个排列。<br>如果我们是先确定一个<code>amount</code>，再去用所有硬币去凑，就会凑出来不同的排列。<br>所以要锁定硬币使用的顺序，同一个金额下就不会有不同顺序的硬币的使用情况了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">change</span><span class="params">(amount: <span class="type">Int</span>, coins: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(amount + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (a <span class="keyword">in</span> coin..amount) &#123;</span><br><span class="line">                dp[a] += dp[a - coin]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
        <tag>背包问题</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.52.N皇后 II（困难）</title>
    <url>/LeetCode/LeetCode.52.N%E7%9A%87%E5%90%8E%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-queens-ii/">LeetCode.52.N皇后 II（困难）</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<span id="more"></span>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 9</code></li>
<li>  皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最笨的办法就跟求出N皇后所有选择方案，取选择方案的个数，但这样空间复杂度大，本题只要求方案数，我们得看看空间复杂度能不能降低。</p>
<h3 id="N皇后问题的求解步骤"><a href="#N皇后问题的求解步骤" class="headerlink" title="N皇后问题的求解步骤"></a>N皇后问题的求解步骤</h3><ol>
<li>遍历先所有行</li>
<li>每一行遍历所有列</li>
<li>判断当前列可以放置，进行放置</li>
<li>然后再深度优先搜索，继续放置</li>
<li>直到放置完最后一行</li>
</ol>
<h3 id="什么情况下需要占用额外空间？"><a href="#什么情况下需要占用额外空间？" class="headerlink" title="什么情况下需要占用额外空间？"></a>什么情况下需要占用额外空间？</h3><p>在判断当前行当前列是不是可以放置皇后这个问题上，可能会需要一定的空间记录之前放置过皇后的情况。</p>
<h3 id="怎么判断某一列之前是否已经放置过皇后了？"><a href="#怎么判断某一列之前是否已经放置过皇后了？" class="headerlink" title="怎么判断某一列之前是否已经放置过皇后了？"></a>怎么判断某一列之前是否已经放置过皇后了？</h3><p>如果在某一列放置过皇后之后，就把这一列记录下来，到下一行再遍历所有列进行列选择时，就可以查询之前哪些列是放过的，放过的就不在这一列放了。</p>
<p>假设列总数是n，最多也就记录n个列有没有被放过皇后，可以用一个数组保存。</p>
<h3 id="怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？"><a href="#怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？" class="headerlink" title="怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？"></a>怎么判断当前棋格的左上角和右上角是否已经放置过皇后了？</h3><p>如果从上往下斜着看，当在上一行第x列放置过皇后之后，我们可以知道下一行的第x + 1列和第x - 1列肯定也不能再放皇后了，因为都处于斜线位置上。</p>
<p>所以在遍历下一行的时候可以直接排除第x + 1列和第x - 1列，就相当于排除了斜线上不能放的位置。</p>
<p>但是到再下一行时，斜线会蔓延到第x + 2列和第x - 2列不可以放皇后。</p>
<p>也就是说斜线上禁止放皇后的位置随着行的增大而平移，位置需要随行保持更新，而且两个方向的斜线更新的方向也不一样。</p>
<p>所以这里需要两个数组存储两个方向斜线列的变化，每增加一行，数组值都要往左和往右移动一个位置。</p>
<h3 id="如何优化空间复杂度？"><a href="#如何优化空间复杂度？" class="headerlink" title="如何优化空间复杂度？"></a>如何优化空间复杂度？</h3><p>使用数组记录状态会占用O(n)的空间复杂度。</p>
<p>可以注意到<code>1 &lt;= n &lt;= 9</code>，能够使用二进制的位来记录状态，这样就节省了数组的空间开销，每个状态各自需要一个整数就可以判断，整数总共有32位，足以容纳9个状态值。</p>
<h3 id="怎么用二进制记录三种状态？"><a href="#怎么用二进制记录三种状态？" class="headerlink" title="怎么用二进制记录三种状态？"></a>怎么用二进制记录三种状态？</h3><ul>
<li>用整数变量<code>c</code>的每一位是否是1，表示某一列是否已经已经放过皇后了</li>
<li>用整数变量<code>ld</code>的每一位是否是1，表示某一列的右上角是否已经已经放过皇后了</li>
<li>用整数变量<code>rd</code>的每一位是否是1，表示某一列的左上角是否已经已经放过皇后了</li>
</ul>
<h3 id="怎么知道哪些列还能放皇后？"><a href="#怎么知道哪些列还能放皇后？" class="headerlink" title="怎么知道哪些列还能放皇后？"></a>怎么知道哪些列还能放皇后？</h3><p>具体到某一行时，需要知道哪些列还能放皇后。</p>
<p>哪些列不能放皇后，我们求<code>c</code>、<code>ld</code>、<code>rd</code>三个变量的或的结果<code>q</code>就知道了。</p>
<p><code>q</code>的二进制中所有为1的位就是已经放过皇后的，不能再放了。</p>
<p>找<code>q</code>中所有为0的位就是可以放皇后的位置；位数不超过n。</p>
<p>0不方便找，也不方便判断，1方便判断，所以可以反过来，把<code>q</code>取反，这样所有为1的位置都是可以放皇后的，但是高位会有多余的1，所以再跟n个1做与操作，把高位多余的1给截取掉。</p>
<p>n个1怎么快速求？可以把1左移n位，再减1。模拟一下就知道。</p>
<p>用<code>bits</code>变量来存储 <code>q</code>取反再跟n个1与操作的结果，<code>bits</code>的某一位为1表示这一位可以放皇后。</p>
<h3 id="怎么遍历所有可以放皇后的列？"><a href="#怎么遍历所有可以放皇后的列？" class="headerlink" title="怎么遍历所有可以放皇后的列？"></a>怎么遍历所有可以放皇后的列？</h3><ul>
<li>依次取<code>bits</code>每一位的1。</li>
<li>遍历何时结束？可以把访问过的1都消除掉，bits为0说明遍历完所有的1了。同时把访问过的1消除掉，也方便取下一个1。</li>
</ul>
<h4 id="怎么依次取bits每一位的1？"><a href="#怎么依次取bits每一位的1？" class="headerlink" title="怎么依次取bits每一位的1？"></a>怎么依次取<code>bits</code>每一位的1？</h4><p>可以想办法通过位运算快速求解，充分发挥二进制的优势。</p>
<p>可以每次取最低位的1，我们只要构造一个二进制数，跟bits前面的所有位都相反，就在最后一个1的位置跟bits一样，这样两者做一下与操作就可以得到最低位1。</p>
<p>取反可以想到反码，如果对bits取反，最低位1变成0，接着后面全部都是1，我们可以给反码加1，就可以把最低位的0和1变回来。</p>
<p>反码加1就是补码，所以取<code>-bits</code>跟<code>bits</code>做与操作，得到<code>bits</code>最低位的1。</p>
<h4 id="怎么消除最低位的1？"><a href="#怎么消除最低位的1？" class="headerlink" title="怎么消除最低位的1？"></a>怎么消除最低位的1？</h4><p><code>bits - 1</code>后，最低位1就没了，但是更低位本来全部是0现在都变成1，再跟<code>bits</code>与一下，它们的高位都相同，而<code>bits</code>低位都是0，这样就把<code>bit</code>最低位的1给消除了。</p>
<h4 id="怎么更新c、ld、rd？"><a href="#怎么更新c、ld、rd？" class="headerlink" title="怎么更新c、ld、rd？"></a>怎么更新<code>c</code>、<code>ld</code>、<code>rd</code>？</h4><p>取出的<code>bits</code>的最低位的1为<code>pick</code>。</p>
<p><code>pick</code>二进制中的1代表的列是不能被下一行再访问了，<code>c</code>要多增加这一列的1，<code>c = c or pick</code> 。</p>
<p><code>pick</code>二进制中的1代表的列的左下方的列在下一行是不能被访问的，并且<code>ld</code>中所有不能访问的列都要左移1位，正好可以用移位运算符很方便的做移动，<code>ld = (ld or pick) shl 1</code>。</p>
<p><code>pick</code>二进制中的1代表的列的右下方的列在下一行是不能被访问的，并且<code>rd</code>中所有不能访问的列都要右移1位，正好可以用移位运算符很方便的做移动，<code>rd = (rd or pick) shr 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">totalNQueens</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(row: <span class="type">Int</span>, c: <span class="type">Int</span>, ld: <span class="type">Int</span>, rd: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> bits = (c or ld or rd).inv() and ((<span class="number">1</span> shl n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (bits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> pick = bits and -bits</span><br><span class="line">                find(row + <span class="number">1</span>, c or pick, (pick or ld) shl <span class="number">1</span>, (pick or rd) shr <span class="number">1</span>)</span><br><span class="line">                bits = bits and (bits - <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>二进制</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.53.最大子序和（简单）</title>
    <url>/LeetCode/LeetCode.53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode.53.最大子序和（简单）</a></p>
<p>给定一个整数数组  <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最值问题考虑用动态规划，从某个状态倒推，拆解为上一个状态+所有可能的最小步骤，看是否符合动态规划的条件。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>设<code>dp[i]</code>为以<code>nums[i]</code>为结尾的连续子数组的最大和。</p>
<p>求<code>dp[i]</code>肯定是要加上<code>nums[i]</code>的，此时合成子数组有两种选择：</p>
<ol>
<li><code>nums[i]</code>单独为一个子数组</li>
<li><code>nums[i]</code>和前面的连续子数组合并</li>
</ol>
<p>如何选择？</p>
<ol>
<li>如果 <code>dp[i - 1] + nums[i] &gt; nums[i]</code>，那么<code>dp[i] = dp[i - 1] + nums[i]</code>。</li>
<li>如果 <code>dp[i - 1] + nums[i] &lt; nums[i]</code>，那<code>nums[i]</code>单独成子数组后和反而更大，<code>dp[i] = nums[i]</code>。</li>
</ol>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i] = max(dp[i - 1] + nums[i], nums[i]) </code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p><code>dp[0]</code>就是<code>nums[0]</code>本身了，只包含自己的子数组。</p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只依赖于前一项的递推，可以不用数组，只用一个变量记录上一个值。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            <span class="keyword">val</span> cur = maxOf(pre + num, num)</span><br><span class="line">            maxSum = maxOf(maxSum, cur)</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.55.跳跃游戏（中等）</title>
    <url>/LeetCode/LeetCode.55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">LeetCode.55.跳跃游戏（中等）</a></p>
<p>给定一个非负整数数组 <code>nums</code>  ，你最初位于数组的  <strong>第一个下标</strong>  。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="到达最后一个下标需要什么条件？"><a href="#到达最后一个下标需要什么条件？" class="headerlink" title="到达最后一个下标需要什么条件？"></a>到达最后一个下标需要什么条件？</h3><p>跳过的长度要大于等于数组长度</p>
<h3 id="什么情况下不能到达最后一个下标？"><a href="#什么情况下不能到达最后一个下标？" class="headerlink" title="什么情况下不能到达最后一个下标？"></a>什么情况下不能到达最后一个下标？</h3><p>到达某个位置后，不继续往后跳了，比如到了某个位置，可跳跃长度为0，就不会往后跳了，跳到最后一个位置就无从谈起。</p>
<h3 id="我怎么知道总共跳跃的长度有没有超过数组的长度？"><a href="#我怎么知道总共跳跃的长度有没有超过数组的长度？" class="headerlink" title="我怎么知道总共跳跃的长度有没有超过数组的长度？"></a>我怎么知道总共跳跃的长度有没有超过数组的长度？</h3><p>只能从头到尾遍历数组，记录最多能跳多远，会不会在某个位置停止跳跃，如果不会停止跳跃，肯定能跳到终点。</p>
<h3 id="停止跳跃有什么特征？怎么判断有没有停止跳跃？"><a href="#停止跳跃有什么特征？怎么判断有没有停止跳跃？" class="headerlink" title="停止跳跃有什么特征？怎么判断有没有停止跳跃？"></a>停止跳跃有什么特征？怎么判断有没有停止跳跃？</h3><p>如果记录最远能够跳到的位置，停止跳跃的时候，记录的位置不会再改变了。<br>在遍历数组检查最多能跳多远的时候，如果发现数组当前遍历的下标超过记录的最远跳过的位置，说明跳跃停止了。因为遍历数组相当于每次跳1步，是最低速度，如果能持续跳跃，不会低于这个速度，最低也是持平。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            j = maxOf(j, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums.size) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.62.不同路径（中等）</title>
    <url>/LeetCode/LeetCode.62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/unique-paths/">LeetCode.62.不同路径（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li>从上边<code>[m - 1, n]</code>来</li>
<li>从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？<br>按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为整个路径是要从上到下的，从下面上来，最后还是要下去，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为整个路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。<br>而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径数，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径数时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径数。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，达到的路径数量就是1。<br>第一行所有格子没有上面，都只能从左边过来，路径数都是1。<br>第一列所有格子没有左边，都只能从上边过来，路径数都是1。</p>
<p><strong>复杂度</strong><br>需要查看所有格子的情况来寻找路径数，所以要遍历所有网格，时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>记录所有达到所有格子的路径数，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径数推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径数？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径数，所以记录一行是必须的。<br>读取上一行格子的路径数，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.63.不同路径 II（中等）</title>
    <url>/LeetCode/LeetCode.63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode.63.不同路径 II（中等）</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有障碍物说明不能达到，换句话说，到达障碍物格子的路径数为0。</p>
<p>设<code>dp[i][j]</code>为到达<code>[i, j]</code>格的路径数。</p>
<p><strong>状态转移方程</strong></p>
<ol>
<li><code>[i, j]</code>没有障碍物，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</li>
<li><code>[i, j]</code>有障碍物，<code>dp[i][j] = 0</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，下面格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br>只关心左边和上边的格子的路径数，不需要记录所有行的数据，只需要记录一行。<br>能不能只记录左边和上边，用两个变量完成？<br>不能，终点在最右边，路径可能从最左边过来，所以要记录一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = obstacleGrid.size</span><br><span class="line">        <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍物，右边格子都不能到达，路径数为0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">            dp[j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment">// dp[j]: 达到上方格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]: 达到左方格子的路径数</span></span><br><span class="line">                <span class="keyword">else</span> dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.64.最小路径和（中等）</title>
    <url>/LeetCode/LeetCode.64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">LeetCode.64.最小路径和（中等）</a></p>
<p>给定一个包含非负整数的  <code>_m_ x _n_</code> 网格 <code>grid</code>  ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要达到右下角<code>[m, n]</code>，只有两种可能：</p>
<ol>
<li> 从上边<code>[m - 1, n]</code>来</li>
<li> 从左边<code>[m, n - 1]</code>来</li>
</ol>
<p><code>[m - 1, n]</code>怎么达到？  按道理有3条路径，从上来、从左来、从下来。<br>但是从下来不考虑，因为从起点到终点的路径是要从上到下的，如果从下面上来最后还是要下去，路径和增大了，多此一举。</p>
<p>同理中间的格子，如果是从右边过来也是多此一举，因为起点到终点的路径是要从左到右的。</p>
<p>所以对于每个格子，只考虑从上和从左过来。</p>
<p>某个状态的问题就拆解为了子问题+有限步骤，并且符合最优子结构，也无后效性。  而且有大量重叠子问题，比如到达<code>[i, j]</code>格的路径和，在计算到达<code>[i + 1][j]</code>路径数和到达<code>[i][j + 1]</code>路径和时都会用到。</p>
<p>符合使用动态规划所有条件。</p>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>为达到方格<code>[i, j]</code>的路径和。<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><strong>边界处理</strong><br><code>[0, 0]</code>格没有左边和上面，路径和就是当前元素值。<br>第一行所有格子没有上面，都只能从左边过来，路径和从左边累加。<br>第一列所有格子没有左边，都只能从上边过来，路径和从右边累加。</p>
<p><strong>复杂度</strong><br>要遍历所有网格，才能找到最少路径和，所以时间无法省略。<br>时间复杂度$O(mn)$。</p>
<p>如果记录达到所有格子的路径和，空间复杂度$O(mn)$。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + minOf(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>由于每个格子的路径数只会从上面和左边的路径和推导而来，而且只会读取上面和左边的项，所以不需要记录所有格子的路径数。</p>
<p>那么要记录多少个格子的路径和？<br>因为终点格子可以从左边过来，所以要记录左边所有的格子的路径和，所以记录一行是必须的。  读取上一行格子的路径和，直接读取之前记录的行就行了。<br>所以只需要记录一行格子的路径和。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minPathSum</span><span class="params">(grid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = grid.size</span><br><span class="line">        <span class="keyword">val</span> n = grid[<span class="number">0</span>].size</span><br><span class="line">        <span class="comment">// 存储一行格子的路径数</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 第一行不能从上边过来，特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="comment">// dp[j]是上面格子的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1]是左边格子的路径数</span></span><br><span class="line">                dp[j] = <span class="keyword">if</span> (j == <span class="number">0</span>) grid[i][j] + dp[j]</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] + minOf(dp[j], dp[j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(mn)$<br>空间复杂度$O(n)$</p>
<p>如果<code>m &lt; n</code>，也可以做到$O(m)$空间复杂度，交换行列把矩阵转置，并不影响结果，再递推就行。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.65.有效数字（困难）</title>
    <url>/LeetCode/LeetCode.65.%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/valid-number/">LeetCode.65.有效数字（困难）</a></p>
<span id="more"></span>

<p>有效数字（按顺序）可以分成以下几个部分：</p>
<ul>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
</ul>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：<ul>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ul>
</li>
</ul>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
<p>部分有效数字列举如下：</p>
<ul>
<li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li>
</ul>
<p>部分无效数字列举如下：</p>
<ul>
<li>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</li>
</ul>
<p>给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 20</code></li>
<li>  <code>s</code>  仅含英文字母（大写和小写），数字（<code>0-9</code>），加号  <code>&#39;+&#39;</code>  ，减号  <code>&#39;-&#39;</code>  ，或者点  <code>&#39;.&#39;</code>  。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：正则表达式"><a href="#解法1：正则表达式" class="headerlink" title="解法1：正则表达式"></a>解法1：正则表达式</h2><p>检查字符串是不是符合某种规则，用正则表达式是最直接的想法。</p>
<h3 id="怎么表示一个整数？"><a href="#怎么表示一个整数？" class="headerlink" title="怎么表示一个整数？"></a>怎么表示一个整数？</h3><p><code>[+-]?\\d+</code></p>
<ul>
<li><code>[+-]?</code>满足整数条件1：<code>（可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）</code>。</li>
<li><code>\\d+</code>满足整数条件2：<code>至少一位数字</code>。</li>
</ul>
<h3 id="怎么表示一个小数？"><a href="#怎么表示一个小数？" class="headerlink" title="怎么表示一个小数？"></a>怎么表示一个小数？</h3><p><code>[+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)</code></p>
<ul>
<li><code>[+-]?</code>满足条件<code>（可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）</code>。</li>
<li><code>(\\d+\\.)</code>满足条件<code>至少一位数字，后面跟着一个点 &#39;.&#39;</code>。</li>
<li><code>(\\d+\\.\\d+)</code>    满足条件<code>至少一位数字，后面跟着一个点 &#39;.&#39; ，后面再跟着至少一位数字</code>。</li>
<li><code>(\\.\\d+)</code>满足条件<code>一个点 &#39;.&#39; ，后面跟着至少一位数字</code>。</li>
</ul>
<h3 id="怎么表示科学计数法？"><a href="#怎么表示科学计数法？" class="headerlink" title="怎么表示科学计数法？"></a>怎么表示科学计数法？</h3><p>一个整数或者小数 + <code>([eE][+-]?\\d+) </code></p>
<p><code>([eE][+-]?\\d+) </code>满足条件<code>一个 &#39;e&#39; 或 &#39;E&#39; ，后面跟着一个 整数</code>，根据示例，e后面的整数前面可以带正负号。</p>
<h3 id="满足题意的正则表达式？"><a href="#满足题意的正则表达式？" class="headerlink" title="满足题意的正则表达式？"></a>满足题意的正则表达式？</h3><p>把上面三个综合起来，就能得到最终的表达式：</p>
<p><code>([+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)|(\\d+)))([eE][+-]?\\d+)?</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> regex = Regex(<span class="string">&quot;([+-]?(\\d+(\\.\\d*)?|(\\.\\d+)))([eE][+-]?\\d+)?&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> regex.matches(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：模拟"><a href="#解法2：模拟" class="headerlink" title="解法2：模拟"></a>解法2：模拟</h2><p>暴力模拟逻辑会比较乱，可以做一个简单的分类，这样相对会比较清晰。</p>
<p>有效数字有三种可能的字符串形式：</p>
<ol>
<li>整数</li>
<li>小数</li>
<li>科学计数</li>
</ol>
<p>针对三种形式的数字，分别写一个校验器做判断即可。</p>
<p>在科学计数的校验器中，可以去除科学计数的特征字符，再复用整数校验器和小数校验器的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> validator = Decorator()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validator.validate(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> s.all &#123; it.isDigit() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dotIndex = s.indexOf(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> intPart = s.substring(<span class="number">0</span>, dotIndex)</span><br><span class="line">        <span class="keyword">val</span> decimalPart = s.substring(dotIndex + <span class="number">1</span>, s.length)</span><br><span class="line">        <span class="keyword">return</span> intPart.all &#123; it.isDigit() &#125; &amp;&amp; decimalPart.all &#123; it.isDigit() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScienceFormatValidator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> floatValidator = FloatValidator()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> intValidator = IntValidator()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> eIndex = s.indexOf(<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (eIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (eIndex == s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> left = s.substring(<span class="number">0</span>, eIndex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> right = s.substring(eIndex + <span class="number">1</span>, s.length)</span><br><span class="line">        <span class="keyword">if</span> (right[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || right[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            right = right.substring(<span class="number">1</span>, right.length)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (intValidator.validate(left) || floatValidator.validate(left)) &amp;&amp; intValidator.validate(right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> : <span class="type">Validator &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> validators = listOf(</span><br><span class="line">            IntValidator(),</span><br><span class="line">            FloatValidator(),</span><br><span class="line">            ScienceFormatValidator()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> str = s.trimSpaceAndSign()</span><br><span class="line">        validators.forEach &#123; validator -&gt;</span><br><span class="line">            <span class="keyword">if</span> (validator.validate(str)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">trimSpaceAndSign</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> s = trim()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (s.isNotEmpty() &amp;&amp; (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">        s.substring(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3：DFA"><a href="#解法3：DFA" class="headerlink" title="解法3：DFA"></a>解法3：DFA</h2><p>字符匹配规则的过程，可以看作是状态转移的过程，字符作为输入，即状态改变的条件，让一个状态产生转移另一个状态，如果能转换到最终状态，说明字符串是匹配的。</p>
<p>可以用状态机来解决字符串匹配。这里使用DFA，即确定有穷状态机，对每个状态和输入符号可以得到下一个唯一到状态。</p>
<p>那么问题就转变为：</p>
<ol>
<li>有哪些状态？</li>
<li>初始状态是什么？</li>
<li>结束状态是什么？</li>
<li>输入有哪些？</li>
<li>状态转移失败怎么办？</li>
<li>状态转移的所有情况有哪些？</li>
</ol>
<h3 id="有哪些状态？"><a href="#有哪些状态？" class="headerlink" title="有哪些状态？"></a>有哪些状态？</h3><p>我们把所有正确的、互相独立的状态列出来，然后看输入什么字符可以从一个状态转换到另一个状态，就构建出了状态机。</p>
<p>可以把 当前处理到有效数字字符串的哪个部分 当作状态，所有的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.空字符串</span><br><span class="line">1.符号位</span><br><span class="line">2.整数部分数字</span><br><span class="line">3.左侧有整数的小数点</span><br><span class="line">4.左侧无整数的小数点</span><br><span class="line">5.小数部分的数字</span><br><span class="line">6.指数字符e或E</span><br><span class="line">7.指数后面的符号位</span><br><span class="line">8.指数后面的整数部分</span><br></pre></td></tr></table></figure>

<h3 id="初始状态是什么？"><a href="#初始状态是什么？" class="headerlink" title="初始状态是什么？"></a>初始状态是什么？</h3><p>0.空字符串</p>
<h3 id="结束状态是什么？"><a href="#结束状态是什么？" class="headerlink" title="结束状态是什么？"></a>结束状态是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.整数部分数字</span><br><span class="line">3.左侧有整数的小数点</span><br><span class="line">5.小数部分的数字</span><br><span class="line">8.指数后面的整数部分</span><br></pre></td></tr></table></figure>

<h3 id="输入有哪些？"><a href="#输入有哪些？" class="headerlink" title="输入有哪些？"></a>输入有哪些？</h3><ul>
<li>空格</li>
<li>正负号  <code>+</code>  或<code>-</code>  </li>
<li>数字<code>0-9</code></li>
<li>点  <code>.</code>  </li>
<li>英文字母<code>e</code>或<code>E</code></li>
<li>其他字符</li>
</ul>
<h3 id="状态转移失败怎么办？"><a href="#状态转移失败怎么办？" class="headerlink" title="状态转移失败怎么办？"></a>状态转移失败怎么办？</h3><p>如果对于某个输入不能转换到下一个状态，应该提前终止匹配。</p>
<h3 id="状态转移的所有情况有哪些？"><a href="#状态转移的所有情况有哪些？" class="headerlink" title="状态转移的所有情况有哪些？"></a>状态转移的所有情况有哪些？</h3><p>可以用状态表描述所有状态转移的情况，结合规则和示例定义所有状态的转移情况。</p>
<p>如果状态不可转移，用-1表示。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>空格</th>
<th>+/-</th>
<th>0-9</th>
<th>.</th>
<th>e/E</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>0.空字符串</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>1.符号位</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>2.整数部分数字</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>3.左侧有整数的小数点</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>4.左侧无整数的小数点</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>5.小数部分的数字</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>6.指数字符e或E</td>
<td>-1</td>
<td>7</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>7.指数后面的符号位</td>
<td>-1</td>
<td>-1</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>8.指数后面的整数部分</td>
<td>-1</td>
<td>-1</td>
<td>8</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="状态表怎么存储？"><a href="#状态表怎么存储？" class="headerlink" title="状态表怎么存储？"></a>状态表怎么存储？</h3><ul>
<li>二维数组。</li>
<li>哈希表嵌套，不存储-1的状态，这样还可以节约一点空间。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h4><p>字符串长度为n，需要遍历字符串所有字符。</p>
<p>状态转移查表只需要O(1)时间。</p>
<h4 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O(1)"></a>空间复杂度：O(1)</h4><p>虽然状态表占用一定的空间，但跟字符串长度无关，并且大小固定，所以可以认为是常数空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      |       状态        |空格|+/-|0-9|. |e/E|其他|</span></span><br><span class="line"><span class="comment">     *      | -----------------|----|---|---|--|---|--|</span></span><br><span class="line"><span class="comment">     *      |0.空字符串          |0  |1  |2  |4  |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |1.符号位            |-1 |-1 |2  |4 |-1  |-1|</span></span><br><span class="line"><span class="comment">     *      |2.整数部分数字       |-1 |-1 |2  |3  |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |3.左侧有整数的小数点  |-1 |-1 |5  |-1 |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |4.左侧无整数的小数点  |-1 |-1 |5  |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |5.小数部分的数字     |-1 |-1 |5  |-1 |6  |-1|</span></span><br><span class="line"><span class="comment">     *      |6.指数字符e或E       |-1 |7 |8  |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |7.指数后面的符号位    |-1 |-1 |8 |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     *      |8.指数后面的整数部分  |-1 |-1 |8 |-1 |-1 |-1|</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table = arrayOf(</span><br><span class="line">        intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        intArrayOf(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> finalState = arrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isNumber</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            state = table[state][c.index]</span><br><span class="line">            <span class="keyword">if</span> (state == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state <span class="keyword">in</span> finalState</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="built_in">Char</span>.index: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="string">&#x27; &#x27;</span> -&gt; <span class="number">0</span></span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span> -&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="number">2</span></span><br><span class="line">            <span class="string">&#x27;.&#x27;</span> -&gt; <span class="number">3</span></span><br><span class="line">            <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;E&#x27;</span> -&gt; <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>正则表达式</tag>
        <tag>DFA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.68.文本左右对齐（困难）</title>
    <url>/LeetCode/LeetCode.68.%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/text-justification/">LeetCode.68.文本左右对齐（困难）</a></p>
<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<span id="more"></span>

<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<p>说明:</p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 maxWidth。</li>
<li>输入单词数组 words 至少包含一个单词。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>顺着题目说明思考步骤。</p>
<h3 id="怎么知道一行可以放多少个单词？"><a href="#怎么知道一行可以放多少个单词？" class="headerlink" title="怎么知道一行可以放多少个单词？"></a>怎么知道一行可以放多少个单词？</h3><p>依次遍历单词，累加单词长度，跟<code>maxWidth</code>对比，找出一行可以容纳的最多的单词。</p>
<p>如果一行有<code>n</code>个单词，要注意，前<code>n - 1</code>个单词末尾都要至少有一个空格，需要考虑进去。</p>
<h3 id="如何知道每行有多少个空格？"><a href="#如何知道每行有多少个空格？" class="headerlink" title="如何知道每行有多少个空格？"></a>如何知道每行有多少个空格？</h3><p><code>maxWidth - 这一行所有单词长度</code></p>
<h3 id="如何平均分配空格到每个单词的末尾？"><a href="#如何平均分配空格到每个单词的末尾？" class="headerlink" title="如何平均分配空格到每个单词的末尾？"></a>如何平均分配空格到每个单词的末尾？</h3><p>假设一行的空格数有<code>spaceCount</code>，一行可以放置的单词有<code>n</code>个。</p>
<ul>
<li>只有前<code>n - 1</code>个单词的末尾需要分配空格。</li>
<li>按照平均分配的原则，每个单词末尾的空格数应当为<code>spaceCount / (n - 1)</code>。</li>
<li>如果<code>spaceCount / (n - 1)</code>不能整除，说明一行单词间的空格不能均匀分配，按照题意，左侧放置的空格数要多于右侧的空格数。<ul>
<li>多出来的空格数是<code>spaceCount % (n - 1)</code>，从左到右给每个单词末尾加一个空格，均匀掉。</li>
</ul>
</li>
</ul>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><ul>
<li>对于最后一行，按照题意：<code>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</code>，同时末尾要全部填满空格。</li>
<li>对于一行只有一个单词，空格只能全部填在末尾，让单词左对齐。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fullJustify</span><span class="params">(words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, maxWidth: <span class="type">Int</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> n = words.size</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 统计一行能放多少个单词</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这一行所有单词的长度</span></span><br><span class="line">            <span class="keyword">var</span> wordsLength = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> j = i</span><br><span class="line">            <span class="comment">// 每个单词末尾一个空格数量的累加为 j - i</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; wordsLength + words[j].length + j - i &lt;= maxWidth) &#123;</span><br><span class="line">                wordsLength += words[j].length</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 最后一行单独处理，因为处理空格的逻辑跟普通行不一样，所以放在普通行处理空格的前面</span></span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">val</span> line = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> i until j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line.isNotEmpty()) line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                    line.append(words[k])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> line.length until maxWidth) &#123;</span><br><span class="line">                    line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(line.toString())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;&lt;&lt; </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 平均分配空格到单词末尾</span></span><br><span class="line">            <span class="keyword">val</span> line = StringBuilder()</span><br><span class="line">            <span class="keyword">val</span> wordCount = j - i</span><br><span class="line">            <span class="keyword">val</span> spaceLength = <span class="keyword">if</span> (wordCount == <span class="number">1</span>) <span class="number">0</span> <span class="keyword">else</span> (maxWidth - wordsLength) / (wordCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">var</span> extraSpaceLength = <span class="keyword">if</span> (wordCount == <span class="number">1</span>) <span class="number">0</span> <span class="keyword">else</span> (maxWidth - wordsLength) % (wordCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> i until j) &#123;</span><br><span class="line">                <span class="comment">// 空格分配在每个单词前面</span></span><br><span class="line">                <span class="keyword">if</span> (line.isNotEmpty()) &#123;</span><br><span class="line">                    repeat(spaceLength) &#123; line.append(<span class="string">&quot; &quot;</span>) &#125;</span><br><span class="line">                    <span class="keyword">if</span> (extraSpaceLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                        extraSpaceLength--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                line.append(words[k])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;&lt;&lt; </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于一行只有一个单词和最后一行，末尾填充空格</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> line.length until maxWidth) &#123;</span><br><span class="line">                line.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加一行的结果</span></span><br><span class="line">            result.add(line.toString())</span><br><span class="line"></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.70.爬楼梯（简单）</title>
    <url>/LeetCode/LeetCode.70.%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/climbing-stairs/">LeetCode.70.爬楼梯（简单）</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，考虑用动态规划，看是否符合动态规划的条件。<br>一般从最终状态做倒推，拆解当前状态问题为上一个状态+有限的步骤。</p>
<h3 id="倒推"><a href="#倒推" class="headerlink" title="倒推"></a>倒推</h3><p>爬到第n阶，最后一步一定是只有两种可能：</p>
<ol>
<li>先爬到第n-1个台阶，再爬1个台阶</li>
<li>先爬到第n-2个台阶，再爬2个台阶</li>
</ol>
<p>把两种可能的方法数累加就是爬到第n阶第方法数。</p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>爬到第1阶，只有1种爬法，即爬1个台阶。<br>爬到第2阶，可以从第0阶爬2个台阶，也可以从第1阶爬1个台阶，共2种爬法。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            cur = pre1 + pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.714.买卖股票的最佳时机含手续费（中等）</title>
    <url>/LeetCode/LeetCode.714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode.714.买卖股票的最佳时机含手续费（中等）</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状态转移方程同<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a></p>
<p>卖出时计算利润时把交易费扣除即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>, fee: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            noholdProfit = maxOf(noholdProfit, holdProfit + prices[i] - fee)</span><br><span class="line">            holdProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.72.编辑距离（困难）</title>
    <url>/LeetCode/LeetCode.72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/">LeetCode.72.编辑距离（困难）</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看着题目就给出了原子化的最小操作步骤了，看着就能拆成子问题的样子。</p>
<p>从两个单词末尾开始看起。</p>
<ul>
<li>如果<code>word1[i1] == word2[i2]</code>，就不用操作；<br>  接着就是去对比<code>word1[0, i1 - 1]</code>和<code>word2[0, i2 - 1]</code>这两个子字符串是不是一样，看子问题。</li>
<li>如果<code>word1[i1] != word2[i2]</code>，那么每个单词都有三种操作可以变成另一个；<br>具体哪种操作后的总操作数最少呢？只能每个都试一下，然后选个操作数最少的。</li>
</ul>
<p><strong>状态转移方程</strong><br>设<code>dp[i][j]</code>是<code>word1[0, i]</code>转换为<code>word2[0, j]</code>的操作数。</p>
<ul>
<li><code>word1[i] == word2[j]</code>时，<br><code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>word1[i] != word2[j]</code>时：<ul>
<li><code>word1</code>末尾插入一个与<code>word2[j]</code>相同的字符，插入之前的操作数是<code>dp[i][j - 1]</code>。</li>
<li><code>word1</code>末尾删除一个字符，删除之前的操作数是<code>dp[i - 1][j]</code>。</li>
<li><code>word1</code>末尾字符替换为<code>word2[j]</code>，替换之前的操作数是<code>dp[i - 1][j - 1]</code>。</li>
<li>取插入、删除、替换操作数中最小的一个，<code>dp[i][j] = 1 + minOf(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])</code></li>
</ul>
</li>
</ul>
<p><strong>边界条件</strong></p>
<ul>
<li><code>i == 0</code>时，<ul>
<li><code>dp[i - 1][j]</code>表示空字符串变换到<code>word2[0, j]</code>需要的操作数，很显然要插入<code>j + 1</code>个字符，操作数是<code>j + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>j == 0</code>时，<ul>
<li><code>dp[i][j - 1]</code>表示空字符串变换到<code>word1[0, i]</code>需要的操作数，很显然要插入<code>i + 1</code>个字符，操作数是<code>i + 1</code>。</li>
<li><code>dp[i - 1][j - 1]</code>同理</li>
</ul>
</li>
<li><code>i == 0 &amp;&amp; j == 0</code>时，<ul>
<li><code>dp[i - 1][j - 1]</code>（即<code>dp[-1][-1]</code>）表时空字符串转换到空字符串，操作数为0。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(word1.length - <span class="number">1</span>, word2.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度</p>
<p>设m为word1长度，n为word2长度，m &lt; n。</p>
<p>画出递归树可以观察到，一个大问题最多可以拆解为3个子问题，也就是一个结点的下一层最多有3个结点，可以一直这样扩张，树高也就是m和n中的较大值。<br>最坏时间复杂度就是递归树的所有结点数，通过等比数列求和公式可得结点总数为 $O(3^n)$。</p>
<p>一次递归占用一个方法栈，空间复杂度就看同一时刻最多会有多少个方法栈存在，因为递归没有发现结果会回溯，所以得到正确答案的时候递归深度最深，也就是方法栈最多的时候。<br>空间复杂度 $O(n)$。</p>
</blockquote>
<p>递归有大量重叠子问题，比如<code>min(i1 - 1, i2 - 1)</code>在依次经历过<code>min(i1 - 1, i2)</code>和<code>min(i1 - 1, i2 - 1)</code>后可以得到，计算了两次，后续递归还有更多重叠子问题，得把中间计算结果保存一下。</p>
<p><strong>记忆化递归</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> n2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> memo = Array(n1) &#123; IntArray(n2) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">min</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == -<span class="number">1</span>) <span class="keyword">return</span> i2 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i2 == -<span class="number">1</span>) <span class="keyword">return</span> i1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">            memo[i1][i2] = <span class="keyword">if</span> (word1[i1] == word2[i2]) min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> insertion = min(i1, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> deletion = min(i1 - <span class="number">1</span>, i2)</span><br><span class="line">                <span class="keyword">val</span> replacement = min(i1 - <span class="number">1</span>, i2 - <span class="number">1</span>)</span><br><span class="line">                <span class="number">1</span> + minOf(insertion, deletion, replacement)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1 - <span class="number">1</span>, n2 - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上递推</strong><br>自底向上递推会用到前一项的值，为了避免大量边界判断，把dp数组长度加1。<br><code>dp[i][j]</code>表示<code>word1[0, i - 1]</code>和<code>word2[0, j - 1]</code>的最小编辑距离。</p>
<p><code>dp[i][0]</code>表示<code>word1[0, i - 1]</code>变成空字符串需要多少步操作，很显然是要删除<code>word1[0,i - 1]</code>所有字符，共有<code>i</code>个字符。</p>
<p><code>dp[0][j]</code>表示空字符串要变成<code>word2[0,j - 1]</code>需要多少步操作，很显然是要插入<code>word2[0, j - 1]</code>全部字符，总共<code>j</code>个字符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(len1 + <span class="number">1</span>) &#123; IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len1) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.len2) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until len1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until len2) &#123;</span><br><span class="line">	            <span class="comment">// 当前字符相等，不需要操作，操作步数看上一个状态</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前字符不等，可以插入、替换、删除</span></span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + dp[i][j]</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[i + <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[i][j + <span class="number">1</span>]</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(mn)，需要用二维dp数组记录中间计算状态。</p>
</blockquote>
<p><strong>空间优化</strong><br><code>dp[i][j]</code>只跟左、上、左上三项有关，不需要用二维数组记录所有状态，只需要一行数组记录上一行状态即可。</p>
<p>这里有个问题在于，从左到右更新<code>dp</code>数组时会把左上角的值给覆盖掉，所以要在更新左边的值之前，把左上角的值先提前保存一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minDistance</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> len1 = word1.length</span><br><span class="line">        <span class="keyword">val</span> len2 = word2.length</span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(len2 + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.len2) dp[j] = j</span><br><span class="line">        <span class="comment">// 表示左上角的值</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len1) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span>.len2) &#123;</span><br><span class="line">	            <span class="comment">// 更新左边的值之前，把左上角的值先提前保存一下</span></span><br><span class="line">                <span class="keyword">val</span> tmp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[j] = pre</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> replacement = <span class="number">1</span> + pre</span><br><span class="line">                    <span class="keyword">val</span> insertion = <span class="number">1</span> + dp[j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">val</span> deletion = <span class="number">1</span> + dp[j]</span><br><span class="line">                    dp[j] = minOf(replacement, insertion, deletion)</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度 ：O(mn)，m为word1长度，n为word2长度。<br>空间复杂度 ：O(n)，只需要用一维dp数组记录中间计算状态。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.740.删除并获得点数（中等）</title>
    <url>/LeetCode/LeetCode.740.%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">LeetCode.740.删除并获得点数（中等）</a></p>
<p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于要删除值相邻的元素，可以在脑海里先按元素值对nums数组排序，方便梳理题意，最终求解的东西跟数组顺序也没关系。</p>
<p>删除一个<code>nums[i]</code>获得点数后，所有<code>nums[i] - 1</code>和<code>nums[i] + 1</code>的相邻元素被删除了（不计点数），数组里剩下的所有等于<code>nums[i]</code>的值都还是要逐个主动删除并且计入点数的，因为它们不会因为是某个被删除元素的相邻元素而被删除，因为相邻元素从删除第一个<code>nums[i]</code>就删完了。</p>
<p>所以，假设<code>nums[i]</code>在数组里有<code>c</code>个，删除<code>nums[i]</code>可以获得的点数是<code>nums[i] * c</code>。</p>
<p>可以用一个数组<code>sum</code>记录<code>nums</code>数组中所有相同元素的和，以<code>nums[i]</code>作为<code>sum</code>数组的下标，方便查询点数。即<code>sum[nums[i]] = nums[i] * c</code>。</p>
<p>获取了<code>sum[nums[i]]</code>就不能选取<code>sum[nums[i] - 1]</code>和<code>sum[nums[i] + 1]</code>了，这就转变为打家劫舍的最优化问题。  </p>
<p><code>sum</code>数组的长度为<code>nums数组的最大值 + 1</code>，是一个常数空间，对性能影响可以接受。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteAndEarn</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> maxValue = nums.max()!!</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(maxValue + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            sum[num] += num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rob</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> pre1 = maxOf(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">var</span> cur = pre1</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until nums.size) &#123;</span><br><span class="line">            cur = maxOf(pre2 + nums[i], pre1)</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.746.使用最小花费爬楼梯（简单）</title>
    <url>/LeetCode/LeetCode.746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">LeetCode.746.使用最小花费爬楼梯（简单）</a></p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最优化问题，往动态规划上考虑，看是否符合动态规划的条件：最优子结构、重叠子问题、无后效性。<br>一般从最终状态做倒推，拆分步骤，列出所有到达最终状态的步骤，看能否拆分为上一个同性质的子问题+有限步骤，拆分步骤的过程得出状态转移方程。</p>
<p>cost数组长度为n，到达楼顶就是到达下标n的地方。<br>设<code>dp[i]</code>表示达到到达下标i所需的最小花费，<code>0 &lt;= i &lt;= n</code>。</p>
<h3 id="初始边界"><a href="#初始边界" class="headerlink" title="初始边界"></a>初始边界</h3><p>可以从下标为0或1的阶梯开始爬，说明<code>dp[0] = dp[1] = 0</code>。</p>
<h3 id="划分子问题"><a href="#划分子问题" class="headerlink" title="划分子问题"></a>划分子问题</h3><p>达到第i个阶梯，最后一步有两种选择：</p>
<ol>
<li>在第i-1层爬1个阶梯。</li>
<li>在第i-2层爬2个阶梯。</li>
</ol>
<p>到达第i-1层的最小花费是<code>dp[i-1]</code>，爬1个阶梯需要耗费<code>cost[i-1]</code><br>到达第i-2层的最小花费是<code>dp[i-2]</code>，爬2个阶梯需要耗费<code>cost[i-2]</code><br>那么，到达第i层阶梯就是取两者中较小值。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>dp[i]</code>只与前两项值有关，所以不需要数组，用两个变量保存前面两项值即可。</p>
<h3 id="代码（Kotlin）"><a href="#代码（Kotlin）" class="headerlink" title="代码（Kotlin）"></a>代码（Kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">            cur = minOf(pre1 + cost[i - <span class="number">1</span>], pre2 + cost[i - <span class="number">2</span>])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.75.颜色分类（中等）</title>
    <url>/LeetCode/LeetCode.75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/">LeetCode.75.颜色分类（中等）</a></p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="排序解法"><a href="#排序解法" class="headerlink" title="排序解法"></a>排序解法</h3><p>直接用排序算法排序数组即可得到结果。</p>
<p>采用不同的排序算法，时间复杂度和空间复杂度各不同。</p>
<p>如果用基于比较的排序算法，平均时间复杂度最低为O(n * log n)，空间复杂度O(1)，例如快速排序、堆排序。</p>
<p>由于数组元素取值就三种情况，是常数个，可以使用不基于元素比较的线性时间排序算法，如计数排序，时间复杂度O(n)，空间复杂度O(n)。</p>
<h3 id="更优的解法"><a href="#更优的解法" class="headerlink" title="更优的解法"></a>更优的解法</h3><p>由于元素取值只有极少的常数个，可以发现这里元素归位的过程很像快速排序的划分算法，把不同类型的元素放在轴心元素的两边。</p>
<p>如果只有两个颜色（红色和白色），可以直接用划分了，而一次划分时间复杂度是O(n)，空间复杂度O(1)。</p>
<p>快速排序的划分算法：</p>
<ul>
<li>双指针分别指向数组开始和末尾。</li>
<li>左指针遇到白色就与右指针交换元素，把白色放在右边，右指针向左前进一位。</li>
<li>右指针遇到红色就与左指针交换元素，把红色放在左边，左指针向右前进一位。</li>
<li>左右指针相遇后，红色和白色都放置在各自的一边了。</li>
</ul>
<p>划分算法的关键是，遇到不是这个位置的元素，就把它放到属于它的那一类的位置。</p>
<p>可以发现，左指针的左边总是红色元素，右指针的右边总是白色元素。</p>
<p><strong>三个颜色会有什么不同？</strong></p>
<p>那就再增加一个蓝色指针，表示这个指针的左边到红色指针的右边都是蓝色元素。</p>
<p>在用蓝色指针遍历数组时：</p>
<ul>
<li>发现红色元素，放到红色指针左边。</li>
<li>发现白色元素，放到白色指针右边。</li>
<li>发现蓝色元素，已经在自己这边了，前进一个位置。</li>
</ul>
<p>蓝色指针和白色指针相遇后，所有颜色就正确归位了。</p>
<p>最终还是一次线性划分就能解决。<br>时间复杂度O(n)，空间复杂度O(1)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sortColors</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p0 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> p2 = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">when</span>(nums[p1]) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    nums.swap(p0, p1)</span><br><span class="line">                    p0++</span><br><span class="line">                    p1++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    nums.swap(p1, p2)</span><br><span class="line">                    p2--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; p1++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.76.最小覆盖子串（困难）</title>
    <url>/LeetCode/LeetCode.76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode.76.最小覆盖子串（困难）</a></p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<span id="more"></span>
<p>注意：</p>
<ul>
<li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li>
<li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在  <code>o(n)</code>  时间内解决此问题的算法吗？</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力朴素法"><a href="#暴力朴素法" class="headerlink" title="暴力朴素法"></a>暴力朴素法</h3><p>设<code>s</code>长度为<code>n</code>，<code>t</code>长度为<code>m</code>。</p>
<p>把<code>t</code>的字符都存在哈希表中，相同字符进行计数。</p>
<p>从<code>s</code>的每一个位置开始，看后面的<code>m</code>个字符是否都在哈希表中，并且相同字符的个数也一样。</p>
<p>这样匹配的时间复杂度是<code>O(mn)</code>，空间复杂度<code>O(m)</code>。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>暴力法有很多重复的判断，所以时间复杂度高，如果能把已经判断过的东西不用再判断了就可以降低时间复杂度。</p>
<p>可以使用滑动窗口，最多也就是滑动窗口的左右边界走完整个字符串，时间复杂度是<code>O(n)</code>的。</p>
<p>算法步骤：</p>
<ol>
<li>不停的扩大窗口，直至窗口中包含了t中所有字符。</li>
<li>不停的缩小窗口，直至窗口中没有包含t中所有字符。</li>
<li>重复上述两步，每一步记录最小的窗口的大小。</li>
</ol>
<p>还是需要把<code>t</code>的字符都存在哈希表中，方便判断窗口中有没有包含t中所有字符，相同字符进行计数。</p>
<p>细节见源码注释。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    滑动窗口两步走:</span></span><br><span class="line"><span class="comment">    1. 不停的扩大窗口，直至窗口中包含了t中所有字符；如果不能再扩大了就不扩大了</span></span><br><span class="line"><span class="comment">    2. 不停的缩小窗口，直至窗口中没有包含t中所有字符，缩小前记录最小的符合答案条件的子串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minWindow</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// S中包含T所有字符的最小子串</span></span><br><span class="line">        <span class="keyword">var</span> minSubstr = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">val</span> window = Window(s, t)</span><br><span class="line">        <span class="keyword">while</span> (window.extend()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (window.match()) &#123;</span><br><span class="line">                <span class="comment">// 有更小的满足答案的窗口，那就要记录下来</span></span><br><span class="line">                <span class="comment">// 但是初始时minSubstr是长度为0，需要特殊对待，因为一旦发现了满足答案的窗口，就要更新记录</span></span><br><span class="line">                <span class="keyword">if</span> (minSubstr.isEmpty() || window.windowSize() &lt; minSubstr.length) &#123;</span><br><span class="line">                    minSubstr = window.windowString()</span><br><span class="line">                &#125;</span><br><span class="line">                window.shorten()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSubstr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>(</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> s: String,</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> t: String</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 记录t中所有字符出现的次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> tMap = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口已出现的字符的次数，可以只记录t中存在的字符，t中不存在的字符记录也没啥意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> wMap = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录匹配的字符数量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> matchedCharCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> right = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            t.forEach &#123; c -&gt;</span><br><span class="line">                tMap[c] = <span class="number">1</span> + tMap.getOrDefault(c, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 扩大窗口</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果还能继续扩大返回true，不能再扩大了返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">extend</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="comment">// 窗口已经滑动到字符串最右侧了</span></span><br><span class="line">            <span class="keyword">if</span> (right == s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            right++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 窗口又增加一个字符</span></span><br><span class="line">            <span class="keyword">val</span> c = s[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">                <span class="comment">// 窗口只记录t中存在的字符，记录t中不存在的字符也没啥意义</span></span><br><span class="line">                wMap[c] = <span class="number">1</span> + wMap.getOrDefault(c, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果窗口内当前字符c的个数已经达到t中c字符的数量，记录匹配的字符数量</span></span><br><span class="line">                <span class="comment">// 字符数量过多不管它，在缩小窗口时一起考虑这个问题</span></span><br><span class="line">                <span class="keyword">if</span> (tMap.containsKey(c) &amp;&amp; tMap[c] == wMap[c]) &#123;</span><br><span class="line">                    matchedCharCount++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口中有字符串t中所有的字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchedCharCount == tMap.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 减少左边界缩短窗口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">shorten</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> c = s[left]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">                wMap[c] = wMap.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 窗口里c字符数量小于t中c的字符数量，匹配字符数量减1</span></span><br><span class="line">                <span class="comment">// 这里感觉有多减的风险，但是其实不会发生，因为一旦不匹配了，就不会再继续缩小窗口了，而是会扩大窗口，所以不用考虑</span></span><br><span class="line">                <span class="keyword">if</span> (wMap[c]!! &lt; tMap[c]!!) &#123;</span><br><span class="line">                    matchedCharCount--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口字符串长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">windowSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 窗口字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">windowString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.84.柱状图中最大的矩形（困难）</title>
    <url>/LeetCode/LeetCode.84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a></p>
<p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><p>暴力法虽然时间复杂度往往比较高，但是可以理清思路。</p>
<p><strong>思路</strong></p>
<p>就是枚举以每个柱子高度作为边长的最大矩形面积。</p>
<p>从每个柱子向左和向右检查是否有相同高度或更高的柱子，统计可以形成的矩形的最大宽度，然后计算面积，记录最大的。</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度<code>O(n ^ 2)</code>：</p>
<ul>
<li>枚举所有柱子需要访问数组所有元素。</li>
<li>一次中心扩散最坏情况下要访问数组所有元素，比如所有柱子高度相同。</li>
</ul>
<p>空间复杂度<code>O(1)</code>：</p>
<ul>
<li>没有额外空间开销</li>
</ul>
<h3 id="暴力法多余的时间开销在哪？"><a href="#暴力法多余的时间开销在哪？" class="headerlink" title="暴力法多余的时间开销在哪？"></a>暴力法多余的时间开销在哪？</h3><p>中心扩散时，当前柱子的向右扩散，和后面柱子的向左扩散，这两个是重复的动作，应该优化。</p>
<h3 id="应该怎么优化时间开销？"><a href="#应该怎么优化时间开销？" class="headerlink" title="应该怎么优化时间开销？"></a>应该怎么优化时间开销？</h3><p>由于要查看每一个柱子高度能够形成多大面积的矩形，所以至少要遍历一次数组。</p>
<p>我们是从左到右遍历数组的，可以想办法避免向右扩散，只向左扩散来计算当前矩形面积，因为左边的柱子已经遍历过了。</p>
<p>那么现在问题变为：</p>
<ul>
<li>遇到什么样的柱子才能向左扩散？</li>
<li>向左扩散时，左边的柱子什么时候计算以它们的高度为矩形边长的面积？</li>
</ul>
<h3 id="遇到什么样的柱子才能向左扩散？"><a href="#遇到什么样的柱子才能向左扩散？" class="headerlink" title="遇到什么样的柱子才能向左扩散？"></a>遇到什么样的柱子才能向左扩散？</h3><ul>
<li>看暴力法中向右扩散的条件是，右边的柱子比当前柱子高，才需要扩散。</li>
<li>那么右边柱子如果比当前柱子矮，就无法向右扩散，只能向左扩散。</li>
</ul>
<h3 id="向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？"><a href="#向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？" class="headerlink" title="向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？"></a>向左扩散左边的柱子什么时候计算以它们的高度为矩形边长的面积？</h3><p>在遇到不能向右扩散的柱子之前，所遍历过的柱子的特点是：它们高度是从左到右递增或相等的，否则就应该向左扩散了。</p>
<p>假设在遍历时，发现当前柱子比前一个柱子矮，设当前柱子是第i个。</p>
<h4 id="以第i-1个柱子高度构成的矩形面积怎么求？"><a href="#以第i-1个柱子高度构成的矩形面积怎么求？" class="headerlink" title="以第i - 1个柱子高度构成的矩形面积怎么求？"></a>以第i - 1个柱子高度构成的矩形面积怎么求？</h4><ul>
<li>要寻找左右边界在哪。</li>
<li>右边界是知道的，就是i，因为第i - 1个柱子的高度不能向右扩散了。</li>
<li>左边界是i - 2，因为第i - 2个柱子到第i - 1个柱子的高度是递增的，第i - 1个柱子的高度不能向左扩散。</li>
</ul>
<h4 id="以第i-2个柱子高度构成的矩形面积怎么求？"><a href="#以第i-2个柱子高度构成的矩形面积怎么求？" class="headerlink" title="以第i - 2个柱子高度构成的矩形面积怎么求？"></a>以第i - 2个柱子高度构成的矩形面积怎么求？</h4><ul>
<li>左边界是i - 3，因为左边柱子高度是递增的。</li>
<li>右边界在哪，要取决于第i - 2个柱子和第i个柱子哪个更高。<ul>
<li>如果第i - 2个柱子比第i个柱子高，右边界是i，因为第i - 2个柱子到第i - 1个柱子的高度是递增的，所以第i - 2个柱子可以把矩形扩散到比它高的柱子下面。</li>
<li>如果第i - 2个柱子比第i个柱子矮，右边界不是i了，因为第i - 2个柱子的高度还可以向右扩散。<ul>
<li>什么时候可以计算以第i - 2个柱子高度的矩形面积呢？要在后面遇到比第i - 2个柱子矮的柱子才行，右边界就是后面那个矮柱子的索引，左边界是i - 3。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应该怎么记录左边柱子的信息？"><a href="#应该怎么记录左边柱子的信息？" class="headerlink" title="应该怎么记录左边柱子的信息？"></a>应该怎么记录左边柱子的信息？</h3><ul>
<li>由于在遇到高度递减的柱子时，会求以左边柱子高度构成的矩形面积，而且并且有的柱子会求有的柱子不会求，所以要记录下所有没有求过矩形面积的柱子索引，并要能添加和移除，需要用一个集合保存。</li>
<li>由于要访问左边柱子的高度，而遍历顺序是从左到右的，所以符合这个数据访问顺序的数据结构是栈。</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>计算第一个柱子高度的矩形面积时左边界是-1，取做边界的时候要特殊处理一下。</li>
<li>如果末尾的柱子都是递增的，不会触发向左扩散，需要再遍历结束后手动触发一下。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><ul>
<li>遍历一次数组需要访问n个元素。</li>
<li>虽然访问栈需要往回看，但是入栈的元素都是不重复的，并且每个元素只会访问一次，往回看最多访问n个元素。</li>
</ul>
<h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><p>最坏情况下，数组完全递增，栈最多保存n个元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">largestRectangleArea</span><span class="params">(heights: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = heights.size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">                <span class="keyword">val</span> right = i</span><br><span class="line">                <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">                maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发末尾递增柱子的矩形面积计算</span></span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">val</span> right = n</span><br><span class="line">            <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">            maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.85.最大矩形（困难）</title>
    <url>/LeetCode/LeetCode.85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">LeetCode.85.最大矩形（困难）</a></p>
<p>给定一个仅包含 <code>0</code>  和  <code>1</code>  、大小为  <code>rows x cols</code>  的二维二进制矩阵，找出只包含  <code>1</code>  的最大矩形，并返回其面积。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果以某一行为横轴，该行以上的列为纵轴区域，问题就转变为<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a>。</p>
<p>某一行下，每一列下，与行相连的1的个数就是柱子高度。</p>
<h3 id="整个求解过程"><a href="#整个求解过程" class="headerlink" title="整个求解过程"></a>整个求解过程</h3><ul>
<li>统计每一行下柱子的高度</li>
<li>带入<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode.84.柱状图中最大的矩形（困难）</a>的求解公式里求出柱子可以形成的最大矩形面积</li>
<li>然后在所有行的最大矩形面积里取一个最大值。</li>
</ul>
<h3 id="每行柱子高度统计方法优化"><a href="#每行柱子高度统计方法优化" class="headerlink" title="每行柱子高度统计方法优化"></a>每行柱子高度统计方法优化</h3><ul>
<li>如果到达每一行，再往上遍历遍历每列柱子高度，是有重复计算的。</li>
<li>可以保存之前行的柱子高度的结果，在到下一行的时候，发现这一行某一列是1，就累加高度，是0就清空柱子高度，因为无法形成柱子。这样就不用重复计算了。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maximalRectangle</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> m = matrix.size</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> heights = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (col <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) heights[col]++</span><br><span class="line">                <span class="keyword">else</span> heights[col] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> area = largestRectangleArea(heights)</span><br><span class="line">            maxArea = maxOf(maxArea, area)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">largestRectangleArea</span><span class="params">(heights: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = heights.size</span><br><span class="line">        <span class="keyword">var</span> maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> stack = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">                <span class="keyword">val</span> right = i</span><br><span class="line">                <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">                <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">                maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发末尾递增柱子的矩形面积计算</span></span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">val</span> right = n</span><br><span class="line">            <span class="keyword">val</span> left = <span class="keyword">if</span> (stack.isNotEmpty()) stack.peek() <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> width = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> rectArea = width * height</span><br><span class="line">            maxArea = maxOf(maxArea, rectArea)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度O-mn"><a href="#时间复杂度O-mn" class="headerlink" title="时间复杂度O(mn)"></a>时间复杂度O(mn)</h4><p>m为矩阵行数，n为矩阵列数。</p>
<ul>
<li>求柱子高度需要遍历矩阵所有元素，所有元素有m*n个。</li>
<li>求每个柱子高度需要O(n)。</li>
</ul>
<h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><ul>
<li>高度数组占用O(n)。</li>
<li>求柱子最大矩形面积需要O(n)的栈。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.87.扰乱字符串（困难）</title>
    <url>/LeetCode/LeetCode.87.%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/scramble-string/">LeetCode.87.扰乱字符串（困难）</a></p>
<p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：</p>
<ul>
<li>如果字符串的长度为 1 ，算法停止</li>
<li>如果字符串的长度 &gt; 1 ，执行下述步骤：<ul>
<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。</li>
<li>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。</li>
<li>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
</ul>
</li>
</ul>
<p>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目描述已经给出了拆解步骤和子问题的划分。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从最后一步开始想：</p>
<ul>
<li>设s1拆解为a1和a2，s2拆解为b1和b2</li>
<li>因拆解后子串顺序有两种，如果s1能扰乱为s2，那么s1和s2对应关系也就有两种：<ul>
<li>a1是否能从b1扰乱来，并且，a2是否能从b2扰乱来；其中<code>a1.length == b1.length &amp;&amp; a2.length == b2.length</code>。</li>
<li>a1是否能从b2扰乱来，并且，a2是否能从b1扰乱来；其中<code>a1.length == b2.length &amp;&amp; a2.length == b1.length</code>。</li>
</ul>
</li>
</ul>
<p>子问题和拆解步骤就出来了。</p>
<h3 id="应该怎么拆解字符串？"><a href="#应该怎么拆解字符串？" class="headerlink" title="应该怎么拆解字符串？"></a>应该怎么拆解字符串？</h3><p>穷举所有可以拆解的位置</p>
<h3 id="有哪些状态？"><a href="#有哪些状态？" class="headerlink" title="有哪些状态？"></a>有哪些状态？</h3><ul>
<li>拆解字符串需要知道起始索引和结束索引。</li>
<li>有两个字符串，也就有4个状态。</li>
<li>但是拆解过后的子串长度是相等的，所以可以不记录两个结束索引，只记录拆解的子串长度，缩减为3个状态。</li>
</ul>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li>如果两个字符串长度不相等，两者无法通过扰乱变为一致。</li>
<li>如果两个字符串长度相等，但每种字符个数不相等，两者无法通过扰乱变为一致。</li>
<li>拆到只有一个字符的时候，直接判断字符是否相同。</li>
</ul>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> s1CharCountMap = s1.groupingBy&#123;it&#125;.eachCount()</span><br><span class="line">        <span class="keyword">val</span> s2CharCountMap = s2.groupingBy&#123;it&#125;.eachCount()</span><br><span class="line">        <span class="keyword">if</span> (s1CharCountMap != s2CharCountMap) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> a1 = s1.substring(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> a2 = s1.substring(i + <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">val</span> b1 = s2.substring(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> b2 = s2.substring(i + <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (isScramble(a1, b1) &amp;&amp; isScramble(a2, b2)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (isScramble(a1, b2) &amp;&amp; isScramble(a2, b1)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度指数级别</p>
</blockquote>
<h3 id="指针递归"><a href="#指针递归" class="headerlink" title="指针递归"></a>指针递归</h3><p>上面的递归解法非常直白，但是不方便存储中间计算结果，子串改成指针形式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1[i1, i1 + length - 1]和s2[i2, i2 + length - 1]是否有一样的字符和字符个数</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hasSameChars</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> counts = IntArray(<span class="number">26</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i1 until i1 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s1[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i2 until i2 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s2[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counts.sum() == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">1</span>) <span class="keyword">return</span> s1[i1] == s2[i2]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 词频不一样，肯定不能转换</span></span><br><span class="line">            <span class="keyword">if</span> (!hasSameChars(i1, i2, length)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k为s1和s2分割出来的左半部分的长度</span></span><br><span class="line">            <span class="comment">// 左子串最短长度为1</span></span><br><span class="line">            <span class="comment">// 左子串最长长度为length - 1，因为要留一个长度给右子串</span></span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2, k) &amp;&amp; test(i1 + k, i2 + k, length - k)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2 + length - k, k) &amp;&amp; test(i1 + k, i2, length - k)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test(<span class="number">0</span>, <span class="number">0</span>, n) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h3><p>暴力递归有重叠子问题，需要记录中间计算状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1[i1, i1 + length - 1]和s2[i2, i2 + length - 1]是否有一样的字符和字符个数</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hasSameChars</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> counts = IntArray(<span class="number">26</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i1 until i1 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s1[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i2 until i2 + length) &#123;</span><br><span class="line">                <span class="keyword">val</span> index = s2[j].toInt() - <span class="string">&#x27;a&#x27;</span>.toInt()</span><br><span class="line">                counts[index]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counts.sum() == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> memo = Array(n) &#123; Array(n) &#123; IntArray(n + <span class="number">1</span>) &#123; -<span class="number">1</span> &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i1: <span class="type">Int</span>, i2: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[i1][i2][length] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> matched = s1[i1] == s2[i2]</span><br><span class="line">                memo[i1][i2][length] = <span class="keyword">if</span> (matched) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> matched</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 词频不一样，肯定不能转换</span></span><br><span class="line">            <span class="keyword">if</span> (!hasSameChars(i1, i2, length)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k为s1和s2分割出来的左半部分的长度</span></span><br><span class="line">            <span class="comment">// 左子串最短长度为1</span></span><br><span class="line">            <span class="comment">// 左子串最长长度为length - 1，因为要留一个长度给右子串</span></span><br><span class="line">            <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2, k) &amp;&amp; test(i1 + k, i2 + k, length - k)) &#123;</span><br><span class="line">                    memo[i1][i2][length] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (test(i1, i2 + length - k, k) &amp;&amp; test(i1 + k, i2, length - k)) &#123;</span><br><span class="line">                    memo[i1][i2][length] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test(<span class="number">0</span>, <span class="number">0</span>, n) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度O-n-4"><a href="#时间复杂度O-n-4" class="headerlink" title="时间复杂度O(n^4)"></a>时间复杂度O(n^4)</h3><ul>
<li>递归会枚举所有length的取值情况，1 &lt;= length &lt;= n。</li>
<li>对于每个length枚举了左子串字符数k的所有取值可能，1 &lt;= k &lt;= length。</li>
<li>递归枚举了所有i1的取值情况，0 &lt;= i1 &lt;= n - 1</li>
<li>递归枚举了所有i2的取值情况，0 &lt;= i2 &lt;= n - 1</li>
</ul>
<h3 id="空间复杂度O-n-3"><a href="#空间复杂度O-n-3" class="headerlink" title="空间复杂度O(n^3)"></a>空间复杂度O(n^3)</h3><p>状态存储是三维数组。</p>
<h3 id="自底向上的动态规划"><a href="#自底向上的动态规划" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h3><p>记忆化递归的备忘录数组的填充过程已经给出了状态转移方程。</p>
<p>设<code>dp[i][j][len]</code>代表  <code>s1</code>  从  <code>i</code>  开始，<code>s2</code>  从  <code>j</code>  开始，后面长度为  <code>len</code>  的字符是否能形成扰乱字符串。</p>
<p><strong>状态转移方程</strong></p>
<p>设<code>s1</code>的左子串的长度为<code>k</code>。</p>
<p><code>dp[i][j][len] = dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k] || dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]</code></p>
<p><strong>边界情况</strong></p>
<p>长度为1时，只需要判断字符是否相同。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isScramble</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length != s2.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> n = s1.length</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(n) &#123; BooleanArray(n + <span class="number">1</span>) &#123; <span class="literal">false</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = s1[i] == s2[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (len <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.(n - len)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span> until len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k] || dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]) &#123;</span><br><span class="line">                            dp[i][j][len] = <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.91.解码方法（中等）</title>
    <url>/LeetCode/LeetCode.91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://leetcode-cn.com/problems/decode-ways/">LeetCode.91.解码方法（中等）</a></p>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<blockquote>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
</blockquote>
<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<ul>
<li>“AAJF” ，将消息分组为 (1 1 10 6)</li>
<li>“KJF” ，将消息分组为 (11 10 6)</li>
</ul>
<p>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>思考能否将某个状态下的问题拆分为子问题+有限步骤。</p>
<p>设<code>a[i]</code>为<code>s[0..i]</code>中解码方法总数。</p>
<h3 id="a-i-取值受什么影响？"><a href="#a-i-取值受什么影响？" class="headerlink" title="a[i]取值受什么影响？"></a>a[i]取值受什么影响？</h3><p>受<code>s[i - 1]</code>和<code>s[i - 2]</code>的取值影响，因为要决定是解析一个字符还是两个字符。<br><code>a[i]</code>可以通过<code>a[i - 1]</code>或<code>a[i - 2]</code>递推而来。</p>
<h3 id="s-i-1-和s-i-2-组合的数有哪些情况？"><a href="#s-i-1-和s-i-2-组合的数有哪些情况？" class="headerlink" title="s[i - 1]和s[i - 2]组合的数有哪些情况？"></a><code>s[i - 1]</code>和<code>s[i - 2]</code>组合的数有哪些情况？</h3><p>根据题意，没有直接映射到0的情况，要注意：</p>
<ol>
<li>不能单独映射0，只能作为10或者20整体解析，方案数不变，<code>a[i] = a[i - 1]</code>。一旦出现0的前面不是1或2，整个s无法解析，直接返回0方案数。</li>
<li>06这样的0处在十位数的也不能作为个位数解析，只能一个个解析，方案数不变，<code>a[i] = a[i - 1]</code></li>
</ol>
<p>两个数字剩余的合法取值范围在[11, 19]、[21, 26]，此时可以映射一个字母，也可以映射两个字母。<br><code>a[i] = a[i - 1] + a[i - 2]</code></p>
<p>其他大于26的情况，只能映射一个字母，方案数不变，<code>a[i] = a[i - 1]</code></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><code>a[i]</code>只与前两个状态有关，只用两个保存状态即可，不需要数组记录所有状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numDecodings</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = s.length</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始的一个字符只有一种映射方案</span></span><br><span class="line">        <span class="keyword">var</span> prepre = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始时，前两个字符的解析方案数</span></span><br><span class="line">        <span class="keyword">var</span> pre = <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> num = parseInt(s[<span class="number">0</span>], s[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cur = pre</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第3个字符开始解析</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">            cur = <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>) prepre</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> num = parseInt(s[i - <span class="number">1</span>], s[i])</span><br><span class="line">                <span class="keyword">if</span> (num <span class="keyword">in</span> <span class="number">11.</span><span class="number">.19</span> || num <span class="keyword">in</span> <span class="number">21.</span><span class="number">.26</span>) pre + prepre <span class="keyword">else</span> pre</span><br><span class="line">            &#125;</span><br><span class="line">            prepre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(a: <span class="type">Char</span>, b: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tens = (a.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()) * <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> units = b.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line">        <span class="keyword">return</span> tens + units</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.918.环形子数组的最大和（中等）</title>
    <url>/LeetCode/LeetCode.918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">LeetCode.918.环形子数组的最大和（中等）</a></p>
<p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p>
<p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，且当 i &gt;= 0 时 C[i+A.length] = C[i]）</p>
<p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="环形数组跟非环形数组的区别是什么？"><a href="#环形数组跟非环形数组的区别是什么？" class="headerlink" title="环形数组跟非环形数组的区别是什么？"></a>环形数组跟非环形数组的区别是什么？</h3><p>环形数组中最终求得的最大和子数组有两种情况</p>
<ol>
<li>数组A的首尾元素不会连接</li>
<li>数组A的首尾元素会连接</li>
</ol>
<h3 id="数组A的首尾元素不会连接的情况如何求解？"><a href="#数组A的首尾元素不会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素不会连接的情况如何求解？"></a>数组A的首尾元素不会连接的情况如何求解？</h3><p>第1种情况就是非环形数组的普通求法，参与计算的区间为<code>[0, n - 1]</code></p>
<h3 id="数组A的首尾元素会连接的情况如何求解？"><a href="#数组A的首尾元素会连接的情况如何求解？" class="headerlink" title="数组A的首尾元素会连接的情况如何求解？"></a>数组A的首尾元素会连接的情况如何求解？</h3><p>第2种情况不好用非环形数组的方法求解，实际观察结果可以得到等价情况：先求出中间部分的子数组的最小和，再用整个数组A的和减去中间的最小和就是两端首尾相连的子数组的最大和。<br>这时只在数组A的<code>[1, n - 2]</code>区间求解，这才能保证首尾不连接。</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubarraySumCircular</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMaxSumInLinearCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = maxOf(pre + nums[i], nums[i])</span><br><span class="line">                maxSum = maxOf(maxSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getMinSumInCyclicCase</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> minSum = nums[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.(n - <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">val</span> cur = minOf(pre + nums[i], nums[i])</span><br><span class="line">                minSum = minOf(minSum, cur)</span><br><span class="line">                pre = cur</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minSum</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxOf(</span><br><span class="line">            getMaxSumInLinearCase(), </span><br><span class="line">            nums.sum() - getMinSumInCyclicCase()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.931.下降路径最小和（中等）</title>
    <url>/LeetCode/LeetCode.931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">LeetCode.931.下降路径最小和（中等）</a></p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最值问题考虑动态规划，拆分大问题为子问题+有限步骤。</p>
<p>下降路径在第一行任何元素都能开始。</p>
<p>针对第一行某个元素，要选取左下方、正下方、右下方三条向下路径中和最小的路径的和，再加上当前元素的值，就是当前元素开始的下降路径的最小和。<br>第二行每个元素的和最小的下降路径求法一样，直到最后一行。</p>
<p>第一行每个元素的下降路径最小和都逐个求出后，选取一个最小的。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>设<code>dp[r][c]</code>是第r行第c列下降路径最小和。<br><code>dp[r][c] = matrix[r][c] + minOf(dp[r + 1, c - 1], dp[r + 1, c], dp[r + 1, c + 1])</code></p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>最后一行，没有下面一行了<br><code>dp[r][c] = matrix[r][c]</code></li>
<li>第一列，只能读取下方和右下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c], dp[r + 1, c + 1])</code></li>
<li>最后一列，只能读取下方和左下方元素。<br><code>dp[r][c] = minOf(dp[r + 1, c - 1], dp[r + 1, c])</code></li>
</ul>
<h3 id="递推顺序"><a href="#递推顺序" class="headerlink" title="递推顺序"></a>递推顺序</h3><p>从下往上</p>
<h3 id="代码（kotlin）"><a href="#代码（kotlin）" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> dp = Array(rows) &#123; IntArray(columns) &#123; <span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            dp[rows - <span class="number">1</span>][c] = matrix[rows - <span class="number">1</span>][c]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                dp[r][c] = matrix[r][c] + </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(dp[r + <span class="number">1</span>][c], dp[r + <span class="number">1</span>][c - <span class="number">1</span>], dp[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, dp[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>因为是逐行递推的，所以可以用原数组存储，不用额外开辟二维数组。</p>
<h3 id="代码（kotlin）-1"><a href="#代码（kotlin）-1" class="headerlink" title="代码（kotlin）"></a>代码（kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minFallingPathSum</span><span class="params">(matrix: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = matrix.size </span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> columns = matrix[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">if</span> (columns == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (r <span class="keyword">in</span> rows - <span class="number">2</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                matrix[r][c] += </span><br><span class="line">                <span class="comment">// 第一列</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 最后一列</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == columns - <span class="number">1</span>) minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 中间列</span></span><br><span class="line">                <span class="keyword">else</span> minOf(matrix[r + <span class="number">1</span>][c], matrix[r + <span class="number">1</span>][c - <span class="number">1</span>], matrix[r + <span class="number">1</span>][c + <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> minSum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">            minSum = minOf(minSum, matrix[<span class="number">0</span>][c])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.96.不同的二叉搜索树（中等）</title>
    <url>/LeetCode/LeetCode.96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode.96.不同的二叉搜索树（中等）</a></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<blockquote>
<p>提示：  <code>1 &lt;= n &lt;= 19</code></p>
<span id="more"></span>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树的问题第一反应会想到递归，进而想到能不能划分子问题。</p>
<p>从基本情况开始梳理。<br>构造一棵树，要选一个根节点。<br>如果以某个数字为根节点，左子树有a种，右子树有b种，那么这棵树就有a * b种可能。</p>
<p>左子树和右子树的构建，也要选择根节点，选择逻辑一样，可以递归进行，但是能选的根节点数量少了一个。</p>
<p>递推下去可以发现，如果剩余可选节点数越少，种数就越少。</p>
<p>设<code>sum[i]</code>为节点总数为<code>i</code>的二叉搜索树的种数。<br>除去根节点，假设左子树有<code>j</code>个节点，右子树就有<code>i - 1 - j</code>个节点，其中<code>j</code>的取值范围是<code>0 &lt;= j &lt;= i - 1</code>，得把所有的<code>j</code>可能情况都取一遍值，最后累加结果，就得到<code>sum[i]</code>。</p>
<p><strong>状态转移方程</strong><br><code>sum[i]= ∑ sum[j] * sum[i - 1 - j]</code>，<code>0 &lt;= j &lt;= i - 1</code></p>
<p><strong>边界处理</strong><br>总共只有0个节点，是空树，也算一种树，<code>sum[0] = 1</code>。想象一下如果左子树为空，右子树有n种，那么当前树也应该有n种。<br>总共只有1个节点，只有一种情况，<code>sum[1] = 1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = IntArray(n + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        sum[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">                sum[i] += sum[j] * sum[i - <span class="number">1</span> - j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.188.买卖股票的最佳时机 IV（困难）</title>
    <url>/algorithm/LeetCode.188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode.188.买卖股票的最佳时机 IV（困难）</a></p>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最优化问题考虑用动态规划。</p>
<p>看最终结果受哪些因素影响，穷举不同因素的所有状态值，就可以推导出最终结果。</p>
<h3 id="最终收益受哪些维度的状态变化影响？"><a href="#最终收益受哪些维度的状态变化影响？" class="headerlink" title="最终收益受哪些维度的状态变化影响？"></a>最终收益受哪些维度的状态变化影响？</h3><ul>
<li>在第几天买入或卖出肯定是会影响最终收益，可能某一天突然暴涨。</li>
<li>交易次数越多，可能赚取的收益越大。</li>
<li>在第<code>i</code>天可以选择的操作有三种：买入、卖出、什么也不做。<br>什么也不做包含了两种状态：买入过后什么也不做、卖出过后什么也不做。归纳合并一下，这些操作会产生的结果状态是：第<code>i</code>天持有或不持有股票。股票持有状态也会影响最终收益。</li>
</ul>
<p>所以从结果上看，一共有三种纬度的状态变化：</p>
<ul>
<li>第几天做出选择</li>
<li>已经交易了多少次</li>
<li>当前是否持有股票</li>
</ul>
<h3 id="买入的时候算一次交易，还是卖出的时候算一次交易？"><a href="#买入的时候算一次交易，还是卖出的时候算一次交易？" class="headerlink" title="买入的时候算一次交易，还是卖出的时候算一次交易？"></a>买入的时候算一次交易，还是卖出的时候算一次交易？</h3><p>其实都可以，不影响最终结果，只是状态转移过程会有所变化。<br>这里定义买入的时候算一次交易。</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i][j][k]</code>表示，前<code>i</code>天，交易了<code>j</code>次，在第<code>i</code>天持有或不持有股票，所获得最大的收益。其中<code>k == 0</code>表示不持有，<code>k == 1</code>表示持有。</p>
<ul>
<li><code>dp[i][j][0]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][0]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天卖出。<ul>
<li><code>dp[i][j][0] = dp[i - 1][j][1] + prices[i]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>dp[i][j][1]</code>怎么得来？<ul>
<li>第<code>i - 1</code>天持有股票，第<code>i</code>天什么也不操作。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j][1]</code></li>
</ul>
</li>
<li>第<code>i - 1</code>天没有持有股票，第<code>i</code>天买入。<ul>
<li><code>dp[i][j][1] = dp[i - 1][j - 1][0] - prices[i]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>第0天<ul>
<li>持有股票的话，不论多少次交易，只能直接买入一次。</li>
<li>不持有股票的话，收益就是0。</li>
</ul>
</li>
<li>第<code>i</code>天之前都没有交易（即<code>j == 0</code>），第<code>i</code>天要交易操作就是买入。</li>
</ul>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>如果给定的最多交易次数<code>k</code>非常大，状态数组开辟空间也会非常大，考虑是否有优化的可能。</p>
<p><strong>交易次数上限是多少？</strong></p>
<p>一次交易要买入和卖出，总共n天，交易次数不应该超过n / 2。</p>
<p><strong>交易次数超过n / 2要怎么办？</strong></p>
<p>这就等于不限交易次数，与<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode.122.买卖股票的最佳时机 II（简单）</a>解法相同，可以复用这种情况下最优化空间的解答。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(k: <span class="type">Int</span>, prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.isEmpty() || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfitNonLimitCount(prices)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三种状态：第几天买入或卖出、已经交易了多少次、当前是否持有股票</span></span><br><span class="line">        <span class="comment">// dp[i][j][0或1]表示，前i天，交易了j次，在第i天持有或不持有股票，所获得最大的收益</span></span><br><span class="line">        <span class="comment">// 这里定义买入的时候算一次交易</span></span><br><span class="line">        <span class="keyword">val</span> dp = Array(n) &#123; Array(k) &#123; IntArray(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 第0天持有股票的话，最多k次交易，只能直接买入</span></span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第i天，交易了j次，持有股票</span></span><br><span class="line">                    <span class="comment">// 可能是前i-1天就交易了j次并持有股票，也可能前i-1天交易了j-1次在今天买入了</span></span><br><span class="line">                    <span class="comment">// 如果之前没有交易，今天就直接买入就好了</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], -prices[i])</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = maxOf(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">maxProfitNonLimitCount</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = prices.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> holdProfit = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> noholdProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">val</span> newHoldProfit = maxOf(holdProfit, noholdProfit - prices[i])</span><br><span class="line">            <span class="keyword">val</span> newNoholdProfit = maxOf(noholdProfit, holdProfit + prices[i])</span><br><span class="line">            holdProfit = newHoldProfit</span><br><span class="line">            noholdProfit = newNoholdProfit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noholdProfit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度<code>O(n * k)</code>。</li>
<li><code>k &gt;= n / 2</code>时，空间复杂度<code>O(1)</code>；<code>k &lt; n / 2</code>时，空间复杂度<code>O(n * k)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.212.单词搜索 II（困难）</title>
    <url>/algorithm/LeetCode.212.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%20II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-search-ii/">LeetCode.212.单词搜索 II（困难）</a></p>
<p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>网格中找字典单词，而且还是往相邻单元格找，用深度优先搜索。</li>
<li>单词必须按照字母顺序，所以必须尝试从每个单元格开始搜索。</li>
<li>只要在网格中找到了一个单词，接下来就不用再找这个单词了。</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>遍历所有单词。</li>
<li>遍历网格所有的单元格，在每个单元格用回溯找指定单词，找到一个就停止。</li>
</ul>
<h3 id="回溯怎么写？"><a href="#回溯怎么写？" class="headerlink" title="回溯怎么写？"></a>回溯怎么写？</h3><p>标准的回溯模板写法。</p>
<ul>
<li>用一个访问数组记录已访问过的元素，避免循环搜索。</li>
<li>用方向数组简化代码，做好边界检查。</li>
<li>回溯结束条件就是单词所有字符遍历完了。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各索引从小到大依次代表 上、右、下、左</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaRow = intArrayOf(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaColumn = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findWords</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">for</span> (word <span class="keyword">in</span> words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word)) &#123;</span><br><span class="line">                result.add(word)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findWord</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, word: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rows = board.size</span><br><span class="line">        <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> visited = Array(rows) &#123; BooleanArray(columns) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                <span class="keyword">val</span> found = backtrack(board, row, column, visited, word, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (found) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, row: <span class="type">Int</span>, column: <span class="type">Int</span>, visited: <span class="type">Array</span>&lt;<span class="type">BooleanArray</span>&gt;, word: <span class="type">String</span>, wordIndex: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[row][column] == word[wordIndex]) &#123;</span><br><span class="line">            <span class="comment">// 期待的正确情况的边界条件</span></span><br><span class="line">            <span class="keyword">if</span> (wordIndex == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 单词还没搜完，就继续尝试下一个位置</span></span><br><span class="line">            visited[row][column] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> (direction <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newRow = row + deltaRow[direction]</span><br><span class="line">                <span class="keyword">val</span> newColumn = column + deltaColumn[direction]</span><br><span class="line">                <span class="keyword">val</span> rows = board.size</span><br><span class="line">                <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">val</span> isInBound = newRow <span class="keyword">in</span> <span class="number">0</span> until rows &amp;&amp; newColumn <span class="keyword">in</span> <span class="number">0</span> until columns</span><br><span class="line">                <span class="keyword">if</span> (isInBound &amp;&amp; !visited[newRow][newColumn]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(board, newRow, newColumn, visited, word, wordIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[row][column] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：字典树-回溯"><a href="#解法2：字典树-回溯" class="headerlink" title="解法2：字典树 + 回溯"></a>解法2：字典树 + 回溯</h2><p>解法1 的步骤是</p>
<ul>
<li>遍历单词列表选一个单词。</li>
<li>从网格中的每个位置开始回溯，看能否找到这个单词。</li>
</ul>
<p>如果能在网格中的每个位置开始回溯时：</p>
<ul>
<li>发现找到了单词，就能直接记录下来。</li>
<li>所走的字符不能构成单词就不要继续做没有意义的搜索了。</li>
</ul>
<p>这样就是最省时间的。</p>
<p>符合这个访问特点的就是字典树，所以得吧words所有单词先构建出一个字典树。</p>
<p>在网格中的每个位置开始回溯时，用字典树匹配回溯发现的字符，如果能组成单词，就记录下来。</p>
<p><strong>字典树匹配的问题</strong></p>
<p>如果在每个递归层都从字典数的根节点开始匹配，那么会有很多重复判断，可以在回溯递归时，传递字典树的节点给每个递归层，就不会重复判断了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>(</span><br><span class="line">        <span class="keyword">var</span> isEnd: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">val</span> next: Array&lt;Node?&gt; = Array(<span class="number">26</span>) &#123; <span class="literal">null</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">val</span> i = c - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (p.next[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next[i] = Node()</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next[i]!!</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEnd = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各索引从小到大依次代表 上、右、下、左</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaRow = intArrayOf(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> deltaColumn = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findWords</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;, words: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 所有单词构建字典树</span></span><br><span class="line">        <span class="keyword">val</span> trie = Trie()</span><br><span class="line">        <span class="keyword">for</span> (word <span class="keyword">in</span> words) &#123;</span><br><span class="line">            trie.insert(word)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">val</span> result = HashSet&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> rows = board.size</span><br><span class="line">        <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">        <span class="keyword">val</span> visited = Array(rows) &#123; BooleanArray(columns) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">val</span> path = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until columns) &#123;</span><br><span class="line">                backtrack(board, row, column, visited, trie.root, path, result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            row: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            column: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            visited: <span class="type">Array</span>&lt;<span class="type">BooleanArray</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            node: <span class="type">Node</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">Stack</span>&lt;<span class="type">Char</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            result: <span class="type">HashSet</span>&lt;<span class="type">String</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> c = board[row][column]</span><br><span class="line">        <span class="keyword">val</span> currentNode = node.next[c - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.push(c)</span><br><span class="line">            visited[row][column] = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 找到一个单词</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.isEnd) &#123;</span><br><span class="line">                <span class="comment">// 添加结果</span></span><br><span class="line">                <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> path.indices) &#123;</span><br><span class="line">                    sb.append(path[i])</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(sb.toString())</span><br><span class="line">                <span class="comment">// 不能中断搜索，因为字典树当前结点可能还有子树，所以这里找到了一个单词不做return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单词还没搜完，就继续尝试下一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (direction <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newRow = row + deltaRow[direction]</span><br><span class="line">                <span class="keyword">val</span> newColumn = column + deltaColumn[direction]</span><br><span class="line">                <span class="keyword">val</span> rows = board.size</span><br><span class="line">                <span class="keyword">val</span> columns = board[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">val</span> isInBound = newRow <span class="keyword">in</span> <span class="number">0</span> until rows &amp;&amp; newColumn <span class="keyword">in</span> <span class="number">0</span> until columns</span><br><span class="line">                <span class="keyword">if</span> (isInBound &amp;&amp; !visited[newRow][newColumn]) &#123;</span><br><span class="line">                    backtrack(board, newRow, newColumn, visited, currentNode, path, result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            path.pop()</span><br><span class="line">            visited[row][column] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>深度优先搜索</tag>
        <tag>回溯</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.214.最短回文串（困难）</title>
    <url>/algorithm/LeetCode.214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/shortest-palindrome/">LeetCode.214.最短回文串（困难）</a></p>
<p>给定一个字符串  _<strong>s</strong>_，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<span id="more"></span>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串的特点是左右两端字符相同，要在<code>s</code>前面添加字符串使得新字符串是回文串，那就把<code>s</code>的倒置字符串放在前面就可以形成回文了。</p>
<h3 id="s的倒置字符串添加在s前面会有什么问题？"><a href="#s的倒置字符串添加在s前面会有什么问题？" class="headerlink" title="s的倒置字符串添加在s前面会有什么问题？"></a>s的倒置字符串添加在s前面会有什么问题？</h3><p>这样添加还不是最短的回文。</p>
<p>比如s是abbacd，添加dcabba到开头，形成dcabbaabbacd，可以发现abba是多余的，不用添加，dcabbacd是更短的回文串，只要添加dc就行了。</p>
<h3 id="应该添加什么样的字符串才能获得最短回文？"><a href="#应该添加什么样的字符串才能获得最短回文？" class="headerlink" title="应该添加什么样的字符串才能获得最短回文？"></a>应该添加什么样的字符串才能获得最短回文？</h3><p>得找到abbacd的前缀和dcabba的后缀最长的重合的部分的长度，然后找到不重复的部分，添加到字符串前面。</p>
<p>标准化描述：</p>
<ul>
<li>设<code>s&#39;</code>是<code>s</code>的倒置字符串。</li>
<li>求<code>s</code>的前缀和<code>s&#39;</code>的后缀中相同部分最长的长度<code>x</code>。</li>
<li>取<code>s</code>的子串<code>s[x, n - 1]</code>，倒置后添加到<code>s</code>前面，形成最短回文。</li>
</ul>
<h3 id="怎么寻找s和s的倒置字符串最长前后缀？"><a href="#怎么寻找s和s的倒置字符串最长前后缀？" class="headerlink" title="怎么寻找s和s的倒置字符串最长前后缀？"></a>怎么寻找s和s的倒置字符串最长前后缀？</h3><p>联想到kmp做字符串匹配时，要先求一个前缀函数，前缀函数<code>prefix[i]</code>表示<code>s[0, i]</code>中最长的公共前后缀的长度，只要求出前缀函数就可以求解题目。</p>
<h3 id="前缀函数怎么求？"><a href="#前缀函数怎么求？" class="headerlink" title="前缀函数怎么求？"></a>前缀函数怎么求？</h3><p>一句话：让<code>s[0, n - 1]</code>匹配<code>s[1, n - 1]</code>。</p>
<p>算法步骤：</p>
<ul>
<li>双指针<code>i</code>和<code>j</code>遍历<code>s</code>。</li>
<li><code>i</code>从1开始，<code>j</code>从0开始。</li>
<li>s匹配自己，字符能匹配上，双指针都前进。</li>
<li>当前<code>s[i]</code>和<code>s[j]</code>不匹配，要把<code>j</code>往回退。<ul>
<li><code>j</code>退到前一个位置（<code>j - 1</code>）的最长公共前后缀的前缀的下一个字符的位置。继续拿<code>s[j]</code>跟<code>s[i]</code>尝试匹配，如果能匹配的上，<code>prefix[i]</code>就求出来了。</li>
<li>如果<code>j</code>一直回退，最坏也就是回退到0，因为<code>prefix[0] = 0</code>（一个字符不存在前后缀），没的退了，只能比较<code>s[i]</code>和<code>s[0]</code>，没匹配的话公共前后缀长度就是0。</li>
</ul>
</li>
</ul>
<h3 id="前缀函数应该针对哪个字符串求？"><a href="#前缀函数应该针对哪个字符串求？" class="headerlink" title="前缀函数应该针对哪个字符串求？"></a>前缀函数应该针对哪个字符串求？</h3><p>我们要求<code>s</code>的前缀和<code>s</code>的倒置字符串的后缀最长的公共部分。<br>所以弄一个新字符串 <code>s&#39; + s</code>。</p>
<p><strong>这样存在一个问题</strong>，如果所有字符都相同，此时最长公共前后缀就是整个字符串<code>s&#39; + s</code>本身，这不是期望的结果，所以连接<code>s&#39;</code>和<code>s</code>时，中间隔一个用不到的字符，比如<code>#</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shortestPalindrome</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 加#是为了防止出现全部重复的字符，这样最长公共前后缀的长度就不是期望的了</span></span><br><span class="line">        <span class="keyword">val</span> maxLength = (s + <span class="string">&quot;#&quot;</span> + s.reversed()).prefixArray().last()</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxLength).reversed() + s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">prefixArray</span><span class="params">()</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> s = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> n = length</span><br><span class="line">        <span class="keyword">val</span> prefix = IntArray(n) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = prefix[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = prefix[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) j++</span><br><span class="line">            prefix[i] = j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>设字符串<code>s</code>长度为n。</p>
<ul>
<li>时间复杂度O(n)：求前缀函数最坏情况需要O(n + n) = O(n)时间；还要遍历整个<code>s&#39; + s</code>，有2n的长度，需要O(n)时间。</li>
<li>空间复杂度O(n)：前缀函数占用O(n)空间。</li>
</ul>
<p>kmp时间复杂度推导可参考：</p>
<ul>
<li><a href="https://blog.csdn.net/niukai1768/article/details/79579709">KMP时间复杂度分析</a></li>
<li><a href="https://segmentfault.com/q/1010000014560162">KMP算法的时间复杂度是如何计算的？</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode困难</tag>
        <tag>算法</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-synchronized、锁升级、wait和notify</title>
    <url>/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91-synchronized%E3%80%81%E9%94%81%E5%8D%87%E7%BA%A7%E3%80%81wait%E5%92%8Cnotify/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>让一段代码在多线程之间互斥访问，保证原子性、有序性、可见性，并且是可重入的。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>synchronized修饰代码块时需要传入一个对象作为锁，这个对象可以是任意的，进入同步代码块前要获取这个锁，没有获得锁的线程就要阻塞等待，同步代码块执行完释放锁。</li>
<li>修饰成员方法时，锁是对象实例。</li>
<li>修饰静态方法时，锁是类的class实例。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>每个Java对象都关联一个监视器锁对象，同步代码块在字节码层面是通过在代码块的指令前后加上monitorenter和monitorexit指令来标识的。</p>
<p>当线程执行到monitorenter指令时，当前线程试图获取监视器对象所有权，如果未加锁或者已被当前线程持有，就把锁计数加1；执行到monitorexit指令的时候，锁计数减1。锁计数为0时，锁就被释放了。</p>
<p>如果当前线程获取监视器对象失败，线程会阻塞等待，线程会作为一个结点存入监视器对象的锁池队列中，等待唤醒。</p>
<p>监视器对象还有一个等待池队列，在同步代码块中调用锁对象的wait方法的时候，线程会阻塞，并被封装为一个结点，进入监视器对象的等待池队列，调用锁对象的notify和notifyAll的时候，会把等待池队列中的线程放入锁池队列中，只有锁池中的线程才能参与竞争锁。</p>
<p>wait和notify用来线程之间同步过程的，比如实现生产者消费者模型。</p>
<p>监视器锁底层是通过操作系统的互斥锁实现的，操作系统做线程切换需要从用户态转换到内核态，所以比较消耗性能。这种依赖于操作系统互斥锁而实现的锁叫做重量级锁。</p>
<p>如果线程竞争并不激烈，切换线程的开销是不划算的，特别是多个线程在不同的时段获取同一把锁，可以用自旋锁，就是CAS+循环，CAS由硬件之间实现，开销比切换线程开销要小，这就是轻量级锁，在JDK6引入。</p>
<p>锁信息具体存储在对象头的MarkWord里，一个对象在虚拟机的内存布局分为三部分，对象头、实例数据、对齐填充，其中对象头又分为MarkWord、类型指针、数组长度，MarkWord存储了锁相关的信息、hashCode、垃圾回收的分代年龄等。</p>
<p>轻量级锁的CAS操作具体修改的是锁对象头的mark word，修改为指向当前线程栈帧中的锁记录的指针。虚拟机会为每个线程在当前线程栈帧中创建一块锁记录空间，存储锁对象的对象头中的mark word的拷贝。</p>
<p>如果CAS修改成功，当前线程就获得了轻量级锁。</p>
<p>如果更新失败，说明有线程竞争，开始自旋，自旋超过一定次数，升级为重量级锁。避免竞争激烈的情况下自旋空耗CPU。</p>
<p>如果压根都没有线程竞争，只有单线程访问同步代码块，其实每次进行CAS操作获取轻量级锁也是没有必要的开销，所以JDK6又引入了偏向锁，只在第一次申请锁的时候，对Java对象头的MARK WORD做CAS操作，记录下当前申请锁的线程ID，退出同步代码块后，也不释放锁，锁对象的对象头中记录的还是当前的线程ID，同一个线程再次进入这个锁的同步代码块的时候，检查锁的对象头中记录的线程ID是否还是自己，是的话就直接进入，不用再CAS了。当有多个线程要申请锁的时候，就会升级到轻量级锁。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<h1 id="与ReentrantLock区别？该用哪个？"><a href="#与ReentrantLock区别？该用哪个？" class="headerlink" title="与ReentrantLock区别？该用哪个？"></a>与ReentrantLock区别？该用哪个？</h1><p>synchronized一般情况下是够用的，而且写起来比较简单，不会忘记释放锁，如果需要更灵活的功能，可以用ReentrantLock，ReentrantLock也是可重入的锁。</p>
<ol>
<li> 实现也是基于CAS+自旋去竞争一个int类型的state变量，性能比较好</li>
<li> 支持公平锁和非公平锁</li>
<li> 获取锁的时候可以设置超时时间避免发生死锁</li>
<li> 获取锁的方法还可以响应线程中断</li>
<li> 还可以尝试获取锁，获取不不到就不阻塞</li>
<li> 加锁和解锁完全自己控制，可以跨方法执行解锁</li>
<li> 可以关联多个条件队列</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>synchronized</tag>
        <tag>偏向锁</tag>
        <tag>轻量级锁</tag>
        <tag>重量级锁</tag>
        <tag>wait</tag>
        <tag>notify</tag>
      </tags>
  </entry>
  <entry>
    <title>B树、B+树</title>
    <url>/%E7%AE%97%E6%B3%95/B%E6%A0%91%E3%80%81B+%E6%A0%91/</url>
    <content><![CDATA[<h1 id="B和B-里的B是什么意思"><a href="#B和B-里的B是什么意思" class="headerlink" title="B和B+里的B是什么意思?"></a>B和B+里的B是什么意思?</h1><p>B是Balanced的缩写，平衡的意思。</p>
<p>全称可以叫多路（多叉）平衡查找（搜索）树。</p>
<h2 id="多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？"><a href="#多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？" class="headerlink" title="多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？"></a>多路平衡查找树解决了什么问题？平衡二叉查找树为什么不能解决？</h2><p>由于平衡二叉查找树只有两个分叉，查询叶子结点需要访问$log_2{n}$次节点，即树的高度。</p>
<p>如果要减少查找次数，就要让树变矮一点。</p>
<p>那么一个节点有多个分叉，同时让一个节点存储多个值，就可以降低树的高度，进而减少节点平均的访问次数。</p>
<h2 id="减少节点的访问次数有什么好处？"><a href="#减少节点的访问次数有什么好处？" class="headerlink" title="减少节点的访问次数有什么好处？"></a>减少节点的访问次数有什么好处？</h2><p>访问节点的成本可能非常大，减少访问节点的次数，就可以降低总的访问成本。</p>
<p>例如访问IO比访问内存要慢的多，文件系统中普遍采用多路平衡查找树作为存储数据的结构。</p>
<h2 id="B树与B-的区别？"><a href="#B树与B-的区别？" class="headerlink" title="B树与B+的区别？"></a>B树与B+的区别？</h2><p>B树与B+共同点：</p>
<ol>
<li> 都是一个节点按顺序存储多个值</li>
<li> 每个节点可以有多个分叉</li>
</ol>
<p>B树独有：</p>
<ol>
<li> 非叶子节点存储了数据，非叶子节点占用空间更大</li>
</ol>
<p>B+树独有：</p>
<ol>
<li> 非叶子节点不存数据只存索引信息，数据全部在叶子节点，非叶子节点占用空间更小</li>
<li> 叶子结点用双向链表相连，便于顺序查找</li>
</ol>
<h2 id="B-树作为数据库索引有什么优势？"><a href="#B-树作为数据库索引有什么优势？" class="headerlink" title="B+树作为数据库索引有什么优势？"></a>B+树作为数据库索引有什么优势？</h2><p>非叶子结点的大小可以设置为一页，内存从外存读取数据是按页读取的，这样就减少了IO访问次数。</p>
<p>结点内部是有序的，可以再用二分查找去查找元素。</p>
<p>B+树的非叶子结点不存储数据，只存键，这样同样空间大小可以存的键就更多，非叶子结点的数量就会减少，IO访问次数也就变少了。</p>
<p>B+树的叶子结点用双链表链接，这样对区间查询友好，只需要通过非叶结点查找到区间范围，然后顺序遍历即可，可以减少对非叶结点的访问，进而减少IO访问次数。因为由于虚拟内存机制，非叶结点加载到内存后，可能也会被置换到外存，减少对非叶结点的访问次数，也就降低了置换次数，置换是需要IO访问的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">为什么 MySQL 使用 B+ 树</a></li>
<li><a href="https://blog.csdn.net/v_july_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a></li>
<li><a href="https://mp.weixin.qq.com/s/svL_yNmNJ-wj9aGjtO_Yww">拜托，别再问我什么是B+树 了</a></li>
<li><a href="https://blog.csdn.net/qq_21993785/java/article/details/80580679">B+Tree在数据库索引上拥有独特优势的原因（为什么比红黑树更合适）</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>B树</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>LZ77算法</title>
    <url>/%E7%AE%97%E6%B3%95/LZ77%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"><a href="#LZ77和哈夫曼编码区别？适用场景上有有什么不同？" class="headerlink" title="LZ77和哈夫曼编码区别？适用场景上有有什么不同？"></a>LZ77和哈夫曼编码区别？适用场景上有有什么不同？</h2><p>哈夫曼编码是基于统计的数据压缩编码，需要先获得信息源的字符出现频率，然后再进行压缩。</p>
<p>但是，如果信息源是流式传输的，就没办法预先做统计，需要换一种思路。</p>
<p>LZ77利用数据的重复结构信息来进行数据压缩，是基于字典的压缩算法，可以做流逝压缩。</p>
<p>GZIP压缩的过程就是先用LZ77算法进行流式压缩，再对结果做哈夫曼编码压缩。</p>
<h2 id="为什么叫LZ77"><a href="#为什么叫LZ77" class="headerlink" title="为什么叫LZ77?"></a>为什么叫LZ77?</h2><p>由以色列的两位大神Jacob Ziv与Abraham Lempel在1977年发表的论文《A Universal Algorithm for Sequential Data Compression》中提出。</p>
<h2 id="LZ77算法思想概述"><a href="#LZ77算法思想概述" class="headerlink" title="LZ77算法思想概述"></a>LZ77算法思想概述</h2><p>核心思想：利用短语表示数据的重复结构信息来进行数据压缩。</p>
<p>LZ77算法一般称为“滑动窗口压缩”，算法的核心是在前面的历史数据中寻找重复字符串。</p>
<p>通过滑动窗口实现动态字典，用前面出现过的字符串作为字典通过映射（与前一个字符串的距离和字符串长度）替代后面重复出现的字符串。</p>
<p>重复现象是具有局部性的，它的基本假设是，如果一个字符串要重复，那么也是在附近重复，远的地方就不用找了，因此设置了一个滑动窗口。</p>
<p>其方式就是把数据中一些可以组织成短语(最长字符)的字符加入字典，然后再有相同字符出现采用标记来代替字典中的短语，如此通过标记代替多数重复出现的方式以进行压缩。</p>
<p>滑动窗口越大，压缩的效果越好，因为编码的短语越多，但是压缩速度越慢，因为要计算的短语数量越多。</p>
<h2 id="基于字典是什么意思？"><a href="#基于字典是什么意思？" class="headerlink" title="基于字典是什么意思？"></a>基于字典是什么意思？</h2><p>滑动窗口内的字符都是已经出现过的字符，已经出现过的字符会编码为字典短语，后面前向缓冲窗口中的字符如果和字典中的短语相同，就用距离和字符串长度来表示，以达到压缩的目的。</p>
<h2 id="LZ77压缩效果"><a href="#LZ77压缩效果" class="headerlink" title="LZ77压缩效果"></a>LZ77压缩效果</h2><p>大多数情况下LZ77压缩算法的压缩比相当高。</p>
<p>实际压缩率和选择的滑动窗口大小、前向缓冲区大小、数据熵有关系。</p>
<h2 id="LZ77缺点"><a href="#LZ77缺点" class="headerlink" title="LZ77缺点"></a>LZ77缺点</h2><p>压缩过程是比较耗时，因为要花费很多时间寻找滑动窗口中的短语匹配。</p>
<p>不过解压过程很快，因为每个标记都明确告知在哪个位置可以读取了。</p>
<h2 id="什么特征的文本用LZ77压缩效果好？"><a href="#什么特征的文本用LZ77压缩效果好？" class="headerlink" title="什么特征的文本用LZ77压缩效果好？"></a>什么特征的文本用LZ77压缩效果好？</h2><p>压缩就是用更短的符号来表示重复出现的字符串。</p>
<p>压缩就是寻找文本的内容分布概率，将出现频率高的部分代替成更短的形式。</p>
<p>内容越是重复，就可以压缩的更小。</p>
<p>内容如果毫无重复，就很难压缩。</p>
<h2 id="LZ77详细原理"><a href="#LZ77详细原理" class="headerlink" title="LZ77详细原理"></a>LZ77详细原理</h2><p>参见： <a href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></p>
<h2 id="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"><a href="#为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？" class="headerlink" title="为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？"></a>为什么GZIP在用LZ77压缩过后还要进行哈夫曼编码？</h2><p>LZ77编码后得到的是，距离（distance）和长度（length），还有未匹配到短语字典的原始字符（literal）。</p>
<p>比较短的距离和长度可能是频繁出现的，就可以用变长编码来压缩，且文本已经确定下来不会变动，可以做词频统计，就可以用到哈夫曼编码了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.codenong.com/cs106685915/">Linux(程序设计):28—数据流压缩原理（Deflate压缩算法、gzip、zlib）</a></li>
<li><a href="https://www.cnblogs.com/en-heng/p/4992916.html">【数据压缩】LZ77算法原理及实现</a></li>
<li><a href="https://www.cnblogs.com/en-heng/p/4992916.html">LZ77算法原理以及实现</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LZ77</tag>
        <tag>GZIP</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼编码</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="什么是哈夫曼编码"><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是哈夫曼编码</h2><p>出现频次越高的字符，编码长度越小。</p>
<h2 id="哈夫曼编码的价值"><a href="#哈夫曼编码的价值" class="headerlink" title="哈夫曼编码的价值"></a>哈夫曼编码的价值</h2><p>变长编码，使得编码的平均长度最短，实现压缩率大的无损压缩。</p>
<p>因为哈夫曼树是最优的，每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<h2 id="哈夫曼编码过程"><a href="#哈夫曼编码过程" class="headerlink" title="哈夫曼编码过程"></a>哈夫曼编码过程</h2><ul>
<li>把文本中字符按出现的频次排序。</li>
<li>每个字符作为一个结点放入一个集合。</li>
<li>取集合最小的两个频次的结点，为左右子结点，生成一个父结点，父结点的频次是两个子结点频次之和，把父结点再加入到集合中。</li>
<li>重复这个构造过程，生成一个最优二叉树。</li>
<li>给二叉树所有左边设置0，所有右边设置1。</li>
<li>字符都在叶子结点。</li>
<li>根结点到叶子结点路径上的0和1组成的码字就是该字符的编码。</li>
</ul>
<p>因为所有字符都出现在叶子结点，保证了哈夫曼编码当中的任何一个字符的编码都不能是另一个字符编码的前缀。也就是说哈夫曼编码是一种前缀编码。</p>
<hr>
<h2 id="如何证明哈夫曼编码是最优的？"><a href="#如何证明哈夫曼编码是最优的？" class="headerlink" title="如何证明哈夫曼编码是最优的？"></a>如何证明哈夫曼编码是最优的？</h2><p>哈夫曼编码过程每次的选择都是贪心选择，这个局部最优也是全局最优。</p>
<p>其正确性证明依赖于贪心选择性质和最优子结构。</p>
<hr>
<h2 id="哈夫曼编码的特点"><a href="#哈夫曼编码的特点" class="headerlink" title="哈夫曼编码的特点"></a>哈夫曼编码的特点</h2><ol>
<li> 编码非等长</li>
<li> 编码前缀不重复</li>
</ol>
<h2 id="哈夫曼编码的压缩效果？"><a href="#哈夫曼编码的压缩效果？" class="headerlink" title="哈夫曼编码的压缩效果？"></a>哈夫曼编码的压缩效果？</h2><p>哈夫曼编码可以很有效的压缩数据，具体压缩率依赖于数据本身的特性。</p>
<p>齐夫定律：</p>
<p>发现某一单词出现的频率与其在频率表里名次的常数次幂成反比，也就是说极少数的单词会被经常使用，而绝大多数单词很少被提及，这种20/80法则在很多领域都被逐步发现，这种幂律分布被称为“齐夫定律”（Zipf’s law）</p>
<p>一般信息的分配都是幂率分布。</p>
<p>所以用哈夫曼编码压缩的比例一般都挺高的，70%以上。</p>
<h2 id="信息压缩的极限在哪？"><a href="#信息压缩的极限在哪？" class="headerlink" title="信息压缩的极限在哪？"></a>信息压缩的极限在哪？</h2><p>香农第一定理给出了无损的情况下数据压缩的临界值。</p>
<p>参考：<a href="https://www.ruanyifeng.com/blog/2019/08/information-theory.html">信息论入门教程</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h2 id="字典树特点"><a href="#字典树特点" class="headerlink" title="字典树特点"></a>字典树特点</h2><ul>
<li>查询快</li>
<li>存储少</li>
</ul>
<p>对相同前缀的字符串进行了压缩存储，存储空间少，访问一个字符串最多也只需要访问字符串的长度。</p>
<p>利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。</p>
<h2 id="字典树有什么应用场景？"><a href="#字典树有什么应用场景？" class="headerlink" title="字典树有什么应用场景？"></a>字典树有什么应用场景？</h2><h3 id="单词联想预测、单词纠错。"><a href="#单词联想预测、单词纠错。" class="headerlink" title="单词联想预测、单词纠错。"></a>单词联想预测、单词纠错。</h3><p>在搜索引擎中关键词提示，引擎会自动弹出匹配关键词的下拉框。</p>
<h3 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h3><p>事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。</p>
<p>例如：</p>
<ul>
<li>  1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。</li>
<li>  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</li>
</ul>
<p>这样一方面可以节约存储空间，另一方面先用字典树预处理了海量文本，之后进行字符串查找时，不用在整个文本中查找特定字符串</p>
<h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>给定很长的一个串，统计频数出现次数最多情况。</p>
<p>例如：</p>
<ul>
<li>  有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
<li>  一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
</ul>
<h3 id="字符串最长公共前缀"><a href="#字符串最长公共前缀" class="headerlink" title="字符串最长公共前缀"></a>字符串最长公共前缀</h3><p>Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀，所以可以利用这个特点来解决一些前缀问题。</p>
<p>例如：</p>
<ul>
<li>  给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字典树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树、AVL树</title>
    <url>/%E7%AE%97%E6%B3%95/%E9%BB%91%E6%A0%91%E3%80%81AVL%E6%A0%91/</url>
    <content><![CDATA[<h2 id="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"><a href="#普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？" class="headerlink" title="普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？"></a>普通的二叉查找树存在什么问题？平衡二叉查找树解决了什么问题？</h2><p>普通的二叉查找树最坏情况下会退化为一个链表，查找元素的时间复杂度由log_2{n}退化到n。</p>
<p>解决时间复杂度退化，就是要让树的高度始终保持尽可能的小，平衡二叉查找树就是让任意节点的左右子树高度都平衡（差的不多）的二叉查找树，这样查找元素的平均时间复杂度可以保持在log_2{n}，</p>
<h2 id="有哪些平衡二叉查找树？"><a href="#有哪些平衡二叉查找树？" class="headerlink" title="有哪些平衡二叉查找树？"></a>有哪些平衡二叉查找树？</h2><p>AVL树、2-3树、红黑树</p>
<h2 id="为什么流行的主要是这几个树？"><a href="#为什么流行的主要是这几个树？" class="headerlink" title="为什么流行的主要是这几个树？"></a>为什么流行的主要是这几个树？</h2><p>因为逻辑比较简单，易于实现，效率也就高。</p>
<h2 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h2><p>任意结点左右子树高度差小于或等于1。</p>
<p>由Adelson-Velskii 以及 Landis发明，故而叫AVL。</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>定义：</p>
<ul>
<li>在满足二叉查找树的性质基础上，一个结点最多可以存储2个键，可以有3个孩子结点。</li>
<li>2结点里存储1个键，可以有2个孩子结点</li>
<li>3结点里存储2个键，可以有3个孩子结点</li>
</ul>
<p>特点</p>
<ul>
<li>2-3树是完美平衡的，任意结点的左右子树高度相等，这可以分析所有插入的情况来证明。</li>
</ul>
<p>自下而上生长：</p>
<ul>
<li>插入位置在2结点中，直接插入，变为3结点。</li>
<li>插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）。<ul>
<li>如果父结点本来是2结点，现在就变成了3结点。</li>
<li>如果父结点本来是3结点，现在就变成了4结点，继续提升的过程。</li>
<li>如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点。</li>
</ul>
</li>
</ul>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1。</p>
<p>一颗含有n个节点的2-3树的高度在log_3{n}（全是3结点）到log_2{n}（全是2结点）之间。</p>
<p>每次插入后调整结点都是局部的，最坏情况下，一条路径上都是3结点，从叶结点插入新键后，会从叶结点一直调整到根结点，调整次数不会超过对数级别。</p>
<p>10亿个结点的2-3树高度仅在19到30之间，性能较高。</p>
<p>各种操作实现较为复杂。</p>
<h2 id="为什么2-3树可以保持完美平衡？"><a href="#为什么2-3树可以保持完美平衡？" class="headerlink" title="为什么2-3树可以保持完美平衡？"></a>为什么2-3树可以保持完美平衡？</h2><p>这可以分析所有插入的情况来证明。</p>
<p>自下而上生长</p>
<ol>
<li><p> 插入位置在2结点中，直接插入，变为3结点</p>
</li>
<li><p> 插入位置在3结点中，先插入键变成4结点，再把中间的键提升到父结点中，当前结点就变成了两个2结点（不直接把键插入父结点是因为插入的键和提升到父结点的键不一定是同一个）</p>
</li>
<li><p> 如果父结点本来是2结点，现在就变成了3结点</p>
</li>
<li><p> 如果父结点本来是3结点，现在就变成了4结点，继续提升的过程</p>
</li>
<li><p> 如果没有父结点，当前即为根结点，那么就把临时的4结点分解为3个2结点，中间的键提升为2结点作为新的根结点</p>
</li>
</ol>
<p>在根结点为3结点时，插入新键变为4结点，再拆分为3个2结点后，树的高度才会加1</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>实现较为简单，综合性能好。</p>
<p>把2-3树的3结点表示为左斜的红色链接相连的两个2结点，其中一个结点是另一个结点的左子结点，其他链接为黑色链接。</p>
<p>红黑树既是二叉查找树也是2-3树。</p>
<p>等价定义（《算法》第4版 275页 3.3.2.1）：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>红黑树的几条定义都是为了让红黑树满足2-3树的结构。</p>
<p>如果让2-3树中所有链接都为黑色，由于2-3树是完美平衡的，红黑树中红色链接代表3结点，所以红黑树中的黑色链接是完美平衡的。</p>
<p>再把2-3树中的3结点都分解为两个用红色链接相连的2结点，那么不会存在一个结点同时与两条红色链接相连，这一点保证了红色链接是3结点。</p>
<p>对红黑树插入、删除元素后，不满足红黑树的定义，都要通过旋转操作来修正。</p>
<p>红黑树的旋转操作修正，都是符合2-3树的修正的规则的，理解记住了2-3树的各种调整规则，就知道了红黑树各种操作的意义。</p>
<h2 id="红黑树是怎么发明出来的？"><a href="#红黑树是怎么发明出来的？" class="headerlink" title="红黑树是怎么发明出来的？"></a>红黑树是怎么发明出来的？</h2><p>它在1972年由<a href="https://zh.wikipedia.org/wiki/%E9%B2%81%E9%81%93%E5%A4%AB%C2%B7%E8%B4%9D%E5%B0%94">鲁道夫·贝尔</a>发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和<a href="https://zh.wikipedia.org/wiki/Robert_Sedgewick">Robert Sedgewick</a>于<a href="https://zh.wikipedia.org/wiki/1978%E5%B9%B4">1978年</a>写的一篇论文。</p>
<p>红黑树等同于2-3-4树，是2-3-4树的二叉表现形式。</p>
<p>2-3-4树是B树的一种情况。</p>
<p>红黑树结点的颜色表明了当前结点是否属于2-3-4树中的3结点或4结点。</p>
<p>2-3-4树的情况讨论比较复杂，  用2-3树讨论情况较少，可以方便理解。</p>
<hr>
<h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>《算法》第4版 275页 3.3.2.1 定义：</p>
<ol>
<li> 红色链接均为左链接</li>
<li> 没有任何一个结点同时和两条红链接相连</li>
<li> 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ol>
<p>《算法导论》273页  第13章  红黑树  定义：</p>
<ol>
<li> 节点是红色或黑色</li>
<li> 根节点是黑色</li>
<li> 叶节点是黑色</li>
<li> 红节点的两个子节点都是黑色</li>
<li> 任意节点到叶节点的所有路径上的黑色节点数相同</li>
</ol>
<h2 id="红黑树为什么要这样定义？"><a href="#红黑树为什么要这样定义？" class="headerlink" title="红黑树为什么要这样定义？"></a>红黑树为什么要这样定义？</h2><p>红黑树的几条定义都是为了让红黑树满足2-3树的结构，红黑树是2-3树的一种表示形式，而2-3树是完美平衡的，这样红黑树也是黑色平衡的，2-3树比较难以实现，红黑树比较方便实现。</p>
<h2 id="为什么要用红黑树表示2-3树？"><a href="#为什么要用红黑树表示2-3树？" class="headerlink" title="为什么要用红黑树表示2-3树？"></a>为什么要用红黑树表示2-3树？</h2><ul>
<li>因为2-3树是完美平衡的，任意结点的子树没有高度差。</li>
<li>2-3树的实现较为复杂，红黑树的实现较为简单。</li>
</ul>
<h2 id="红黑树的数据结构如何定义？"><a href="#红黑树的数据结构如何定义？" class="headerlink" title="红黑树的数据结构如何定义？"></a>红黑树的数据结构如何定义？</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">Key : Comparable&lt;Key</span>&gt;, <span class="type">Value&gt;</span></span>(</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 父结点指向本结点的链接颜色，用以标明本结点对应2-3树中的2结点还是3结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> color: Color,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字。用于比较来确定数据的顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> key: Key,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关联的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> value: Value,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> left: Node&lt;Key, Value&gt;? = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右子结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> right: Node&lt;Key, Value&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    BLACK, RED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树插入新元素后调整结点的操作规则是怎样的？"><a href="#红黑树插入新元素后调整结点的操作规则是怎样的？" class="headerlink" title="红黑树插入新元素后调整结点的操作规则是怎样的？"></a>红黑树插入新元素后调整结点的操作规则是怎样的？</h2><p>原则：所有操作跟2-3树能逐一对应，保证树的有序性和完美平衡性。</p>
<p>插入新结点先按普通的二叉查找树插入新结点那样进行插入。</p>
<p>普通的二叉查找树插入新元素有三种情况：</p>
<ol>
<li> 树中没有结点，插入的新结点作为根结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的左子结点</li>
<li> 树中有结点，插入的新结点一定是某个结点h的右子结点</li>
</ol>
<p>在红黑树中，结点h又可以分为两种情况</p>
<ol>
<li> 结点h是2结点</li>
<li>结点h位于3结点中<ol>
<li> 结点h是红链接左下的结点</li>
<li> 结点h是红链接右上的结点</li>
</ol>
</li>
</ol>
<p>插入新结点要默认新结点的颜色是红色，表示新结点到父节点的链接是红色，这样与2-3树的插入就可以对应上。</p>
<p>在2-3树中如果插入在2结点中，2结点变为3结点，就不再调整；如果插入的在3结点中，3结点临时变为4结点，再把4结点的中间键放入父结点中，左右两边的键分解为两个2结点与父结点相连。</p>
<p>处理这些情况的组合，就是所有的插入情况，针对不符合2-3树的结构的情况进行调整。</p>
<ul>
<li>结点h是2结点<ul>
<li>新结点是h的左子结点，相当于新结点和结点h组成了2-3树中的3结点，符合2-3树的结构，无需调整</li>
<li>新结点是h的右子结点，相当于新结点和结点h组成了2-3树中的3结点，但我们规定红链接要保持左斜，以减少考虑的情况数量，所以要进行左旋转</li>
</ul>
</li>
<li>结点h位于3结点中，新结点的位置有三种情况：左、中、右<ul>
<li>结点h是红链接左下的结点<ul>
<li>新结点是h的左子结点，此时有了两条连续的红链接，连接的3个结点对应2-3树中临时的4结点，需要把中间的键放入父结点，再把两边的键拆为两个2结点分别与父结点相连，所以操作是先右旋，再变换颜色</li>
<li>新结点是h的右子结点</li>
</ul>
</li>
<li>结点h是红链接右上的结点<ul>
<li>新结点是h的右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有三种标准操作：左旋、右旋、颜色转换</p>
<h2 id="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"><a href="#为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？" class="headerlink" title="为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？"></a>为什么红黑树中红链接只能保持左斜？为什么不能有右斜的红链接？</h2><p>只允许红色的左链接可以减少讨论的情景数量，进而简化代码的实现。</p>
<h2 id="红黑树最坏情况下高度是多少？"><a href="#红黑树最坏情况下高度是多少？" class="headerlink" title="红黑树最坏情况下高度是多少？"></a>红黑树最坏情况下高度是多少？</h2><p>有n个结点的红黑树高度最多为 $2 * log_2{n}$</p>
<p>由于2-3树中的3结点是由左斜红链接连接的两个结点表示的，最坏情况下最左侧路径全部都是红链接，对应2-3树中最左侧都是3结点，其他结点都是2结点。</p>
<p>参考《算法导论》中的证明：<br><a href="https://blog.csdn.net/lanchunhui/java/article/details/75905478">红黑树相关定理及其证明
</a></p>
<h2 id="红黑树的各种操作的时间复杂度是多少？"><a href="#红黑树的各种操作的时间复杂度是多少？" class="headerlink" title="红黑树的各种操作的时间复杂度是多少？"></a>红黑树的各种操作的时间复杂度是多少？</h2><p>设红黑树有n个结点，查找、插入、修改、删除操作的时间复杂度均为O(log n)</p>
<p>查找：</p>
<ul>
<li>最长路径长度不会超过最短路径长度的2倍，查找仍然是对数级别</li>
</ul>
<p>插入：</p>
<ul>
<li>最坏情况下待插入的位置在叶结点，需要从根结点遍历到叶结点，同时最坏情况下遍历的路径都是红链接（路径上都是3结点），此时会从叶结点一直回溯调整结点到根结点，访问次数是2倍的树的高度，而树的高度为log_2{n}</li>
</ul>
<h2 id="红黑树较于AVL树有什么优点？"><a href="#红黑树较于AVL树有什么优点？" class="headerlink" title="红黑树较于AVL树有什么优点？"></a>红黑树较于AVL树有什么优点？</h2><p>单次操作：</p>
<ul>
<li>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</li>
<li>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</li>
</ul>
<p>大量的插入和删除操作：</p>
<ul>
<li>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</li>
<li>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</li>
</ul>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎 </a></li>
</ul>
<h2 id="什么时候用AVL树？"><a href="#什么时候用AVL树？" class="headerlink" title="什么时候用AVL树？"></a>什么时候用AVL树？</h2><p>AVL树平衡性非常好，左右子树高度差不超过1，所以查找次数少。</p>
<p>对于查找非常频繁，插入、修改、删除不频繁的场景，可以使用AVL树。</p>
<h2 id="并发下的问题"><a href="#并发下的问题" class="headerlink" title="并发下的问题"></a>并发下的问题</h2><p>并发情况下，由于平衡搜索树的调整可能要锁整个树。</p>
<p>用跳表这种性能接近于平衡树的数据结构，操作更加局部性，不会锁住太多结点，有利于并发的性能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/wuchanming/p/4444961.html">面试题——轻松搞定面试中的红黑树问题</a></li>
<li><a href="https://www.cnblogs.com/nullzx/p/6111175.html">从2-3-4树到红黑树（上）</a></li>
<li><a href="https://www.zhihu.com/question/30527705/answer/259948086">AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？ - 韦易笑的回答 - 知乎 </a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title>ASM字节码插桩</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/</url>
    <content><![CDATA[<h1 id="ASM是干什么的？"><a href="#ASM是干什么的？" class="headerlink" title="ASM是干什么的？"></a>ASM是干什么的？</h1><p>ASM 是一个 Java 字节码操控框架。</p>
<p>ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。</p>
<p>Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。</p>
<p>ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p>
<p>ASM的应用场景有AOP（CGLIB就是基于ASM）、热部署、修改其他jar包中的类等。</p>
<h1 id="用ASM修改类的好处？"><a href="#用ASM修改类的好处？" class="headerlink" title="用ASM修改类的好处？"></a>用ASM修改类的好处？</h1><ul>
<li>类的修改是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。</li>
<li>越过Java常规语法限制，做出代码编写无法实现的事情。</li>
</ul>
<h1 id="字节码操纵操作工具很多，ASM有什么优势？"><a href="#字节码操纵操作工具很多，ASM有什么优势？" class="headerlink" title="字节码操纵操作工具很多，ASM有什么优势？"></a>字节码操纵操作工具很多，ASM有什么优势？</h1><p>常见的字节码操作工具有：</p>
<ul>
<li>ASM</li>
<li>JavaAssist</li>
<li>AspectJ（基于BCEL）</li>
<li>CGLIB（基于ASM）</li>
<li>ByteBuddy（基于ASM）</li>
</ul>
<p>ASM优势：</p>
<ul>
<li>体积小</li>
<li>性能高</li>
</ul>
<p>ASM劣势：</p>
<ul>
<li>需要熟悉字节码原理，API易用性低</li>
</ul>
<p>JavaAssist优势：</p>
<ul>
<li>不需要熟悉字节码原理，API易用性高</li>
</ul>
<p>JavaAssist劣势：</p>
<ul>
<li>体积大</li>
<li>性能差</li>
</ul>
<p>所以ASM适用于对性能和体积敏感的场景。</p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/9167436/dynamic-java-bytecode-manipulation-framework-comparison">Dynamic Java Bytecode Manipulation Framework Comparison</a></li>
</ul>
<h1 id="Visitor模式怎么理解？"><a href="#Visitor模式怎么理解？" class="headerlink" title="Visitor模式怎么理解？"></a>Visitor模式怎么理解？</h1><p>把可变的和不变的分离。</p>
<p>具体而言，被访问者是不变的，而访问者是可变的。举个例子来说，我是不变的，而不同的人看我会有不同的眼光，这个看我的眼光是可变的。</p>
<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。</p>
<p>访问者模式适用于数据结构相对稳定，算法又易变化的系统。<br>因为访问者模式使得算法操作增加变得容易。</p>
<p>若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。</p>
<p>访问者模式的优点：</p>
<p>增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。</p>
<p>访问者模式的缺点：</p>
<p>增加新的数据结构很困难。</p>
<p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。</p>
<p>参考：</p>
<ul>
<li><a href="https://codeleading.com/article/42914263436/">设计模式之 Visitor（访问者模式）通俗理解</a></li>
<li><a href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a></li>
<li><a href="https://www.iteye.com/blog/mybeautiful-1160374">Visitor模式通俗化</a></li>
</ul>
<h1 id="ASM为什么用Visitor模式？"><a href="#ASM为什么用Visitor模式？" class="headerlink" title="ASM为什么用Visitor模式？"></a>ASM为什么用Visitor模式？</h1><p>.class 文件的结构是固定的，主要有常量池、字段表、方法表、属性表等内容，通过使用访问者模式在扫描 .class 文件中各个表的内容时，就可以修改这些内容了。</p>
<h1 id="ASM的思想是什么？"><a href="#ASM的思想是什么？" class="headerlink" title="ASM的思想是什么？"></a>ASM的思想是什么？</h1><p>ClassReader 的 accept 方法中传进来了一个参数ClassVisitor。在内部，ClassVisitor会不断的读取ClassReader的二进制byte[]，然后在解析后通过参数classVisitor的抽象visitXXX方法将属性全部转发出去。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825235523.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20180825235623.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/CSqingchen/article/details/106483693">Android 中使用ASM，对Activity生命周期打点统计</a></li>
</ul>
<h1 id="ASM-API"><a href="#ASM-API" class="headerlink" title="ASM API"></a>ASM API</h1><p>分为核心API和树形API</p>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：</p>
<ul>
<li>ClassReader：用于读取已经编译好的.class文件。</li>
<li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li>
<li>  各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。</li>
</ul>
<h2 id="树形API"><a href="#树形API" class="headerlink" title="树形API"></a>树形API</h2><p>ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</p>
<h1 id="Intellij-Idea-中-ASM-Bytecode-Outline-插件"><a href="#Intellij-Idea-中-ASM-Bytecode-Outline-插件" class="headerlink" title="Intellij Idea 中 ASM Bytecode Outline 插件"></a>Intellij Idea 中 ASM Bytecode Outline 插件</h1><p>可以把java代码转为ASM框架的代码。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ForwardSailing/article/details/106494116">Android Studio 使用 ASM Bytecode Outline 插件来研究Java字节码</a></li>
</ul>
<h1 id="ASM如何使用？"><a href="#ASM如何使用？" class="headerlink" title="ASM如何使用？"></a>ASM如何使用？</h1><p>ClassWriter是ClassVistor的实现类。</p>
<p>处理逻辑都写自定义ClassVisitor里。</p>
<p>模板的拦截代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">&quot;meituan/bytecode/asm/Base&quot;</span>);</span><br><span class="line">ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理</span></span><br><span class="line">ClassVisitor classVisitor = <span class="keyword">new</span> MyClassVisitor(classWriter);</span><br><span class="line">classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"><span class="keyword">byte</span>[] data = classWriter.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;/classes/meituan/bytecode/asm/Base.class&quot;</span>);</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">fout.write(data);</span><br><span class="line">fout.close();</span><br></pre></td></tr></table></figure>

<p>代码示例：在一个方法前后分别插入方法</p>
<p>例如有一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">halloAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AopInterceptor.beforeInvoke();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Aop&quot;</span>);</span><br><span class="line">        AopInterceptor.afterInvoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要插入AopInterceptor的beforeInvoke()和afterInvoke()在TestBean的halloAop()的执行前后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义ClassVisitor的visitMethod方法中拦截halloAop方法，对不是halloAop的方法返回null表示不处理，对halloAop的拦截处理交给AopMethod类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopClassAdapter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopClassAdapter</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">    String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&lt;init&gt;&quot;</span>.equals(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//放弃原有类中所有构造方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;halloAop&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 只对halloAop方法执行代理</span></span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AopMethod(<span class="keyword">this</span>.api, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodVisitor中</p>
<p>visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，重写visitCode方法，将AOP中的前置逻辑就放在这里。</p>
<p>每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法。我们判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将AOP的后置逻辑放在该方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopMethod</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopMethod</span><span class="params">(<span class="keyword">int</span> api, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitCode();    </span><br><span class="line">        <span class="keyword">this</span>.visitMethodInsn(INVOKESTATIC,<span class="string">&quot;org/more/test/asm/AopInterceptor&quot;</span>, <span class="string">&quot;beforeInvoke&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == RETURN) &#123;<span class="comment">//在返回之前安插after 代码。</span></span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;org/more/test/asm/AopInterceptor&quot;</span>, <span class="string">&quot;afterInvoke&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
<li><a href="https://my.oschina.net/ta8210/blog/162796">深入字节码 – 使用 ASM 实现 AOP</a></li>
<li><a href="https://blog.csdn.net/s127838498/article/details/107968840">Android 通过ASM实现多次点击拦截</a></li>
</ul>
<h1 id="invokevirtual指令执行方法后，方法的返回值存放在哪？"><a href="#invokevirtual指令执行方法后，方法的返回值存放在哪？" class="headerlink" title="invokevirtual指令执行方法后，方法的返回值存放在哪？"></a>invokevirtual指令执行方法后，方法的返回值存放在哪？</h1><p>存放在栈帧的操作栈中。</p>
<blockquote>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p>
<p>举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p>
</blockquote>
<p>参考</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode instruction listings 中对指令的descrpitoin</a></li>
<li><a href="http://gityuan.com/2015/10/24/jvm-bytecode-grammar/">Jvm系列3—字节码指令</a></li>
</ul>
<h1 id="局部变量表的执行过程？"><a href="#局部变量表的执行过程？" class="headerlink" title="局部变量表的执行过程？"></a>局部变量表的执行过程？</h1><p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎</a></li>
<li>深入理解Java虚拟机（第2版）第8章  虚拟机字节码执行引擎<ul>
<li>8.2.1 局部变量表</li>
<li>8.4.3 基于栈的解释器的执行过程</li>
</ul>
</li>
</ul>
<h1 id="MethodNode有什么作用？"><a href="#MethodNode有什么作用？" class="headerlink" title="MethodNode有什么作用？"></a>MethodNode有什么作用？</h1><p>可以获取方法体内部的字节码指令等方法的一切信息</p>
<h1 id="MethodNode有什么使用场景？"><a href="#MethodNode有什么使用场景？" class="headerlink" title="MethodNode有什么使用场景？"></a>MethodNode有什么使用场景？</h1><p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">微信Android客户端卡顿检测工具：Matrix-Android-TraceCanary</a></p>
<h2 id="判断一个方法是空方法？"><a href="#判断一个方法是空方法？" class="headerlink" title="判断一个方法是空方法？"></a>判断一个方法是空方法？</h2><p>遍历字节码指令，没有有效的字节码指令就是空</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmptyMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();  </span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();  </span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断扫描的函数是否只含有-PUT-READ-FIELD-等简单的指令"><a href="#判断扫描的函数是否只含有-PUT-READ-FIELD-等简单的指令" class="headerlink" title="判断扫描的函数是否只含有 PUT/READ FIELD 等简单的指令"></a>判断扫描的函数是否只含有 PUT/READ FIELD 等简单的指令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGetSetMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ignoreCount = <span class="number">0</span>;</span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();</span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opcode != Opcodes.GETFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.GETSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_GETFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_GETSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.RETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.ARETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.DRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.FRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.LRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.IRETURN</span><br><span class="line">                &amp;&amp; opcode != Opcodes.PUTFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.PUTSTATIC</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_PUTFIELD</span><br><span class="line">                &amp;&amp; opcode != Opcodes.H_PUTSTATIC</span><br><span class="line">                &amp;&amp; opcode &gt; Opcodes.SALOAD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConstructor &amp;&amp; opcode == Opcodes.INVOKESPECIAL) &#123;</span><br><span class="line">                ignoreCount++;</span><br><span class="line">                <span class="keyword">if</span> (ignoreCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="判断一个方法是不是仅调用另外一个方法"><a href="#判断一个方法是不是仅调用另外一个方法" class="headerlink" title="判断一个方法是不是仅调用另外一个方法"></a>判断一个方法是不是仅调用另外一个方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSingleMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;AbstractInsnNode&gt; iterator = instructions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        AbstractInsnNode insnNode = iterator.next();</span><br><span class="line">        <span class="keyword">int</span> opcode = insnNode.getOpcode();</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == opcode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Opcodes.INVOKEVIRTUAL &lt;= opcode &amp;&amp; opcode &lt;= Opcodes.INVOKEDYNAMIC) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索（付ASM简易教程）</a></li>
<li><a href="https://juejin.im/post/6844903721789292558">从 Java 字节码到 ASM 实践</a></li>
<li><a href="https://juejin.im/post/6844903831646502920">Android Transform + ASM 初探</a></li>
<li><a href="https://juejin.im/post/6844903725937475592">自定义 gradle plugin，教你如何 hook 系统 task 和字节码</a></li>
<li><a href="https://juejin.im/post/6844904029886087181">详解Android Gradle生成字节码流程</a></li>
<li><a href="http://quinnchen.cn/2018/09/13/2018-09-13-asm-transform/">一起玩转Android项目中的字节码</a></li>
<li><a href="https://blog.csdn.net/CSqingchen/article/details/106483693">Android 中使用ASM，对Activity生命周期打点统计</a></li>
<li><a href="https://www.jianshu.com/p/e5062d62a3d1">认识 .class 文件的字节码结构</a></li>
<li><a href="https://www.jianshu.com/p/0cf9aa251921">理解 JVM 中的类加载机制</a></li>
<li><a href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎</a></li>
<li><a href="https://www.baeldung.com/java-asm">asm官网（内附教程）</a></li>
<li><a href="https://developer.ibm.com/zh/articles/j-lo-asm30/">AOP 的利器：ASM 3.0 介绍</a></li>
<li><a href="https://www.jianshu.com/p/905be2a9a700">ASM 库的介绍和使用</a></li>
<li><a href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a></li>
<li><a href="https://www.jianshu.com/p/905be2a9a700">ASM 库的介绍和使用</a></li>
<li><a href="https://www.jianshu.com/p/c2c1d350d245">从 Java 字节码到 ASM 实践</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>虚拟机</tag>
        <tag>ASM</tag>
        <tag>字节码</tag>
        <tag>插桩</tag>
      </tags>
  </entry>
  <entry>
    <title>JIT编译、HotSpot虚拟机</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/JIT%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="静态编译和动态编译分别是什么？"><a href="#静态编译和动态编译分别是什么？" class="headerlink" title="静态编译和动态编译分别是什么？"></a>静态编译和动态编译分别是什么？</h1><p>动态编译（dynamic compilation），指的是“在运行时进行编译”；</p>
<p>与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation），程序运行前就把代码全部翻译成机器码</p>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/19977592">JIT编译，动态编译与自适应动态编译 - RednaxelaFX的文章 - 知乎</a></li>
</ul>
<h1 id="JIT编译是什么？"><a href="#JIT编译是什么？" class="headerlink" title="JIT编译是什么？"></a>JIT编译是什么？</h1><p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。</p>
<p>JIT编译一词后来被泛化，时常与动态编译等价；但要注意宽泛与狭义的JIT编译所指的区别。</p>
<p>JIT编译，全称 just-in-time compilation，按照其原始的、严格的定义，是每当一部分代码准备要第一次执行的时候，将这部分代码编译，然后跳进编译好的代码里执行。这样，所有执行过的代码都必然会被编译过。早期的JIT编译系统对同一个块代码只会编译一次。JIT编译的单元也可以选择是方法/函数级别，或者别的，例如trace。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824238546.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/26913901/answer/35303563">HotSpot是较新的Java虚拟机技术，用来代替JIT技术, 那么HotSpot和JIT是共存的吗？ - RednaxelaFX的回答 - 知乎</a></li>
<li><a href="https://juejin.im/post/5b3782b1e51d4558dc4ae4a7">你了解JVM中的 JIT 即时编译及优化技术吗？</a></li>
</ul>
<h1 id="解释执行是什么意思？"><a href="#解释执行是什么意思？" class="headerlink" title="解释执行是什么意思？"></a>解释执行是什么意思？</h1><p>解释器：只在执行程序时，才一条一条把字节码解释成机器语言给计算机来执行</p>
<p>Java需要将字节码逐条翻译成对应的机器指令并且执行，这就是传统的JVM的解释器的功能，正是由于解释器逐条翻译并执行这个过程的效率低，引入了JIT即时编译技术。</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1488067">有关JIT你需要知道的</a></li>
</ul>
<h1 id="为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？"><a href="#为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？" class="headerlink" title="为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？"></a>为什么要遇到热点代码才要编译字节码为机器码？为什么不把所有的字节码都编译为机器码？</h1><p>因为有些代码在将来只执行一次也有可能不执行，全部编译占用空间也浪费时间。</p>
<h1 id="JIT编译器有什么好处？"><a href="#JIT编译器有什么好处？" class="headerlink" title="JIT编译器有什么好处？"></a>JIT编译器有什么好处？</h1><p>在运行时编译，可以实时的获取运行时的信息，更好的做编译优化；静态编译是无法做这种优化的。</p>
<p>A JIT compiler runs after the program has started and compiles the code (usually bytecode or some kind of VM instructions) on the fly (or just-in-time, as it’s called) into a form that’s usually faster, typically the host CPU’s native instruction set. A JIT has access to dynamic runtime information whereas a standard compiler doesn’t and can make better optimizations like inlining functions that are used frequently.</p>
<ul>
<li><a href="https://www.zhihu.com/question/21093419/answer/112968115">如何通俗易懂地介绍「即时编译」（JIT），它的优点和缺点是什么？ - lcksuper的回答 - 知乎  </a></li>
</ul>
<h1 id="为何-HotSpot-虚拟机要使用解释器与编译器并存的架构？"><a href="#为何-HotSpot-虚拟机要使用解释器与编译器并存的架构？" class="headerlink" title="为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？"></a>为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？</h1><p>解释器与编译器两者各有优势。</p>
<p>解释器：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。</p>
<p>编译器：在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</p>
<p>两者的协作：在程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。当通过编译器优化时，发现并没有起到优化作用，，可以通过逆优化退回到解释状态继续执行。</p>
<ul>
<li><a href="https://juejin.cn/post/6844903630408155150">你了解JVM中的 JIT 即时编译及优化技术吗？</a></li>
</ul>
<p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。此外，如果编译后出现“罕见陷阱”，可以通过逆优化退回到解释执行。</p>
<p>解释器的执行，抽象的看是这样的：输入的代码 -&gt; [ 解释器 解释执行 ] -&gt; 执行结果</p>
<p>而要JIT编译然后再执行的话，抽象的看则是：输入的代码 -&gt; [ 编译器 编译 ] -&gt; 编译后的代码 -&gt; [ 执行 ] -&gt; 执行结果</p>
<p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快。怎么算是“只执行一次的代码”呢？粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p>
<p>1、只被调用一次，例如类的构造器（class initializer，<clinit>()）</p>
<p>2、没有循环</p>
<p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。只有对频繁执行的代码，JIT编译才能保证有正面的收益。</p>
<p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”。这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/guanghe/p/11880577.html">Java虚拟机解释器与JIT编译器</a></li>
</ul>
<h1 id="HotSpot虚拟机为什么叫Hotspot？"><a href="#HotSpot虚拟机为什么叫Hotspot？" class="headerlink" title="HotSpot虚拟机为什么叫Hotspot？"></a>HotSpot虚拟机为什么叫Hotspot？</h1><p>通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。</p>
<p>HotSpot VM得名于它得混合模式执行引擎：这个执行引擎包括解释器和自适应编译器（adaptive compiler）。默认配置下，一开始所有Java方法都由解释器执行。解释器记录着每个方法得调用次数和循环次数，并以这两个数值为指标去判断一个方法的“热度”。显然，HotSpot VM是以“方法”为单位来寻找热点代码。等到一个方法足够“热”的时候，HotSpot VM就会启动对该方法的编译。这种在所有执行过的代码里只寻找一部分来编译的做法，就叫做自适应编译（adaptive compilation）。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824335546.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/26913901/answer/35303563">HotSpot是较新的Java虚拟机技术，用来代替JIT技术,那么HotSpot和JIT是共存的吗？ - RednaxelaFX的回答 - 知乎</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html">深入浅出 JIT 编译器</a></li>
</ul>
<h1 id="JIT编译与HotSpot虚拟机有什么关系？"><a href="#JIT编译与HotSpot虚拟机有什么关系？" class="headerlink" title="JIT编译与HotSpot虚拟机有什么关系？"></a>JIT编译与HotSpot虚拟机有什么关系？</h1><p>首先，如果一段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。</p>
<p>当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。</p>
<p>在部分的商用虚拟机（Sun HotSpot、IBM J9）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，本文中简称JIT编译器）。</p>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1488067">有关JIT你需要知道的</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>JIT编译</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中创建对象内存分配的过程</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="指针碰撞和空闲列表"><a href="#指针碰撞和空闲列表" class="headerlink" title="指针碰撞和空闲列表"></a>指针碰撞和空闲列表</h1><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump thePointer）。</p>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（FreeList）。</p>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/yun_ld/article/details/105103011">指针碰撞和空闲列表</a></li>
</ul>
<h1 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824235546.png"></p>
<ul>
<li>  当虚拟机收到new指令后，检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，必须先执行类加载过程。</li>
<li>  在类加载完成后可以确定对象分配所需要的空间。如果Java堆中内存是绝对规整的，用过的内存放一边，空闲的内存放另一边，中间放着一个指针作为分界点的指示器，那分配内存就只是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为”指针碰撞”。如果Java堆中内存不是规整的，空闲内存与使用过的内存是相互交错的，虚拟机必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找出足够的空间分配给对象实例，并更新列表上的记录，这种分配方式称为”空闲列表”。采用哪种分配方式通常由虚拟机的垃圾收集器是否带有压缩整理功能决定。</li>
<li>  划分可用空间时，还需考虑为对象实例分配空间时是否是线程安全的。要保证线程安全，有两种方案。一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种是把内存分配的动作按照线程划分在不同空间中进行，每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer , TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</li>
<li>  内存分配完成后，虚拟机对分配到的内存空间都初始化为零值(不包括对象头)，保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用。</li>
<li>  虚拟机将对象的信息放入对象的对象头中。</li>
<li>  执行构造函数</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a9ff882337d4">Java内存分配与回收机制</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收器</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="常见的垃圾回收器有哪些？"><a href="#常见的垃圾回收器有哪些？" class="headerlink" title="常见的垃圾回收器有哪些？"></a>常见的垃圾回收器有哪些？</h1><ol>
<li><p>串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。</p>
</li>
<li><p>并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。</p>
</li>
<li><p>吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。</p>
</li>
<li><p> 并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。</p>
</li>
<li><p>G1（Garbage First）收集器是一款在server端运行的垃圾收集器，专门针对于拥有多核处理器和大内存的机器，在JDK 7u4版本发行时被正式推出，在JDK9中更被指定为官方GC收集器。它满足高吞吐量的同时满足GC停顿的时间尽可能短。</p>
</li>
</ol>
<p>参考《深入理解Java虚拟机（第2版）》 76页 3.5 垃圾收集器。</p>
<h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>新生代收集器，单线程收集，收集时Stop the world（暂停所有线程），采取复制算法</p>
<p>客户端新生代默认收集器，因为用户桌面应用场景中，分配给虚拟机的内存不会很大，停顿时间较短，只要不是频繁发生，可以接受，这样就发挥出Serial收集器简单而高效的优点。</p>
<h1 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h1><p>老生代收集器，单线程收集，收集时Stop the world（暂停所有线程），采取标记整理算法</p>
<h1 id="Parallel-New收集器"><a href="#Parallel-New收集器" class="headerlink" title="Parallel New收集器"></a>Parallel New收集器</h1><p>新生代收集器，Serial收集器的多线程版本，多个GC线程同时进行回收</p>
<h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><p>新生代收集器，采用复制算法多线程收集</p>
<p>目标是达到一个可控的吞吐量，吞吐量优先的收集器</p>
<p>吞吐量=程序运行时间/(程序运行时间+垃圾回收时间)</p>
<p>适合后台运算不需要太多实时交互响应的场景</p>
<p>适合对吞吐量和CPU资源很在意，对交互响应不敏感的的场景，例如后台服务，可以尽可能的多执行任务</p>
<p>可以开启自适应调解策略，让虚拟机根据系统运行情况动态调节内存分配的参数（如新生代大小、Eden与Survivor比例、晋升到老年代的年龄阈值等），以达到最佳的吞吐量，这是与Parallel New的重要区别。</p>
<p>还可以设置最大GC停顿时间和吞吐量给虚拟机设定优化的目标，由虚拟机自动调解最适合的参数来进行内存分配管理。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/764f93fac5f3">GC之Parallel Scavenge收集器</a></li>
<li><a href="https://www.sohu.com/a/217647656_812245">详细介绍JVM吞吐量优先收集器以及各种可以配置的参数</a></li>
</ul>
<h1 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h1><p>老年代收集器，Parallel Scavenge的老年代版本，使用多线程和标记整理，吞吐量优先</p>
<h1 id="Concurrent-Mark-Sweep收集器"><a href="#Concurrent-Mark-Sweep收集器" class="headerlink" title="Concurrent Mark Sweep收集器"></a>Concurrent Mark Sweep收集器</h1><p>老年代收集器，以获得最短的GC停顿时间为目标的收集器，适合卡顿容忍度低的场景，例如有用户交互的情景（如Android手机交互）</p>
<p>收集过程为：</p>
<ol>
<li> 初始标记</li>
<li> 并发标记</li>
<li> 重新标记</li>
<li> 并发清除</li>
</ol>
<p>初始标记和重新标记需要Stop the world（暂停所有线程）。初始标记仅标记跟GC Roots直接关联的对象，速度很快；并发标记就是进行完整的可达性分析（GC Roots Tracing）；重新标记是为了修正并发标记期间进程继续运行而导致对象关系变动而重新标记这些变动的对象关系，运行时间比初始标记稍长，但是远比并发标记时间短，要扫描全堆。</p>
<p>缺点：</p>
<ol>
<li> 并发标记和并发清除所启用的多个GC线程占用了CPU资源，降低系统吞吐量。</li>
<li> 无法处理并发清除期间程序继续运行而产生的浮动垃圾，不能等待老年代满了才收集，等到老年代占用的空间达到一个阈值，就要启用CMS清理，这样就预留了一定的空间来容纳并发清除期间产生的浮动垃圾，如果预留的空间无法满足程序继续运行的需要，则改用Serial Old执行清理。</li>
<li>标记清除算法会产生大量不连续的内存碎片，整理碎片只能串行执行，所以比较耗时，采用标记清除也是因为老年代的回收次数比较少，每次回收都标记整理性价比不高，可以在几次标记清除后再执行一次标记整理，调节一个可控的执行频率。</li>
</ol>
<p>参考</p>
<ul>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
<li><a href="https://www.zhihu.com/question/29114369/answer/387208380">minor gc 会发生stop the world 现象吗？ - wuxinliulei的回答 - 知乎</a></li>
</ul>
<h2 id="为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？"><a href="#为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？" class="headerlink" title="为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？"></a>为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？</h2><p>因为要并发清除，所以用的是标记清理算法，而标记清理算法会产生大量内存碎片，对新生代难以接受，新生代适合用复制算法，或者需要整理内存，以腾出连续的空间以供分配大对象。</p>
<p>因此新生代的收集器并未提供CMS版本。</p>
<h2 id="为什么CMS不能用标记整理而要用标记清理？"><a href="#为什么CMS不能用标记整理而要用标记清理？" class="headerlink" title="为什么CMS不能用标记整理而要用标记清理？"></a>为什么CMS不能用标记整理而要用标记清理？</h2><p>因为老年代存活时间长，每次清理后，要整理的存活的对象太多了，比较耗时。</p>
<p>CMS主要关注低延迟，如果采用压缩算法，则涉及到要移动应用程序的存活对象，此时不停顿，是很难处理的，通常须要停顿下，移动存活对象，再让应用程序继续运行，但这样停顿时间变长，延迟变大。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.shangmayuan.com/a/b18e72c952e749e0a8a21664.html">CMS为何采用标记-清除算法</a></li>
<li><a href="https://hllvm-group.iteye.com/group/forum?tag_id=690">[讨论]</a>  <a href="https://hllvm-group.iteye.com/group/topic/38223">并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a></li>
</ul>
<h1 id="Garbage-First（G1）收集器"><a href="#Garbage-First（G1）收集器" class="headerlink" title="Garbage First（G1）收集器"></a>Garbage First（G1）收集器</h1><p>JVM内部知道，哪些region的对象最少（即：该区域最空），总是会优先收集这些region(因为对象少，内存相对较空，肯定快），这也是Garbage-First得名的由来，G即是Garbage的缩写， 1即First(第1)。</p>
<p>G1 根据存活对象的字节数统计每个区域的 活跃度liveness，然后根据期望停顿时间来确定该 CSet 的大小，并保证那些垃圾多（活跃度低）的区域会被优先回收，故此得名 垃圾优先。</p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>G1 能够在大内存、多处理器计算机上，保证 GC 暂停时间可控，并实现高吞吐量。</p>
<p>其最终目的是取代 CMS 成为服务端 GC 更好的解决方案：</p>
<ol>
<li> 采用 标记-整理 算法，可以避免使用细粒度的空闲列表进行分配。简化了收集器设计并消除了潜在的碎片问题。</li>
<li>提供可预测的GC暂停时间，无需牺牲很多吞吐量。</li>
</ol>
<h2 id="G1相对于CMS的优势"><a href="#G1相对于CMS的优势" class="headerlink" title="G1相对于CMS的优势"></a>G1相对于CMS的优势</h2><ol>
<li>CMS是标记清理，回收过后有大量内存碎片；G1从整体来看是基于标记-整理算法实现的，从局部（两=08u ym,ghvtbfrcRegion之间）上来看是基于“复制”算法实现的，避免了过多的内存碎片</li>
<li>G1在逻辑上虽然也Eden、Survivor、Old区，但是都是以Region为单位，不需要扫描整个内存空间，只要扫描有存活对象的Region，减少了扫描的时间</li>
<li>G1可以通过设置预期停顿时间( Pause Time) 来控制垃圾收集时间，在垃圾回收时尽量满足设置的停顿时间。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</li>
<li>G1会在Young GC中使用，而CMS只能在Old区使用，因为年轻代需要用复制算法以腾出大量连续内存空间，CMS是标记清理算法会产生大量内存碎片</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></li>
</ul>
<h2 id="G1的适合场景"><a href="#G1的适合场景" class="headerlink" title="G1的适合场景"></a>G1的适合场景</h2><ol>
<li> 服务端多核CPU、JVM内存占用较大的应用。</li>
<li> 应用在运行过程中会产生大量内存碎片、需要经常压缩空间。</li>
<li> 想要更可控、可预期的GC停顿周期:防止高并发下应用的雪崩现象，实现高吞吐量。 </li>
</ol>
<p>一句话总结：实现高吞吐、没有内存碎片、收集时间可控。</p>
<p>G1收集器是server-style的垃圾收集器，适用于具有大内存的多处理器计算机。它极有可能满足垃圾回收（GC）暂停时间目标，同时实现高吞吐量。</p>
<p>对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照<a href="https://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html">官方</a> 的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：</p>
<ol>
<li> 实时数据占用了超过半数的堆空间；</li>
<li> 对象分配率或“晋升”的速度变化明显； </li>
<li> 期望消除耗时较长的GC或停顿（超过0.5——1秒）。</li>
</ol>
<h2 id="G1内存划分"><a href="#G1内存划分" class="headerlink" title="G1内存划分"></a>G1内存划分</h2><p>G1把内存分为大约2000个左右的一个个大小固定的小块，小块叫Region，每个Region被标记为分代标志，如Eden、Survivor、Old、Humongous，每个Region在物理内存中可以不连续</p>
<h3 id="G1把内存划分为Region区域有什么好处？"><a href="#G1把内存划分为Region区域有什么好处？" class="headerlink" title="G1把内存划分为Region区域有什么好处？"></a>G1把内存划分为Region区域有什么好处？</h3><ol>
<li>其他收集器会在全堆做扫描，导致gc停顿时间会比较长，而G1只是整理特定几个region，不必扫描全堆</li>
<li>在物理，上不需要连续，则带来了额外的好处有的分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾；停顿时间可预测，用户可以指定收集操作在多长时间内完成</li>
<li> G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩，避免了内存碎片。</li>
</ol>
<h3 id="G1收集器中大对象怎么分配"><a href="#G1收集器中大对象怎么分配" class="headerlink" title="G1收集器中大对象怎么分配"></a>G1收集器中大对象怎么分配</h3><ol>
<li>对象的大小&lt;0.5个RegionSize直接存在新生代Eden Region区</li>
<li>对象的大小&gt;=0.5个RegionSize且对象的大小&lt;1个RegionSize,存到大对象区Humongous Region</li>
<li> 对象的大小&gt;=1个RegionSize存到连续的大对象区Humongous Region</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000038430433">总结G1垃圾收集器面试题</a></li>
</ul>
<h2 id="G1预测停顿时间是怎么做到的？"><a href="#G1预测停顿时间是怎么做到的？" class="headerlink" title="G1预测停顿时间是怎么做到的？"></a>G1预测停顿时间是怎么做到的？</h2><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p>G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p>
<h2 id="G1为什么高效？"><a href="#G1为什么高效？" class="headerlink" title="G1为什么高效？"></a>G1为什么高效？</h2><p>为了提高扫描根对象和标记的效率，G1使用了二个新的辅助存储结构：</p>
<ul>
<li>Remembered Sets：简称RSets，用于根据每个region里的对象，是从哪指向过来的(即：谁引用了我)，每个Region都有独立的RSets。（Other Region -&gt; Self Region)</li>
<li>Collection Sets ：简称CSets，记录了等待回收的Region集合，GC时这些Region中的对象会被回收(copied or moved)。</li>
</ul>
<h3 id="Rememberred-Set是什么？"><a href="#Rememberred-Set是什么？" class="headerlink" title="Rememberred Set是什么？"></a>Rememberred Set是什么？</h3><p>记录哪些分区引用了当前的Region。</p>
<p>使得垃圾回收器不需要扫描整个堆，就可以找到谁引用了当前分区的对象，扫描RSet就行了。</p>
<p>Young区到Old区的引用则不需要单独处理，因为Young区中的对象本身变化比较大，没必要浪费空间去记录下来。</p>
<ol>
<li> RSet：全称Remembered Sets, 用来记录外部指向本Region的所有引用，每个Region维护一个RSet。    </li>
<li> Card: JVM将内存划分成了固定大小的Card。这里可以类比物理内存上page的概念。</li>
</ol>
<p>每个Region初始化时，会初始化一个remembered set（已记忆集合），这个翻译有点拗口，以下简称RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的 xx Card。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/luzhensmart/article/details/106052574">G1-Card Table和Remember Set</a></li>
<li><a href="https://club.perfma.com/article/1933770">CardTable和Remeberred Set区别？</a></li>
<li><a href="https://segmentfault.com/a/1190000021878102">“对象消失”、“三色标记”、“增量更新”</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></li>
<li><a href="https://www.cnblogs.com/GrimMjx/p/12234564.html">搞懂G1垃圾收集器</a></li>
<li><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/94477796">JVM G1收集器</a></li>
<li><a href="https://www.cnblogs.com/buttercup/p/13829881.html#g1-%E7%AE%97%E6%B3%95">G1收集器</a></li>
<li><a href="https://segmentfault.com/a/1190000021878102">面试官问我G1回收器怎么知道你是什么时候的垃圾？</a></li>
</ul>
<h1 id="JDK8默认垃圾回收器是什么？"><a href="#JDK8默认垃圾回收器是什么？" class="headerlink" title="JDK8默认垃圾回收器是什么？"></a>JDK8默认垃圾回收器是什么？</h1><p>Parallel Scavenge + Parallel Old</p>
<p>Parallel Scavenge是吞吐量优先的垃圾收集器，采用复制算法，多线程收集。</p>
<p>Parallel Old是Parallel Scavenge的老年代版本，采用标记整理算法，多线程收集。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/huanxianglove/article/details/90247994">JDK8默认垃圾回收器详解</a></li>
</ul>
<h1 id="JDK9默认垃圾收集器是什么？"><a href="#JDK9默认垃圾收集器是什么？" class="headerlink" title="JDK9默认垃圾收集器是什么？"></a>JDK9默认垃圾收集器是什么？</h1><p>G1。</p>
<p>采用G1因为性能优越。</p>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1429131">为什么G1 GC从JDK 9之后成为默认的垃圾回收器？</a></li>
</ul>
<h1 id="Android-ART虚拟机垃圾回收机制是怎样的？"><a href="#Android-ART虚拟机垃圾回收机制是怎样的？" class="headerlink" title="Android  ART虚拟机垃圾回收机制是怎样的？"></a>Android  ART虚拟机垃圾回收机制是怎样的？</h1><p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/89536376">Android ART 并行拷贝垃圾回收
</a></li>
<li><a href="https://www.kancloud.cn/alex_wsc/androids/473625">老罗的Android之旅：ART运行时垃圾收集机制简要介绍和学习计划
</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
        <tag>CMS</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收算法</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="如何判定一个对象是否可以被垃圾回收？"><a href="#如何判定一个对象是否可以被垃圾回收？" class="headerlink" title="如何判定一个对象是否可以被垃圾回收？"></a>如何判定一个对象是否可以被垃圾回收？</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>记录每个对象被引用数量，产生新引用计数加1，引用失效计数减1</p>
<p>优点：实现简单<br>缺点：无法解决环形依赖引用</p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>一个对象到GC Roots对象没有引用链，表示此对象是没有地方使用，可以被回收。</p>
<h3 id="可以作为GC-Roots的对象"><a href="#可以作为GC-Roots的对象" class="headerlink" title="可以作为GC Roots的对象"></a>可以作为GC Roots的对象</h3><ol>
<li> 虚拟机栈中的引用的对象，即栈帧中的局部变量表中引用的对象</li>
<li> 本地方法栈中引用的对象，即native方法中引用的对象</li>
<li> 方法区中类的静态属性引用的对象</li>
<li> 方法区中常量引用的对象</li>
</ol>
<p>优点：</p>
<ul>
<li>分析更加精确，解决了环形引用的问题</li>
</ul>
<p>缺点：</p>
<ul>
<li> 实现复杂，分析时间长</li>
<li>分析过程需要保证引用关系不能发生变化，需要GC停顿，即让所有线程的执行都暂停（Stop the world）</li>
</ul>
<p>参考《深入理解Java虚拟机（第2版）》3.2 对象已死吗</p>
<h1 id="GC停顿是什么？"><a href="#GC停顿是什么？" class="headerlink" title="GC停顿是什么？"></a>GC停顿是什么？</h1><p>对象的可达性分析需要枚举GC Roots节点对象，必须要保证对象之间的引用关系不能一直变化，必须要停顿所有线程的执行，这就是Stop the world，也是垃圾回收的性能瓶颈所在。暂停线程的工作，需要等到安全点才能暂停。</p>
<h1 id="怎么让线程在安全点暂停？"><a href="#怎么让线程在安全点暂停？" class="headerlink" title="怎么让线程在安全点暂停？"></a>怎么让线程在安全点暂停？</h1><p>主动式中断（Voluntary  Suspension），GC需要中断线程时，不直接中断线程，仅仅给每个线程设置一个标志，各线程主动轮询这个标志，发现中断标志为true就自己中断挂起。</p>
<h1 id="线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？"><a href="#线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？" class="headerlink" title="线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？"></a>线程不执行代码时（处于睡眠、等待或阻塞），无法主动轮询响应中断标志，虚拟机如果等待其恢复运行时间可能太长，垃圾回收时应该怎么应对？</h1><p>如果一段代码中引用关系不会变化，称为这一段为安全区域，线程执行到安全区域的代码时，会标记自己已经进入了安全区域；虚拟机发起垃圾回收时，就不用管已经位于安全区域的线程了。</p>
<p>线程离开安全区域时，要检查系统是否已经完成了GC Roots的枚举（或者是检查整个垃圾回收是否已结束），如果还没有完成，就必须要等待，直到收到可以安全离开安全区域的信号为止。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h1 id="垃圾回收算法有哪些？分别有什么优缺点-？"><a href="#垃圾回收算法有哪些？分别有什么优缺点-？" class="headerlink" title="垃圾回收算法有哪些？分别有什么优缺点  ？"></a>垃圾回收算法有哪些？分别有什么优缺点  ？</h1><p>垃圾回收算法主要有：</p>
<ol>
<li> 标记-清除（Mark-Sweep）</li>
<li> 复制（Copying）</li>
<li> 标记-整理（Mark-Compact）</li>
<li> 分代收集</li>
</ol>
<h2 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记-清除（Mark-Sweep）"></a>标记-清除（Mark-Sweep）</h2><p>先标记出内存中所有需要回收的对象，再统一回收所有被标记的对象。标记过程就是对象到GC Roots对象的可达性分析。</p>
<p>缺点：</p>
<ol>
<li>记和清除两个过程都不高效。</li>
<li>容易产生大量不连续的空间碎片，分配大对象的时候无法找到连续的内存空间时会再次触发垃圾回收。</li>
</ol>
<h2 id="复制（Copying）"><a href="#复制（Copying）" class="headerlink" title="复制（Copying）"></a>复制（Copying）</h2><p>将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完后，将还存活的对象复制到另外一块内存上，再把已使用过的那块内存一次清理掉。</p>
<p>优点：</p>
<ol>
<li> 每次对整半块的内存清理，实现简单</li>
<li> 内存分配时也没有内存碎片的问题，整体上更高效</li>
</ol>
<p>缺点：</p>
<ol>
<li> 有一半的内存空间闲置不用浪费了</li>
<li> 对象存活率较高时，就要进行较多的复制操作，效率降低</li>
</ol>
<h2 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记-整理（Mark-Compact）"></a>标记-整理（Mark-Compact）</h2><p>先标记出内存中所有存活的对象，再统一向内存的一端移动，最后直接清理掉边界以外的内存</p>
<p>优点：</p>
<ol>
<li> 不会产生不连续的内存碎片</li>
</ol>
<p>缺点：</p>
<ol>
<li> 标记和整理的速度较慢</li>
</ol>
<h2 id="分代收集（Generational-Collection）"><a href="#分代收集（Generational-Collection）" class="headerlink" title="分代收集（Generational Collection）"></a>分代收集（Generational Collection）</h2><p>根据对象的存活周期将堆内存划分为几块，这样可以针对不同的区域的特性使用最合适最高效的垃圾回收算法，一般把堆划分为新生代和老年代，默认新生代占堆的三分之一空间，老年代占堆的三分之二空间。</p>
<p>新生代又被划分为一块较大的Eden区域和两个较小的Survivor区域，每次使用Eden区和其中一个Survivor区。</p>
<p>在新生代中每次垃圾回收时都有大量的对象死去，只有少量对象存活，采用复制算法，当开始垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间，只要付出少量存活对象的复制成本就可以完成内存回收。在HotSpot虚拟机中Eden区和Survivor区大小比值默认为8:1，新生代只有10%的内存空间被浪费。当新生代空间不够时，需要老年代空间做分配担保，大对象直接存入老年代。</p>
<p>老年代中对象存活率高，必须使用标记清除或标记整理来进行回收。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824235449.png"></p>
<p>参考《深入理解Java虚拟机（第2版）》 3.3 垃圾收集算法</p>
<h1 id="分代收集有什么好处？"><a href="#分代收集有什么好处？" class="headerlink" title="分代收集有什么好处？"></a>分代收集有什么好处？</h1><p>对传统的、基本的GC实现来说，由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？<br>于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。</p>
<p>这个思路所基于的基本假设大家都很熟悉了：weak generational hypothesis——大部分对象的生命期很短（die young），而没有die young的对象则很可能会存活很长时间（live long）。</p>
<p>这是对过往的很多应用行为分析之后得出的一个假设。基于这个假设，如果让新创建的对象都在young gen里创建，然后频繁收集young gen，则大部分垃圾都能在young GC中被收集掉。由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/53613423/answer/135743258">java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎 </a></li>
</ul>
<h1 id="基于分代收集回收算法，堆上的内存分配策略是怎样的？"><a href="#基于分代收集回收算法，堆上的内存分配策略是怎样的？" class="headerlink" title="基于分代收集回收算法，堆上的内存分配策略是怎样的？"></a>基于分代收集回收算法，堆上的内存分配策略是怎样的？</h1><p>参考《深入理解Java虚拟机（第2版）》 3.6 内存分配与回收策略</p>
<h2 id="对象优先在新生代Eden区分配"><a href="#对象优先在新生代Eden区分配" class="headerlink" title="对象优先在新生代Eden区分配"></a>对象优先在新生代Eden区分配</h2><p>当Eden区没有足够的空间分配时，虚拟机发起一次Minor GC。</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>例如很长的字符串或很长的数组。</p>
<h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>每个对象都有一个年龄计数器，对象在Eden区出生，经过一次Minor GC仍然存活，并能被Survivor容纳，年龄就增加1岁，年龄增加到一定程度（默认为15），就会晋升到老年代。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>因为Eden区不足时会触发Minor GC，如果Minor GC后新生代空间仍然不足，需要老年代做分配担保，将存活的对象移动到老年代，如果老年代也没空间了，就要进行Full  GC了，清理整个堆（包括老年代和新生代）。</p>
<p>Minor  GC  前检查老年代剩余空间是否大于新生代所有对象的大小总和，如果大于，说明进行Minor  GC是安全的，因为最坏情况下新生代对象全部存活并且达到年龄上限，可以安全的移动到老年代；如果老年代剩余空间小于新生代所有对象大小总和，最坏情况下老年代容纳不了新生代所有对象，新的对象也没有办法分配在Eden区了，这个时候按道理就要触发Full  GC了，清理整个堆（包括老年代和新生代）。</p>
<h1 id="Minor-GC、Full-GC分别是什么？有什么区别？分别在什么时候触发？"><a href="#Minor-GC、Full-GC分别是什么？有什么区别？分别在什么时候触发？" class="headerlink" title="Minor  GC、Full GC分别是什么？有什么区别？分别在什么时候触发？"></a>Minor  GC、Full GC分别是什么？有什么区别？分别在什么时候触发？</h1><ul>
<li>Minor GC 回收新生代</li>
<li>Full GC 回收整个堆，包括新生代、老年代、元空间（Java8新增）</li>
</ul>
<p>Eden区不足时会触发Minor GC，如果Minor GC后新生代空间仍然不足，需要老年代做分配担保，将存活的对象移动到老年代，如果老年代也没空间了，就要进行Full  GC了，清理整个堆（包括老年代和新生代）。</p>
<p>如果一开始就能知道老年代空间不足，就不需要先Minor  GC再Full  GC，直接进行Full  GC更省事，所以Minor GC前会判断老年代剩余空间是否大于新生代所有对象大小总和，如果大于，最坏情况下新生代对象全部存活，全部放到老年代还是可以放得下的，如果小于，最坏情况下肯定是放不下，但也有可能经过Minor  GC后，剩余存活对象Survivor放不下但老年代可以放的下，这是不确定的，此时如果设置了允许分配担保失败，会检查老年代剩余空间是否大于历次新生代晋升到老年代的对象的平均总大小，如果大于说明Minor  GC应该是安全，这样也不会频繁触发Full GC，如果小于就直接进行Full GC了。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/41922036/answer/93079526">Major GC和Full GC的区别是什么？触发条件呢？ - RednaxelaFX的回答 - 知乎 </a></li>
<li>参考《深入理解Java虚拟机（第2版）》 3.6 内存分配与回收策略</li>
</ul>
<h1 id="JVM是如何避免Minor-GC时扫描全堆的？"><a href="#JVM是如何避免Minor-GC时扫描全堆的？" class="headerlink" title="JVM是如何避免Minor GC时扫描全堆的？"></a>JVM是如何避免Minor GC时扫描全堆的？</h1><p>垃圾回收时要判断哪些对象可以被回收，要做可达性分析，跟GC Root有引用关系的对象是存活对象，分析引用关系的时候，是不知道一个类被谁引用的，但是反过来可以知道一个类引用了别的什么类。</p>
<p>这就带来了一个问题，年轻代的Minor GC很频繁，做可达性分析的时候，如果有老年代的对象引用了年轻代的对象，为了找出这个引用关系，你得去扫描整个老年代，一个个检查老年代的对象是否对年轻代的对象有引用，这样效率太低了，扫描了全堆。</p>
<p>如果能记录下老年代有哪些类引用了年轻代类，那就不用扫描整个老年代了。这就是卡表（Card Table）的作用。</p>
<p>参考：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></p>
<h1 id="Minor-GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？"><a href="#Minor-GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？" class="headerlink" title="Minor GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？"></a>Minor GC时做对象的可达性分析，如果有老年代对象引用新生代时，难道要扫描一遍整个老年代？</h1><p>Minor GC时检查老年代中有没有引用新生代对象是通过检查卡表来完成的，老年代内存被划分为等长的卡页，每个卡页有一个编号，卡表中每一项代表某个卡页是否有对象引用新生代对象，这样Minor GC时就不用扫描整个老年代了，保证频繁进行Minor  GC不会占用太多CPU时间，提高了CPU的吞吐量。</p>
<p>虚拟机在对老年代中的对象更新引用时，会加入写屏障，暂时中断写操作，检查老年代的对象是否引用了新生代的对象，如果是的话，便更新CardTable，标记这一块卡页为脏。</p>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/post/5c39920b6fb9a049e82bbf94">JVM之卡表（Card Table）</a></li>
<li><a href="https://segmentfault.com/a/1190000004682407">jvm的card table数据结构</a></li>
</ul>
<hr>
<h1 id="卡表（CardTable）是什么？"><a href="#卡表（CardTable）是什么？" class="headerlink" title="卡表（CardTable）是什么？"></a>卡表（CardTable）是什么？</h1><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825001223.png"></p>
<p>讲老年代的空间划分为大小为512B的若干张卡。</p>
<p>卡表是单字节的数组，数组中每个元素对应着一张卡，当发生老年代对象引用新生代时，虚拟机将该卡对应的卡片元素设置为适当的值。之后Minor GC时通过扫描卡表就可以很快识别出哪些卡中存在老年代指向新生代的引用。用空间换时间，避免了全堆扫描。</p>
<p>参考：</p>
<ul>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
</ul>
<h1 id="System-gc-是什么使用场景？"><a href="#System-gc-是什么使用场景？" class="headerlink" title="System.gc()是什么使用场景？"></a>System.gc()是什么使用场景？</h1><p>调用此方法只会建议虚拟机进行垃圾回收，并不会强制执行垃圾回收。</p>
<p>由于频繁垃圾回收会导致频繁的线程暂停导致性能下降，因此应当尽量让虚拟机自动管理垃圾回收，对不用的对象置为null。</p>
<p>所以System.gc()可以当作不存在，需要测试垃圾回收时可能需要，平时不应当主动依赖这个方法做垃圾回收。</p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/66540/when-does-system-gc-do-something">When does System.gc() do something?</a></li>
<li><a href="https://blog.csdn.net/qq_36761831/article/details/81211540">Java中 System.gc() 调用垃圾收集器与 finalize() 函数</a></li>
</ul>
<h1 id="垃圾回收的性能瓶颈在哪"><a href="#垃圾回收的性能瓶颈在哪" class="headerlink" title="垃圾回收的性能瓶颈在哪"></a>垃圾回收的性能瓶颈在哪</h1><p>性能瓶颈在于需要暂停所有的线程，影响程序正常运行。</p>
<p>根据程序特性合理配置各个区域大小，减少垃圾回收触发次数，可以提高性能，因为每次垃圾回收都要暂停所有线程的工作。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《深入理解Java虚拟机（第2版）》第3章  垃圾回收器与内存分配策略</li>
<li><a href="https://www.zhihu.com/question/53613423/answer/135743258">java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎 </a></li>
<li><a href="https://www.cnblogs.com/zhxiansheng/p/11294529.html">新生代和老年代垃圾回收的细节
</a></li>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
        <tag>分代收集</tag>
        <tag>CardTable</tag>
        <tag>System.gc()</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Class结构</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%9A%84Class%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="如何方便的查看class结构？"><a href="#如何方便的查看class结构？" class="headerlink" title="如何方便的查看class结构？"></a>如何方便的查看class结构？</h1><ul>
<li><p>方法一<br>javap -verbose xxx.class</p>
</li>
<li><p>方法二<br>Intellij Idea装 jclasslib 插件<br>代码编译后在菜单栏”View”中选择”Show Bytecode With jclasslib”</p>
</li>
</ul>
<h1 id="Class文件的整体结构是怎样的"><a href="#Class文件的整体结构是怎样的" class="headerlink" title="Class文件的整体结构是怎样的?"></a>Class文件的整体结构是怎样的?</h1><p>JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210125335546.png"></p>
<p>class文件各数据项之间没有分隔符。</p>
<p>class文件采用类似于C语言的伪结构存储数据，这种伪结构只有两种数据类型：无符号数和表。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210125335542.png"></p>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》第6章  类文件结构</li>
</ul>
<h1 id="方法表的具体存储格式是怎样的？"><a href="#方法表的具体存储格式是怎样的？" class="headerlink" title="方法表的具体存储格式是怎样的？"></a>方法表的具体存储格式是怎样的？</h1><p>方法表也是由两部分组成：</p>
<ul>
<li>第一部分为两个字节描述方法的个数。</li>
<li>第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性。</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210125235546.png"></p>
<p>方法名索引、描述符索引，这两个的索引指的是在常量池中的索引，方法名和描述符都存储在class的常量池中，可以通过索引值在常量池中找到。</p>
<p>属性包括以下3个部分：</p>
<ol>
<li> “Code区”：源代码对应的JVM指令操作码，在进行字节码增强时重点操作的就是“Code区”这一部分。</li>
<li> “LineNumberTable”：行号表，将Code区的操作码和源代码中的行号对应，Debug时会起到作用（源代码走一行，需要走多少个JVM指令操作码）。 </li>
<li> “LocalVariableTable”：本地变量表，包含This和局部变量，之所以可以在每一个方法内部都可以调用This，是因为JVM将This作为每一个方法的第一个参数隐式进行传入。当然，这是针对非Static方法而言。</li>
</ol>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》第6章  类文件结构 6.3.6 方法表集合</li>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
</ul>
<h1 id="class文件结构一个具体的案例"><a href="#class文件结构一个具体的案例" class="headerlink" title="class文件结构一个具体的案例?"></a>class文件结构一个具体的案例?</h1><p>参考《深入理解Java虚拟机（第2版）》第6章 类文件结构 6.3.7 属性表集合 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile ~/Demo.class </span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">9</span>-<span class="number">30</span>; size <span class="number">338</span> bytes </span><br><span class="line">  MD5 checksum d2cf9d824e949e4dcc98ac47657cba67 </span><br><span class="line">  Compiled from <span class="string">&quot;Demo.java&quot;</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0 </span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52 </span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span> </span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>: </span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V </span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">19</span>         <span class="comment">// Demo.m:I </span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">20</span>            <span class="comment">// Demo </span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object </span></span><br><span class="line">   #<span class="number">5</span> = Utf8               m </span><br><span class="line">   #<span class="number">6</span> = Utf8               I </span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt; </span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V </span><br><span class="line">   #<span class="number">9</span> = Utf8               Code </span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable </span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable </span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="keyword">this</span> </span><br><span class="line">  #<span class="number">13</span> = Utf8               LDemo; </span><br><span class="line">  #<span class="number">14</span> = Utf8               inc </span><br><span class="line">  #<span class="number">15</span> = Utf8               ()I </span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile </span><br><span class="line">  #<span class="number">17</span> = Utf8               Demo.java </span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V </span></span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// m:I </span></span><br><span class="line">  #<span class="number">20</span> = Utf8               Demo </span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/Object </span><br><span class="line">&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>; </span><br><span class="line">    descriptor: ()V </span><br><span class="line">    flags: ACC_PUBLIC </span><br><span class="line">    Code: </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span> </span><br><span class="line">         <span class="number">0</span>: aload_0 </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span> </span><br><span class="line">      LineNumberTable: </span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span> </span><br><span class="line">      LocalVariableTable: </span><br><span class="line">        Start  Length  Slot  Name   Signature </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LDemo; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>; </span><br><span class="line">    descriptor: ()I </span><br><span class="line">    flags: ACC_PUBLIC </span><br><span class="line">    Code: </span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span> </span><br><span class="line">         <span class="number">0</span>: aload_0 </span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field m:I </span></span><br><span class="line">         <span class="number">4</span>: iconst_1 </span><br><span class="line">         <span class="number">5</span>: iadd </span><br><span class="line">         <span class="number">6</span>: ireturn </span><br><span class="line">      LineNumberTable: </span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span> </span><br><span class="line">      LocalVariableTable: </span><br><span class="line">        Start  Length  Slot  Name   Signature </span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   LDemo; </span><br><span class="line">&#125; </span><br><span class="line">SourceFile: <span class="string">&quot;Demo.java&quot;</span> </span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《深入理解Java虚拟机（第2版）》第6章  类文件结构</li>
<li><a href="https://www.cnblogs.com/webor2006/p/9459681.html">Java字节码方法表与属性表深度剖析</a></li>
<li><a href="https://www.cnblogs.com/webor2006/p/9459681.html">Java字节码方法表与属性表深度剖析</a></li>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Class结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器（ClassLoader）</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89/</url>
    <content><![CDATA[<h1 id="类加载器是干什么的"><a href="#类加载器是干什么的" class="headerlink" title="类加载器是干什么的?"></a>类加载器是干什么的?</h1><p>负责将class文件（Java编译后的字节码文件）读取到内存，并转换为java.lang.Class的一个实例。</p>
<h1 id="常见类加载器有哪些？分别是什么作用？"><a href="#常见类加载器有哪些？分别是什么作用？" class="headerlink" title="常见类加载器有哪些？分别是什么作用？"></a>常见类加载器有哪些？分别是什么作用？</h1><p>从虚拟机角度，分为启动类加载器和非启动类加载器。</p>
<ol>
<li> 启动类加载器（BootstrapClassLoader）是由C++实现，是虚拟机的一部分</li>
<li> 其他的类加载器，都是由Java实现，全部继承自ClassLoader。</li>
</ol>
<p>Java系统提供的类加载器主要有如下三种：</p>
<ol>
<li> BootstrapClassLoader（启动类加载器）：加载 ${JAVA_HOME}\lib 或 -Xbootclasspath指定的目录下的类。</li>
<li> ExtClassLoader（扩展类加载器）：加载${JAVA_HOME}\lib\ext或环境变量java.ext.dir指定目录的类。</li>
<li> AppClassLoader（应用程序类加载器）：加载用户项目指定的classpath里的类，可通过ClassLoader的getSystemClassLoader()方法获得，所以也会称为系统类加载器。</li>
</ol>
<h1 id="如何确定类的唯一性？"><a href="#如何确定类的唯一性？" class="headerlink" title="如何确定类的唯一性？"></a>如何确定类的唯一性？</h1><p>问题等同于：如何判断两个类是否是同一个类？</p>
<p>对于任何一个类，由类加载器和类本身确立其在虚拟机中的唯一性。</p>
<ul>
<li>首先类本身信息要相同，如类的全限定名。</li>
<li>其次必须是同一个类加载器加载的。</li>
</ul>
<p>相同的类，被不同的类加载器加载，会被视为不同的类。</p>
<p>为什么要这样设计？</p>
<p>涉及到安全性问题，要配合双亲委派模型的机制来解释。</p>
<h1 id="双亲委派（Parents-Delegation）模型是什么"><a href="#双亲委派（Parents-Delegation）模型是什么" class="headerlink" title="双亲委派（Parents Delegation）模型是什么?"></a>双亲委派（Parents Delegation）模型是什么?</h1><p>直接看ClassLoader的loadClass()方法的源码就很直白。</p>
<ul>
<li>除了启动类加载器，其他每个类加载器都有一个父类加载器（在ClassLoader源码中体现为类型为ClassLoader的parent成员变量，是组合关系而非继承关系）。</li>
<li>加载类时（ClassLoader的loadClass方法）会先通过父类加载器加载类，层层传递到顶层的启动类加载器（parent为null就通过native方法调用启动类加载器加载类）。</li>
<li>只有当父类加载器无法加载类，才会用当前的类加载器尝试加载类。</li>
</ul>
<p>这个逻辑是Java设计者推荐的加载方式，并不是强制约束，开发者可以自定义类加载器复写loadClass()方法来改变这一流程。</p>
<h1 id="双亲委派解决了什么问题？为何要这样设计？"><a href="#双亲委派解决了什么问题？为何要这样设计？" class="headerlink" title="双亲委派解决了什么问题？为何要这样设计？"></a>双亲委派解决了什么问题？为何要这样设计？</h1><p>是为了基础核心类加载的安全性考虑。</p>
<p>像<code>java.lang.Object</code>这种系统是存放在rt.jar中的，无论哪个类加载器要加载这个类，都会委派启动类加载器加载Object，这样可以保证在各种环境下，加载出的Object都是<code>&lt;JAVA_HOME&gt;\lib\rt.jar</code>的。</p>
<p>如果没有双亲委派机制，用户自己也定义了一个<code>java.lang.Object</code>，写了有问题的代码，放在用户项目的Classpath，那就会影响所有类的基础行为，因为Object是所有类的父类。所以也会要求不同的类加载器加载同一个类属于不同的类。</p>
<p>双亲委派模型很好的解决了各个类加载器的基础类统一问题，越基础越公共的类越是由上层的类加载器加载。同时保证了基础类的不会被随意的篡改，保证安全感。</p>
<h1 id="双亲委派会有哪些无法解决的问题？应该怎么解决？"><a href="#双亲委派会有哪些无法解决的问题？应该怎么解决？" class="headerlink" title="双亲委派会有哪些无法解决的问题？应该怎么解决？"></a>双亲委派会有哪些无法解决的问题？应该怎么解决？</h1><p>当基础类是接口，需要加载不同的接口实现类，实现类并不在当前类加载器管控的类的范围里，双亲委派的类加载顺序就要反过来，由父类加载器去请求子类加载器加载接口实现类。</p>
<p>典型的场景是SPI(Service Provider Interface)依赖注入框架。</p>
<p>SPI约定为：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p>
<p>SPI的核心类ServiceLoader是jdk的类，位于rt.jar中，由BootstrapClassLoader加载，接口实现类肯定是不能由BootstrapClassLoader加载，BootstrapClassLoader只加载jdk核心类，只能由AppClassLoader或用户自定义的ClassLoader来加载，按照双亲委派机制的话，这样就无法完成了，只能逆向请求加载。</p>
<p>解决之道就是使用<strong>线程上下文加载器（ContextClassLoader）</strong>，SPI在加载服务接口实现类时，调用Thread的getContextClassLoader()来加载实现类，可以通过Thread的setContextClassLoader(ClassLoader cl)方法来设置线程上下文类加载器，如果没有手动设置过，默认会继承父线程的上下文类加载器，如果父线程也没有设置过，则默认采用AppClassLoader</p>
<p>ServiceLoader.load()方法中要去加载实现类，需要用一个ClassLoader来加载，但是ServiceLoader是系统类，获取到的ClassLoader是BootstrapClassLoader，所以需要从一个地方获取实现类所处位置的ClassLoader，通过Thread的contextClassLoader就可以实现这个效果。</p>
<h1 id="一个类加载器明明只有一个parent，Parents-Delegation为什么被翻译为双亲委派？"><a href="#一个类加载器明明只有一个parent，Parents-Delegation为什么被翻译为双亲委派？" class="headerlink" title="一个类加载器明明只有一个parent，Parents Delegation为什么被翻译为双亲委派？"></a>一个类加载器明明只有一个parent，Parents Delegation为什么被翻译为双亲委派？</h1><p>翻译错误，以讹传讹。</p>
<p>由于除了启动类加载器其他类加载器都有parent，也就是每个非启动类加载器都有多个祖先，所以应该翻译为祖先委派更妥当</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/288949359/answer/468524259">Java 中的双亲委派的“双”怎么理解 ？ - 大宽宽的回答 - 知乎 </a></li>
</ul>
<h1 id="Class-forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？"><a href="#Class-forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？" class="headerlink" title="Class.forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？"></a>Class.forName和ClassLoader的loadClass有什么区别？动态加载一个类时，应该选用哪一个方式？</h1><p>ClassLoader在loadClass后仅将字节码加载到内存，不会对类进行初始化。</p>
<p>Class.forName()在加载类到内存后后，会对类进行初始化，即执行类的static代码块和static变量的赋值，也可以传参控制不初始化。底层也是用ClassLoader来loadClass的。</p>
<p>Class.forName()用的调用者类的类加载器加载类，也可以手动传递classLoader参数</p>
<p>如果期望一个类加载后要执行static代码块做初始化操作，应该使用Class.forName()，如jdbc里的初始化。</p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/8100376/class-forname-vs-classloader-loadclass-which-to-use-for-dynamic-loading">Class.forName() vs ClassLoader.loadClass() - which to use for dynamic loading? </a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/javazejian/article/details/73413292">深入理解Java类加载器(ClassLoader)</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
        <tag>ClassLoader</tag>
        <tag>双亲委派</tag>
        <tag>ContextClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载流程</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h1><p>类从被加载到虚拟机内存，到卸载出内存为止，常规的生命周期如下：</p>
<ol>
<li> 加载（Loading）</li>
<li> 链接（Linking）</li>
<li> 初始化（Initialization）</li>
<li> 使用（Using）</li>
<li> 卸载（Unloading）</li>
</ol>
<p>其中链接（Linking）又可以分为：</p>
<ol>
<li> 验证（Verification）</li>
<li> 准备（Preparation）</li>
<li> 解析（Resolution）</li>
</ol>
<p>加载、验证、准备、初始化，这几个顺序是确定的，解析某些情况下发生在初始化之后，这是为了支持Java语言的运行时绑定（动态绑定）。</p>
<p>参考</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》7.3节  类加载的过程</li>
</ul>
<h1 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h1><p>加载:</p>
<ol>
<li> 通过类的全限定名来获取类的二进制字节流。</li>
<li> 将字节流代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li> 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>第1条，通过类的全限定名来获取类的二进制字节流，jvm没有限制具体的实现，历史上的典型实现有：</p>
<ol>
<li> 从zip包中读取，如jar。</li>
<li> 从网络中获取。</li>
<li> 运行时动态生成，如动态代理，在java.lang.reflect.Proxy中用了ProxyGenerator.generateProxyClass为特定接口生成形式。为“*$Proxy”的代理类二进制字节流。</li>
<li> 从其他文件生成，如由文件生成class。</li>
<li> 通过数据库读取。</li>
</ol>
<p>非数组类加载类中获取类的二进制字节流的动作自定义性最强，既可以用系统提供的引导类加载器完成，也可以用用户自定义类加载器完成，开发者可以自定义一个ClassLoader并重写findClass方法来控制字节流的获取。</p>
<p>数组类的加载由虚拟机直接创建。<br>数组元素类是基本类型，虚拟机会把数组类标记为与BootstrapClassLoader关联。</p>
<h1 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h1><h2 id="类加载后为什么需要验证？"><a href="#类加载后为什么需要验证？" class="headerlink" title="类加载后为什么需要验证？"></a>类加载后为什么需要验证？</h2><p>由于类加载过程不要求class一定从Java源代码编译而来，可以通过任何途径产生，在字节码可以做到Java语法层面做不到的事情，也有可能不符合正常的Java语法规范，所以如果不对class字节流进行验证，可能会使系统遭受攻击。</p>
<h2 id="类的验证过程是怎样的？"><a href="#类的验证过程是怎样的？" class="headerlink" title="类的验证过程是怎样的？"></a>类的验证过程是怎样的？</h2><p>大致会完成以下验证动作：</p>
<ol>
<li> 文件格式验证</li>
<li> 元数据验证</li>
<li> 字节码验证</li>
<li> 符号引用验证</li>
</ol>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>例如：</p>
<ol>
<li> 是否以magic number 0xCAFEBABE开头</li>
<li> 主次版本号是否在当前虚拟机处理范围</li>
<li> 常量池中的常量是否有不被支持的的常量类型</li>
</ol>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>是对字节码描述的元数据信息进行语义分析，保证元数据信息符合Java语言规范，如：</p>
<ol>
<li> 这个类是否有父类。</li>
<li> 这个类是否继承了不允许被继承的类（被final关键字修饰的类）。</li>
<li> 如果这个类不是抽象类，是否实现了父类或接口之中的要求实现的方法。</li>
</ol>
<h4 id="类的元数据指什么？"><a href="#类的元数据指什么？" class="headerlink" title="类的元数据指什么？"></a>类的元数据指什么？</h4><p>一个class文件中的信息分为代码和元数据两部分，其中代码是指方法体里的java代码，在class文件中表现为Code属性，其他所有数据项都用于描述元数据，包括类、字段、方法定义等。</p>
<p>参考《深入理解Java虚拟机（第2版）》183页 6.3.7 属性表集合</p>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>对方法体做校验分析，通过数据流和控制流分析，确定程序语义是否是合法的、符合逻辑的，如：</p>
<ol>
<li> 保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li> 保证方法体内类型转换是有效的。</li>
</ol>
<p>通过了字节码验证，也无法保证程序就是没有错误的，无法通过程序准确的检查出代码是否在有限的时间内结束运行，即离散数学中的Halting Problem。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20081359/answer/162329455">如何通俗地解释停机问题（Halting Problem）？ - 张皓的回答 - 知乎</a></li>
</ul>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>发生在虚拟机将符号转为直接引用的时候，这个动作将在连接的第三个阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，内容如根据名能否找到类、方法字段等。</p>
<p>这阶段目的是确保解析动作的正常执行，如果无法通过符号验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethdError等。</p>
<h1 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h1><p>类的准备阶段会完成：</p>
<ol>
<li> 为类的静态变量分配内存</li>
<li> 设置变量初始值</li>
</ol>
<p>如果是常量，则编译时存放进引用其的class的常量池中，加载时存入方法区的运行时常量池。</p>
<p>类变量是指static修饰过的变量。</p>
<p>在类变量未被final修饰时，变量的初始值是数据类型的零值。</p>
<p>例如 public static int value = 123; 语句，在准备阶段赋值是0（int类型的零值）而不是123。</p>
<h1 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h1><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用（Symbolic References）<br>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li>
<li>直接引用（Direct References）<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在内存地址中。</li>
</ul>
<p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。  </p>
<p>在Java语言中符合“编译器可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们都不可能通过继承而别的方式重写其他版本，因此他们都适合在类加载阶段进行解析。<br>与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。</p>
<ul>
<li>  invokestatic：调用静态方法。</li>
<li>  invokespecial：调用实例构造器<init>方法、私有方法和父类方法。</li>
<li>  invokevirtual：调用所有的虚方法。</li>
<li>  invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li>  invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，他们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法。</p>
<p>方法调用并不等于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本(即调用哪一方法)，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作。Class文件的编译过程不包含编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h1 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h1><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 代码。</p>
<p>在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则根据程序员自己设置的变量赋值。初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。</p>
<h2 id="lt-clinit-gt-方法生成的细节"><a href="#lt-clinit-gt-方法生成的细节" class="headerlink" title="&lt;clinit&gt;() 方法生成的细节"></a><code>&lt;clinit&gt;()</code> 方法生成的细节</h2><ul>
<li><code>&lt;clinit&gt;()</code>  方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的前后顺序决定的，静态语句块中只能访问定义在它之前的变量，定义在它后面的变量，可以赋值，但是不能访问。</li>
<li><code>&lt;clinit&gt;()</code> 方法与类的构造函数 <code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code> 方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code> 方法肯定是 Object 的。</li>
<li><code>&lt;clinit&gt;()</code>方法对类或接口来说不是必需的，如果一个类中没有静态语句块也没有对变量赋值的操作，那么编译器不为这个类生成<code>&lt;clinit&gt;()</code> 方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，接口不需要首先执行父类的<code>&lt;clinit&gt;()</code> 方法。只有当用到父类中的变量时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code> 方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code> 方法在多线程中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code> 方法，其它线程被阻塞。</li>
</ul>
<p>另外就是在同一个类加载器下，<code>&lt;clinit&gt;()</code> 方法只会被执行一次，也就是说一个类型只会被初始化一次。</p>
<h2 id="类什么情况下会触发初始化"><a href="#类什么情况下会触发初始化" class="headerlink" title="类什么情况下会触发初始化?"></a>类什么情况下会触发初始化?</h2><p>以下五种情况必须对类进行初始化（加载、验证、准备自然必须在初始化之前完成）：</p>
<ol>
<li> 遇到new、putstatic、getstatic、invokestatic这几条字节指令；生成这 4 条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入到常量池的静态字段除外）以及调用一个类的静态方法的时候。</li>
<li> 被final修饰的静态字段在编译期已经被把结果存入从常量池了，会触发static的指令吗，需要调研试验一下。</li>
<li> 通过Class.forName反射调用一个类，参数中初始化选项默认为true。</li>
<li> 初始化一个类，要先触发父类的初始化；初始化一个接口时只有在真正使用到父接口的时候（如引用接口中定义的常量）才初始化。</li>
<li> 虚拟机启动时，会先初始化主类，即含有main方法的类。</li>
<li>使用jdk7的动态语言机制时，一个MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，需要初始化这些方法句柄对应的类。</li>
</ol>
<h2 id="不会触发类初始化的典型场景"><a href="#不会触发类初始化的典型场景" class="headerlink" title="不会触发类初始化的典型场景"></a>不会触发类初始化的典型场景</h2><ol>
<li> 调用父类的静态成员变量，只会执行父类的static代码块，不会执行子类的static代码块，即子类没有初始化。</li>
<li> 创建一个类的数组，不会触发数组元素类初始化（元素类的static代码块不会执行）。</li>
<li> A类只引用了B类中定义的常量（static final定义的基本类型字面量或字符串字面量的属性），不会触发该B类的初始化，因为在编译阶段通过常量池传播优化，已经将B类的常量值存储到了A类常量池中，以后A类对B类中常量的引用都转换为对A类自身常量池中的引用。</li>
</ol>
<h1 id="卸载（Unloading）"><a href="#卸载（Unloading）" class="headerlink" title="卸载（Unloading）"></a>卸载（Unloading）</h1><h2 id="类卸载时机"><a href="#类卸载时机" class="headerlink" title="类卸载时机"></a>类卸载时机</h2><p>类的卸载就从虚拟机中移除类，这个由虚拟机的垃圾回收机制决定，一般要满足下面的条件：</p>
<ol>
<li> 该类所有的实例对象都已被回收。</li>
<li> 该类的类加载器对象已被回收。</li>
<li> 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《深入理解Java虚拟机（第2版）》第7章  虚拟机类加载机制</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载流程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行时内存结构</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Java运行时数据区域有哪些？"><a href="#Java运行时数据区域有哪些？" class="headerlink" title="Java运行时数据区域有哪些？"></a>Java运行时数据区域有哪些？</h1><ol>
<li> 程序计数器</li>
<li> 虚拟机栈</li>
<li> 本地方法栈</li>
<li> 方法区</li>
<li> 堆</li>
</ol>
<p>其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的，方法区和堆是线程间共享的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824234546.png"></p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20200325265523.png"></p>
<h1 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h1><p>可以看作是当前线程所执行的字节码的行号指示器。</p>
<h2 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h2><ol>
<li> 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li> 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<h2 id="为什么必须每个线程都要单独弄一个程序计数器？"><a href="#为什么必须每个线程都要单独弄一个程序计数器？" class="headerlink" title="为什么必须每个线程都要单独弄一个程序计数器？"></a>为什么必须每个线程都要单独弄一个程序计数器？</h2><p>因为多线程是通过轮流切换占用CPU时间片来实现的，线程数量大于CPU数量时，就会有线程处于等待状态，等到可以占用CPU时间片了，会恢复线程的执行，这时就必须要回到线程等待前的指令执行位置，以便接下来继续执行后面的指令，每个线程运行的指令又不一样，所以必须对每个线程都要保存当前执行的指令位置。</p>
<h1 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h1><p>虚拟机栈对应Java中的方法执行的内存模型。</p>
<p>栈中的每个元素称为栈帧，每个方法执行的时候都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从开始执行到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824234622.png"></p>
<h2 id="局部变量表（Local-Variable-Table）"><a href="#局部变量表（Local-Variable-Table）" class="headerlink" title="局部变量表（Local Variable Table）"></a>局部变量表（Local Variable Table）</h2><p>存放方法参数和方法内的局部变量。</p>
<p>局部变量表中存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型，可能指向一个对象的起始地址的指针，也可能是指向一个对象的句柄）和returnAddress类型（指向一条字节码指令的地址）</p>
<p>局部变量表的基本存储单位是变量槽（Variable Slot），每个槽的大小是4个字节，64位的long和double会占用局部变量表的两个槽位（slot），其余数据类型占用一个槽位。</p>
<p>局部变量表所需的内存空间在编译阶段完全确定，因为数据类型的大小是确定的，方法运行期间不会改变局部变量表的大小。字节码中方法的Code属性的max_locals数据项中确定了需要分配的局部变量表的最大容量，在编译时写入。</p>
<p>局部变量表存储顺序：变量表从索引0开始，依次存放方法所属的对象引用（如果为静态方法则没有）、方法参数变量（按照顺序声明）、方法内局部变量（按照顺序声明）。对于byte、short、char这三种数据类型需要转换为int类型存储在局部变量表中。</p>
<p>一个代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IntegerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        Integer c = 3;</span><br><span class="line">        Integer d = 3;</span><br><span class="line">        Integer e = 321;</span><br><span class="line">        Integer f = 321;</span><br><span class="line">        Long g = 3L;</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == a + b);</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalVariableTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">      0     183     0  args   [Ljava/lang/String;</span><br><span class="line">      5     178     1     a   Ljava/lang/Integer;</span><br><span class="line">     10     173     2     b   Ljava/lang/Integer;</span><br><span class="line">     15     168     3     c   Ljava/lang/Integer;</span><br><span class="line">     21     162     4     d   Ljava/lang/Integer;</span><br><span class="line">     29     154     5     e   Ljava/lang/Integer;</span><br><span class="line">     37     146     6     f   Ljava/lang/Integer;</span><br><span class="line">     45     138     7     g   Ljava/lang/Long;</span><br></pre></td></tr></table></figure>

<h3 id="没有局部变量表会怎么样？"><a href="#没有局部变量表会怎么样？" class="headerlink" title="没有局部变量表会怎么样？"></a>没有局部变量表会怎么样？</h3><p>参考《深入理解Java虚拟机（第2版）》190页 6.3.7 属性表集合。</p>
<blockquote>
<p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间关系。<br>注：LocalVariableTable属性不是必须的，在javac编译时，可通过-g：none或-h：vars来取消或关闭这项信息。如果没有生成这项信息，最大的影响就是当别人引用这个方法时，所有的参数名称都将失去，IDE将会使用诸如arg0、arg1之类的占位符来代替原有的参数名，这对程序没什么影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获取参数值。</p>
</blockquote>
<h2 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h2><p>用于保存计算过程中的中间结果，作为计算的临时数据存储区。</p>
<p>大多数指令都要从这里弹出数据，执行运算后将结果再压回操作数栈。</p>
<p>操作数栈最大深度在编译时也是写入到字节码中方法的Code属性的max_stacks数据项中。</p>
<p>操作数栈的基本单位是4个字节，32位数据类型占用一个单位，64位数据类型占用两个单位，对于byte、short、char这三种数据类型需要转换为int类型再存入栈中。</p>
<p><a href="https://www.jianshu.com/p/0333144544e2">操作数栈的特点</a></p>
<p>java的指令是基于栈的指令集架构（Instruction Set Architecture，ISA），指令流中的指令大部分都是零地址指令，指令依赖操作数栈进行工作。</p>
<p>另外一种常用的指令集架构是基于寄存器的指令集。</p>
<p>基于栈的指令集  优点（反过来就是  基于寄存器的指令集  缺点）：</p>
<ol>
<li> 可移植性强，直接依赖硬件寄存器将会受到硬件条件的约束</li>
<li> 代码相对紧凑，因为指令没有操作数</li>
<li> 编译器实现更简单，因为不用考虑空间分配，栈大小固定，编译时可知</li>
</ol>
<p>基于栈的指令集  缺点（反过来就是  基于寄存器的指令集  优点）：</p>
<ol>
<li> 速度稍慢，因为栈实现在内存中，频繁访问栈意味着频繁访问内存，访问内存是比访问寄存器慢很多的</li>
<li> 指令数量多，因为访问数据频繁，入栈和出栈这两个指令就很多</li>
</ol>
<p>参考《深入理解Java虚拟机（第2版）》270页 8.4.2 <a href="https://www.jianshu.com/p/20c2b6f5fe59">基于栈的指令集与基于寄存器的指令集</a>。</p>
<h2 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h2><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p>
<p>Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>
<p>动态连接是一个将符号引用解析为直接引用的过程。当java虚拟机执行字节码时，如果它遇到一个操作码，这个操作码第一次使用一个指向另一个类的符号引用，那么虚拟机就必须解析这个符号引用。<br>在解析时，虚拟机执行两个基本任务：</p>
<ol>
<li>查找被引用的类（如果必要的话就装载它）。</li>
<li>将符号引用替换为直接引用，这样当它以后再次遇到相同的引用时，它就可以立即使用这个直接引用，而不必花时间再次解析这个符号引用了。</li>
</ol>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》8.2.3 动态链接</li>
</ul>
<h2 id="方法返回地址（Return-Address）"><a href="#方法返回地址（Return-Address）" class="headerlink" title="方法返回地址（Return Address）"></a>方法返回地址（Return Address）</h2><p>方法退出的过程实际上等同于把当前栈帧出栈。</p>
<p>因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令</p>
<p>参考《深入理解Java虚拟机（第2版）》 8.2.4 方法返回地址</p>
<h2 id="虚拟机栈会有什么潜在的问题？"><a href="#虚拟机栈会有什么潜在的问题？" class="headerlink" title="虚拟机栈会有什么潜在的问题？"></a>虚拟机栈会有什么潜在的问题？</h2><ul>
<li>某个线程中方法嵌套执行的太多了，超过虚拟机栈允许的最大深度，将会抛出StackOverflow（栈溢出）异常。<ul>
<li>一个典型的场景是递归方法，递归深度过大，会引起栈溢出，某些语言下可以采用尾递归优化。</li>
</ul>
</li>
<li>当线程不断增多，不停的申请虚拟机栈，内存可能不够用了，会引发OutOfMemoryError异常，即内存溢出。<ul>
<li>一个典型的场景是，程序中的同时运行的线程不停的增多。</li>
</ul>
</li>
</ul>
<h1 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h1><p>虚拟机栈对应的是java方法的执行过程，本地方法栈对应native方法的执行过程。</p>
<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p>创建一个对象实例便存储在堆，所有线程共享。</p>
<p>物理上可以不连续，逻辑上是连续的即可。</p>
<p>是虚拟机管理的内存区域最大的一块，是虚拟机垃圾回收的主要区域。</p>
<p>现代垃圾回收收集器基本都采用分代回收，堆被划分为新生代和老年代，新生代又分为Eden区、From Survivor区、To Survivor区。划分特定区域是为了更高效的进行垃圾回收。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210824235449.png"></p>
<h2 id="对象都是在堆上分配的吗？"><a href="#对象都是在堆上分配的吗？" class="headerlink" title="对象都是在堆上分配的吗？"></a>对象都是在堆上分配的吗？</h2><p>创建新对象实例也可能分配在TLAB和栈上。</p>
<p>对象不在堆上分配主要的原因还是堆是共享的，在堆上分配有锁的开销。无论是TLAB还是栈都是线程私有的，私有即避免了竞争（当然也可能产生额外的问题例如可见性问题），这是典型的用空间换效率的做法。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/yangzl2008/java/article/details/43202969">Java中的逃逸分析和TLAB以及Java对象分配</a></li>
<li><a href="https://hesey.wang/2011/07/object-allocation-on-non-heap.html">对象都是在堆上分配的吗</a></li>
</ul>
<h1 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h1><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>各线程共享的区域。</p>
<h2 id="方法区里的东西放在堆里不行吗？"><a href="#方法区里的东西放在堆里不行吗？" class="headerlink" title="方法区里的东西放在堆里不行吗？"></a>方法区里的东西放在堆里不行吗？</h2><p>因为方法区存储的类信息、常量等数据都是生命周期比较长的，要放在堆，也只能放在老年代，但可能生命周期比老年代的对象还要长。</p>
<p>故而单独开辟一个空间，单独管理，提高垃圾回收的效率。</p>
<h2 id="方法区什么时候垃圾回收？"><a href="#方法区什么时候垃圾回收？" class="headerlink" title="方法区什么时候垃圾回收？"></a>方法区什么时候垃圾回收？</h2><p>回收废弃常量和无用的类。</p>
<p>无用类三条判断方法：</p>
<ol>
<li> 堆中没有该类的实例</li>
<li> 该类的类加载器已被回收</li>
<li> 没有任何地方引用Class对象，也没有反射调用</li>
</ol>
<p>这也是类卸载的判断。</p>
<p>参考《深入理解Java虚拟机》3.2.5 回收方法区 68页。</p>
<p>大量使用反射，动态代理，cglib等字节码框架都需要类卸载机制，保证方法区不溢出。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>《深入理解 Java 虚拟机 第三版》2.2.7 小节 关于 Java 直接内存的描述。</p>
<blockquote>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。  </p>
<p>在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。  </p>
<p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 <code>-Xmx</code> 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>内存结构</tag>
        <tag>程序计数器</tag>
        <tag>虚拟机栈</tag>
        <tag>局部变量表</tag>
        <tag>操作数栈</tag>
        <tag>方法区</tag>
        <tag>内存堆</tag>
        <tag>直接内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java静态分派、动态分派</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</url>
    <content><![CDATA[<p>静态类型：变量被声明时的类型；例如，Animal a = new Dog(), 静态类型为Animal, 实际类型为Dog</p>
<p>实际类型：变量所引用的对象的真实类型</p>
<p>重载方法是静态分派，即编译时多态</p>
<p>重写方法是动态分派，即运行时多态</p>
<h1 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h1><p>方法的接收者：一个方法所属的对象</p>
<p>宗量：方法的接收者和方法的参数，只有这两种宗量</p>
<p>单分派：根据一个宗量进行对方法的选择</p>
<p>多分派：根据多于一个的宗量对方法进行选择</p>
<p>单分派和多分派取决于宗量,  方法调用者和方法参数都是宗量.</p>
<p>静态分派的方法调用：首先确定调用者的静态类型是什么,然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个, 需要根据这两个宗量来编译, 所以是静态多分派(多个宗量确定).</p>
<p>动态分派的方法调用：在运行期间,虚拟机会根据调用者的实际类型调用对应的方法, 只需根据这一个宗量就可以确定要调用的方法,所以是动态单分派(一个宗量)</p>
<p>到目前为止，Java 语言还是一门 “静态多分派、动态单分派” 的语言，也就是说在执行静态分派时是根据多个宗量判断调用哪个方法的，因为在静态分派时要根据不同的静态类型和不同的方法描述符选择目标方法，在动态分派的时候，是根据单宗量选择目标方法的，因为在运行期，方法的描述符已经确定好，invokevirtual 字节码指令根据变量的实际类型选择目标方法。</p>
<p>方法的描述符：方法参数类型+返回值类型</p>
<h1 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h1> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classStaticDispatch &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Humanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Manguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,man&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Womanguy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,woman&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123; </span><br><span class="line">        Humanman=newMan(); </span><br><span class="line">        Humanwoman=newWoman(); </span><br><span class="line">        StaticDispatchdispatch=newStaticDispatch(); </span><br><span class="line">        dispatch.sayHello(man); </span><br><span class="line">        dispatch.sayHello(woman); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>静态类型：是指对象 man 的 Human 类型， 静态类型本身是不会发送变化的，只有在使用时才会发送变化，静态类型在编译期间就可以确定一个变量的静态类型 </p>
<p>实际类型：是指对象 man 的 Man 类型，实际类型在编译期间是不可确定的，只有在运行期才可确定 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化 </span></span><br><span class="line">Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">man = <span class="keyword">new</span> Woman(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态类型变化 </span></span><br><span class="line">dispatch.sayHello((Man) man); </span><br><span class="line">dispatch.sayHello((Woman) man); </span><br></pre></td></tr></table></figure>

<p>所以第一段代码中，方法接收者是 StaticDispatch 对象，虽然两个变量的实际类型不同，但是静态类型是相同的都是 Human，虚拟机（准确的说是编译器）在实现重载时是通过参数的静态类型而不是实际类型做出判定的，并且在编译阶段，变量的静态类型是可以确定的，所以编译器会根据变量的静态类型决定使用哪个重载方法。 </p>
<p>所有依赖静态类型定位目标方法的分派动作称为静态分派，静态分派典型的应用就是方法的重载。静态分派发生在编译阶段，所以方法的静态分派动作是由编译器执行的。 </p>
<h1 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, man&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello, woman&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/picportal/pic/raw/master/img/20200325235523.png"></p>
<p>从上图中，我们可以看到 main() 方法的字节码指令执行过程：</p>
<ul>
<li>0 ~ 7 句是调用 Man 类的实例构造器创建一个 Man 类的对象，并将对象的引用压入到局部变量表的第 1 个 Slot 中</li>
<li>8 ~ 15 句是调用 Woman 类的实例构造器创建一个 Woman 类的对象，并将对象的引用压入到局部变量表的第 2 个 Slot 中</li>
<li>16 ~ 17 句是将第 1 个 Slot 中的变量（也就是 man）加载到局部变量表中，并调用 sayHello() 方法，关键的就是第 17 句指令 invokevirtual</li>
</ul>
<p>虽然第 17 句指令调用的常量池中的 Human.sayHello() 方法，但是最终执行的却是 Man.sayHello() 方法，这就要从 invokevirtual 指令的多态查找说起，invokevirtual 的查找过程如下所示：</p>
<ul>
<li>找到操作数栈顶的引用所指的对象的实际类型，记做 C</li>
<li>在类型 C 中查找与常量中的描述符和简单名称相同的方法，如果找到则进行访问权限的判断，如果通过则返回这个方法的直接引用，查找结束；如果权限不通过，则返回 java.lang.IllegalAccessError 的异常</li>
<li>如果在 C 中没有找到描述符和简单名称都符合的方法，则按照继承关系从下往上依次在 C 的父类中进行查找和验证过程</li>
<li>如果最终还是没有找到该方法，则抛出 java.lang.AbstractMethodError 的异常</li>
</ul>
<p>在上述 invokespecial 查找方法的过程中，最重要的就是第一步，根据对象的引用确定对象的实际类型，这个方法重写的本质。如上所述，在运行期内，根据对象的实际类型确定方法执行版本的分派过程叫做动态分派。</p>
<h1 id="如何理解Java是静态多分派、动态单分派？"><a href="#如何理解Java是静态多分派、动态单分派？" class="headerlink" title="如何理解Java是静态多分派、动态单分派？"></a>如何理解Java是静态多分派、动态单分派？</h1><p>编译时期确定方法有两点依据：</p>
<ol>
<li>调用方法的静态类型</li>
<li>方法的参数</li>
</ol>
<p>所以说是静态多分派。</p>
<p>运行时期再确定方法只有一点依据,就是调用方法的实际类型,所以说是动态单分派。</p>
<p>所以最后实际的方法调用是编译和运行的结合,即调用方法的实际类型和参数(运行时期直接引用会根据调用方法的实际类型确定,编译时期调用方法的静态类型只不过是虚引用),按书上说法,在编译时期,方法名和参数就被确定了,运行时只需要确定调用者即可;所以方法选择上,编译时期缩小了范围,运行时期确定了具体的方法。</p>
<p>对于静态分派（重载），肯定会依赖接收者的静态类型与参数的静态类型（参数肯定存在，同名无参的方法只会有一个，不存在分派）。</p>
<p>对于动态分派（重写），虚拟机只会根据接收者的实际类型选择，而不会理睬参数的实际类型。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li>深入理解Java虚拟机（第2版）  第8章  虚拟机字节码执行引擎 8.3.2 分派</li>
<li><a href="https://www.jianshu.com/p/58f876f2e8b8">虚拟机字节码执行引擎（读书笔记）</a></li>
<li><a href="https://www.zhihu.com/question/28462483/answer/398040520">如何理解java是一门静态多分派且动态单分派的语言？</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>静态分派</tag>
        <tag>动态分派</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.finalize()</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Object.finalize()/</url>
    <content><![CDATA[<h1 id="Object的finalize-方法什么时候被执行？"><a href="#Object的finalize-方法什么时候被执行？" class="headerlink" title="Object的finalize()方法什么时候被执行？"></a>Object的finalize()方法什么时候被执行？</h1><p>当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：</p>
<p>如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记。</p>
<p>GC会再判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。</p>
<p>如果对象覆盖finalize()方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalize()方法，但不承诺等待其运行结束。</p>
<p>执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<h1 id="Object-finalize-设计目的？"><a href="#Object-finalize-设计目的？" class="headerlink" title="Object.finalize()设计目的？"></a>Object.finalize()设计目的？</h1><p>f对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。</p>
<h1 id="Object-finalize-使用场景"><a href="#Object-finalize-使用场景" class="headerlink" title="Object.finalize()使用场景"></a>Object.finalize()使用场景</h1><p>由于发生垃圾回收就会调用finalize()，所以它可以作为垃圾回收的监听回调。</p>
<p>在Android framework源码中BinderInternal实现了gc监听的功能，ActivityThread在gc发生时，如果当前内存不足时，则清理一些不必要的activity以释放内存。</p>
<p>再比如你调用了一些native的方法，可以要在finalize()里去调用C的释放函数。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/qq_36761831/article/details/81211540">Java中 System.gc() 调用垃圾收集器与 finalize() 函数
</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1082673">是时候忘掉finalize方法了</a></li>
<li><a href="https://www.nowcoder.com/questionTerminal/d8eab06913084e42b515633604eef7cd">finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</a></li>
<li>《深入理解Java虚拟机》</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Object.finalize()</tag>
      </tags>
  </entry>
  <entry>
    <title>TLAB（线程本地分配缓存 ）</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/TLAB%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E9%85%8D%E7%BC%93%E5%AD%98%20%EF%BC%89/</url>
    <content><![CDATA[<h1 id="TLAB全称"><a href="#TLAB全称" class="headerlink" title="TLAB全称"></a>TLAB全称</h1><p>Thread Local Allocation Buffer</p>
<p>线程本地分配缓存</p>
<h1 id="TLAB作用"><a href="#TLAB作用" class="headerlink" title="TLAB作用"></a>TLAB作用</h1><p>线程私有的内存分配区域，默认占Eden区1%，是为了避免多线程间在堆上分配内存时发生指针碰撞而降低性能。</p>
<p>Java中很多对象都是小对象，并且即用即丢，小对象分配在TLAB上，没有锁的开销，效率比分配在堆上要高。</p>
<h1 id="Java对象分配的过程"><a href="#Java对象分配的过程" class="headerlink" title="Java对象分配的过程"></a>Java对象分配的过程</h1><ol>
<li>编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.</li>
<li>如果tlab_top + size &lt;= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.</li>
<li>重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4.</li>
<li>在Eden区加锁（这个区是多线程共享的），如果eden_top + size &lt;= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5.</li>
<li>执行一次Young GC（minor collection）。</li>
<li>经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。</li>
</ol>
<p>对象不在堆上分配主要的原因还是堆是共享的，在堆上分配有锁的开销。无论是TLAB还是栈都是线程私有的，私有即避免了竞争（当然也可能产生额外的问题例如可见性问题），这是典型的用空间换效率的做法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/yangzl2008/java/article/details/43202969">Java中的逃逸分析和TLAB以及Java对象分配</a></li>
<li><a href="https://www.jianshu.com/p/8be816cbb5ed">浅析java中的TLAB
</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>TLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>句柄、直接指针</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="句柄是什么？"><a href="#句柄是什么？" class="headerlink" title="句柄是什么？"></a>句柄是什么？</h1><p>指针的指针。</p>
<p>jvm中内存里的对象都有一个指针指向对象的开始地址，句柄就是指向对象的指针。</p>
<h1 id="句柄解决了什么问题"><a href="#句柄解决了什么问题" class="headerlink" title="句柄解决了什么问题?"></a>句柄解决了什么问题?</h1><p>对实际的对象资源做了一层代理，屏蔽细节，避免了直接操控资源可能的危险。</p>
<p>弄了句柄，对象实际位置在内存中可以随意变化，比如标记整理垃圾回收后对象被移动到其他地方。</p>
<p>虚拟内存机制，可能会将已经载入内存的数据换到外存硬盘上，这样对象的地址就会变动，其他地方引用这块被换走的地址也要更新，如果使用这块数据的地方引用的是句柄，这样实际数据在内存的位置可以随意变化，使用数据的地方还是引用固定的地址，不用更新。</p>
<p>Windows系统中有许多内核对象（这里的对象不完全等价于”面向对象程序设计”一词中的”对象”，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个”对象”的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p>
<ol>
<li><p>暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p>
</li>
<li><p>操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p>
</li>
</ol>
<p>所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p>
<p>在Windows系统中，这个编号就叫做”句柄”。</p>
<p>参考：<br><a href="https://www.cnblogs.com/klb561/p/10555571.html">句柄的概念</a></p>
<h1 id="为什么叫句柄这个名字？"><a href="#为什么叫句柄这个名字？" class="headerlink" title="为什么叫句柄这个名字？"></a>为什么叫句柄这个名字？</h1><p>从名字上说，handle是指中间媒介，例如门把手是door handle，刀柄是knife handle。</p>
<p>所以文件句柄file handle以即其他资源句柄，也是这个中间媒介的意思，通过这个媒介操作资源。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/27656256/answer/943130123">句柄是什么？ - 黄兢成的回答 - 知乎 解释句柄这个词语的表面含义</a></li>
</ul>
<h1 id="JVM对象访问定位"><a href="#JVM对象访问定位" class="headerlink" title="JVM对象访问定位"></a>JVM对象访问定位</h1><p>JVM通过栈上的reference类型数据来操作堆上的具体对象。</p>
<p>由于reference数据只是规定了一个指向对象的引用，没有定义如何去定位访问对象的具体位置。</p>
<p>主流的实现方式有两种：</p>
<ul>
<li>句柄<br>  在堆中划分句柄池，reference存储对象的句柄地址，句柄包含对象实例数据和类型数据的各自具体地址信息。<ul>
<li>好处：reference中的数据是稳定的句柄地址 对象被移动只会改变句柄中的信息 不会改变句柄的地址 reference不需要变化。</li>
<li>坏处：增加了指针定位的开销。</li>
</ul>
</li>
<li>直接指针<br>  栈上reference类型数据槽中直接存储堆对象的地址。<ul>
<li>好处：直接访问对象 减少指针定位开销。</li>
<li>坏处：当对象内存地址发生变化 reference中数据也需要调整。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》 2.3.3 对象的访问定位 48页</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>句柄</tag>
        <tag>直接指针</tag>
      </tags>
  </entry>
  <entry>
    <title>强引用、软引用、弱引用、虚引用</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h1><p>正常的赋值语句生成的引用，只要强引用存在，与GC Roots对象有引用链，就不会被垃圾回收。</p>
<h1 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h1><p>虚拟机内存不够用时才会尝试回收软引用链接的对象，此次回收后还是不够用，才会抛出内存溢出的异常。</p>
<h1 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h1><p>发生垃圾回收时，不论当前内存是否足够，都会回收弱引用链接的对象。</p>
<h2 id="弱引用应用场景"><a href="#弱引用应用场景" class="headerlink" title="弱引用应用场景"></a>弱引用应用场景</h2><p>官方文档：</p>
<blockquote>
<p>假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后垃圾收集器会把这个弱可达对象标记为可终结(finalizable)的，这样它们随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所登记到的引用队列(Reference Queue)中。</p>
</blockquote>
<p>实际上，WeakReference类有两个构造函数：</p>
<ul>
<li>WeakReference(T referent) //创建一个指向给定对象的弱引用</li>
<li>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) //创建一个指向给定对象并且登记到给定引用队列的弱引用</li>
</ul>
<p>我们可以看到第二个构造方法中提供了一个ReferenceQueue类型的参数，通过提供这个参数，我们便把创建的弱引用对象注册到了一个引用队列上，这样当它被垃圾回收器清除时，就会把它送入这个引用队列中，我们便可以对这些被清除的弱引用对象进行统一管理。</p>
<p>参考：<a href="https://www.jianshu.com/p/dac0958778e0">WeakReference才是LeakCanary真正的核心</a></p>
<h1 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h1><p>在虚引用链接的对象被垃圾回收后，虚引用会受到虚拟机的通知，并不能通过虚引用直接获得对象的实例，虚引用也不会影响对象的生命周期。</p>
<h2 id="虚引用应用场景"><a href="#虚引用应用场景" class="headerlink" title="虚引用应用场景"></a>虚引用应用场景</h2><p>DirectByteBuffer中对堆外内存的释放，通过虚引用监听DirectByteBuffer对象被GC回收后，再调用释放堆外内存的方法。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>StrongReference</tag>
        <tag>SoftReference</tag>
        <tag>WeakReference</tag>
        <tag>PhantomReference</tag>
      </tags>
  </entry>
  <entry>
    <title>Android集合类-ArrayMap原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-ArrayMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="ArrayMap、SparseArray、HashMap的区别？"><a href="#ArrayMap、SparseArray、HashMap的区别？" class="headerlink" title="ArrayMap、SparseArray、HashMap的区别？"></a>ArrayMap、SparseArray、HashMap的区别？</h1><ul>
<li><p>数据结构</p>
<ul>
<li>  ArrayMap和SparseArray采用的都是两个数组，Android专门针对内存优化而设计的</li>
<li>  HashMap采用的是数据+链表+红黑树</li>
</ul>
</li>
<li><p>内存优化</p>
<ul>
<li>  ArrayMap比HashMap更节省内存，综合性能方面在数据量不大的情况下，推荐使用ArrayMap；</li>
<li>  Hash需要创建一个额外对象来保存每一个放入map的entry，且容量的利用率比ArrayMap低，整体更消耗内存</li>
<li>  SparseArray比ArrayMap节省1/3的内存，但SparseArray只能用于key为int类型的Map，所以int类型的Map数据推荐使用SparseArray；</li>
</ul>
</li>
<li><p>性能方面：</p>
<ul>
<li>  ArrayMap查找时间复杂度O(logN)；ArrayMap增加、删除操作需要移动成员，速度相比较慢，对于个数小于1000的情况下，性能基本没有明显差异</li>
<li>  HashMap查找、修改的时间复杂度为O(1)；</li>
<li>  SparseArray适合频繁删除和插入来回执行的场景，性能比较好</li>
</ul>
</li>
<li><p>缓存机制</p>
<ul>
<li>  ArrayMap针对容量为4和8的对象进行缓存，可避免频繁创建对象而分配内存与GC操作，这两个缓存池大小的上限为10个，防止缓存池无限增大；</li>
<li>  HashMap没有缓存机制</li>
<li>  SparseArray有延迟回收机制，提供删除效率，同时减少数组成员来回拷贝的次数</li>
</ul>
</li>
<li><p>扩容机制</p>
<ul>
<li>  ArrayMap是在容量满的时机触发容量扩大至原来的1.5倍，在容量不足1/3时触发内存收缩至原来的0.5倍，更节省的内存扩容机制</li>
<li>  HashMap是在容量的0.75倍时触发容量扩大至原来的2倍，且没有内存收缩机制。HashMap扩容过程有hash重建，相对耗时。所以能大致知道数据量，可指定创建指定容量的对象，能减少性能浪费。</li>
</ul>
</li>
<li><p>并发问题</p>
<ul>
<li>  ArrayMap是非线程安全的类，大量方法中通过对mSize判断是否发生并发，来决定抛出异常。但没有覆盖到所有并发场景，比如大小没有改变而成员内容改变的情况就没有覆盖</li>
<li>  HashMap是在每次增加、删除、清空操作的过程将modCount加1，在关键方法内进入时记录当前mCount，执行完核心逻辑后，再检测mCount是否被其他线程修改，来决定抛出异常。这一点的处理比ArrayMap更有全面。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>HashMap的查找和插入时间复杂度为O(1)的代价是牺牲大量的内存来实现的。</li>
<li>而SparseArray和ArrayMap性能略逊于HashMap，但更节省内存。</li>
<li>SparseArray的key是int类型，ArrayMap的key是任意类型。</li>
<li>SparseArray删除元素是延迟删除，减少数组拷贝的频次。</li>
<li>ArrayMap有对容量4和8的缓存机制，避免频繁的内存分配和垃圾回收。</li>
</ul>
<p>Android中的小数据量的哈希表，Google推荐数据量小于1000使用ArrayMap，大于1000使用HashMap。</p>
<h1 id="为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？"><a href="#为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？" class="headerlink" title="为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？"></a>为什么ArrayMap数据量大了性能不如HashMap？数据量小了性能比HashMap好？</h1><p>ArrayMap中的 mHashs 数组以升序的方式保存了所有的 hash code，在查找数据时则通过二分查找 hash code 所对应的 index。这也是它的 get() 比 HashMap 慢的根据原因所在。</p>
<p>插入、删除需要移动数组的元素，数据多了的话，速度也相对较慢，数据少了影响较小。</p>
<h1 id="ArrayMap底层存储结构是怎样的？"><a href="#ArrayMap底层存储结构是怎样的？" class="headerlink" title="ArrayMap底层存储结构是怎样的？"></a>ArrayMap底层存储结构是怎样的？</h1><ul>
<li>  mHashes是一个记录所有key的hashcode值组成的数组，是从小到大的排序方式；</li>
<li>  mArray是一个记录着key-value键值对所组成的数组，是mHashes大小的2倍；</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214641.png"></p>
<p>为什么mArray的大小是mHahses的2倍？</p>
<p>因为mArray存储了key和value，所以需要2倍于mHashes的容量。</p>
<p>mHashes 在 index 处存储了 key 的 hash code，而 mArray 则在 hash code 的 index&lt;&lt;1 处存储 key，在 index&lt;&lt;1 + 1 处存储 value。简单点说就是偶数处存储 key，相邻奇数处存储 value。</p>
<h1 id="多个key的hashCode发生冲突时是怎么存储数据的？"><a href="#多个key的hashCode发生冲突时是怎么存储数据的？" class="headerlink" title="多个key的hashCode发生冲突时是怎么存储数据的？"></a>多个key的hashCode发生冲突时是怎么存储数据的？</h1><p>HashMap用的是拉链法把同一个hashCode元素放在一个桶中</p>
<p>ArrayMap用的是开放定址法之线性探测法</p>
<p>相同的hashCode存储在mHashes数组中相邻的位置，把原来数组中该位置之后的元素全部后移一位</p>
<p>例子：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214729.png"></p>
<p>index == 0 时 和 index == 1时的 hash code 是一样的，说明 key1 与 key2 的 hash code 是一样的，也就是存在 hash 冲突了。那么，如上，这里的解决办法就是 hash code 存储了 2 份，而 key-value 分别存储一份。</p>
<h1 id="ArrayMap-indexOf-key-hash-原理"><a href="#ArrayMap-indexOf-key-hash-原理" class="headerlink" title="ArrayMap.indexOf(key, hash)原理?"></a>ArrayMap.indexOf(key, hash)原理?</h1><p>源码的注释已经说的很明白</p>
<ol>
<li> 在mHashes中二分查找hash的索引</li>
<li> 如果mHashes中没找到hash，说明不存在这个元素，返回二分查找得出的应该插入的位置，以保障mHashes存储的hash保持升序</li>
<li> 如果mHashes中找到了hash，有两种情况：找到元素了  或  存在哈希冲突，这一点通过mArray存储的key和方法传入的key是否相等来判断，如果相等说明找到元素了，不相等则没有找到，没有找到要返回待插入的位置</li>
<li> 由于相同的hash在mHashes中存储在相邻的位置，如果mHashes中找到了hash，但是mArray中存储的key不相等，则往右往左分别寻找相同hash对应的mArray中的key是否相等</li>
</ol>
<h1 id="ArrayMap-put-key-value-原理"><a href="#ArrayMap-put-key-value-原理" class="headerlink" title="ArrayMap.put(key, value)原理?"></a>ArrayMap.put(key, value)原理?</h1><ol>
<li> 求key的hashCode</li>
<li> 通过indexOf(key, hash)计算新的hash应该插入mHashes数组中什么位置</li>
<li> 如果index &gt; 0 说明之前这个key已经存了值，替换为新的value就结束put流程</li>
<li> index &lt; 0 说明mHashes里不存在这个hash，index为待插入的位置</li>
<li> 如果容量不够了，就申请新的数组，容量为之前的1.5倍，把旧数组的值全部拷贝到新的数组</li>
<li> index后面的元素全部后移一位，给index的位置腾出空间</li>
<li> 存储hash到mHashes[index]，存储key、value到mArray的index * 2和index * 2 + 1的位置</li>
</ol>
<h1 id="为什么通过key求得index后要左移1位？"><a href="#为什么通过key求得index后要左移1位？" class="headerlink" title="为什么通过key求得index后要左移1位？"></a>为什么通过key求得index后要左移1位？</h1><p>因为这个index是mHashes的索引，mHashes数组长度是mArray数组长度的一半，索引乘以2，就是作为mArray的索引</p>
<h1 id="ArrayMap-remove-原理？"><a href="#ArrayMap-remove-原理？" class="headerlink" title="ArrayMap.remove()原理？"></a>ArrayMap.remove()原理？</h1><p>一般情况下删除一个数据，只需要将 index 后面的数据都往 index 方向移一位，然后删除末位数即可。</p>
<p>如果再满足缩容的条件就进行缩容，条件是mHashs长度大于 2 * BASE_SIZE 且  实际元素个数小于mHashs长度的1/3，就把容量压缩为实际元素大小的1.5倍</p>
<p>为什么是1.5倍，这样保证不会频繁的创建数组，也不会浪费太多的空间，平衡了性能</p>
<h1 id="mHashes里存的hashcode为什么要升序？"><a href="#mHashes里存的hashcode为什么要升序？" class="headerlink" title="mHashes里存的hashcode为什么要升序？"></a>mHashes里存的hashcode为什么要升序？</h1><p>因为要二分查找获取插入位置。</p>
<h1 id="为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？"><a href="#为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？" class="headerlink" title="为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？"></a>为什么mHashes中查找元素要二分查找？不能用HashMap的索引定位法吗？</h1><h2 id="HashMap是怎么计算索引位置的？"><a href="#HashMap是怎么计算索引位置的？" class="headerlink" title="HashMap是怎么计算索引位置的？"></a>HashMap是怎么计算索引位置的？</h2><p>HashMap是直接用数组大小与key的hashCode做与操作得到数组索引。</p>
<h2 id="为什么ArrayMap不按照HashMap计算索引的方式来做呢？"><a href="#为什么ArrayMap不按照HashMap计算索引的方式来做呢？" class="headerlink" title="为什么ArrayMap不按照HashMap计算索引的方式来做呢？"></a>为什么ArrayMap不按照HashMap计算索引的方式来做呢？</h2><p>因为扩容后会重新hash，让元素分布的更均匀以较少哈希冲突，重新hash过程比较耗时，实现起来也比较复杂。</p>
<p>数据量小的情况下，用二分查找足够应付。</p>
<h1 id="ArrayMap为什么要设计一个缓存机制？"><a href="#ArrayMap为什么要设计一个缓存机制？" class="headerlink" title="ArrayMap为什么要设计一个缓存机制？"></a>ArrayMap为什么要设计一个缓存机制？</h1><p>很多场景可能起初都是数据很少，为了减少频繁地创建和回收数组，特意设计了两个缓存池，分别缓存大小为4和8的ArrayMap对象，这两个长度的Map根据统计信息应该用的很多。</p>
<h1 id="ArrayMap缓存机制实现原理？"><a href="#ArrayMap缓存机制实现原理？" class="headerlink" title="ArrayMap缓存机制实现原理？"></a>ArrayMap缓存机制实现原理？</h1><p>freeArrays(hashes, array, size) 会把hashes数组和array数组用链表的形式存储下来，头结点用mBaseCache、mTwiceBaseCache存储，分别表示数组长度为4和8的缓存<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214932.png"></p>
<p>freeArrays()触发时机:</p>
<ul>
<li>  当执行removeAt()移除最后一个元素的情况</li>
<li>  当执行clear()清理的情况</li>
<li>  当执行ensureCapacity()在当前容量小于预期容量的情况下, 先执行allocArrays,再执行freeArrays</li>
<li>  当执行put()在容量满的情况下, 先执行allocArrays, 再执行freeArrays</li>
</ul>
<p>当allocArrays分配内存时，如果所需要分配的大小等于4或者8，且相对应的缓冲池不为空，则会从相应缓存池中取出缓存的mArray和mHashes。<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214947.png"></p>
<p>这里需要注意的是只有大小为4或者8的内存分配才有可能从缓存池取数据，因为freeArrays过程放入缓存池的大小只有4或8，对于其他大小的内存分配则需要创建新的数组。</p>
<p>优化小技巧，对于分配数据不超过8的对象的情况下，一定要创建4或者8大小，否则浪费了缓存机制。比如ArrayMap[7]就是不友好的写法，建议写成ArrayMap[8]。</p>
<p>两个缓存池大小上限为10个。</p>
<h1 id="扩容的条件？"><a href="#扩容的条件？" class="headerlink" title="扩容的条件？"></a>扩容的条件？</h1><p>mSize是实际存储的元素的个数</p>
<p>当mSize大于或等于mHashes数组长度时需要扩容，新容量的规则如下：</p>
<ul>
<li>  当map个数满足条件 osize&lt;4时，则扩容后的大小为4；</li>
<li>  当map个数满足条件 4&lt;= osize &lt; 8时，则扩容后的大小为8；</li>
<li>  当map个数满足条件 osize&gt;=8时，则扩容后的大小为原来的1.5倍；</li>
</ul>
<h1 id="缩容的条件？"><a href="#缩容的条件？" class="headerlink" title="缩容的条件？"></a>缩容的条件？</h1><p>当数组内存的大小大于8，且已存储数据的个数mSize小于数组空间大小的1/3的情况下，需要收紧数据的内容容量，分配新的数组，老的内存靠虚拟机自动回收。</p>
<ul>
<li>  如果mSize&lt;=8，则设置新大小为8；</li>
<li>  如果mSize&gt; 8，则设置新大小为mSize的1.5倍。</li>
</ul>
<p>也就是说在数据较大的情况下，当内存使用量不足1/3的情况下，内存数组会收紧50%</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a></li>
<li><a href="https://juejin.im/post/6844903762470060045">ArrayMap详解及源码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>ArrayMap</tag>
        <tag>SparseArray</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Android集合类-SparseArray原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Android%E9%9B%86%E5%90%88%E7%B1%BB-SparseArray%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="稀疏表是什么？"><a href="#稀疏表是什么？" class="headerlink" title="稀疏表是什么？"></a>稀疏表是什么？</h1><p>key为整数的哈希表</p>
<h1 id="稀疏表特点"><a href="#稀疏表特点" class="headerlink" title="稀疏表特点"></a>稀疏表特点</h1><ul>
<li>Key为int类型的哈希表，避免了Integer自动装箱。</li>
<li>底层用数组存储元素，一个数组存储key，一个数组存储value，key是有序的，通过二分查找来定位元素。</li>
<li>插入元素会移动数组，remove的时候只设置了一个removed标记位，避免频繁移动数组元素。</li>
<li>数据量大的时候，复制数组时间就长了，查找时间也长了。</li>
<li>好处是不需要额外的结构体，比较节约空间，数据量较小情况下访问想效率比较高。</li>
</ul>
<h1 id="SparseArray相比HashMap解决了什么？"><a href="#SparseArray相比HashMap解决了什么？" class="headerlink" title="SparseArray相比HashMap解决了什么？"></a>SparseArray相比HashMap解决了什么？</h1><p>优点：</p>
<ol>
<li> 避免了基本数据类型的装箱操作</li>
<li> 不需要额外的结构体，单个元素的存储成本更低</li>
<li> 数据量小的情况下，随机访问的效率更高，因为不需要额外复杂操作、删除元素也是延迟的</li>
</ol>
<p>缺点：</p>
<ol>
<li> 插入操作需要复制数组，增删效率降低</li>
<li> 数据量巨大时，复制数组成本巨大，gc()成本也巨大</li>
<li> 数据量巨大时，查询效率也会明显下降，因为需要二分查找，而不是直接哈希命中</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/6844903442901630983">SparseArray 的使用及实现原理</a></li>
</ul>
<h1 id="SparseArray适用场景？"><a href="#SparseArray适用场景？" class="headerlink" title="SparseArray适用场景？"></a>SparseArray适用场景？</h1><p>原则：</p>
<ol>
<li> 数据量不大（千这个数量级以内）。</li>
<li> 空间比时间重要，例如移动端对内存使用量敏感。</li>
<li> 需要使用Map，且key为int类型。</li>
</ol>
<p>例如：<br>如果有一个ViewPager的每个页面都有一个图表，并且图表的点有上千个，而ViewPager会缓存左右两页，至少要开3个图表，用HashMap明显占用内存更多，容易引发内存溢出，而且自动装箱的消耗更多，用SparseArray肯定更快，内存占用更小。</p>
<h1 id="SparseArray-put-int-key-E-value-原理？"><a href="#SparseArray-put-int-key-E-value-原理？" class="headerlink" title="SparseArray.put(int key, E value)原理？"></a>SparseArray.put(int key, E value)原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a mapping from the specified key to the specified value,</span></span><br><span class="line"><span class="comment"> * replacing the previous mapping from the specified key if there</span></span><br><span class="line"><span class="comment"> * was one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是一次插入数据的操作，单看的话有些难懂，因为插入跟删除之间有一定的关系，所以要看懂这段代码，还必须搞懂删除的逻辑。在看删除之前，还是先大体梳理一下插入的几个特点：</p>
<ul>
<li>  <strong>存放<code>key</code>的数组是有序的（二分查找的前提条件）</strong></li>
<li>  <strong>如果冲突，新值直接覆盖原值，并且不会返回原值（<code>HashMap</code>会返回原值）</strong></li>
<li>  <strong>如果当前要插入的 key 的索引上的值为DELETE，直接覆盖</strong></li>
<li>  <strong>前几步都失败了，检查是否需要<code>gc()</code>并且在该索引上插入数据</strong></li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/6844903442901630983">SparseArray 的使用及实现原理</a></li>
</ul>
<h1 id="GrowingArrayUtils-insert-的原理？"><a href="#GrowingArrayUtils-insert-的原理？" class="headerlink" title="GrowingArrayUtils.insert()的原理？"></a>GrowingArrayUtils.insert()的原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts an element into the array at the specified index, growing the array if there is no</span></span><br><span class="line"><span class="comment"> * more room.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array The array to which to append the element. Must NOT be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentSize The number of elements in the array. Must be less than or equal to</span></span><br><span class="line"><span class="comment"> *                    array.length.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element The element to insert.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array to which the element was appended. This may be different than the given</span></span><br><span class="line"><span class="comment"> *         array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] insert(T[] array, <span class="keyword">int</span> currentSize, <span class="keyword">int</span> index, T element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentSize + <span class="number">1</span> &lt;= array.length) &#123;</span><br><span class="line">        System.arraycopy(array, index, array, index + <span class="number">1</span>, currentSize - index);</span><br><span class="line">        array[index] = element;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(),</span><br><span class="line">            growSize(currentSize));</span><br><span class="line">    System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, index);</span><br><span class="line">    newArray[index] = element;</span><br><span class="line">    System.arraycopy(array, index, newArray, index + <span class="number">1</span>, array.length - index);</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前数据个数并不超过数组长度，直接把待插入位置后面的元素全部后移一位，腾出空间给新元素。</p>
<p>如果数据总个数超过了数组容纳的长度，需要扩容，扩容大小为growSize(currentSize)求得，为原大小的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given the current size of an array, returns an ideal size to which the array should grow.</span></span><br><span class="line"><span class="comment"> * This is typically double the given size, but should not be relied upon to do so in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">growSize</span><span class="params">(<span class="keyword">int</span> currentSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize &lt;= <span class="number">4</span> ? <span class="number">8</span> : currentSize * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据新大小创建新的数组，然后：</p>
<ol>
<li> 把原数组中待插入位置前面的元素都复制到新数组的前面</li>
<li> 新数组中指定位置插入新元素</li>
<li> 把原数组中待插入位置后面的元素都复制到新数组中插入元素的后面</li>
</ol>
<h1 id="SparseArray-remove-int-key-原理"><a href="#SparseArray-remove-int-key-原理" class="headerlink" title="SparseArray.remove(int key)原理?"></a>SparseArray.remove(int key)原理?</h1><p>通过key二分查找到index，然后讲DELETED赋值给mValues[index]，标记这个位置会删除</p>
<p>为什么删除标记位DELETED？而不是直接删除元素？</p>
<p>直接删除元素会复制数组，如果删除比较频繁，就会降低性能，这里是为了避免频繁进行数组拷贝调整</p>
<h1 id="什么时候会清理掉DELETED的元素？"><a href="#什么时候会清理掉DELETED的元素？" class="headerlink" title="什么时候会清理掉DELETED的元素？"></a>什么时候会清理掉DELETED的元素？</h1><p>SparseArray.gc()里会清理</p>
<h1 id="SparseArray-gc-的原理？"><a href="#SparseArray-gc-的原理？" class="headerlink" title="SparseArray.gc()的原理？"></a>SparseArray.gc()的原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mValues里如果没有DELETED，那么i和o应该是相等的，但是如果有DELETED，o就会小于i，然后就可以把元素全部前移到数组头部，把空位留在数组尾部，相当于碎片整理了一下，留下了尾部整块的空闲空间。</p>
<h1 id="什么时候触发GC-？"><a href="#什么时候触发GC-？" class="headerlink" title="什么时候触发GC()？"></a>什么时候触发GC()？</h1><p>以下方法会调用gc()：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825214148.png"></p>
<p>put的时候如果发现数组大小不够，就清理。</p>
<p>size()求大小需要求得正确的大小。</p>
<h1 id="SparseArray使用过程有什么坑？"><a href="#SparseArray使用过程有什么坑？" class="headerlink" title="SparseArray使用过程有什么坑？"></a>SparseArray使用过程有什么坑？</h1><p>indexOfValue比较的是value的指针，而并没有调用equals方法。</p>
<p>如果value是String就有问题。</p>
<p>如果是Integer，在Integer的缓存范围内也有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an index for which &#123;<span class="doctag">@link</span> #valueAt&#125; would return the</span></span><br><span class="line"><span class="comment"> * specified value, or a negative number if no keys map to the</span></span><br><span class="line"><span class="comment"> * specified value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Beware that this is a linear search, unlike lookups by key,</span></span><br><span class="line"><span class="comment"> * and that multiple keys can map to the same value and this will</span></span><br><span class="line"><span class="comment"> * find only one of them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note also that unlike most collections&#x27; &#123;<span class="doctag">@code</span> indexOf&#125; methods,</span></span><br><span class="line"><span class="comment"> * this method compares values using &#123;<span class="doctag">@code</span> ==&#125; rather than &#123;<span class="doctag">@code</span> equals&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfValue</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/hapoy9/article/details/75554539">安卓SparseArray的indexOfValue方法遇到的坑</a></li>
<li><a href="https://blog.csdn.net/brehrehr/article/details/100118779">记录SparseArray的使用方法和使用过程遇到的问题</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>SparseArray</tag>
        <tag>稀疏表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-ArrayDeque</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayDeque/</url>
    <content><![CDATA[<h1 id="ArrayDeque特点"><a href="#ArrayDeque特点" class="headerlink" title="ArrayDeque特点"></a>ArrayDeque特点</h1><p>基于数组的双端队列。</p>
<p>分别用两个索引指针指示头尾元素位置，循环访问数组元素，访问头尾元素时间复杂度为O(1)</p>
<p>容量不够时扩容，容量增加一倍。</p>
<p>也可以当栈使用。</p>
<h1 id="有了LinkedList实现双端队列，为什么还要用ArrayDeque？"><a href="#有了LinkedList实现双端队列，为什么还要用ArrayDeque？" class="headerlink" title="有了LinkedList实现双端队列，为什么还要用ArrayDeque？"></a>有了LinkedList实现双端队列，为什么还要用ArrayDeque？</h1><p>数组在内存中是连续存储的，CPU访问内存数据具有空间局部性特点，数组对CPU缓存很友好，可以大大提升访问速度。</p>
<p>链表每个节点存储位置是分散不连续的，CPU缓存命中率低，CPU访问主存次数增加，速度慢。</p>
<p>所以需要栈和队列时，优先选择用ArrayDeque。</p>
<h1 id="ArrayDeque缺点"><a href="#ArrayDeque缺点" class="headerlink" title="ArrayDeque缺点"></a>ArrayDeque缺点</h1><ol>
<li> ArrayDeque较于链表的方式的缺点就是容量不够时需要扩容，耗费O(n)的时间</li>
<li> 删除元素后不会缩容，所以不适合数据量变化大且长期处于少数据状态的情况，会浪费空间</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist">Why is ArrayDeque better than LinkedList</a></li>
<li><a href="https://mp.weixin.qq.com/s/PG6NOMgXS6Slh0aXRv9W-g">死磕 java集合之ArrayDeque源码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>集合类</tag>
        <tag>ArrayDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-ArrayList</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/</url>
    <content><![CDATA[<h1 id="ArrayList如何扩容的？"><a href="#ArrayList如何扩容的？" class="headerlink" title="ArrayList如何扩容的？"></a>ArrayList如何扩容的？</h1><p>无参构造函数中初始化一个空数组</p>
<p>调用add，往数组末尾添加元素前，会调用ensureCapacityInternal(size+1)，第一次会创建DEFAULT_CAPACITY（值为10）长度的数组，再会调用grow()，新的数组长度为之前长度的1.5倍，接着调用Arrays.copyOf()将旧的数组元素复制到新数组中，底层实现是System.arraycopy()。</p>
<p>以上是自动扩容，也可以调用ensureCapacity(minCapacity)来手动扩容，需要手动扩容因为，如果提前知道数据量很大，就可以直接扩容到指定容量，自动扩容每次都会扩容原来的1.5倍，避免频繁拷贝数组的开销。</p>
<p>remove和clear后没有缩容，只会把数组中不需要的元素对应的位置设置为null，以便垃圾回收。</p>
<h1 id="ArrayList查询元素的时间复杂度是多少？"><a href="#ArrayList查询元素的时间复杂度是多少？" class="headerlink" title="ArrayList查询元素的时间复杂度是多少？"></a>ArrayList查询元素的时间复杂度是多少？</h1><p>数组访问任意位置元素的时间复杂度为O(1)</p>
<h1 id="ArrayList插入元素的时间复杂度是多少？"><a href="#ArrayList插入元素的时间复杂度是多少？" class="headerlink" title="ArrayList插入元素的时间复杂度是多少？"></a>ArrayList插入元素的时间复杂度是多少？</h1><p>插入末尾时间复杂度为O(1)，因为有指针记录末尾的位置，有新元素直接填充末尾的空位，当末尾没有空位时，需要扩容，扩容为原来长度的1.5倍，扩容需要拷贝旧数组的数据到新数组，时间复杂度是O(n），所以插入元素到末尾的均摊时间复杂度是O(1)。</p>
<p>插入元素到中间位置的时间复杂度较高，因为要把插入位置后面所有元素后移一位，设数组长度为n，插入第1、2、3、… 、n-1、n个位置，分别需要移动元素的个数是n、n-1、n-2、… 、2、1，由等差数列求和公式得结果为n(n+1)/2，除以n得平均移动(n+1)/2个，所以插入到中间位置的平均时间复杂度是O(n)。</p>
<h1 id="ArrayList删除元素的时间复杂度是多少？"><a href="#ArrayList删除元素的时间复杂度是多少？" class="headerlink" title="ArrayList删除元素的时间复杂度是多少？"></a>ArrayList删除元素的时间复杂度是多少？</h1><p>与插入元素的情况一样，删除末尾元素时间复杂度为O(1)，删除中间位置的元素要把该位置后面的元素都前移一位，平均时间复杂度为O(n)</p>
<h1 id="ArrayList与LinkedList有何区别？"><a href="#ArrayList与LinkedList有何区别？" class="headerlink" title="ArrayList与LinkedList有何区别？"></a>ArrayList与LinkedList有何区别？</h1><ol>
<li> ArrayList基于数组实现，容量不够时会动态扩容；LinkedList基于链表实现，实际是是一个双向链表，同时可以作为队列、栈使用</li>
<li> ArrayList适合随机访问数据，时间复杂度O(1)；LinkedList不适合随机访问数据，因为这会遍历链表，最坏情况下访问最后一个元素，要遍历整个链表，时间复杂度O(n)</li>
<li> LinkedList适合插入和删除首尾元素，时间复杂度O(1)；ArrayList插入和删除尾元素，其实是在数组的末尾填充元素，时间复杂度O(1)，插入尾元素可能会触发扩容，扩容时会拷贝数组，时间复杂度会达到O(n)，ArrayList插入和删除非末尾元素，需要移动操作，时间复杂度O(n)</li>
<li> LinkedList需要占用更多的内存，因为每个结点除了存储元素数据外，还有额外的链表指针，ArrayList底层是数组，存储的直接是元素数据</li>
<li> ArrayList对于CPU缓存命中率友好，因为存储空间连续，符合数据访问的空间局部性特点</li>
</ol>
<h1 id="如何求两个ArrayList的交集、并集、差集？"><a href="#如何求两个ArrayList的交集、并集、差集？" class="headerlink" title="如何求两个ArrayList的交集、并集、差集？"></a>如何求两个ArrayList的交集、并集、差集？</h1><p>并集：addAll</p>
<p>交集：retainAll</p>
<p>差集：removeAll</p>
<h1 id="ArrayList序列化有什么注意事项？"><a href="#ArrayList序列化有什么注意事项？" class="headerlink" title="ArrayList序列化有什么注意事项？"></a>ArrayList序列化有什么注意事项？</h1><p>底层的elementData数组，可能没有填充满，所以不能直接序列化，会浪费空间，序列化时要先写入数组元素真实个数，再写入数组中实际存储的元素</p>
<h1 id="Arrays-asList-T…-a-有什么坑"><a href="#Arrays-asList-T…-a-有什么坑" class="headerlink" title="Arrays.asList(T… a)有什么坑"></a>Arrays.asList(T… a)有什么坑</h1><ol>
<li> 传递一个原始数据类型的数组，例如int[]，会只被当做一个元素，只能使用对象类型的数组</li>
<li> 得到的list无法add、remove、clear，会抛出异常</li>
</ol>
<h1 id="ArrayList有什么坑？"><a href="#ArrayList有什么坑？" class="headerlink" title="ArrayList有什么坑？"></a>ArrayList有什么坑？</h1><p>List.remove()有两个。</p>
<p>一个public E remove(int index)</p>
<p>一个是public boolean remove(Object o)</p>
<p>容易调用不是预期的重载方法。</p>
<h1 id="ArrayList单线程遍历然后删除元素会有什么问题？"><a href="#ArrayList单线程遍历然后删除元素会有什么问题？" class="headerlink" title="ArrayList单线程遍历然后删除元素会有什么问题？"></a>ArrayList单线程遍历然后删除元素会有什么问题？</h1><p>索引错位。</p>
<p>用Iterartor的next迭代列表的时候，通过ArrayList的remove方法移除元素会抛出ConcurrentModificationException，因为迭代器迭代的时候，内部也是用一个int类型指针记录位置的，要是外面删除了元素，位置就错位了，迭代就不准了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/5c66c47851882562e5443491">ArrayList的扩容机制</a></li>
<li><a href="https://www.nowcoder.com/questionTerminal/2a42d992a5d74435b625415ce511bb69">ArrayList和LinkedList有什么区别？</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>集合类</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-ConcurrentHashMap原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-ConcurrentHashMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>高性能且线程安全的哈希表。</p>
<h1 id="线程安全是怎么实现的？"><a href="#线程安全是怎么实现的？" class="headerlink" title="线程安全是怎么实现的？"></a>线程安全是怎么实现的？</h1><p>Java7中ConcurrentHashMap将哈希表分割成为多个段（Segment），每一个段继承ReentrantLock，对每一段进行加锁。每个Segment里类似又有一个小的HashMap，等于是双重哈希表。</p>
<p>Java8中采用了自旋CAS和synchronzied保证线程安全，锁的粒度调整为对table数组中每个元素进行加锁；put元素时，定位到桶位置后，通过synchronzied给桶中链表首节点或红黑树根节点加锁。这样多线程竞争哈希表同一个桶位置的几率又降低了。</p>
<p>java8的ConcurrentHashMap的数据结构参考java8的HashMap，采用数组+链表+红黑树。</p>
<ul>
<li><p>put方法里，是一个无限循环，即自旋，修改table数组都是通过cas操作，自旋锁的机制避免了阻塞和恢复线程的上下文切换开销。</p>
</li>
<li><p>只要当前桶位置没有元素，就先自旋CAS进行更新。</p>
</li>
<li><p>存在hash冲突或修改已有的值时，需要进入桶内部的链表或红黑树进行操作时，才开始用synchronized真正加锁。</p>
</li>
</ul>
<p>get是不加锁的，所以与CopyOnWriteArrayList一样，不保证读数据的实时性，数据是弱一致性。</p>
<p>size的求法和LongAdder里的思路一样，将大小数据分段累加，避免多线程竞争，用自旋cas保证数据更新的原子性。</p>
<h1 id="不能解决什么问题？"><a href="#不能解决什么问题？" class="headerlink" title="不能解决什么问题？"></a>不能解决什么问题？</h1><p>因为数据是弱一致性的，get时并不加锁，所以对读数据实时性要求高的需求不能满足。</p>
<p>例如线程1在某一时刻执行了put(key, value)，先线程2随后立即get(key)不一定能读取到线程1刚put的，因为put可能正在进行中还没结束。</p>
<h1 id="扩容机制是怎样的？"><a href="#扩容机制是怎样的？" class="headerlink" title="扩容机制是怎样的？"></a>扩容机制是怎样的？</h1><p>本来一个线程扩容时，其他线程应该都阻塞等待这个线程扩容完成后才能对哈希表进行读写，这就成了并发的瓶颈。</p>
<p>ConcurrentHashMap具体实现是，反正你闲着也是闲着，不如一起来扩容。</p>
<p>扩容时nextTable会指向扩容后的数组，扩容方法transfer里通过自旋进行。</p>
<p>多个线程通过sizeCtl判断当前所处状态，再通过transferIndex协调各线程应该操作哪一些桶。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">ConcurrentHashMap1.8 - 扩容详解（图文并茂）</a></li>
<li><a href="https://www.cnblogs.com/lfs2640666960/p/9621461.html">深入理解HashMap+ConcurrentHashMap的扩容策略  </a></li>
<li><a href="https://www.jianshu.com/p/487d00afe6ca">ConcurrentHashMap源码分析（JDK8） 扩容实现机制</a></li>
</ul>
<h1 id="跟同样是线程安全的Hashtable有何区别？"><a href="#跟同样是线程安全的Hashtable有何区别？" class="headerlink" title="跟同样是线程安全的Hashtable有何区别？"></a>跟同样是线程安全的Hashtable有何区别？</h1><p>Hashtable的线程安全是对整个哈希表上锁（在多数方法上加上sychronized），其中一个线程访问哈希表时，其他线程只能等待，很多没有必要上锁的场景也上锁，因此在多线程竞争激烈的情况下整体访问速度会变慢。</p>
<p>ConcurrentHashMap把哈希表分割成若干个段，修改每一段时仅针对访问的段上锁，不同的线程访问不同的段时互不干扰，减少了多个线程争抢同一把锁的几率，减少了线程等待的时间，所以提高了性能。</p>
<p>分段锁是怎么实现的？</p>
<p>get方法不加锁，结点类里的value设置了volatile保证了value在多线程下的可见性，保证get到value最新的修改值。</p>
<p>总结：</p>
<ol>
<li> 循环+CAS实现自旋锁，减少线程阻塞恢复的上下文切换消耗</li>
<li> size更新采用LongAdder分段锁思想，减少竞争</li>
<li> LongAdder机制中的字节填充解决伪共享</li>
<li> 多线程协同分组扩容。</li>
</ol>
<h1 id="与Collections-synchronizedMap-的区别？"><a href="#与Collections-synchronizedMap-的区别？" class="headerlink" title="与Collections.synchronizedMap()的区别？"></a>与Collections.synchronizedMap()的区别？</h1><p>Collections.synchronizedMap()对HashMap做了一层装饰，用synchronized锁住整个哈希表，以保证各操作的线程安全，锁的粒度比较大。<br>性能比ConcurrentHashMap更差，但可以保证读的实时性。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li>
<li><a href="https://juejin.im/post/5dee05ac6fb9a0163f77beb6">深入解析 ConcurrentHashMap 实现内幕，吊打面试官？没问题</a></li>
<li><a href="https://www.cnblogs.com/heqiyoujing/p/11143525.html">ConcurrentHashMap面试题</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-CopyOnWriteArrayList</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-CopyOnWriteArrayList/</url>
    <content><![CDATA[<h1 id="ArrayList存在什么问题？"><a href="#ArrayList存在什么问题？" class="headerlink" title="ArrayList存在什么问题？"></a>ArrayList存在什么问题？</h1><p>ArrayList是线程不安全的。</p>
<p>可以用Collections.synchronizedList()加全局独占锁保证线程安全，但在读多写少的情况下，多线程读之间互斥降低了系统吞吐量。</p>
<p>如果读与读之间不互斥，写与写、写与读才互斥，这样可以保证最大的吞吐量，这就是CopyOnWriteArrayList。</p>
<h1 id="CopyOnWriteArrayList保证线程安全的原理？"><a href="#CopyOnWriteArrayList保证线程安全的原理？" class="headerlink" title="CopyOnWriteArrayList保证线程安全的原理？"></a>CopyOnWriteArrayList保证线程安全的原理？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用读写锁保证并发，可以保证读读之间没有阻塞等待，但有线程写数据时，读线程必须阻塞等待，这保证了每次都都可以读到最新修改的值。</p>
<p>CopyOnWriteArrayList牺牲了读的实时性，读操作不上锁，只在写数据时使用ReentrantLock上锁，写数据时会把原数组拷贝到新的数组中，写数据的同时再有线程读数据，读到的是之前数组的值，不保证数据实时性，只保证最终结果一致性，牺牲了数据实时性，换取了读操作没有阻塞等待。</p>
<p>对数据实时性要求很高的需求，不要使用CopyOnWriteArrayList。</p>
<p>线程1在add数据时，线程2随后get数据，不一定能获取到线程1刚add的的元素，因为线程1可能还没执行完。</p>
<h1 id="CopyOnWriteArrayList存在什么问题？"><a href="#CopyOnWriteArrayList存在什么问题？" class="headerlink" title="CopyOnWriteArrayList存在什么问题？"></a>CopyOnWriteArrayList存在什么问题？</h1><ol>
<li> 读数据不是实时的，读的时候可能正在写数据，读不到最新的值，也不会阻塞等待，适合读多写少的场景</li>
<li> 每次写数据都要复制整个数组，如果写操作频繁，会频繁触发垃圾回收，垃圾回收又会导致线程停顿，造成APP卡顿变多</li>
</ol>
<h1 id="CopyOnWriteArrayList适用场景？"><a href="#CopyOnWriteArrayList适用场景？" class="headerlink" title="CopyOnWriteArrayList适用场景？"></a>CopyOnWriteArrayList适用场景？</h1><ol>
<li> 高并发</li>
<li> 读多写少</li>
<li> 对读数据实时性要求不高</li>
</ol>
<h1 id="为什么没有扩容"><a href="#为什么没有扩容" class="headerlink" title="为什么没有扩容?"></a>为什么没有扩容?</h1><p>因为每次add元素都要拷贝数组，这个时间消耗是必须的，所以也没必要扩容了，拷贝数据到一个恰好比原数组多一个位置的新数组。</p>
<h1 id="Vector有什么问题"><a href="#Vector有什么问题" class="headerlink" title="Vector有什么问题?"></a>Vector有什么问题?</h1><ol>
<li> Vector是线程安全的列表，底层实现也是数组，但是几乎每一个方法都加上了synchonized，多线程读操作之间会互斥，读多写少的情况下，吞吐量不高</li>
<li> Vector扩容，容量是翻倍，指数增长，ArrayList只增长为原来的1.5倍，更节约空间。</li>
</ol>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>集合类</tag>
        <tag>CopyOnWriteArrayList</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-LinkedHashMap</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-LinkedHashMap/</url>
    <content><![CDATA[<h1 id="LinkedHashMap特点"><a href="#LinkedHashMap特点" class="headerlink" title="LinkedHashMap特点"></a>LinkedHashMap特点</h1><p>作用：记录HashMap插入元素的顺序或访问元素的顺序</p>
<p>原理：双向链表和哈希表的结合</p>
<p>使用场景：适用于实现缓存，用空间换时间，如LRU</p>
<p>继承HashMap，大部分操作和HashMap实现一致</p>
<h1 id="元素的顺序在访问时是怎样体现的？"><a href="#元素的顺序在访问时是怎样体现的？" class="headerlink" title="元素的顺序在访问时是怎样体现的？"></a>元素的顺序在访问时是怎样体现的？</h1><p>构造函数可以指定accessOrder：</p>
<ul>
<li>true表示记录元素访问顺序。</li>
<li>false表示记录元素插入的顺序，默认为false。</li>
</ul>
<p>创建一个记录元素访问顺序的LinkedHashMap：<br><code>new LinkedHashMap(16, 0.75f, true)</code></p>
<ul>
<li>记录元素插入顺序时，通过迭代器遍历时，先插入的元素会先访问到。</li>
<li>记录元素访问顺序时，刚访问过的元素会调整到链表末尾，通过迭代器遍历时，先遍历到的是最久没有被访问过的元素。</li>
</ul>
<h1 id="为什么最新插入和最后访问的要放在末尾？"><a href="#为什么最新插入和最后访问的要放在末尾？" class="headerlink" title="为什么最新插入和最后访问的要放在末尾？"></a>为什么最新插入和最后访问的要放在末尾？</h1><p>插入新元素默认就是在链表尾部插入，是符合常规逻辑的，最新访问的放在末尾也就是统一这个规则了。</p>
<h1 id="LinkedHashMap实现原理？"><a href="#LinkedHashMap实现原理？" class="headerlink" title="LinkedHashMap实现原理？"></a>LinkedHashMap实现原理？</h1><p>双向链表的结点类继承HashMap桶中链表的结点类，增加了前后指针，实际效果如下：</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825215429.png"></p>
<h1 id="LinkedHashMap有什么应用？"><a href="#LinkedHashMap有什么应用？" class="headerlink" title="LinkedHashMap有什么应用？"></a>LinkedHashMap有什么应用？</h1><p>LRU缓存。</p>
<p>用LinkedHashMap手撕 <a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode.146. LRU 缓存机制（难度：中等）</a></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> map = LinkedHashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map[key] ?: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size == capacity &amp;&amp; !map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">val</span> oldest = map.iterator().next()</span><br><span class="line">            map.remove(oldest.key)</span><br><span class="line">        &#125;</span><br><span class="line">        map[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-TreeMap、ConcurrentSkipListMap</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-TreeMap%E3%80%81ConcurrentSkipListMap/</url>
    <content><![CDATA[<h1 id="TreeMap作用"><a href="#TreeMap作用" class="headerlink" title="TreeMap作用"></a>TreeMap作用</h1><ul>
<li> 元素可以按key保持顺序。</li>
<li> 因为有序，提供了很多范围查询的方法，非常方便。</li>
</ul>
<h1 id="TreeMap的实现"><a href="#TreeMap的实现" class="headerlink" title="TreeMap的实现"></a>TreeMap的实现</h1><p>TreeMap实现了NavigableMap接口，该接口又继承SortedMap接口，两个提供了很多范围查询的方法，非常方便。</p>
<p>用红黑树实现，插入、删除、查询的平均时间复杂度都是log(n)。</p>
<h1 id="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap"><a href="#TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap" class="headerlink" title="TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?"></a>TreeMap也是非线程安全的，为什么不提供ConcurrentTreeMap?</h1><ol>
<li> 因为红黑树的结构调整可能涉及整个树的结点，这样并发下就要锁住很多结点，使用跳表会更局部一点，只锁住局部的几个结点，并发性能更高。</li>
<li> 红黑树加锁实现起来比较复杂，跳表是链表加锁比较容易实现</li>
</ol>
<p>可以用过Collections.synchronizedSortedMap()保证线程安全，也可以改用ConcurrentSkipListMap并发性能更好。</p>
<h1 id="TreeMap为什么用红黑树不用AVL树？"><a href="#TreeMap为什么用红黑树不用AVL树？" class="headerlink" title="TreeMap为什么用红黑树不用AVL树？"></a>TreeMap为什么用红黑树不用AVL树？</h1><p>跟HashMap中的问题一样。</p>
<p>红黑树的3结点可以吸收变化，在多次使用中可以减少调整数据结构的次数，从而提升性能。</p>
<h1 id="ConcurrentSkipListMap是什么？"><a href="#ConcurrentSkipListMap是什么？" class="headerlink" title="ConcurrentSkipListMap是什么？"></a>ConcurrentSkipListMap是什么？</h1><p>跳表：链表+多级索引（多层链表）。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825212310.png"></p>
<ul>
<li>给有序链表再增加若干层额外的指针索引，用空间换时间。</li>
<li>每一层都是一个有序链表。</li>
<li>实际效果类似于平衡二叉搜索树。</li>
<li>插入、删除、查询的平均时间复杂度都是log(n)。</li>
<li>支持按key排序所有元素，也支持快速查找。</li>
</ul>
<h1 id="跳表的数据结构存在什么问题？"><a href="#跳表的数据结构存在什么问题？" class="headerlink" title="跳表的数据结构存在什么问题？"></a>跳表的数据结构存在什么问题？</h1><p>按照理想的生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。</p>
<h1 id="跳表与红黑树区别？"><a href="#跳表与红黑树区别？" class="headerlink" title="跳表与红黑树区别？"></a>跳表与红黑树区别？</h1><ol>
<li> 红黑树为了保持平衡有可能会调整很多结点甚至整个树，而跳表只要修改相邻结点更加的局部，跳表调整次数少性能也就高，同时并发加锁时，锁住的结点更少，可以减少竞争</li>
<li> 跳表的区间查询更高效，因为找到链表头结点顺序遍历就行了，红黑树需要中序遍历相对比较复杂</li>
<li> 跳表占用空间更少，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
</ol>
<h1 id="ConcurrentSkipListMap存在什么问题？"><a href="#ConcurrentSkipListMap存在什么问题？" class="headerlink" title="ConcurrentSkipListMap存在什么问题？"></a>ConcurrentSkipListMap存在什么问题？</h1><p>size方法求得链表长度要遍历整个链表，并且没有加锁，多线程高并发下这个方法返回值并不准确，高并发下使用size的意义不大。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/yd2sOhmVtZeEkJ06cTE7qA"> 死磕 java集合之ConcurrentSkipListMap源码分析——发现个bug</a></li>
<li><a href="https://stackoverflow.com/questions/1811782/when-should-i-use-concurrentskiplistmap">When should I use ConcurrentSkipListMap?</a></li>
<li><a href="https://www.zhihu.com/question/20202931/answer/16086538">为啥 redis 使用跳表(skiplist)而不是使用 red-black？ - 于康的回答 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>TreeMap</tag>
        <tag>ConcurrentSkipListMap</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（冒泡、选择、插入、希尔、快速、归并、堆、计数）</title>
    <url>/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>左侧无序区域中的最大数字交换到右侧已排序区域的最左侧。</p>
<h3 id="冒泡排序代码"><a href="#冒泡排序代码" class="headerlink" title="冒泡排序代码"></a>冒泡排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            <span class="comment">// nums[0, n - 1 - i]是无序区域，初始时整个数组无序</span></span><br><span class="line">            <span class="comment">// nums[n - i,n - 1]是有序区域，是数组中大的数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一趟冒泡是否有交换发生</span></span><br><span class="line">            <span class="keyword">var</span> isNotSwapped = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为要比较当前和下一个数大小，所以j只能取到n - 1 - i的前一个数</span></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span> - i) &#123;</span><br><span class="line">                <span class="comment">// 不是升序，就要交换一下</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换</span></span><br><span class="line">                    <span class="keyword">val</span> tmp = nums[j + <span class="number">1</span>]</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">                    nums[j] = tmp</span><br><span class="line">                    <span class="comment">// 标记有交换</span></span><br><span class="line">                    isNotSwapped = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有交换，说明无序区域已经有序，那么整个数组也是有序的了</span></span><br><span class="line">            <span class="keyword">if</span> (isNotSwapped) <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>冒泡排序是稳定的</strong>。</p>
<p>因为交换是当前数大于下一个数才会交换。</p>
<p>如果有<code>x1 == x2</code>，<code>x1</code>在<code>x2</code>左边，<code>x1</code>始终不会被交换到<code>x2</code>右边。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="一句话描述-1"><a href="#一句话描述-1" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>右侧未排序区域选取一个最小的数，交换到前面已排序区域的末尾。</p>
<h3 id="选择排序代码"><a href="#选择排序代码" class="headerlink" title="选择排序代码"></a>选择排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// s[0,i-1]为已排序区域，s[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序取一个最小的放入已排序区域的末尾  </span></span><br><span class="line">  <span class="keyword">var</span> minIndex = i  </span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;  </span><br><span class="line">                    minIndex = j  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 将未排序区域中最小值与已排序区域末尾的下一个位置的数字交换  </span></span><br><span class="line">  <span class="comment">// 已排序区域末尾的下一个位置就是i了，最小值索引是minIndex  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[minIndex]  </span><br><span class="line">            nums[minIndex] = nums[i]  </span><br><span class="line">            nums[i] = tmp  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>选择排序不稳定</strong>，因为发生了位置交换。</p>
<p>由于每次会在后面的未排序区域选择最小的数字与前面的已排序区域末尾元素交换，如果未排序区域交换的位置的前面有与已排序区域末尾元素相等的元素，这两个元素的相对位置就变了。</p>
<p>例如[2, 3, 4, 2, 1]，第一趟选择会把最小的1放到最前面，第一个2交换到最后面，这样两个2的相对顺序就变了。</p>
<p>如何不发生位置交换呢？</p>
<p>有两种做法：</p>
<ul>
<li>一个是开辟一个新数组，把最小的放到第一个位置上，把第二小的放到第二个位置上等等。空间复杂度是O(n)。</li>
<li>一个是使用链表，空间复杂度是O(1)。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>交换次数比冒泡排序少，交换次数是跟数组长度呈线性关系。</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h3 id="一句话描述-2"><a href="#一句话描述-2" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>扑克牌拿牌后插牌的排序：把数组右侧未排序区域的最左侧元素插入数组左侧已排序区域中。</p>
<h3 id="直接插入排序代码"><a href="#直接插入排序代码" class="headerlink" title="直接插入排序代码"></a>直接插入排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;  </span><br><span class="line">        <span class="keyword">val</span> n = nums.size  </span><br><span class="line">  <span class="comment">// 初始时未排序区域共有n个数，每次向左侧已排序区域插入一个数，总共需要插入n次  </span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;  </span><br><span class="line">            <span class="comment">// nums[0,i-1]为已排序区域  </span></span><br><span class="line">  <span class="comment">// nums[i,n-1]为未排序区域  </span></span><br><span class="line">  <span class="comment">// 从未排序区域第一个元素开始，从后往前一个个跟已排序区域数字比较，相邻两个数字顺序不对就交换，直至顺序正确  </span></span><br><span class="line">  <span class="comment">// 由于要比较当前数字和前一个数字的大小，所以索引j最少只能取到第2个元素位置即索引1  </span></span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果相邻两个数不是升序则需要交换  </span></span><br><span class="line">  <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                    <span class="comment">// 交换元素  </span></span><br><span class="line">  <span class="keyword">val</span> tmp = nums[j]  </span><br><span class="line">                    nums[j] = nums[j - <span class="number">1</span>]  </span><br><span class="line">                    nums[j - <span class="number">1</span>] = tmp  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>已排序区域寻找插入位置可以使用二分查找。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适合部分有序的数组，这样比较次数就会大大减少，从而提高效率。</p>
<p>对于大规模乱序的数组，插入排序很慢，因为只会交换相邻的元素，元素只能一步一步的从数组的一端移动到另一端。</p>
<p>例如，如果是升序排序，数组最小的元素在数组末尾，那么移动到开头就要交换N-1次。如果有一个完全降序的数组，用插入排序变为升序的话，要做的事情太多了。</p>
<p>给定一个10万个元素的数组，部分有序，部分无序，选择哪一种排序算法最好？</p>
<p>用插入排序，插入排序在已排序区域寻找插入位置可以用二分法加快寻找</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h3 id="一句话描述-3"><a href="#一句话描述-3" class="headerlink" title="一句话描述"></a>一句话描述</h3><p>先大步再小步的插入排序。</p>
<p>大步插入排序使得用很少的交换次数让数组变得部分有序，从而在小步排序时发挥插入排序的优势，达到总体的比较和交换次数变少。</p>
<h3 id="希尔排序代码"><a href="#希尔排序代码" class="headerlink" title="希尔排序代码"></a>希尔排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">var</span> d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (d &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            d = <span class="number">3</span> * d + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> d until n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo d step d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[j - d]) &#123;</span><br><span class="line">                        <span class="keyword">val</span> tmp = nums[j]</span><br><span class="line">                        nums[j] = nums[j - d]</span><br><span class="line">                        nums[j - d] = tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递增序列如何选择？不同的递增序列有什么影响？"><a href="#递增序列如何选择？不同的递增序列有什么影响？" class="headerlink" title="递增序列如何选择？不同的递增序列有什么影响？"></a>递增序列如何选择？不同的递增序列有什么影响？</h3><blockquote>
<p>《算法（第4版）》</p>
<p>如何选择递增序列呢？要回答这个问题并不简单。算法的性能不仅取决于h，还取决于h 之间的数学性质，比如它们的公因子等。</p>
<p>有很多论文研究了各种不同的递增序列，但都无法证明某个序列是 “ 最好的” 。</p>
<p>算法2.3中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。但可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。</p>
</blockquote>
<p>一个简单的序列选择：<br>从1开始，一直 d * 3 + 1，直到小于 n / 3。</p>
<h3 id="希尔排序更高效的原因？"><a href="#希尔排序更高效的原因？" class="headerlink" title="希尔排序更高效的原因？"></a>希尔排序更高效的原因？</h3><p>希尔排序权衡了数组的规模和有序性。</p>
<p>排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p>
<p>子数组部分有序的程度取决于递增序列的选择。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>在大规模乱序的情况下，希尔排序可以减少元素交换的次数，数组越大优势越大。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>选取一个轴心元素，将数组划分成比这个数小的和比这个数字大的两个子数组，分别对两个子数组递归调用划分。</p>
<h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">val</span> pivotIndex = partition(nums, low, high)</span><br><span class="line">        quickSort(nums, low, pivotIndex - <span class="number">1</span>)</span><br><span class="line">        quickSort(nums, pivotIndex + <span class="number">1</span>, high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start = low</span><br><span class="line">    <span class="keyword">var</span> end = high</span><br><span class="line">    <span class="keyword">val</span> pivot = nums[start]</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] &gt;= pivot) &#123;</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] &lt;= pivot) &#123;</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[end] = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么partition()里的while判断条件里low不能等于high？</strong></p>
<p>因为一开始取pivot就已经挖空了一个位置。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>每次划分，轴心元素就在最终排序完成后的位置上。</p>
<h3 id="快排为什么是O-n-log-n-复杂度？"><a href="#快排为什么是O-n-log-n-复杂度？" class="headerlink" title="快排为什么是O(n log n)复杂度？"></a>快排为什么是O(n log n)复杂度？</h3><p>根据主定理推导。</p>
<p>参考： <a href="https://www.zhihu.com/question/22393997/answer/406278523">如何证明快速排序法的平均复杂度为 O(nlogn)？ - 知乎 </a></p>
<h3 id="什么会影响时间复杂度？"><a href="#什么会影响时间复杂度？" class="headerlink" title="什么会影响时间复杂度？"></a>什么会影响时间复杂度？</h3><p>用于划分数组的中枢元素的选择会影响时间复杂度，划分的左右子数组数量越接近效果越好，否则会让整个快速排序退化到O(n^2)级别。</p>
<p>具体怎么划分要根据数组本身的数据分布特性来决定</p>
<p>以下情况会变得低效：</p>
<p>（1）近乎有序的数列</p>
<p>对于一个近乎有序的数列，当直接使用第一个元素作为基准点的时候，将会导致划分的子数组大小差距太大，进而无法发挥快排划分的优势</p>
<p>（2）含有大量重复数据的数列</p>
<p>選取的數字如果是重複較多的數字，划分出的两个子数组有一边的长度会很大，因为移动指针的时候，判断条件是大于等于和小于等于枢纽元素</p>
<h3 id="如何优化时间复杂度？"><a href="#如何优化时间复杂度？" class="headerlink" title="如何优化时间复杂度？"></a>如何优化时间复杂度？</h3><p>针对近乎有序的数组：</p>
<p><strong>三数取中法</strong></p>
<p>选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间大的数交换到数列首位的位置，之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。</p>
<p><a href="https://leetcode-cn.com/problems/sort-colors/">LeetCode.75.颜色分类（中等）</a>正好就是用到这种方法。</p>
<p><strong>随机交换法</strong></p>
<p>选取基准点之前设计随机种子，通过随机函数得到一个在数列长度内的数，将这个随机数作为索引所指的数和第一个元素进行交换，之后将首位元素作为基准点。即随机选一个数放到首位的地方。这样一来，第一次就将最小的数交换到首位的概率是非常小的，第二次将次小的数交换到首位的概率依然非常的小。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h3 id="一句话说明"><a href="#一句话说明" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>堆就是一个完全二叉树，堆排序两步走：<br>建堆：从最后一个非叶子节点到根结点不停的向下调整堆。<br>排序调整：堆顶元素与数组末尾元素交换，再向下调整堆顶元素。</p>
<h3 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        buildHeap(nums)</span><br><span class="line">        <span class="comment">// 堆顶最大的元素与数组末尾的数字进行交换</span></span><br><span class="line">        <span class="comment">// 堆大小减1</span></span><br><span class="line">        <span class="comment">// 新的堆顶元素可能破坏最大堆性质，需要向下调整，把缩小后的堆的最大的元素放到堆顶</span></span><br><span class="line">        <span class="comment">// 重复如此最后堆大小缩减为0，原数组从末尾开始向前填充大的数，最后得到升序数组</span></span><br><span class="line">        <span class="keyword">for</span> (length <span class="keyword">in</span> nums.size downTo <span class="number">1</span>) &#123;</span><br><span class="line">            nums.swap(<span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">            sink(nums, <span class="number">1</span>, length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildHeap</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 给数组元素从1到n编号，最后一个非叶节点的编号为n/2</span></span><br><span class="line">        <span class="comment">// 从最后一个非叶节点开始往前不停的向下调整堆</span></span><br><span class="line">        <span class="comment">// 如果一个结点的左右子树已经是堆，从该结点向下调整后该结点为根结点的二叉树依然保持着堆的性质</span></span><br><span class="line">        <span class="comment">// 所以可以从下往上不停的向下调整</span></span><br><span class="line">        <span class="keyword">for</span> (parent <span class="keyword">in</span> n / <span class="number">2</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            sink(nums, parent, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对[nums]的第[k]个元素为根结点的子堆进行向下调整，把大的元素放到堆顶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要从[k]向下调整是因为[k]与孩子结点可能不满足堆性质</span></span><br><span class="line"><span class="comment">     * 初始时已经建立了堆，交换前我们可以认定k的左右子树都已经满足最大堆的性质，即k的左右子结点一定比它下面的所有结点值都大</span></span><br><span class="line"><span class="comment">     * 如果k当前比左右孩子最大的一个要小，当把k的左右孩子结点与k交换，依然满足k大于所有其孩子结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sink</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> parent = k</span><br><span class="line">        <span class="comment">// 最后一个非叶节点编号是length/2</span></span><br><span class="line">        <span class="comment">// parent初始时是在上层的结点，一直会往下遍历，一直遍历到最后一个非叶节点</span></span><br><span class="line">        <span class="keyword">while</span> (parent &lt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 找出较小的孩子结点child</span></span><br><span class="line">            <span class="keyword">var</span> child = parent * <span class="number">2</span></span><br><span class="line">            <span class="comment">// 如果child不是最后一个元素，对比下其相邻的孩子谁更大，取更大的孩子结点，以便接下来跟其父结点parent比较，检查是否满足最大堆的性质</span></span><br><span class="line">            <span class="keyword">if</span> (child &lt; length &amp;&amp; nums[child - <span class="number">1</span>] &lt; nums[child]) child++</span><br><span class="line">            <span class="comment">// 因为初始已经建了最大堆，我们可以认定parent的左右子树都已经满足堆的性质</span></span><br><span class="line">            <span class="comment">// 如果当前parent与child也满足堆性质，则不用继续调整了</span></span><br><span class="line">            <span class="comment">// 这里构建的是大顶堆，要求父结点比孩子结点要大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[parent - <span class="number">1</span>] &gt;= nums[child - <span class="number">1</span>]) <span class="keyword">break</span></span><br><span class="line">            <span class="comment">// 父结点比孩子结点小，不满足最大堆性质，交换父结点和孩子结点的值，以满足最大堆性质</span></span><br><span class="line">            nums.swap(parent - <span class="number">1</span>, child - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 交换后，以孩子结点child为根的子堆可能不满足最大堆性质，继续向下检查调整</span></span><br><span class="line">            parent = child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组IntArray的扩展函数swap，用以交换数组内两个位置[i]和[j]的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">swap</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j]</span><br><span class="line">        <span class="keyword">this</span>[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？"><a href="#堆排序的时间复杂度也是O-n-logn-，为什么一般排序用快速排序？" class="headerlink" title="堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？"></a>堆排序的时间复杂度也是O(n * logn)，为什么一般排序用快速排序？</h3><p>因为堆是一种完全二叉树，访问的数据不在内存中连续的区域，空间访问局部性效果不太好，缓存命中率低，进而降低了程序运行速度。</p>
<p>快速排序会访问数组相邻的元素，空间访问局部性比较好，程序运行速度快。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="一句话说明-1"><a href="#一句话说明-1" class="headerlink" title="一句话说明"></a>一句话说明</h3><p>归并两个子数组为一个有序数组。</p>
<p>可以自顶向下递归进行，也可以自底向上迭代进行。</p>
<h3 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h3><p>自顶向下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下，分而治之</span></span><br><span class="line"><span class="comment">     * 类似于二叉树后序遍历的写法，理解二叉树后续遍历这个递归写法就好理解对应上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个元素的时候，low与high相等，只有一个数字的子数组认定是有序的，不需要再排序了</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">val</span> mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            mergeSort(nums, low, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自底向上：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        mergeSort(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="comment">// 从最小的子数组开始向上归并，最小的子数组长度是1，每次向上归并后子数组大小变为原来的两倍</span></span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (size &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 按照子数组的大小将长度为n的数组划分为n/size个子数组</span></span><br><span class="line">            <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 依次归并 n/size 个子数组</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; n - size) &#123;</span><br><span class="line">                <span class="comment">// 第一个子数组的右边界索引（包含）</span></span><br><span class="line">                <span class="keyword">val</span> mid = low + size - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 第二个子数组的右边界索引（包含），最后一个子数组可能只包含的元素个数较少，需要防止数组越界</span></span><br><span class="line">                <span class="keyword">val</span> high = min(low + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 归并两个子数组</span></span><br><span class="line">                merge(nums, low, mid, high)</span><br><span class="line">                <span class="comment">// 每次归并2个子数组，所以下一次归并发生在第三个子数组的位置</span></span><br><span class="line">                low += size * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            size *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并两个子数组为一个有序数组，用双指针法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums: <span class="type">IntArray</span>, low: <span class="type">Int</span>, mid: <span class="type">Int</span>, high: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copiedNums = nums.copyOf()</span><br><span class="line">        <span class="comment">// 最终将两个子数组归并的大数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p = low</span><br><span class="line">        <span class="comment">// 划分的第一个（左侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p1 = low</span><br><span class="line">        <span class="comment">// 划分的第二个（右侧）子数组的指针</span></span><br><span class="line">        <span class="keyword">var</span> p2 = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 以上三个指针都会从各自数组的起始位置移动到末尾位置</span></span><br><span class="line">        <span class="comment">// 开始遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> low..high) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="comment">// 2.当其中一个子数组已经遍历完了，即代表该子数组的元素已经全部复制到大数组，把剩下一个未遍历完的数组的剩余元素在全部复制到大数组的末尾</span></span><br><span class="line">                p1 &gt; mid -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">                p2 &gt; high -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="comment">// 1.一开始会比较个子数组最前端的元素大小，把小的放到最终数组的位置</span></span><br><span class="line">                copiedNums[p1] &lt; copiedNums[p2] -&gt; nums[p++] = copiedNums[p1++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; nums[p++] = copiedNums[p2++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h3 id="一句话说明-2"><a href="#一句话说明-2" class="headerlink" title="一句话说明"></a>一句话说明</h3><ol>
<li> 记录待排序数组每个取值的个数</li>
<li> 用一个数组累加记录有多少数是小于等于当前索引I</li>
<li> 逆序输出</li>
</ol>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> w = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [nums]取值范围在1到w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = nums.size</span><br><span class="line">        <span class="keyword">val</span> copied = nums.copyOf()</span><br><span class="line">        <span class="keyword">val</span> count = IntArray(w + <span class="number">1</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="comment">// 统计每个取值有多少个</span></span><br><span class="line">        <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            count[num]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加计数</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.w) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序遍历原数组，保持元素相对顺序不变</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> index = count[copied[i]] - <span class="number">1</span></span><br><span class="line">            nums[index] = copied[i]</span><br><span class="line">            count[copied[i]]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么最后要逆序遍历原数组？"><a href="#为什么最后要逆序遍历原数组？" class="headerlink" title="为什么最后要逆序遍历原数组？"></a>为什么最后要逆序遍历原数组？</h3><ol>
<li> 这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边，从而保证排序的稳定性</li>
<li> 如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法，但如果不关注稳定性，那么结果还是正确的</li>
</ol>
<p>保证相同的数字还是按照原数组中的顺序，保证稳定性</p>
<p>比如[1,2,3,4,5,5,5]</p>
<p>最后从后向前遍历原数组，3个5的输出顺序还是跟原数组的顺序是一致的</p>
<p>如果是从前向后输出，3个5的位置正好倒过来了，因为最终排序的索引是通过计数来得到的，计数是从大到小的，所以最后相同值的索引位置的计算是从大到小的，也就是说相同值的索引位置是从后往前的，如果顺序遍历原数组，遇到几个相同的数字，会先把前面的数字先放到后面了</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>O(n)时间复杂度</p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>数组取值范围是常数范围。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Class常量池、运行时常量池、字符串常量池</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA/Class%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="Class常量池"><a href="#Class常量池" class="headerlink" title="Class常量池"></a>Class常量池</h1><h2 id="Class常量池在哪，是做什么的？"><a href="#Class常量池在哪，是做什么的？" class="headerlink" title="Class常量池在哪，是做什么的？"></a>Class常量池在哪，是做什么的？</h2><p>每个Class文件中都有常量池，位于魔数和主次版本号之后，是Class文件中第一个出现的表类型的数据项，占用空间最大的数据项之一，也是与其他项目关联最多的数据类型。</p>
<p>Class常量池主要存放：</p>
<ol>
<li> 字面量（Literal）</li>
<li> 符号引用（Symbolic References）</li>
</ol>
<p>可以理解为Class文件中的资源仓库。</p>
<p>参考《深入理解Java虚拟机（第2版）》168页 6.3.2 常量池。</p>
<h3 id="字面量是什么？"><a href="#字面量是什么？" class="headerlink" title="字面量是什么？"></a>字面量是什么？</h3><p>直观的数据值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 100;</span><br><span class="line">float f = 2.3f;</span><br><span class="line">String s = &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
<p>100、2.3f、”abc”是字面量</p>
<p>0x1FB等十六进制、八进制、二进制等直观的数据值也是字面量。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/55994121/answer/147296098">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎 </a></li>
<li><a href="https://www.cnblogs.com/itplay/p/11137526.html">Java 8 中的常量池、字符串池、包装类对象池</a></li>
</ul>
<h3 id="符号引用是什么？"><a href="#符号引用是什么？" class="headerlink" title="符号引用是什么？"></a>符号引用是什么？</h3><ol>
<li> 类和接口的全限定名</li>
<li> 字段的名称和描述符 </li>
<li> 方法的名称和描述符</li>
</ol>
<blockquote>
<p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。</p>
<p>也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</p>
<p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<p>因为java要支持动态性，所以不能在编译期就确定最终的内存布局。</p>
<p>参考《深入理解Java虚拟机（第2版）》168页 6.3.2 常量池。</p>
<h4 id="字段描述符和方法的描述符是什么？"><a href="#字段描述符和方法的描述符是什么？" class="headerlink" title="字段描述符和方法的描述符是什么？"></a>字段描述符和方法的描述符是什么？</h4><p>字段的描述符唯一确定一个字段，方法的描述符唯一确定一个方法。</p>
<p>参考：</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》177页 6.3.5 字段表集合</li>
<li><a href="https://blog.csdn.net/zhangjg_blog/article/details/21487287">深入理解Java Class文件格式（二）</a></li>
</ul>
<h2 id="Class常量池的实际存储格式是什么样的"><a href="#Class常量池的实际存储格式是什么样的" class="headerlink" title="Class常量池的实际存储格式是什么样的?"></a>Class常量池的实际存储格式是什么样的?</h2><p>常量池整体上分为两部分：</p>
<ul>
<li>常量池计数器</li>
<li>常量池数据区</li>
</ul>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235549.png"></p>
<p>常量池计数器（constant_pool_count）：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。</p>
<p>常量池数据区：数据区是由（constant_pool_count-1）个cp_info结构组成，一个cp_info结构对应一个常量。在字节码中共有14种类型的cp_info（如下图6所示），每种类型的结构都是固定的。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235546.png"></p>
<p>具体以CONSTANT_utf8_info为例，它的结构如下图7左侧所示。首先一个字节“tag”，它的值取自上图6中对应项的Tag，由于它的类型是utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度Length，然后Length个字节为这个字符串具体的值。从图2中的字节码摘取一个cp_info结构，如下图7右侧所示。将它翻译过来后，其含义为：该常量类型为utf8字符串，长度为一字节，数据为“a”。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235548.png"></p>
<p>参考</p>
<ul>
<li>《深入理解Java虚拟机（第2版）》168页 6.3.2 常量池</li>
<li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团：字节码增强技术探索</a></li>
</ul>
<h2 id="Class常量池一个具体内容的例子？"><a href="#Class常量池一个具体内容的例子？" class="headerlink" title="Class常量池一个具体内容的例子？"></a>Class常量池一个具体内容的例子？</h2><p>定义如下的类：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0x101</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">this</span>.value = temp + v; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>生成的class常量池如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constant pool: </span><br><span class="line">   #1 = Methodref          #6.#29         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">   #2 = Fieldref           #5.#30         // JavaBasicKnowledge/JavaBean.value:I </span><br><span class="line">   #3 = String             #31            // abc </span><br><span class="line">   #4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.s:Ljava/lang/String; </span><br><span class="line">   #5 = Class              #33            // JavaBasicKnowledge/JavaBean </span><br><span class="line">   #6 = Class              #34            // java/lang/Object </span><br><span class="line">   #7 = Utf8               value </span><br><span class="line">   #8 = Utf8               I </span><br><span class="line">   #9 = Utf8               s </span><br><span class="line">  #10 = Utf8               Ljava/lang/String; </span><br><span class="line">  #11 = Utf8               f </span><br><span class="line">  #12 = Utf8               ConstantValue </span><br><span class="line">  #13 = Integer            257 </span><br><span class="line">  #14 = Utf8               &lt;init&gt; </span><br><span class="line">  #15 = Utf8               ()V </span><br><span class="line">  #16 = Utf8               Code </span><br><span class="line">  #17 = Utf8               LineNumberTable </span><br><span class="line">  #18 = Utf8               LocalVariableTable </span><br><span class="line">  #19 = Utf8               this </span><br><span class="line">  #20 = Utf8               LJavaBasicKnowledge/JavaBean; </span><br><span class="line">  #21 = Utf8               setValue </span><br><span class="line">  #22 = Utf8               (I)V </span><br><span class="line">  #23 = Utf8               v </span><br><span class="line">  #24 = Utf8               temp </span><br><span class="line">  #25 = Utf8               getValue </span><br><span class="line">  #26 = Utf8               ()I </span><br><span class="line">  #27 = Utf8               SourceFile </span><br><span class="line">  #28 = Utf8               StringConstantPool.java </span><br><span class="line">  #29 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V </span><br><span class="line">  #30 = NameAndType        #7:#8          // value:I </span><br><span class="line">  #31 = Utf8               abc </span><br><span class="line">  #32 = NameAndType        #9:#10         // s:Ljava/lang/String; </span><br><span class="line">  #33 = Utf8               JavaBasicKnowledge/JavaBean </span><br><span class="line">  #34 = Utf8               java/lang/Object </span><br></pre></td></tr></table></figure>

<p>字面量：</p>
<p>这里需要说明的一点，上面说的存在于常量池的字面量，指的是数据的值，也就是abc和0x101(257),通过上面对常量池的观察可知这两个字面量是确实存在于常量池的。</p>
<p>而对于基本类型数据(甚至是方法中的局部变量)，也就是上面的private int value = 1;常量池中只保留了他的的字段描述符I和字段的名称value，他们的字面量不会存在于常量池。</p>
<p>符号引用：</p>
<p>对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1450501">彻底弄懂java中的常量池</a></li>
</ul>
<h2 id="一个方法名最多可以有多长？"><a href="#一个方法名最多可以有多长？" class="headerlink" title="一个方法名最多可以有多长？"></a>一个方法名最多可以有多长？</h2><p>在HotSpot VM中，运行时常量池里，CONSTANT_Utf8_info可以表示Class文件的方法、字段等等，其结构如下：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210128235522.png"></p>
<p>首先是1个字节的tag,表示这是一个CONSTANT_Utf8_info结构的常量，然后是两个字节的length，表示要储存字节的长度，之后是一个字节的byte数组，表示真正的储存的length个长度的字符串。这里需要注意的是，一个字节只是代表这里有一个byte类型的数组，而这个数组的长度当然可以远远大于一个字节。当然，由于CONSTANT_Utf8_info结构只能用u2即两个字节来表示长度，因此长度的最大值为2byte，也就是65535。</p>
<h2 id="Android虚拟机的Class常量池跟JVM的有什么不同？"><a href="#Android虚拟机的Class常量池跟JVM的有什么不同？" class="headerlink" title="Android虚拟机的Class常量池跟JVM的有什么不同？"></a>Android虚拟机的Class常量池跟JVM的有什么不同？</h2><blockquote>
<p>Java从设计之初就非要支持分离编译（separate compilation）与按需动态类加载（on-demand dynamic class loading），导致Java的Class文件必须独立的（self-contained）——每个Class文件必须自己携带自己的常量池，其主要信息是字符串与若干其它常量的值，以及用于符号链接的符号引用信息（symbolic reference）。</p>
<p>如果大家关注过Class文件的内容的话，会知道其实通常Class文件里表示程序逻辑的代码部分——“字节码”——只占Class文件大小的小头；而大头都被常量池占了。而且多个Class文件的常量池内容之间常常有重叠，所以当程序涉及多个Class文件时，就容易有冗余信息，不利于减少传输/存储代码的大小。</p>
<p>大家或许还记得Google在Google I/O 2008的<a href="https://link.zhihu.com/?target=https://sites.google.com/site/io/dalvik-vm-internals">Dalvik VM Internals</a>演讲里，Dan得意的介绍到Dalvik的Dex格式在未压缩的情况下都比压缩了的JAR文件还小么？</p>
<p>Dan准确的介绍了Dex体积更小的原因：一个Dex相当于一个或多个JAR包，里面可以包含多个Class文件对应的内容。一个Dex文件里的所有Class都共享同一个常量池，因而不会像Class文件那样在多个常量池之间有冗余。这样Dex文件就等同于在元数据层面上对JAR文件做了压缩，所以前者比后者更小。</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/35777031/answer/64575683">栈式虚拟机和寄存器式虚拟机？</a> </li>
</ul>
<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h2 id="字符串常量池在内存区域中的哪一块？"><a href="#字符串常量池在内存区域中的哪一块？" class="headerlink" title="字符串常量池在内存区域中的哪一块？"></a>字符串常量池在内存区域中的哪一块？</h2><p><img src="https://gitee.com/picportal/pic/raw/master/img/20210225235523.png"></p>
<p>方法区实际上是在一块叫“非堆”的区域包含——可以简单粗略的理解为非堆中包含了永生代，而永生代中又包含了方法区和字符串常量池。</p>
<p>其中的Interned String就是全局共享的“字符串常量池（String Pool）”，和运行时常量池不是一个概念。但我们在代码中申明String s1 = “Hello”;这句代码后，在类加载的过程中，类的class文件的信息会被解析到内存的方法区里。</p>
<p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。</p>
<p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p>
<h2 id="String-s1-“Hello”，到底有没有在堆中创建对象？"><a href="#String-s1-“Hello”，到底有没有在堆中创建对象？" class="headerlink" title="String s1 = “Hello”，到底有没有在堆中创建对象？"></a>String s1 = “Hello”，到底有没有在堆中创建对象？</h2><p>class文件里常量池里大部分数据会被加载到“运行时常量池”，包括String的字面量；但同时“Hello”字符串的一个引用会被存到同样在“非堆”区域的“字符串常量池”中，而”Hello”本体还是和所有对象一样，创建在Java堆中。</p>
<p>当主线程开始创建s1时，虚拟机会先去字符串池中找是否有equals(“Hello”)的String，如果相等就把在字符串池中“Hello”的引用复制给s1；如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。</p>
<p>当用字面量赋值的方法创建字符串时，无论创建多少次，只要字符串的值相同，它们所指向的都是堆中的同一个对象。</p>
<h2 id="字符串常量池本质是个什么东西？"><a href="#字符串常量池本质是个什么东西？" class="headerlink" title="字符串常量池本质是个什么东西？"></a>字符串常量池本质是个什么东西？</h2><p>字符串常量池是JVM所维护的一个字符串实例的引用表。</p>
<p>在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。</p>
<h2 id="String”字面量”-是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？"><a href="#String”字面量”-是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？" class="headerlink" title="String”字面量” 是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？"></a>String”字面量” 是何时进入字符串常量池的？如何决定是否要复用字符串常量池中的驻留字符串？</h2><p>在执行ldc指令时，该指令表示int、float或String型常量从常量池推送至栈顶。</p>
<blockquote>
<p>ldc全称：load constant</p>
</blockquote>
<p>就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生），在执行ldc指令时，触发lazy resolution这个动作。</p>
<p>ldc字节码在这里的执行语义是：到当前类的运行时常量池（runtime constant pool，HotSpot VM里是ConstantPool + ConstantPoolCache）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。</p>
<p>在遇到String类型常量时，resolve的过程如果发现StringTable已经有了内容匹配的java.lang.String的引用，则直接返回这个引用，反之，如果StringTable里尚未有内容匹配的String实例的引用，则会在Java堆里创建一个对应内容的String对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p>
<p>可见，ldc指令是否需要创建新的String实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的String的引用。</p>
<h2 id="String-intern-用法和规则是什么？"><a href="#String-intern-用法和规则是什么？" class="headerlink" title="String.intern()用法和规则是什么？"></a>String.intern()用法和规则是什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">		System.out.println(str1.intern() == str1);</span><br><span class="line">		String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">		System.out.println(str2.intern() == str2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>以上代码，在 JDK6 下执行结果为 false、false，在 JDK7 以上执行结果为 true、false。</p>
<p>首先我们调用StringBuilder创建了一个”计算机软件”String对象，因为调用了new关键字，因此是在运行时创建，之前JVM中是没有这个字符串的。</p>
<p>在 JDK6 下，intern()会把首次遇到的字符串实例复制到永久代中，返回的也是这个永久代中字符串实例的引用；而在JDK1.7开始，intern()方法不再复制字符串实例，String 的 intern 方法首先将尝试在常量池中查找该对象的引用，如果找到则直接返回该对象在常量池中的引用地址。</p>
<p>因此在1.7中，“计算机软件”这个字符串实例只存在一份，存在于java堆中！通过3中的分析，我们知道当String str1 = new StringBuilder(“计算机”).append(“软件”).toString();这句代码执行完之后，已经在堆中创建了一个字符串对象，并且在全局字符串常量池中保留了这个字符串的引用，那么str1.intern()直接返回这个引用，这当然满足str1.intern() == str1——都是他自己嘛；对于引用str2，因为JVM中已经有“java”这个字符串了，因此new StringBuilder(“ja”).append(“va”).toString()会重新创建一个新的“java”字符串对象，而intern()会返回首次遇到的常量的实例引用，因此他返回的是系统中的那个”java”字符串对象引用(首次)，因此会返回false。</p>
<p>在 JDK6 下 str1、str2 指向的是新创建的对象，该对象将在 Java Heap 中创建，所以 str1、str2 指向的是 Java Heap 中的内存地址；调用 intern 方法后将尝试在常量池中查找该对象，没找到后将其放入常量池并返回，所以此时 str1/str2.intern() 指向的是常量池中的地址，JDK6常量池在永久代，与堆隔离，所以 s1.intern()和s1 的地址当然不同了。</p>
<h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><h2 id="运行时常量池是什么？"><a href="#运行时常量池是什么？" class="headerlink" title="运行时常量池是什么？"></a>运行时常量池是什么？</h2><p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过加载、链接（验证、准备、解析）、初始化，在第一步加载的时候需要完成：</p>
<ol>
<li> 通过一个类的全限定名来获取此类的二进制字节流</li>
<li> 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构    </li>
<li> 在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ol>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下不同的类共用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210225235522.png"></p>
<h2 id="运行时常量池-和-驻留字符串常量池-有什么联系？"><a href="#运行时常量池-和-驻留字符串常量池-有什么联系？" class="headerlink" title="运行时常量池  和  驻留字符串常量池  有什么联系？"></a>运行时常量池  和  驻留字符串常量池  有什么联系？</h2><p>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = &quot;abc&quot;;</span><br><span class="line">String str2 = new String(&quot;def&quot;);</span><br><span class="line">String str3 = &quot;abc&quot;;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = &quot;def&quot;;</span><br><span class="line">System.out.println(str1 == str3); // true</span><br><span class="line">System.out.println(str2 == str4); // false</span><br><span class="line">System.out.println(str4 == str5); // true</span><br></pre></td></tr></table></figure>

<p>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p>
<p>回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。</p>
<p>“abc”的常量会被ldc指令从常量池推送到栈顶，ldc会触发动态解析。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/itplay/p/11137526.html">【JVM】Java 8 中的常量池、字符串池、包装类对象池</a></li>
<li><a href="https://www.zhihu.com/question/55994121/answer/147296098">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎 </a></li>
<li><a href="https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">Java中几种常量池的区分</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1450501">彻底弄懂java中的常量池</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Class常量池</tag>
        <tag>运行时常量池</tag>
        <tag>字符串常量池</tag>
        <tag>驻留字符串</tag>
        <tag>String.intern()</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类-HashMap原理</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/Java%E9%9B%86%E5%90%88%E7%B1%BB-HashMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>JDK 1.7：</p>
<ul>
<li><a href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.7-Java%20SE%20Development%20Kit%207u80/src/java/util/HashMap.java</a></li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li><a href="https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java">https://sourcegraph.com/github.com/zxiaofan/JDK/-/blob/JDK1.8/src/java/util/HashMap.java</a></li>
</ul>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ol>
<li> 非线程安全，所以存取速度快</li>
<li> 可以接受null的键和值</li>
<li> 不保证key有序</li>
<li> key的顺序会随时间变化（动态调整大小后会变化）</li>
</ol>
<h1 id="散列过程"><a href="#散列过程" class="headerlink" title="散列过程"></a>散列过程</h1><ol>
<li> 通过散列函数，用元素的key计算出元素在数组中的索引位置</li>
<li> 解决散列冲突，即相同散列值（数组索引位置）元素如何存取</li>
</ol>
<h1 id="散列函数的选取标准"><a href="#散列函数的选取标准" class="headerlink" title="散列函数的选取标准"></a>散列函数的选取标准</h1><ol>
<li> 易于计算</li>
<li> 均匀分布所有键</li>
</ol>
<h1 id="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"><a href="#拉链法查找一个元素的最少、最坏、平均次数分别是多少？" class="headerlink" title="拉链法查找一个元素的最少、最坏、平均次数分别是多少？"></a>拉链法查找一个元素的最少、最坏、平均次数分别是多少？</h1><p>设哈希表大小为m，已存储的元素个数为n</p>
<p>如果散列函数把所有元素散列到一个位置，链表的长度就是n，最坏情况下就是查找链表中最后一个元素，查找次数是n</p>
<p>如果散列函数散列到哈希表每个位置的概率相同，此时元素分布最均匀，拉链法相当于把n个元素分为m组，那么每组（链表）长度最多为n/m，最坏情况下查找链表最后一个元素，需要n/m次</p>
<h1 id="桶（bucket）是什么意思？"><a href="#桶（bucket）是什么意思？" class="headerlink" title="桶（bucket）是什么意思？"></a>桶（bucket）是什么意思？</h1><p>HashMap内部的哈希表由数组实现，数组的每一个位置称为桶，存储一个链表的头结点，或红黑树的根节点，一个桶下所有元素key的hashCode都相同，元素存储在哪一个桶是根据元素key计算出数组索引位置而定的</p>
<h1 id="什么情况下会要求哈希表的大小要是质数？"><a href="#什么情况下会要求哈希表的大小要是质数？" class="headerlink" title="什么情况下会要求哈希表的大小要是质数？"></a>什么情况下会要求哈希表的大小要是质数？</h1><p>简述：</p>
<ul>
<li>关注哈希表的大小是因为求得元素在哈希表中存储存储位置是通过  key的hashCode % 哈希表大小  得到，如果散列函数计算结果不均匀，容易产生散列冲突，提高了查找次数。</li>
<li>质数不容易被整除，故而可以让计算出的索引分布的比较均匀。合数有公因子，计算出的索引位置容易聚集在公因数的位置，产生较多的散列冲突。</li>
</ul>
<p>key与哈希表大小互质，这样取模的结果就分散的比较均匀。</p>
<p>如果key可以整除哈希表大小，如果key容易在公因数的位置产生聚集，就会产生较多的散列冲突。</p>
<p>使用质数作为容量，可以使元素更分散，减少冲突；</p>
<p>如果用合数作为容量，会使元素聚集，增加冲突，增加查找次数。</p>
<p>一般是通过除留取余法确定元素在数组中存储索引位置，即：</p>
<p>元素在数组中的存储位置 = key的hashCode % 哈希表长度</p>
<p>假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。</p>
<p>例如2 4 6 8 10 12这6个数，如果对 6 取余  得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多，并且呈现以合数的因子为间隔增长；如果对 7取余  得到 2 4 6 1 3 5 得到6种HASH值，没有冲突。</p>
<p>用质数作为数组容量使得任何数想整除它是不可能的，因此探测序列最终会检查到所有单元，冲突较少。</p>
<p>当散列函数计算结果的均匀性较差时，最好使用质数作为哈希表大小可以在除留取余时使得计算出的索引位置分布的更均匀。</p>
<p>但是库一般都会提供散列比较均匀的散列函数，只要散列函数设计的均匀，什么数做桶的大小都行，有时为了方便支持桶的动态扩容或者避免使用除法，桶的大小使用2的幂。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？
</a></li>
<li><a href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">算法分析：哈希表的大小为何是素数</a></li>
<li><a href="https://blog.moew.xyz/2019/07/29/%E4%B8%BA%E4%BD%95%E5%9C%A8%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%EF%BC%8C%E8%A6%81%E5%B0%BD%E9%87%8F%E5%8F%96%E7%B4%A0%E6%95%B0/">为何在散列表中除留余数法取模运算中，要尽量取素数
</a></li>
</ul>
<h1 id="为什么桶容量要是2的次方？"><a href="#为什么桶容量要是2的次方？" class="headerlink" title="为什么桶容量要是2的次方？"></a>为什么桶容量要是2的次方？</h1><p>散列表用数组实现时，要计算元素应当存储在数组的哪个位置（索引），应当将元素key的hashCode对散列表大小取模，取模结果就是元素要存放在数组的索引位置。</p>
<p>如果key的hashCode函数不能把key散列的均匀，就需要用质数作为哈希表大小，在除留取余的求数组索引时能够让元素分布的比较均匀。</p>
<p>如果key的hashCode能够散列的比较均匀，那么其实用什么数作为哈希表大小都可以。</p>
<p>桶容量为2的幂时取模的好处：<br>1.可以用位运算取模，计算速度更快，位运算也很方便。<br>2.可以让元素分布的均匀，减少散列冲突。<br>3.方便扩容计算，扩容也只需要乘以2，容量左移一位。</p>
<h1 id="为什么2的幂的容量可以让元素分布更均匀？"><a href="#为什么2的幂的容量可以让元素分布更均匀？" class="headerlink" title="为什么2的幂的容量可以让元素分布更均匀？"></a>为什么2的幂的容量可以让元素分布更均匀？</h1><p>位运算对2的幂取模过程：一个二进制数乘以2的n次方相当于将该数左移n位，一个二进制数除以2的n次方相当于将该数右移n位，右移出界的部分就是余数，其实也就是原数低n位，取低n位的数，只需要将原数跟低位是n个1的二进制数做与操作就可以得到，低位是n个1的二进制数可以由2的n次方再减1得到。</p>
<p>如果对不是2的幂的数进行位运算取模，假设这个数是x，x-1的二进制数一定不是全部都是1，而是含有0，此时x-1与原数做与操作后，那些有0的位置都会用不到，造成空间浪费，也增大了散列冲突。如果x-1全部是1的话，只要key的hashCode的二进制中的1在低n位分布均匀，就可以保证计算index的过程是分布均匀的，要求x-1的二进制全部是1，那么x就是2的幂。</p>
<h1 id="通过构造函数传入不是2的幂的容量值会怎样？"><a href="#通过构造函数传入不是2的幂的容量值会怎样？" class="headerlink" title="通过构造函数传入不是2的幂的容量值会怎样？"></a>通过构造函数传入不是2的幂的容量值会怎样？</h1><p>会找一个最接近传入容量的2的幂作为实际桶的容量。</p>
<h1 id="哈希表容量是2的幂会有什么问题？"><a href="#哈希表容量是2的幂会有什么问题？" class="headerlink" title="哈希表容量是2的幂会有什么问题？"></a>哈希表容量是2的幂会有什么问题？</h1><p>key的hash取余求索引时，会截断hash的高位，如果多个key的hash的低位比较固定，高位变化较大，那么最后计算的散列冲突就很多了。</p>
<p>所以需要扰动函数处理一下key的hash，把高位的变化信息传递到低位。</p>
<h1 id="扰动函数是什么，起到什么作用？"><a href="#扰动函数是什么，起到什么作用？" class="headerlink" title="扰动函数是什么，起到什么作用？"></a>扰动函数是什么，起到什么作用？</h1><p>存储一个元素时，需要决定该元素应该存储在table（桶）中哪一个位置，需要用元素的key的hashCode对桶容量做取模运算来获得要存储的数组索引位置。</p>
<p>如果桶容量较小，取模操作会仅对key.hashCode()的低位做运算，如果多个元素的key的hashCode()低位相同，只是高位不同，那么冲突就较多，所以需要将高位和低位结合起来取模，减少冲突，避免散列分布不均。</p>
<p>所以在对hashCode做取模运算之前，还需要让hashCode经过扰动函数扰动一下。</p>
<p>jdk1.8中对key的hashCode的扰动函数做了优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将key.hashCode()的低16位和高16位做异或运算。</p>
<p>仅仅异或一下做扰动，权衡了速度、性能、质量，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<h2 id="为什么是右移16位？"><a href="#为什么是右移16位？" class="headerlink" title="为什么是右移16位？"></a>为什么是右移16位？</h2><p>推测：因为java中int是32位的，高16位和低16位异或已经算是顾全到了数字的二进制的每一位。</p>
<p>实际：权衡了速度、性能、质量</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
</ul>
<h2 id="扰动函数为什么是异或运算？"><a href="#扰动函数为什么是异或运算？" class="headerlink" title="扰动函数为什么是异或运算？"></a>扰动函数为什么是异或运算？</h2><ol>
<li> 实现简单，运算快捷</li>
<li>对参与运算的两方的二进制的每一位都各自有50%的概率影响结果输出</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">Why is XOR the default way to combine hashes?</a></li>
</ul>
<h1 id="桶的最大容量为什么是2的30次方，不是2的31次方？"><a href="#桶的最大容量为什么是2的30次方，不是2的31次方？" class="headerlink" title="桶的最大容量为什么是2的30次方，不是2的31次方？"></a>桶的最大容量为什么是2的30次方，不是2的31次方？</h1><p>java中int是32位，理论上1可以最多左移31位，因为1不移动就占了1位，所以可以移动的位数是32-1=31位；而虚拟机规定int类型最高位是符号位，符号位不参与移动，可移动位数就是31-1=30位</p>
<h1 id="两个key对象的hashCode相同，如何获取value对象"><a href="#两个key对象的hashCode相同，如何获取value对象" class="headerlink" title="两个key对象的hashCode相同，如何获取value对象?"></a>两个key对象的hashCode相同，如何获取value对象?</h1><p>在遍历该桶的链表，链表中每个节点保存了键值对信息，将目标key与每个节点的key调用equals方法比较，相等的则为想要找到的节点，取其value对象。</p>
<h1 id="什么对象适合做为HashMap的key"><a href="#什么对象适合做为HashMap的key" class="headerlink" title="什么对象适合做为HashMap的key?"></a>什么对象适合做为HashMap的key?</h1><p>使用String，Integer等系统类比较好，因为他们的hashCode方法实现是比较均匀的，可以减少散列冲突。</p>
<p>其次这些类一旦创建都是不可变的，一来可以缓存hashCode，二来保证唯一性，三来线程安全。</p>
<h1 id="自定义对象实现hashCode-方法有什么注意事项？"><a href="#自定义对象实现hashCode-方法有什么注意事项？" class="headerlink" title="自定义对象实现hashCode()方法有什么注意事项？"></a>自定义对象实现hashCode()方法有什么注意事项？</h1><p><strong>原则：</strong><br>一个对象的hashCode应该认为有均等的机会得到2的32次方中的任意一个32位整数值。</p>
<p><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205744.png" alt="《算法4》节选"></p>
<p>一个优秀的散列方法需要满足三个条件：</p>
<ul>
<li>一致性 - 等价的键必然产生相等的散列值</li>
<li>高效性 - 计算简便</li>
<li>均匀性 - 均匀地散列所有的键</li>
</ul>
<p>保证均匀性的最好办法也许是保证键的每一位都在散列值的计算中起到了相同的作用，实现散列函数最常见的错误是忽略了高位的键。</p>
<p>可以参考String的hashCode设计，kotlin的data class自动生成的hashCode以及集合类的hashCode算法都很相似。</p>
<p>需要使用不可变的属性实现hashCode()方法，因为：</p>
<ol>
<li> 可以在计算一次哈希值后缓存起来，提高哈希表的读取速度。</li>
<li> 如果key在放入哈希表时和取出哈希表时hashCode()发生变化，则会取不到之前存放的对象。</li>
<li> 不可变的属性是线程安全的。</li>
</ol>
<h1 id="装载因子是什么？"><a href="#装载因子是什么？" class="headerlink" title="装载因子是什么？"></a>装载因子是什么？</h1><p>哈希表中已存储元素个数与哈希表总大小比值，即已存储元素个数与桶个数比值。</p>
<p>装载因子越大，说明填充率高，空间利用率高，但是散列冲突可能性增大。</p>
<p>装载因子越小，说明填充率低，浪费很多空间，但是散列冲突可能性减小。</p>
<p>冲突越多，查找元素的时间越长，所以必须在时间和空间上进行权衡。</p>
<h1 id="装载因子有什么作用？"><a href="#装载因子有什么作用？" class="headerlink" title="装载因子有什么作用？"></a>装载因子有什么作用？</h1><p>装载因子 = 已存储的元素个数 / 桶大小</p>
<p>HashMap构造时可以传入一个装载因子，不传入的话会使用默认的装载因子0.75，构造时规定这个装载因子意思是装载因子的最大值。</p>
<p>随着哈希表中存储元素的个数增多，填充率越高，实际的装载因子会逐渐增大，当  实际装载因子  大于  预设装载因子  时，为了避免大量的散列冲突，要增大桶的数量，HashMap会将通大小调整为原来的两倍，因为桶大小要求是2的幂，所以就扩大2倍。</p>
<h1 id="桶容量是如何动态扩展的？"><a href="#桶容量是如何动态扩展的？" class="headerlink" title="桶容量是如何动态扩展的？"></a>桶容量是如何动态扩展的？</h1><p>当  已存储元素个数  超过  哈希表大小 * 装载因子，会扩容至原大小的两倍，并对部分元素重新散列。</p>
<p>当put元素时，发现已存储元素个数超过threshold时，会触发扩容。</p>
<p>threshold的首次赋值由构造HashMap时传入的初始容量和装载因子决定。</p>
<p>threshold = 初始容量 * 装载因子</p>
<p>每次扩容桶（table）大小会变为原来两倍，threshold也会变为原来的两倍。</p>
<h1 id="构造函数传入不是2的幂的初始容量会怎样？"><a href="#构造函数传入不是2的幂的初始容量会怎样？" class="headerlink" title="构造函数传入不是2的幂的初始容量会怎样？"></a>构造函数传入不是2的幂的初始容量会怎样？</h1><p>不管传什么初始容量，都会经由tableSizeFor()计算得到大于等于传入的初始容量的最小的2的幂作为桶的实际容量大小</p>
<p>在put()时触发resize()，threshold也会被重新赋值为桶容量乘以装载因子。</p>
<h1 id="tableSizeFor-算法过程是怎样的？"><a href="#tableSizeFor-算法过程是怎样的？" class="headerlink" title="tableSizeFor()算法过程是怎样的？"></a>tableSizeFor()算法过程是怎样的？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三种情况</p>
<ol>
<li>cap小于0，返回1</li>
<li>cap经过位运算后大于等于MAXIMUM_CAPACITY，返回MAXIMUM_CAPACITY</li>
<li>cap经过位运算后返回n+1</li>
</ol>
<p>先考虑正常的情况，对于一个给定的cap，分为两种情况，cap可能是2的幂或非2的幂。</p>
<ol>
<li>当cap不是2的幂，例如10，二进制为1010，cap - 1 = 1001，几个右移操作实际的结果就是从cap - 1的二进制的1的最高位开始到最低位全部变成1，最后返回n + 1就是2的幂了</li>
<li>当cap是2的幂，例如16，二进制为10000，cap-1 = 1111，右移操作后n还是为1111，n+1就还是16</li>
</ol>
<p>所以正常情况下tableSizeFor()得出的就是大于等于cap的数</p>
<p>如果cap一开始不减1，当cap是2的幂时，最后计算得出的就会是cap的2倍</p>
<p>cap小于0，没有实际的意义，不能表示桶容量，故而返回最小正整数1</p>
<p>cap大于等于MAXIMUM_CAPACITY时，MAXIMUM_CAPACITY是2的30次方，此时cap的二进制最高位1是在第31位，逻辑右移再加1会得到32个1，int中最高位（第32位）是符号位，最高位1表示负数了，没有意义，故而将最大值限定在2的30次方，2的30次方减1的二进制是从第1位到第30位全都是1</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）
</a></li>
</ul>
<h1 id="为什么要调整桶大小？"><a href="#为什么要调整桶大小？" class="headerlink" title="为什么要调整桶大小？"></a>为什么要调整桶大小？</h1><p>为了减少散列冲突，减少元素查找次数</p>
<h1 id="为什么桶初始容量是16？"><a href="#为什么桶初始容量是16？" class="headerlink" title="为什么桶初始容量是16？"></a>为什么桶初始容量是16？</h1><p>这个问题不好解答可以考虑边界情况，桶容量过大、过小会导致什么</p>
<p>桶容量过大会导致大量空间浪费</p>
<p>桶容量过小会导致频繁扩容，扩容一次是耗时的</p>
<p>16应当是一个权衡评估后得出的值</p>
<h1 id="默认装载因子为什么是0-75？"><a href="#默认装载因子为什么是0-75？" class="headerlink" title="默认装载因子为什么是0.75？"></a>默认装载因子为什么是0.75？</h1><p>可以先考虑装载因子过大和过小分别会有什么问题</p>
<p>装载因子过大，表明哈希表填充率高，但是散列冲突的可能性大，查找元素的次数多</p>
<p>装载因子过小，表明哈希表的空闲空间大，空间利用率低，但冲突较少，查找元素次数少</p>
<p>0.75乘以2的幂是整数，不需要再做四舍五入，计算方便</p>
<p>根据HashMap注释</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost(reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>参考资料</p>
<ul>
<li><a href="https://blog.csdn.net/reliveIT/article/details/82960063">HashMap defaultLoadFactor = 0.75和泊松分布没有关系
</a></li>
<li><a href="https://www.jianshu.com/p/64f6de3ffcc1">HashMap的loadFactor为什么是0.75？
</a></li>
<li><a href="https://stackoverflow.com/a/31401836/2011291">StackOverflow: What is the significance of load factor in HashMap?
</a></li>
</ul>
<h1 id="resize-的大致过程"><a href="#resize-的大致过程" class="headerlink" title="resize()的大致过程"></a>resize()的大致过程</h1><p>根据resize()方法的注释所言，resize()会将桶容量扩充两倍，由于容量是2的幂，原来桶中的元素位置要么是原封不动，要么是再移动2的幂个位置。</p>
<p>求元素的在table中的索引依然是  元素key的hashCode &amp; (桶容量-1)</p>
<p>例如原来容量是16，二进制为10000，求元素索引时是 hashCode &amp; 1111</p>
<p>扩容两倍后容量是32，二进制位100000，求元素索引的计算变成了 hashCode &amp; 11111，比之前多了一个1，如果元素key的hashCode在该位也是1，等同于元素的索引位置增加了2的幂。</p>
<p>桶中是链表时，会将链表划分为两个链表，一个留在原桶，一个放入移动了2的幂的桶中。</p>
<p>为什么要这样调整？原封不动不行吗？</p>
<p>因为这样做是为了保证散列均匀，减少冲突。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现
</a></li>
</ul>
<h1 id="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"><a href="#为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？"></a>为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？</h1><p>因为节点数过少时，红黑树的插入、删除的成本比链表要高很多。</p>
<p>在散列均匀的情况下，冲突较少，每个桶中链表的平均长度比较短，性能可接受。</p>
<h1 id="为什么链表的长度为8时变成红黑树？"><a href="#为什么链表的长度为8时变成红黑树？" class="headerlink" title="为什么链表的长度为8时变成红黑树？"></a>为什么链表的长度为8时变成红黑树？</h1><p>根据jdk1.8的HashMap中的注释所言，假设散列分布均匀，在负载因子为0.75的条件下，某一个桶中元素出现的频率满足λ为0.5的泊松分布。从概率来看，之所以链表长度超过 8 以后要变成红黑树，因为在散列分布均匀的情况下出现这种情况的概率小到忽略不计，一旦出现，几乎可以认为是散列函数设计有问题导致的，即散列不均匀。</p>
<p>所以红黑树是专门应对元素key糟糕的（分布不均匀）的散列函数而准备的。</p>
<p>二项分布：n次重复独立伯努利试验，一次伯努利实验只有两种对立的结果。</p>
<p>泊松分布：当二项分布的n很大，p很小时，可以近似为泊松分布。</p>
<p>算法第四版465页：<br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205936.png"><br><img src="https://gitee.com/picportal/pic/raw/master/img/20210825205952.png"></p>
<p>散列均匀时，每个桶的链表的平均长度为  实际元素总数  / 哈希表大小，这个就是装载因子λ</p>
<p>现在的问题就是，将N个元素随机放入M个桶，每个桶的元素平均个数为λ（N/M），求每个桶元素个数为k的概率。</p>
<p>对于某一个桶而言，一个元素放入桶中是一个二元结果，要么放入，要么不放入，散列均匀的情况下，不管有多少个桶，每个元素出现在同一个桶的概率是相同，每个桶中平均有λ个元素时，那么一个元素出现在同一个桶的概率就是λ/N，就是桶元素数量占元素总数的比值，理解很直观。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://ysmull.cn/JCF/HashMap.html">谈谈 HashMap 实现中的若干数学问题
</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26263743">泊松分布 (Poisson Distributions) 的推导
</a></li>
</ul>
<h1 id="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"><a href="#为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？" class="headerlink" title="为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？"></a>为何红黑树节点数在小于等于6时又变成链表？为什么不是小于等于8时变回链表？</h1><p>是为了防止频繁插入和删除元素时不停的在树和链表之间互相转换、降低性能，红黑树和链表之间的转换是有成本的。</p>
<h1 id="MIN-TREEIFY-CAPACITY是做什么的？"><a href="#MIN-TREEIFY-CAPACITY是做什么的？" class="headerlink" title="MIN_TREEIFY_CAPACITY是做什么的？"></a>MIN_TREEIFY_CAPACITY是做什么的？</h1><p>桶中元素超过TREEIFY_THRESHOLD个（8个）后，还要保证哈希表数组table的大小大于等于MIN_TREEIFY_CAPACITY才会把链表转红黑树，容量过小时使用红黑树性价比不高，用扩容来解决桶元素堆积的问题更适合。</p>
<p>这个值为什么要是4 * TREEIFY_THRESHOLD，是为了避免在resize和树化之间产生冲突，比如初始容量是16，装载因子0.75，存储元素有16*0.75=12个时就应该扩容，但是此时如果是4个元素在一个桶，8个元素在另外一个桶，是要先树化的，树化后再等resize扩容了，可能又要将红黑树链表化，这样反复来回影响性能。</p>
<h1 id="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"><a href="#平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？" class="headerlink" title="平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？"></a>平衡二叉搜索树中为何选用红黑树？用AVL树会有什么问题？红黑树和AVL树有何区别？</h1><p>单次的插入和删除操作：</p>
<p>单次插入数据，红黑树和AVL树平均都只需要几次旋转即可完成。</p>
<p>单次删除元素，红黑树大多数只需要几次旋转调整，AVL树需要调整查找路径上所有结点。</p>
<p>大量的插入和删除操作：</p>
<p>红黑树由于是基于2-3树，3结点的存在可以吸纳一部分不平衡性，不用做频繁的旋转调整。</p>
<p>AVL树需要始终保持平衡，在大量插入或删除元素后，AVL树的调整的次数多于红黑树。</p>
<p>在大量数据的统计意义上，红黑树的插入和删除次数相对于AVL树较少，适合插入和删除频繁的场景。</p>
<p>AVL树由于是高度平衡的，红黑树不是高度平衡，AVL树的查找次数比红黑树更少，适合对查询效率非常敏感，插入和删除不频繁的场景。</p>
<p>红黑树的查询跟AVL树仍然是同一个数量级，所以综合查询、插入、删除的性能，红黑树表现较好。</p>
<p>参考</p>
<ul>
<li><a href="https://www.zhihu.com/question/20545708/answer/58717264">为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 </a></li>
<li><a href="https://www.zhihu.com/question/19856999/answer/944180969">红黑树比 AVL 树具体更高效在哪里？ - 伍亦勤的回答 - 知乎</a></li>
<li><a href="https://stackoverflow.com/questions/16257761/difference-between-red-black-trees-and-avl-trees">Difference between red-black trees and AVL trees</a></li>
<li><a href="https://blog.csdn.net/21aspnet/article/details/88939297">为什么Java8中HashMap链表使用红黑树而不是AVL树
</a></li>
</ul>
<h1 id="put方法大致过程"><a href="#put方法大致过程" class="headerlink" title="put方法大致过程"></a>put方法大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>table数组为null则通过resize()初始化table，创建HashMap对象不会立刻初始化table数组</li>
<li>利用扰动后的hashCode除留取余求得元素在table中的索引</li>
<li>如果没有碰撞冲突，直接存入桶中</li>
<li>如果有碰撞冲突，桶中维护一个链表存储哈希值相同的元素，java7是头插法，java8是尾插法</li>
<li>链表长度超过TREEIFY_THRESHOLD，链表转为红黑树</li>
<li>如果元素已存在，替换value。元素存在先通过key的hashCode查看桶中是否有元素，没有则不存在，有元素需要依次遍历桶中元素，通过key的equals方法比较是否相等，有相等的则存在。</li>
<li> 哈希表实际存储元素数量超过了阈值threshold（哈希表大小 * 装载因子），调用resize()扩容。</li>
</ol>
<h1 id="get方法的大致过程"><a href="#get方法的大致过程" class="headerlink" title="get方法的大致过程"></a>get方法的大致过程</h1><ol>
<li>获取key的hashCode()并扰动</li>
<li>根据哈希值求得table索引</li>
<li>若桶中第一个元素命中，直接返回</li>
<li> 有冲突则依次遍历链表或红黑树，通过key的equals比较来寻找目标节点，找到了返回其value，没有找到返回null</li>
</ol>
<h1 id="HashMap为什么线程不安全？高并发下会产生什么问题？"><a href="#HashMap为什么线程不安全？高并发下会产生什么问题？" class="headerlink" title="HashMap为什么线程不安全？高并发下会产生什么问题？"></a>HashMap为什么线程不安全？高并发下会产生什么问题？</h1><p>一句话：jdk7的HashMap在扩容时会改变链表中元素原本的顺序，高并发情况下容易导致链表产生环，进而导致死循环，CPU占用率飙升到100%。</p>
<p>jdk7中扩容采用头插法是考虑到缓存的时间局部性原则，最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数。</p>
<p>jdk8中扩容改为尾插法，高并发情况下不会产生死循环了，但是resize依然不是原子性的，可能会产生数据丢失。</p>
<p>其他方法例如链表和红黑树互转的过程，都不是原子性的，都可能会产生数据丢失的问题。</p>
<p>参考</p>
<ul>
<li><a href="https://www.jianshu.com/p/e2f75c8cce01">为什么HashMap线程不安全
</a></li>
</ul>
<h1 id="Java-8-对HashMap做出了哪些改进？"><a href="#Java-8-对HashMap做出了哪些改进？" class="headerlink" title="Java  8  对HashMap做出了哪些改进？"></a>Java  8  对HashMap做出了哪些改进？</h1><ol>
<li>桶中链表长度超过8将链表转为红黑树，以应对不均匀的散列函数导致的查询次数增多</li>
<li> 链表插入元素由头插法改为尾插法，以解决并发下插入元素时链表产生环进而导致的死循环</li>
</ol>
<h1 id="modCount是做什么的？"><a href="#modCount是做什么的？" class="headerlink" title="modCount是做什么的？"></a>modCount是做什么的？</h1><p>对哈希表做出了修改（添加和删除元素），modCount就会增加，表示修改的次数，使用迭代器迭代哈希表时一旦发现modCount变化了，就会立刻抛出ConcurrentModificationException，以避免迭代时的不确定性，这称为fail-fast机制。注意修改一个已存在的元素的value不改变modCount。</p>
<h1 id="HashMap的缺点是什么？想要用哈希表还有哪些选择？"><a href="#HashMap的缺点是什么？想要用哈希表还有哪些选择？" class="headerlink" title="HashMap的缺点是什么？想要用哈希表还有哪些选择？"></a>HashMap的缺点是什么？想要用哈希表还有哪些选择？</h1><p>缺点就是结构复杂，占用内存可能较多，对哈希表有简单需求的地方不需要这么复杂而完善的类</p>
<p>例如ThreadLocalMap就自己实现了一套简单的哈希表，采用开放定址法</p>
<p>还有Android上SparseArray、ArrayMap实现的内存消耗更低的哈希表</p>
<h1 id="HashMap与Hashtable的区别？"><a href="#HashMap与Hashtable的区别？" class="headerlink" title="HashMap与Hashtable的区别？"></a>HashMap与Hashtable的区别？</h1><ol>
<li> Hashtable的get、put、clear、contains、size等大部分方法上都加上了synchronized关键字，给整个对象上锁，HashMap非线程安全</li>
<li> Hashtable中没有红黑树仅有链表</li>
<li> Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li> Hashtable不允许null的key和value，而HashMap都允许</li>
<li> Hashtable求key的hashCode没有扰动</li>
<li> HashMap和Hashtable使用Iterator遍历元素过程中对哈希表添加或删除元素是会抛出异常的（fast-fail），但Hashtable用Enumeration迭代时不会fast-fail，因为通过Enumeration的nextElement()获取下一个元素时没有对modCount做判断，而Iterator的next方法对modCount做了判断。</li>
<li> Hashtable是jdk1添加的，HashMap是jdk2添加的</li>
</ol>
<p>Dictionary已被废弃，所以Hashtable已经被废弃，而且同步性能较差，大多数操作都会锁住整个对象。用jdk1.5引入的采用分段锁的ConcurrentHashMap同步性能更好。</p>
]]></content>
      <categories>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>集合类</tag>
        <tag>HashMap</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图的连通</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A/</url>
    <content><![CDATA[<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>有两个图G=(V,E)和G’=(V’,E’)，V’是V的子集且E’是E的子集，称G’是G的子图。</p>
<p>并非所有V和E的子集都能构成G的子图，因为这样的子集可能不是图。</p>
<h2 id="连通"><a href="#连通" class="headerlink" title="连通"></a>连通</h2><p>无向图中顶点u到顶点v之间有一条路径，称顶点u和顶点v是连通的。</p>
<h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><p>有向图中顶点u到顶点v之间有一条路径，顶点v到顶点u之间也有一条路径，称顶点u和顶点v是强连通的。</p>
<h2 id="弱连通"><a href="#弱连通" class="headerlink" title="弱连通"></a>弱连通</h2><p>有向图中顶点u到顶点v之间有一条路径，顶点v到顶点u之间没有路径，称顶点u和顶点v是弱连通的</p>
<h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>无向图中任意两个顶点连通，称此无向图为连通图。</p>
<h2 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h2><p>有向图中任意两个顶点强连通，称此有向图为强连通图。</p>
<h2 id="弱连通图"><a href="#弱连通图" class="headerlink" title="弱连通图"></a>弱连通图</h2><p>有向图的边去掉方向后是一个连通图，称此有向图为弱连通图。</p>
<h2 id="非连通图"><a href="#非连通图" class="headerlink" title="非连通图"></a>非连通图</h2><p>一个图的顶点数为n，若边数小于n-1，则该图是非连通图，即图的所有边无法连接图中所有的顶点。</p>
<p><img src="data:image/png;base64,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" alt="非连通图"></p>
<h2 id="连通子图"><a href="#连通子图" class="headerlink" title="连通子图"></a>连通子图</h2><p>在非连通图中，存在至少两个连通的子图。</p>
<h2 id="极大连通子图（针对无向图）"><a href="#极大连通子图（针对无向图）" class="headerlink" title="极大连通子图（针对无向图）"></a>极大连通子图（针对无向图）</h2><p>非连通图中的连通子图称为极大连通子图。</p>
<h4 id="加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？"><a href="#加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？" class="headerlink" title="加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？"></a>加入任何一个不在它的点集中的点都会导致它不再连通，极小连通子图似乎也有这个性质？</h4><p>无向连通图只有一个极大连通子图，就是本身。</p>
<h2 id="极小连通子图（针对无向图）"><a href="#极小连通子图（针对无向图）" class="headerlink" title="极小连通子图（针对无向图）"></a>极小连通子图（针对无向图）</h2><p>保持子图连通但边数最少。</p>
<p>若极小连通子图有n个顶点，则其有n - 1条边。</p>
<h2 id="极大强连通子图（针对有向图）"><a href="#极大强连通子图（针对有向图）" class="headerlink" title="极大强连通子图（针对有向图）"></a>极大强连通子图（针对有向图）</h2><p>子图中的每两个顶点都是强连通的。</p>
<p>推论：一个环肯定是极大强连通子图，每两个顶点互相都有路径到达。</p>
<p><img src="data:image/png;base64,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"></p>
<h2 id="连通分量（针对无向图）"><a href="#连通分量（针对无向图）" class="headerlink" title="连通分量（针对无向图）"></a>连通分量（针对无向图）</h2><p>无向图中的极大连通子图称为无向图的连通分量。</p>
<p>无向连通图只有一个连通分量，为本身。</p>
<h2 id="强连通分量（针对有向图）"><a href="#强连通分量（针对有向图）" class="headerlink" title="强连通分量（针对有向图）"></a>强连通分量（针对有向图）</h2><p>有向图的极大强连通子图。</p>
<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><p>对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。</p>
<p>来自 &lt;<a href="https://oi-wiki.org/graph/cut/">https://oi-wiki.org/graph/cut/</a>&gt;</p>
<h2 id="桥（割边）"><a href="#桥（割边）" class="headerlink" title="桥（割边）"></a>桥（割边）</h2><p>对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。</p>
<p>来自 &lt;<a href="https://oi-wiki.org/graph/cut/">https://oi-wiki.org/graph/cut/</a>&gt;</p>
<h2 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h2><p>dfn[u]是图的dfs节点访问次序，dfn意为depth first number</p>
<p>low[u]是默认为dfn[u]，如果dfs时通过一条边访问到了已访问的节点，选取已访问节点中的最小的dfn值</p>
<p>low数组在另一个意义上可以看作，把有环的部分给标记出来了，环上的节点low值都一样</p>
<p>参考资料：</p>
<ul>
<li> <a href="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）</a></li>
<li><a href="https://oi-wiki.org/graph/scc/">OI WIKI: Tarjan算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101923309">60 分钟搞定图论中的 Tarjan 算法（一）</a>&gt;</li>
<li><a href="https://blog.csdn.net/hurmishine/article/details/75248876">全网最!详!细!Tarjan算法讲解。</a>&gt;</li>
</ul>
<h2 id="tarjan算法有什么应用场景"><a href="#tarjan算法有什么应用场景" class="headerlink" title="tarjan算法有什么应用场景?"></a>tarjan算法有什么应用场景?</h2><ol>
<li> 求图的割点</li>
<li> 求图的割边（桥）</li>
<li> 判断图的连通性</li>
<li> 判断图有没有环</li>
</ol>
<h2 id="tarjan算法为什么可以判断图的割点和割边？"><a href="#tarjan算法为什么可以判断图的割点和割边？" class="headerlink" title="tarjan算法为什么可以判断图的割点和割边？"></a>tarjan算法为什么可以判断图的割点和割边？</h2><p>判断一个顶点是不是割点除了从定义，还可以从DFS（深度优先遍历）的角度出发。我们先通过DFS定义两个概念。</p>
<p>假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的父顶点，V为U的孩子顶点。在顶点U之前被访问过的顶点，我们就称之为U的祖先顶点。</p>
<p>显然如果顶点U的所有孩子顶点可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U至少存在一个孩子顶点，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。</p>
<p>来自：<a href="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）</a></p>
<h2 id="tarjan算法在LeetCode中的可以应用的题目？"><a href="#tarjan算法在LeetCode中的可以应用的题目？" class="headerlink" title="tarjan算法在LeetCode中的可以应用的题目？"></a>tarjan算法在LeetCode中的可以应用的题目？</h2><ul>
<li><a href="https://leetcode-cn.com/problems/critical-connections-in-a-network/">1192.查找集群内的关键连接</a></li>
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ViewDragHelper源码解析</title>
    <url>/2015-05-21-viewdraghelper-source-analysis/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，<code>ViewDragHelper</code>的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>
<p>要想完全掌握<code>ViewDragHelper</code>的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾<code>ViewDragHelper</code>的原理、用法、注意事项等。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p>在自定义ViewGroup的构造方法里调用<code>ViewDragHelper</code>的静态工厂方法<code>create</code>()创建<code>ViewDragHelper</code>实例</p>
</li>
<li><p>实现<code>ViewDragHelper.Callback</code><br>最重要的几个方法是</p>
<ul>
<li><code>tryCaptureView()</code>里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>clampViewPositionVertical()</code>决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>
<li><code>clampViewPositionHorizontal()</code>与<code>clampViewPositionVertical()</code>同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>
<li><code>getViewVerticalDragRange()</code>要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>
<li><code>getViewHorizontalDragRange()</code>与<code>getViewVerticalDragRange()</code>同理，只不过是发生在水平方向上。</li>
</ul>
</li>
<li><p>在<code>onInterceptTouchEvent()</code>方法里调用并返回<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>方法</p>
</li>
<li><p>在<code>onTouchEvent()</code>方法里调用<code>ViewDragHelper()</code>的<code>processTouchEvent()</code>方法。<code>ACTION_DOWN</code>事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在<code>onTouchEvent()</code>返回<code>true</code>，否则将收不到后续事件，不会产生拖动。</p>
</li>
<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的<code>computeScroll()</code>方法，方法实现如下：</p>
<pre><code> @Override
 public void computeScroll() &#123;
     if (mDragHelper.continueSettling(true)) &#123;
         postInvalidate();
     &#125;
 &#125;
</code></pre>
<p>并在<code>ViewDragHelper.Callback</code>的<code>onViewReleased()</code>方法里调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>，或在任意地方调用<code>smoothSlideViewTo()</code>方法。</p>
</li>
<li><p>如果要实现边缘拖动的效果，需要调用<code>ViewDragHelper</code>的<code>setEdgeTrackingEnabled()</code>方法，注册想要监听的边缘。然后实现<code>ViewDragHelper.Callback</code>里的<code>onEdgeDragStarted()</code>方法，在此手动调用<code>captureChildView()</code>传递要拖动的子View。</p>
</li>
</ol>
<p>具体的使用Demo请见最后面公布的几个案例。</p>
<h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><p>ViewDragHelper的完整源码可在<a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java">GitHub</a>或<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol>
<li>了解View的坐标系统，<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a></li>
<li>了解MotionEvent中关于多点触控的机制，<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a></li>
<li>了解Scroller类原理，<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li>了解Touch事件的分发机制，<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>
</ol>
<h3 id="ViewDragHelper实例的创建"><a href="#ViewDragHelper实例的创建" class="headerlink" title="ViewDragHelper实例的创建"></a>ViewDragHelper实例的创建</h3><p><code>ViewDragHelper</code>重载了两个<code>create()</code>静态方法，先看两个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code>的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。<code>create()</code>直接调用了<code>ViewDragHelper</code>构造方法，我们再来看看这个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apps should use ViewDragHelper.create() to get a new instance.</span></span><br><span class="line"><span class="comment"> * This will allow VDH to use internal compatibility implementations for different</span></span><br><span class="line"><span class="comment"> * platform versions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parent view may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Callback may not be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mParentView = forParent;</span><br><span class="line">	mCallback = cb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">	mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">	mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">	mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">	mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">	mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过<code>create()</code>工厂方法来创建<code>ViewDragHelper</code>实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li><code>mParentView</code>和<code>mCallback</code>分别保存传递过来的对应参数</li>
<li><code>ViewConfiguration</code>类里定义了<code>View</code>相关的一系列时间、大小、距离等常量</li>
<li><code>mEdgeSize</code>表示边缘触摸的范围。例如<code>mEdgeSize</code>为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于<code>mParentView.getLeft() + mEdgeSize</code>时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见<code>ViewDragHelper</code>的<code>getEdgesTouched()</code>方法。</li>
<li><code>mTouchSlop</code>是一个很小的距离值，只有在前后两次触摸点的距离超过<code>mTouchSlop</code>的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>
<li><code>mMaxVelocity</code>、<code>mMinVelocity</code>是fling时的最大、最小速率，单位是像素每秒。</li>
<li><code>mScroller</code>是<code>View</code>滚动的辅助类，该类的详细解析参见下面几篇文章<ul>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> </li>
<li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html">Android中Scroller类的分析</a></li>
</ul>
</li>
</ul>
<p>再看三个参数的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new ViewDragHelper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forParent Parent view to monitor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span></span><br><span class="line"><span class="comment"> *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb Callback to provide information and receive events</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new ViewDragHelper instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">	helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">	<span class="keyword">return</span> helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数<code>sensitivity</code>是用来调节<code>mTouchSlop</code>的值。<code>sensitivity</code>越大，<code>mTouchSlop</code>越小，对滑动的检测就越敏感。例如<code>sensitivity</code>为1时，前后触摸点距离超过20dp才进行滑动处理，现在<code>sensitivity</code>为2的话，前后触摸点距离超过10dp就进行处理了。</p>
<h3 id="对Touch事件的处理"><a href="#对Touch事件的处理" class="headerlink" title="对Touch事件的处理"></a>对Touch事件的处理</h3><p>当<code>mParentView</code>（自定义ViewGroup）被触摸时，首先会调用<code>mParentView</code>的<code>onInterceptTouchEvent(MotionEvent ev)</code>，接着就调用<code>shouldInterceptTouchEvent(MotionEvent ev)</code> ，所以先来看看这个方法的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if this event as provided to the parent view&#x27;s onInterceptTouchEvent should</span></span><br><span class="line"><span class="comment"> * cause the parent to intercept the touch event stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看9~21行，首先是关于多点触控（<code>MotionEvent</code>的<code>actionIndex</code>、<code>ACTION_POINTER_DOWN </code>等概念），不明白的请参阅<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a>。</p>
<p><code>mVelocityTracker</code>记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生<code>ACTION_DOWN</code>事件都会调用<code>cancel()</code>，而在<code>cancel()</code>方法里<code>mVelocityTracker</code>又被清空了，所以<code>mVelocityTracker </code>记录下的是本次<code>ACTION_DOWN</code>事件直至<code>ACTION_UP</code>事件发生后（下次<code>ACTION_DOWN</code>事件发生前）的所有触摸点的信息。</p>
<p>再来看24~42行<code>case MotionEvent.ACTION_DOWN</code>部分，先是调用<code>saveInitialMotion(x, y, pointerId)</code>保存手势的初始信息，即<code>ACTION_DOWN</code>发生时的触摸点坐标（x、y）、触摸手指编号（<code>pointerId</code>），如果触摸到了<code>mParentView</code>的边缘还会记录触摸的是哪个边缘。接着调用<code>findTopChildUnder((int) x, (int) y);</code>来获取当前触摸点下最顶层的子View，看<code>findTopChildUnder </code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the topmost child under the given point within the parent view&#x27;s coordinate system.</span></span><br><span class="line"><span class="comment"> * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x X position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y Y position to test in the parent&#x27;s coordinate system</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">				y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">			<span class="keyword">return</span> child;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现<code>Callback</code>里的<code>getOrderedChildIndex(int index)</code>方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（<code>getOrderedChildIndex()</code>默认直接返回<code>index</code>），会选择到topView，要想让bottomView被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">	<span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">	<span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">		<span class="keyword">return</span> indexBottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32~35行，这里还看到了一个<code>mDragState</code>成员变量，它共有三种取值：</p>
<ol>
<li><code>STATE_IDLE</code>：所有的View处于静止空闲状态</li>
<li><code>STATE_DRAGGING</code>：某个View正在被用户拖动（用户正在与设备交互）</li>
<li><code>STATE_SETTLING</code>：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br><code>mCapturedView</code>默认为<code>null</code>，所以一开始不会执行这里的代码，<code>mDragState</code>处于<code>STATE_SETTLING</code>状态时才会执行<code>tryCaptureViewForDrag()</code>，执行的情况到后面再分析，这里先跳过。</li>
</ol>
<p>37~40行调用了<code>Callback.onEdgeTouched</code>向外部通知<code>mParentView</code>的某些边缘被触摸到了，<code>mInitialEdgesTouched</code>是在刚才调用过的<code>saveInitialMotion</code>方法里进行赋值的。</p>
<p><code>ACTION_DOWN </code>部分处理完了，跳过<code>switch</code>语句块，剩下的代码就只有<code>return mDragState == STATE_DRAGGING;</code>。在<code>ACTION_DOWN</code>部分没有对<code>mDragState</code>进行赋值，其默认值为<code>STATE_IDLE</code>，所以此处返回<code>false</code>。</p>
<p>那么返回<code>false</code>后接下来应该是会调用哪个方法呢，根据<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在<code>mParentView</code>的所有子View中寻找响应这个Touch事件的View（会调用每个子View的<code>dispatchTouchEvent()</code>方法，<code>dispatchTouchEvent</code>里一般又会调用<code>onTouchEvent()</code>）；</p>
<ul>
<li><p>如果没有子View消费这次事件（子View的<code>dispatchTouchEvent()</code>返回都是<code>false</code>），会调用<code>mParentView</code>的<code>super.dispatchTouchEvent(ev)</code>，即<code>View</code>中的<code>dispatchTouchEvent(ev)</code>，然后调用<code>mParentView</code>的<code>onTouchEvent()</code>方法，再调用<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>方法。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动（除了<code>ACTION_DOWN</code>外的其他事件发生时返回<code>true</code>或<code>false</code>都不会影响接下来的事件接受），因为拖动的相关代码是写在<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分的。要注意的是返回<code>true</code>后<code>mParentView</code>的<code>onInterceptTouchEvent()</code>就不会收到后续的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件了。</p>
</li>
<li><p>如果有子View消费了本次<code>ACTION_DOWN</code>事件，<code>mParentView</code>的<code>onTouchEvent()</code>就收不到<code>ACTION_DOWN</code>事件了，也就是<code>ViewDragHelper</code>的<code>processTouchEvent(MotionEvent ev)</code>收不到<code>ACTION_DOWN</code>事件了。不过只要该View没有调用过<code>requestDisallowInterceptTouchEvent(true)</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分还是会执行的，如果在此时返回了<code>true</code>拦截了<code>ACTION_MOVE</code>事件，<code>processTouchEvent()</code>里的<code>ACTION_MOVE</code>部分也就会正常执行，拖动也就没问题了。<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分具体做了怎样的处理，稍后再来解析。</p>
</li>
</ul>
<p>接下来对这两种情况逐一解析。</p>
<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用<code>processTouchEvent(MotionEvent ev)</code>的<code>ACTION_DOWN</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process a touch event received by the parent view. This method will dispatch callback events</span></span><br><span class="line"><span class="comment"> * as needed before returning. The parent view&#x27;s onTouchEvent implementation should call this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev The touch event received by the parent view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="comment">// Reset things for a new event stream, just in case we didn&#x27;t get</span></span><br><span class="line">		<span class="comment">// the whole previous stream.</span></span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">			saveInitialMotion(x, y, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">			<span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">			<span class="comment">// Start immediately if possible.</span></span><br><span class="line">			tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">			<span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">				mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他case暂且省略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跟<code>shouldInterceptTouchEvent()</code>里<code>ACTION_DOWN</code>那部分基本一致，唯一区别就是这里没有约束条件直接调用了<code>tryCaptureViewForDrag()</code>方法，现在来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to capture the view with the given pointer ID. The callback will be involved.</span></span><br><span class="line"><span class="comment"> * This will put us into the &quot;dragging&quot; state. If we&#x27;ve already captured this view with</span></span><br><span class="line"><span class="comment"> * this pointer this method will immediately return true without consulting the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCapture View to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pointerId Pointer to capture with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if capture was successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;</span><br><span class="line">		<span class="comment">// Already done!</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;</span><br><span class="line">		mActivePointerId = pointerId;</span><br><span class="line">		captureChildView(toCapture, pointerId);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>Callback</code>的<code>tryCaptureView(View child, int pointerId)</code>方法，把当前触摸到的View和触摸手指编号传递了过去，在<code>tryCaptureView()</code>中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在<code>tryCaptureView()</code>中返回<code>true</code>，让<code>ViewDragHelper</code>把当前触摸的View捕获下来，接着就调用了<code>captureChildView(toCapture, pointerId)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Capture a specific child view for dragging within the parent. The callback will be notified</span></span><br><span class="line"><span class="comment"> * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span></span><br><span class="line"><span class="comment"> * capture this view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childView Child view to capture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;captureChildView: parameter must be a descendant &quot;</span> +</span><br><span class="line">				<span class="string">&quot;of the ViewDragHelper&#x27;s tracked parent view (&quot;</span> + mParentView + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCapturedView = childView;</span><br><span class="line">	mActivePointerId = activePointerId;</span><br><span class="line">	mCallback.onViewCaptured(childView, activePointerId);</span><br><span class="line">	setDragState(STATE_DRAGGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，在<code>captureChildView(toCapture, pointerId)</code>中将要拖动的View和触摸的手指编号记录下来，并调用<code>Callback</code>的<code>onViewCaptured(childView, activePointerId)</code>通知外部有子View被捕获到了，再调用<code>setDragState()</code>设置当前的状态为<code>STATE_DRAGGING</code>，看<code>setDragState()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">		mDragState = state;</span><br><span class="line">		mCallback.onViewDragStateChanged(state);</span><br><span class="line">		<span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">			mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态改变后会调用<code>Callback</code>的<code>onViewDragStateChanged()</code>通知状态的变化。</p>
<p>假设<code>ACTION_DOWN</code>发生后在<code>mParentView</code>的<code>onTouchEvent()</code>返回了<code>true</code>，接下来就会执行<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);</span><br><span class="line"></span><br><span class="line">				dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</span><br><span class="line"></span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">					reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">					<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">						<span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">					<span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">							tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				saveLastMotion(ev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断<code>mDragState</code>是否为<code>STATE_DRAGGING</code>，而唯一调用<code>setDragState(STATE_DRAGGING)</code>的地方就是<code>tryCaptureViewForDrag()</code>了，刚才在<code>ACTION_DOWN</code>里调用过<code>tryCaptureViewForDrag()</code>，现在又要分两种情况。<br>如果刚才在<code>ACTION_DOWN</code>里捕获到要拖动的View，那么就执行<code>if</code>部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，<code>mDragState</code>依然是<code>STATE_IDLE</code>，然后会执行<code>else</code>部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让<code>mDragState</code>变为<code>STATE_DRAGGING</code>，之后就会执行<code>if</code>部分的代码了。这里还有两个方法涉及到了<code>Callback</code>里的方法，需要来解析一下，分别是<code>reportNewEdgeDrags()</code>和<code>checkTouchSlop()</code>，先看<code>reportNewEdgeDrags()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_LEFT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_TOP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_RIGHT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">		dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">		mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">		mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在<code>mEdgeDragsInProgress</code>中，再调用<code>Callback</code>的<code>onEdgeDragStarted(int edgeFlags, int pointerId)</code>通知某个边缘开始产生拖动了。虽然<code>reportNewEdgeDrags()</code>会被调用很多次（因为<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分会执行很多次），但<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code>只会调用一次，具体的要看<code>checkNewEdgeDrag()</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">			(mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">			(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;</span><br><span class="line">		mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>checkNewEdgeDrag()</code>返回<code>true</code>表示在指定的<code>edge</code>（边缘）开始产生拖动了。</li>
<li>方法的两个参数<code>delta</code>和<code>odelta</code>需要解释一下，<code>odelta</code>里的o应该代表opposite，这是什么意思呢，以<code>reportNewEdgeDrags()</code>里调用<code>checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)</code>为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里<code>delta</code>为<code>dx</code>，<code>odelta</code>为<code>dy</code>，也就是说<code>delta</code>是指我们主要监测的方向上的变化，<code>odelta</code>是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>
<li><code>mInitialEdgesTouched</code>是在<code>ACTION_DOWN</code>部分的<code>saveInitialMotion()</code>里生成的，<code>ACTION_DOWN</code>发生时触摸到的边缘会被记录在<code>mInitialEdgesTouched</code>中。如果<code>ACTION_DOWN</code>发生时没有触摸到边缘，或者触摸到的边缘不是指定的<code>edge</code>，就直接返回false了。</li>
<li><code>mTrackingEdges</code>是由<code>setEdgeTrackingEnabled(int edgeFlags)</code>设置的，当我们想要追踪监听边缘触摸时才需要调用<code>setEdgeTrackingEnabled(int edgeFlags)</code>，如果我们没有调用过它，这里就直接返回<code>false</code>了。</li>
<li><code>mEdgeDragsLocked</code>它在这个方法里被引用了多次，它在整个<code>ViewDragHelper</code>里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行<code>mEdgeDragsLocked[pointerId] &amp; edge) == edge</code>执行的结果是<code>false</code>。我们再跳到11到14行看看，<code>absDelta &lt; absODelta * 0.5f</code>的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用<code>Callback</code>的<code>onEdgeLock(edge)</code>检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在<code>mEdgeDragsInProgress</code>里了，也不会收到<code>Callback</code>的<code>onEdgeDragStarted()</code>通知了。并且将锁定的边缘记录在<code>mEdgeDragsLocked</code>变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的<code>edge</code>被锁定，就直接返回<code>false</code>了。</li>
<li>回到第7行的<code>(mEdgeDragsInProgress[pointerId] &amp; edge) == edge</code>，<code>mEdgeDragsInProgress</code>是保存已发生过拖动事件的边缘的，如果给定的<code>edge</code>已经保存过了，那就没必要再检测其他东西了，直接返回<code>false</code>了。</li>
<li>第8行<code>(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)</code>很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>
<li>最后一句返回的时候再次检查给定的<code>edge</code>有没有记录过，确保了每个边缘只会调用一次<code>reportNewEdgeDrags</code>的<code>mCallback.onEdgeDragStarted(dragsStarted, pointerId)</code></li>
</ul>
<p>再来看<code>checkTouchSlop()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if we&#x27;ve crossed a reasonable touch slop for the given child view.</span></span><br><span class="line"><span class="comment"> * If the child cannot be dragged along the horizontal or vertical axis, motion</span></span><br><span class="line"><span class="comment"> * along that axis will not count toward the slop check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx Motion since initial position along X axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the touch slop has been crossed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">		<span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（<code>mTouchSlop</code>）了，注意<code>dx</code>和<code>dy</code>指的是当前触摸点到<code>ACTION_DOWN</code>触摸到的点的距离。这里先检查<code>Callback</code>的<code>getViewHorizontalDragRange(child)</code>和<code>getViewVerticalDragRange(child)</code>是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分就不会调用<code>tryCaptureViewForDrag()</code>来捕获当前触摸到的View了，拖动也就没办法进行了。</p>
<p>回到<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了<code>Callback</code>中的相关方法，让<code>tryCaptureViewForDrag()</code>正常的捕获到触摸到的View了，下一次<code>ACTION_MOVE</code>时就执行<code>if</code>部分的代码了，也就是开始不停的调用<code>dragTo()</code>对<code>mCaptureView</code>进行真正拖动了，看<code>dragTo()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clampedX = left;</span><br><span class="line">	<span class="keyword">int</span> clampedY = top;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</span><br><span class="line">		mCapturedView.offsetLeftAndRight(clampedX - oldLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">		clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</span><br><span class="line">		mCapturedView.offsetTopAndBottom(clampedY - oldTop);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">		mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">				clampedDx, clampedDy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>dx</code>和<code>dy</code>是前后两次<code>ACTION_MOVE</code>移动的距离，<code>left</code>和<code>top</code>分别为<code>mCapturedView.getLeft() + dx</code>, <code>mCapturedView.getTop() + dy</code>，也就是期望的移动后的坐标，对<code>View</code>的<code>getLeft()</code>等方法不理解的请参阅<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>
<p>这里通过调用<code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>来完成对<code>mCapturedView</code>移动，这两个是<code>View</code>中定义的方法，看它们的源码就知道内部是通过改变<code>View</code>的<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>、<code>mBottom</code>，即改变<code>View</code>在父容器中的坐标位置，达到移动<code>View</code>的效果，所以如果调用<code>mCapturedView</code>的<code>layout(int l, int t, int r, int b)</code>方法也可以实现移动<code>View</code>的效果。</p>
<p>具体要移动到哪里，由<code>Callback</code>的<code>clampViewPositionHorizontal()</code>和<code>clampViewPositionVertical()</code>来决定的，如果不想在水平方向上移动，在<code>clampViewPositionHorizontal(View child, int left, int dx)</code>里直接返回<code>child.getLeft()</code>就可以了，这样<code>clampedX - oldLeft</code>的值为0，这里调用<code>mCapturedView.offsetLeftAndRight(clampedX - oldLeft)</code>就不会起作用了。垂直方向上同理。</p>
<p>最后会调用<code>Callback</code>的<code>onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)</code>通知捕获到的View位置改变了，并把最终的坐标（<code>clampedX</code>、<code>clampedY</code>）和最终的移动距离（<code>clampedDx</code>、 <code>clampedDy</code>）传递过去。</p>
<p><code>ACTION_MOVE</code>部分就算告一段落了，接下来应该是用户松手触发<code>ACTION_UP</code>，或者是达到某个条件导致后续的<code>ACTION_MOVE</code>被<code>mParentView</code>的上层View给拦截了而收到<code>ACTION_CANCEL</code>，一起来看这两个部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				releaseViewForPointerUp();</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">			<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">				dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cancel();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下<code>releaseViewForPointerUp()</code>和<code>dispatchViewReleased()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">			VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			mMinVelocity, mMaxVelocity);</span><br><span class="line">	dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releaseViewForPointerUp()</code>里也调用了<code>dispatchViewReleased()</code>，只不过传递了速率给它，这个速率就是由<code>processTouchEvent()</code>的<code>mVelocityTracker</code>追踪算出来的。再看<code>dispatchViewReleased()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like all callback events this must happen on the UI thread, but release</span></span><br><span class="line"><span class="comment"> * involves some extra semantics. During a release (mReleaseInProgress)</span></span><br><span class="line"><span class="comment"> * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">	mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">	mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">	mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">		<span class="comment">// onViewReleased didn&#x27;t call a method that would have changed this. Go idle.</span></span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>Callback</code>的<code>onViewReleased(mCapturedView, xvel, yvel)</code>通知外部捕获到的View被释放了，而在<code>onViewReleased()</code>前后有个<code>mReleaseInProgress</code>值得注意，注释里说唯一可以调用<code>ViewDragHelper</code>的<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方就是在<code>Callback</code>的<code>onViewReleased()</code>里了。</p>
<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（<code>flingCapturedView</code>的四个参数<code>int minLeft, int minTop, int maxLeft, int maxTop</code>可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用<code>settleCapturedViewAt(int finalLeft, int finalTop)</code>。</p>
<p>为什么唯一可以调用<code>settleCapturedViewAt()</code>和<code>flingCapturedView()</code>的地方是<code>Callback</code>的<code>onViewReleased()</code>呢？看看它们的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * The appropriate velocity from prior motion will be taken into account.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot settleCapturedViewAt outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view based on standard free-moving fling behavior.</span></span><br><span class="line"><span class="comment"> * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span></span><br><span class="line"><span class="comment"> * to continue the motion until it returns false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minLeft Minimum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minTop Minimum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLeft Maximum X position for the view&#x27;s left edge</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxTop Maximum Y position for the view&#x27;s top edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot flingCapturedView outside of a call to &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Callback#onViewReleased&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			(<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">			minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法里一开始都会判断<code>mReleaseInProgress</code>为<code>false</code>，如果为<code>false</code>就会抛一个<code>IllegalStateException</code>异常，而<code>mReleaseInProgress</code>唯一为<code>true</code>的时候就是在<code>dispatchViewReleased()</code>里调用<code>onViewReleased()</code>的时候。</p>
<p><code>Scroller</code>的用法请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读<code>Scroller</code>源码，代码量不多。</p>
<p><code>ViewDragHelper</code>还有一个移动View的方法是<code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code>，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span></span><br><span class="line"><span class="comment"> * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span></span><br><span class="line"><span class="comment"> * on each subsequent frame to continue the motion until it returns false. If this method</span></span><br><span class="line"><span class="comment"> * returns false there is no further work to do to complete the movement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span></span><br><span class="line"><span class="comment"> * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child Child view to capture and animate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Final left position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Final top position of child</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">	mCapturedView = child;</span><br><span class="line">	mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If we&#x27;re in an IDLE state to begin with and aren&#x27;t moving anywhere, we</span></span><br><span class="line">		<span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">		mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> continueSliding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它不受<code>mReleaseInProgress</code>的限制，所以可以在任何地方调用，效果和<code>settleCapturedViewAt()</code>类似，因为它们最终都调用了<code>forceSettleCapturedViewAt()</code>来启动自动滚动，区别在于<code>settleCapturedViewAt()</code>会以最后松手前的滑动速率为初速度将View滚动到最终位置，而<code>smoothSlideViewTo()</code>滚动的初速度是0。<code>forceSettleCapturedViewAt()</code>里有地方调用了<code>Callback</code>里的方法，所以再来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Settle the captured view at the given (left, top) position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalTop Target top position for the captured view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xvel Horizontal velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> yvel Vertical velocity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">		mScroller.abortAnimation();</span><br><span class="line">		setDragState(STATE_IDLE);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">	mScroller.startScroll(startLeft, startTop, dx, dy, duration);</span><br><span class="line"></span><br><span class="line">	setDragState(STATE_SETTLING);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到自动滑动是靠<code>Scroll</code>类完成，在这里生成了调用<code>mScroller.startScroll()</code>需要的参数。再来看看计算滚动时间的方法<code>computeSettleDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">	xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">			(<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">	<span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clampMag()</code>方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过<code>computeAxisDuration()</code>算出来，通过它的参数可以看到最终的滚动时间是由<code>dx</code>、<code>xvel</code>、<code>mCallback.getViewHorizontalDragRange()</code>共同影响的。看<code>computeAxisDuration()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">			distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> duration;</span><br><span class="line">	velocity = Math.abs(velocity);</span><br><span class="line">	<span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">		duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6<del>10行没看明白，直接看14</del>19行，如果给定的速率<code>velocity</code>不为0，就通过距离除以速率来算出时间；如果<code>velocity</code>为0，就通过要滑动的距离（<code>delta</code>）除以总的移动范围（<code>motionRange</code>，就是<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过<code>MAX_SETTLE_DURATION</code>的，源码里的取值是600毫秒，所以不用担心在<code>Callback</code>里<code>getViewHorizontalDragRange()</code>、<code>getViewVerticalDragRange()</code>返回错误的数而导致自动滚动时间过长了。</p>
<p>在调用<code>settleCapturedViewAt()</code>、<code>flingCapturedView()</code>和<code>smoothSlideViewTo()</code>时，还需要实现<code>mParentView</code>的<code>computeScroll()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这属于<code>Scroll</code>类用法的范畴，不明白的请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>
<p>至此，整个触摸流程和<code>ViewDragHelper</code>的重要的方法都过了一遍。之前在讨论<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次<code>ACTION_DOWN</code>事件的情况，现在来看看这种情况。</p>
<p>假设现在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分执行完了，也有子View消费了这次的<code>ACTION_DOWN</code>事件，那么接下来就会调用<code>mParentView</code>的<code>onInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分，不明白为什么的请参阅<a href="http://blog.csdn.net/xiaanming/article/details/21696315">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用<code>ViewDragHelper</code>的<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">			<span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">				<span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">					<span class="comment">// check the callback&#x27;s</span></span><br><span class="line">					<span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">					<span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">					<span class="comment">// would clamp to the same value. If you can&#x27;t move at</span></span><br><span class="line">					<span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">							targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">							(<span class="keyword">int</span>) dy);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">							toCapture);</span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">					<span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">							&amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">							|| verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">				<span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">					<span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			saveLastMotion(ev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用<code>findTopChildUnder(int x, int y)</code>寻找触摸点处的子View，再用<code>checkTouchSlop(View child, float dx, float dy)</code>检查当前触摸点到<code>ACTION_DOWN</code>触摸点的距离是否达到了<code>mTouchSlop</code>，达到了才会去捕获View。<br>接着看19~41行<code>if (pastSlop)&#123;...&#125;</code>部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到<code>getView[Horizontal|Vertical]DragRange</code>和<code>clampViewPosition[Horizontal|Vertical]</code>四个方法。如果<code>getView[Horizontal|Vertical]DragRange</code>返回都是0，就会认作是不会产生拖动。<code>clampViewPosition[Horizontal|Vertical]</code>返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接<code>break</code>，不会执行后续的代码，而后续代码里有调用<code>tryCaptureViewForDrag()</code>，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的<code>tryCaptureViewForDrag()</code>捕获子View，如果捕获成功，<code>mDragState</code>就会变成<code>STATE_DRAGGING</code>，<code>shouldInterceptTouchEvent()</code>返回<code>true</code>，<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，后续的移动事件就会在<code>mParentView</code>的<code>onTouchEvent()</code>执行了，最后执行的就是<code>mParentView</code>的<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分，拖动正常进行。</p>
<p>回头再看之前在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分留下的坑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他部分...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">			<span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</span><br><span class="line">				tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 省略其他部分...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他case...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的<code>tryCaptureViewForDrag()</code>尝试捕获View，如果捕获成功，<code>mDragState</code>就变为<code>STATE_DRAGGING</code>了，<code>shouldInterceptTouchEvent()</code>就返回<code>true</code>了，然后就是<code>mParentView</code>的<code>onInterceptTouchEvent()</code>返回<code>true</code>，接着执行<code>mParentView</code>的<code>onTouchEvent()</code>，再执行<code>processTouchEvent()</code>的<code>ACTION_DOWN</code>部分。此时（<code>ACTION_DOWN</code>事件发生时）<code>mParentView</code>的<code>onTouchEvent()</code>要返回<code>true</code>，<code>onTouchEvent()</code>才能继续接受到接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等事件，否则无法完成拖动。</p>
<p>至此整个事件传递流程和<code>ViewDragHelper</code>的重要方法基本都解析完了，<code>shouldInterceptTouchEvent()</code>和<code>processTouchEvent()</code>的<code>ACTION_POINTER_DOWN</code>、<code>ACTION_POINTER_UP</code>部分就留给读者自己解析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>
<ul>
<li><p><a href="http://www.processon.com/view/link/5550a7bae4b09739f465ec64">单点触摸，没有考虑边缘滑动检测的最简流程图</a><br><img src="viewdraghelper-toucheventflow-basic.png"></p>
</li>
<li><p><a href="http://www.processon.com/view/link/5550d3dce4b09739f46789bd">单点触摸，考虑了边缘滑动检测的流程图</a><br><img src="viewdraghelper-toucheventflow-withedgetouch.png"></p>
</li>
</ul>
<p>多点触摸情况我就没研究了，在这里忽略~</p>
<p>三个开启自动滚动的方法：</p>
<ul>
<li><code>settleCapturedViewAt(int finalLeft, int finalTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code><br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在<code>Callback</code>的<code>onViewReleased()</code>中调用。</li>
<li><code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code><br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>
</ul>
<p><code>Callback</code>的各个方法总结：</p>
<ul>
<li><p><code>void onViewDragStateChanged(int state)</code><br>拖动状态改变时会调用此方法，状态<code>state</code>有<code>STATE_IDLE</code>、<code>STATE_DRAGGING</code>、<code>STATE_SETTLING</code>三种取值。<br>它在<code>setDragState()</code>里被调用，而<code>setDragState()</code>被调用的地方有</p>
<ul>
<li><code>tryCaptureViewForDrag()</code>成功捕获到子View时<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>部分捕获到</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>部分捕获到</li>
</ul>
</li>
<li>调用<code>settleCapturedViewAt()</code>、<code>smoothSlideViewTo()</code>、<code>flingCapturedView()</code>时</li>
<li>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>、<code>ACTION_CANCEL</code>）</li>
<li>自动滚动停止时（<code>continueSettling()</code>里检测到滚动结束时）</li>
<li>外部调用<code>abort()</code>时</li>
</ul>
</li>
<li><p><code>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</code><br>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>
<ul>
<li>在<code>dragTo()</code>里被调用（正在被拖动时）</li>
<li>在<code>continueSettling()</code>里被调用（自动滚动时）</li>
<li>外部调用<code>abort()</code>时被调用</li>
</ul>
</li>
<li><p><code>void onViewCaptured(View capturedChild, int activePointerId)</code><br><code>tryCaptureViewForDrag()</code>成功捕获到子View时会调用此方法。</p>
<ul>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里成功捕获</li>
<li>在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里成功捕获</li>
<li>手动调用<code>captureChildView()</code></li>
</ul>
</li>
<li><p><code>void onViewReleased(View releasedChild, float xvel, float yvel)</code><br>拖动View松手时（<code>processTouchEvent()</code>的<code>ACTION_UP</code>）或被父View拦截事件时（<code>processTouchEvent()</code>的<code>ACTION_CANCEL</code>）会调用此方法。</p>
</li>
<li><p><code>void onEdgeTouched(int edgeFlags, int pointerId)</code><br><code>ACTION_DOWN</code>或<code>ACTION_POINTER_DOWN</code>事件发生时如果触摸到监听的边缘会调用此方法。<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。</p>
</li>
<li><p><code>boolean onEdgeLock(int edgeFlags)</code><br>返回<code>true</code>表示锁定<code>edgeFlags</code>对应的边缘，锁定后的那些边缘就不会在<code>onEdgeDragStarted()</code>被通知了，默认返回<code>false</code>不锁定给定的边缘，<code>edgeFlags</code>的取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>其中之一。</p>
</li>
<li><p><code>void onEdgeDragStarted(int edgeFlags, int pointerId)</code><br><code>ACTION_MOVE</code>事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。<code>edgeFlags</code>取值为<code>EDGE_LEFT</code>、<code>EDGE_TOP</code>、<code>EDGE_RIGHT</code>、<code>EDGE_BOTTOM</code>的组合。可在此手动调用<code>captureChildView()</code>触发从边缘拖动子View的效果。</p>
</li>
<li><p><code>int getOrderedChildIndex(int index)</code><br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给<code>tryCaptureViewForDrag()</code>来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>
</li>
<li><p><code>int getViewHorizontalDragRange(View child)</code>、<code>int getViewVerticalDragRange(View child)</code><br>返回给定的<code>child</code>在相应的方向上可以被拖动的最远距离，默认返回0。<code>ACTION_DOWN</code>发生时，若触摸点处的<code>child</code>消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。<br>被调用的地方有三处：</p>
<ul>
<li>在<code>checkTouchSlop()</code>中被调用，返回值大于0才会去检查<code>mTouchSlop</code>。在<code>ACTION_MOVE</code>里调用<code>tryCaptureViewForDrag()</code>之前会调用<code>checkTouchSlop()</code>。如果<code>checkTouchSlop()</code>失败，就不会去捕获View了。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>
<li>在调用<code>smoothSlideViewTo()</code>时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在<code>getView[Horizontal|Vertical]DragRange</code>里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>
</ul>
</li>
<li><p><code>boolean tryCaptureView(View child, int pointerId)</code><br>在<code>tryCaptureViewForDrag()</code>中被调用，返回<code>true</code>表示捕获给定的<code>child</code>。<code>tryCaptureViewForDrag()</code>被调用的地方有</p>
<ul>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_DOWN</code>里</li>
<li><code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
<li><code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里</li>
</ul>
</li>
<li><p><code>int clampViewPositionHorizontal(View child, int left, int dx)</code>、<code>int clampViewPositionVertical(View child, int top, int dy)</code><br><code>child</code>在某方向上被拖动时会调用对应方法，返回值是<code>child</code>移动过后的坐标位置，<code>clampViewPositionHorizontal()</code>返回<code>child</code>移动过后的left值，<code>clampViewPositionVertical()</code>返回<code>child</code>移动过后的top值。<br>两个方法被调用的地方有两处：</p>
<ul>
<li>在<code>dragTo()</code>中被调用，<code>dragTo()</code>在<code>processTouchEvent()</code>的<code>ACTION_MOVE</code>里被调用。用来获取被拖动的View要移动到的位置。</li>
<li>如果<code>ACTION_DOWN</code>发生时，触摸点处有子View消费事件，在<code>shouldInterceptTouchEvent()</code>的<code>ACTION_MOVE</code>里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>
</ul>
</li>
</ul>
<h2 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h2><p>在这里列举一部分对<code>ViewDragHelper</code>的应用案例，大家自己剖析它们的源码来实践巩固。</p>
<ol>
<li><a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a>，这是最简单的Demo</li>
<li><a href="https://github.com/BlueMor/DragLayout">QQ5.x侧滑菜单</a>、<a href="https://github.com/kyze8439690/ResideLayout">ResideLayout</a></li>
<li><a href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a>、<a href="https://github.com/liuguangqiang/SwipeBack">SwipeBack</a></li>
<li><a href="https://github.com/umano/AndroidSlidingUpPanel">SlidingUpPanel</a></li>
<li><a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java">DrawerLayout</a></li>
</ol>
<h2 id="其他关于ViewDragHelper的分析文章"><a href="#其他关于ViewDragHelper的分析文章" class="headerlink" title="其他关于ViewDragHelper的分析文章"></a>其他关于ViewDragHelper的分析文章</h2><ul>
<li><a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href="https://github.com/flavienlaurent/flavienlaurent.com">YoutubeLayout</a></li>
<li><a href="http://blog.csdn.net/pi9nc/article/details/39583377">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>
</ul>
<p>转载请注明出处</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>ViewDragHelper</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewDragHelper</tag>
      </tags>
  </entry>
</search>
